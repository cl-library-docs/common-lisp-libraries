{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"common-lisp.readthedocs In case of any inaccuracies, ambiguities or suggestions, please create an issue here . Introduction Common Lisp documentation - libraries or the HyperSpec - isn't known to be particularly \"modern\" or \"attractive\". While those terms are subjective, ease of introduction to a technology does seem to have some objective component to it. Libraries Installation Each of the below libraries can be installed using quicklisp: (ql:quickload \"alexandria\") ; for example See quicklisp.org for instructions on installing quicklisp. Optionally, you may want to use trivial-package-local-nicknames for, well, adding package local nicknames . (ql:quickload :trivial-package-local-nicknames) (trivial-package-local-nicknames:add-package-local-nickname :a :alexandria) ; OR (defpackage my-package (:use #:cl) (:local-nicknames (#:a #:alexandria))) ;;; I'm yet to read up on the naming conventions and the reasons behind those conventions ;;; in the context of systems and packages; some conventions do exist. Libraries documented so far See awesome-cl for more libraries. (See the html version of this page , rather than the markdown version for the working links below.) Defacto libraries alexandria - a utility library bordeaux-threads - library for threading cl-ppcre - regular expressions cl-who - DSL for Markup hunchentoot - web server fiveam - regression testing framework iterate - a lispy extensible alternative to loop postmodern - PostgreSQL programming interace Not yet defacto numcl - lispy clone of numpy unix-opts - minimalistic command line options parser Previous Efforts Documentation efforts have been made at: Quickdocs : I didn't like the theme. I want the API at a glance! Honestly, this can improve! But don't look at me. I'm also not very at ease with full automation without human intervention. Quickref : Frankly, this is just too much. As a user, all I want to know is \"What can this library do? And, how do I do it? (What functions, macros or anything is available?)\" Therefore, for a user, the only good place I found was the Packages section here. It is, after all, a Reference Manual. Another excuse is, again, that I do want human intervention in documentation. common-lisp.net : Ultimately, this seems to be the place for everything. And indeed, most of the work on the site you are reading is directly based on the official documentation. An attempt is made to \"simplify\" wherever need is felt. CLiki : Again, layout and \"at a glance\"! UltraSpec : I liked this. The only trouble? It isn't \"quick\". UltraSpec I liked (the theme of) UltraSpec . I also liked mkdocs - I am using mkdocs with the pre-provided readthedocs theme. What UltraSpec seems to be good for is larger websites than what is currently here, in that it isn't as straightforward as mkdocs for library-documenters to use it. Additionally, markdown files and dokuwiki files (the format UltraSpec requires) are interconvertible (but the compatibility is untested) using pandoc . (pandoc is indeed useful for a ton of other file formats!) mkdocs As a marketing for mkdocs: mkdocs is as simple as pip install mkdocs # or conda create a .yml configuration file (or copy and edit!) put your markdown files inside docs/ directory (or as mentioned in the .yml file) mkdocs gh-deploy # to deploy on github-pages Done! PS: Regardless of the justifications, all I wanted was a documentation site with a \"sidebar\" that, both, tells the page at glance, and is easy to navigate.","title":"index"},{"location":"#common-lispreadthedocs","text":"In case of any inaccuracies, ambiguities or suggestions, please create an issue here .","title":"common-lisp.readthedocs"},{"location":"#introduction","text":"Common Lisp documentation - libraries or the HyperSpec - isn't known to be particularly \"modern\" or \"attractive\". While those terms are subjective, ease of introduction to a technology does seem to have some objective component to it.","title":"Introduction"},{"location":"#libraries","text":"","title":"Libraries"},{"location":"#installation","text":"Each of the below libraries can be installed using quicklisp: (ql:quickload \"alexandria\") ; for example See quicklisp.org for instructions on installing quicklisp. Optionally, you may want to use trivial-package-local-nicknames for, well, adding package local nicknames . (ql:quickload :trivial-package-local-nicknames) (trivial-package-local-nicknames:add-package-local-nickname :a :alexandria) ; OR (defpackage my-package (:use #:cl) (:local-nicknames (#:a #:alexandria))) ;;; I'm yet to read up on the naming conventions and the reasons behind those conventions ;;; in the context of systems and packages; some conventions do exist.","title":"Installation"},{"location":"#libraries-documented-so-far","text":"See awesome-cl for more libraries. (See the html version of this page , rather than the markdown version for the working links below.)","title":"Libraries documented so far"},{"location":"#defacto-libraries","text":"alexandria - a utility library bordeaux-threads - library for threading cl-ppcre - regular expressions cl-who - DSL for Markup hunchentoot - web server fiveam - regression testing framework iterate - a lispy extensible alternative to loop postmodern - PostgreSQL programming interace","title":"Defacto libraries"},{"location":"#not-yet-defacto","text":"numcl - lispy clone of numpy unix-opts - minimalistic command line options parser","title":"Not yet defacto"},{"location":"#previous-efforts","text":"Documentation efforts have been made at: Quickdocs : I didn't like the theme. I want the API at a glance! Honestly, this can improve! But don't look at me. I'm also not very at ease with full automation without human intervention. Quickref : Frankly, this is just too much. As a user, all I want to know is \"What can this library do? And, how do I do it? (What functions, macros or anything is available?)\" Therefore, for a user, the only good place I found was the Packages section here. It is, after all, a Reference Manual. Another excuse is, again, that I do want human intervention in documentation. common-lisp.net : Ultimately, this seems to be the place for everything. And indeed, most of the work on the site you are reading is directly based on the official documentation. An attempt is made to \"simplify\" wherever need is felt. CLiki : Again, layout and \"at a glance\"! UltraSpec : I liked this. The only trouble? It isn't \"quick\".","title":"Previous Efforts"},{"location":"#ultraspec","text":"I liked (the theme of) UltraSpec . I also liked mkdocs - I am using mkdocs with the pre-provided readthedocs theme. What UltraSpec seems to be good for is larger websites than what is currently here, in that it isn't as straightforward as mkdocs for library-documenters to use it. Additionally, markdown files and dokuwiki files (the format UltraSpec requires) are interconvertible (but the compatibility is untested) using pandoc . (pandoc is indeed useful for a ton of other file formats!)","title":"UltraSpec"},{"location":"#mkdocs","text":"As a marketing for mkdocs: mkdocs is as simple as pip install mkdocs # or conda create a .yml configuration file (or copy and edit!) put your markdown files inside docs/ directory (or as mentioned in the .yml file) mkdocs gh-deploy # to deploy on github-pages Done! PS: Regardless of the justifications, all I wanted was a documentation site with a \"sidebar\" that, both, tells the page at glance, and is easy to navigate.","title":"mkdocs"},{"location":"alexandria/","text":"alexandria - Commonly Used Utilities Version: 1.0.0 Repository: alexandria/alexandria - Gitlab This documentation is modified to markdown from here on 01 March, 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . ALEXANDRIA Alexandria software and associated documentation are in the public domain: Authors dedicate this work to public domain, for the benefit of the public at large and to the detriment of the authors' heirs and successors. Authors intends this dedication to be an overt act of relinquishment in perpetuity of all present and future rights under copyright law, whether vested or contingent, in the work. Authors understands that such relinquishment of all rights includes the relinquishment of all rights to enforce (by lawsuit or otherwise) those copyrights in the work. Authors recognize that, once placed in the public domain, the work may be freely reproduced, distributed, transmitted, used, modified, built upon, or otherwise exploited by anyone for any purpose, commercial or non-commercial, and in any way, including by methods that have not yet been invented or conceived. In those legislations where public domain dedications are not recognized or possible, Alexandria is distributed under the following terms and conditions: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 1. HASH TABLES ensure-gethash Macro: (ensure-gethash key hash-table &optional default) Like gethash , but if key is not found in the hash-table saves the default under key before returning it. Secondary return value is true if key was already in the table. copy-hash-table Function: (copy-hash-table table &key key test size rehash-size rehash-threshold) Returns a copy of hash table table , with the same keys and values as the table . The copy has the same properties as the original, unless overridden by the keyword arguments. Before each of the original values is set into the new hash-table, key is invoked on the value. As key defaults to cl:identity , a shallow copy is returned by default. maphash-keys Function: (maphash-keys function table) Like maphash , but calls function with each key in the hash table table . maphash-values Function: (maphash-values function table) Like maphash , but calls function with each value in the hash table table . hash-table-keys Function: (hash-table-keys table) Returns a list containing the keys of hash table table . hash-table-values Function: (hash-table-values table) Returns a list containing the values of hash table table . hash-table-alist Function: (hash-table-alist table) Returns an association list containing the keys and values of hash table table . hash-table-plist Function: (hash-table-plist table) Returns a property list containing the keys and values of hash table table . alist-hash-table Function: (alist-hash-table alist &rest hash-table-initargs) Returns a hash table containing the keys and values of the association list alist . Hash table is initialized using the hash-table-initargs . plist-hash-table Function: (plist-hash-table plist &rest hash-table-initargs) Returns a hash table containing the keys and values of the property list plist . Hash table is initialized using the hash-table-initargs . 2. DATA AND CONTROL FLOW define-constant Macro: (define-constant name initial-value &key test documentation) Ensures that the global variable named by name is a constant with a value that is equal under test to the result of evaluating initial-value . test is a /function designator/ that defaults to eql . If documentation is given, it becomes the documentation string of the constant. Signals an error if name is already a bound non-constant variable. Signals an error if name is already a constant variable whose value is not equal under test to result of evaluating initial-value . destructuring-case Macro: (destructuring-case keyform &body clauses) destructuring-case , -ccase , and -ecase are a combination of case and destructuring-bind . keyform must evaluate to a cons . Clauses are of the form: ((CASE-KEYS . DESTRUCTURING-LAMBDA-LIST) FORM*) The clause whose case-keys matches car of key , as if by case , ccase , or ecase , is selected, and FORMs are then executed with cdr of key is destructured and bound by the destructuring-lambda-list . Example: (defun dcase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)) ((t &rest rest) (format nil \"unknown: ~S\" rest)))) (dcase (list :foo 1 2)) ; =\"foo: 1, 2\" (dcase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (dcase (list :alt1 1)) ; =\"alt: 1\" (dcase (list :alt2 2)) ; =\"alt: 2\" (dcase (list :quux 1 2 3)) ; =\"unknown: 1, 2, 3\" (defun decase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)))) (decase (list :foo 1 2)) ; =\"foo: 1, 2\" (decase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (decase (list :alt1 1)) ; =\"alt: 1\" (decase (list :alt2 2)) ; =\"alt: 2\" (decase (list :quux 1 2 3)) ; =| error ensure-functionf Macro: (ensure-functionf &rest places) Multiple-place modify macro for ensure-function: ensures that each of places contains a function. multiple-value-prog2 Macro: (multiple-value-prog2 first-form second-form &body forms) Evaluates first-form , then second-form , and then forms . Yields as its value all the value returned by second-form . named-lambda Macro: (named-lambda name lambda-list &body body) Expands into a lambda-expression within whose body name denotes the corresponding function. nth-value-or Macro: (nth-value-or nth-value &body forms) Evaluates form arguments one at a time, until the nth-value returned by one of the forms is true. It then returns all the values returned by evaluating that form. If none of the forms return a true nth value, this form returns nil . if-let Macro: (if-let bindings &body (then-form &optional else-form)) Creates new variable bindings, and conditionally executes either then-form or else-form . else-form defaults to nil . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, the then-form is executed with the bindings in effect, otherwise the else-form is executed with the bindings in effect. when-let Macro: (when-let bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, then forms are executed as an implicit progn . Macro: (when-let* bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) Each initial-form is executed in turn, and the variable bound to the corresponding value. Initial-form expressions can refer to variables previously bound by the when-let* . Execution of when-let* stops immediately if any initial-form evaluates to nil . If all initial-forms evaluate to true, then forms are executed as an implicit progn . switch Macro: (switch whole (object &key test key) &body clauses) Evaluates first matching clause, returning its values, or evaluates and returns the values of default if no keys match. cswitch Macro: (cswitch whole (object &key test key) &body clauses) Like switch , but signals a continuable error if no key matches. eswitch Macro: (eswitch whole (object &key test key) &body clauses) Like switch , but signals an error if no key matches. whichever Macro: (whichever &rest possibilities env) Evaluates exactly one of possibilities , chosen at random. xor Macro: (xor &rest datums) Evaluates its arguments one at a time, from left to right. If more then one argument evaluates to a true value no further datums are evaluated, and nil is returned as both primary and secondary value. If exactly one argument evaluates to true, its value is returned as the primary value after all the arguments have been evaluated, and t is returned as the secondary value. If no arguments evaluate to true nil is retuned as primary, and t as secondary value. disjoin Function: (disjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning the primary value of the first predicate that returns true, without calling the remaining predicates. If none of the predicates returns true, nil is returned. conjoin Function: (conjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning nil if any of the predicates returns false, without calling the remaining predicates. If none of the predicates returns false, returns the primary value of the last predicate. compose Function: (compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to to each in turn, starting from the rightmost of more-functions , and then calling the next one with the primary value of the last. Function: (ensure-function function-designator) Returns the function designated by function-designator: if function-designator is a function, it is returned, otherwise it must be a function name and its fdefinition is returned. multiple-value-compose Function: (multiple-value-compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to each in turn, starting from the rightmost of more-functions , and then calling the next one with all the return values of the last. curry Function: (curry function &rest arguments) Returns a function that applies arguments and the arguments it is called with to function . rcurry Function: (rcurry function &rest arguments) Returns a function that applies the arguments it is called with and arguments to function . 3. CONSES proper-list Type designator for proper lists. Implemented as a satisfies type, hence not recommended for performance intensive use. Main usefullness as a type designator of the expected type in a type-error . circular-list Type designator for circular lists. Implemented as a satisfies type, so not recommended for performance intensive use. Main usefullness as the expected-type designator of a type-error . appendf Macro: (appendf place &rest lists env) Modify-macro for append . Appends lists to the place designated by the first argument. nconcf Macro: (nconcf place &rest lists env) Modify-macro for nconc . Concatenates lists to place designated by the first argument. remove-from-plistf Macro: (remove-from-plistf place &rest keys env) Modify macro for remove-from-plist . delete-from-plistf Macro: (delete-from-plistf place &rest keys env) Modify macro for delete-from-plist . reversef Macro: (reversef place env) Modify-macro for reverse . Copies and reverses the list stored in the given place and saves back the result into the place. nreversef Macro: (nreversef place env) Modify-macro for nreverse . Reverses the list stored in the given place by destructively modifying it and saves back the result into the place. unionf Macro: (unionf place list &rest args env) Modify-macro for union . Saves the union of list and the contents of the place designated by the first argument to the designated place. nunionf Macro: (nunionf place list &rest args env) Modify-macro for nunion . Saves the union of list and the contents of the place designated by the first argument to the designated place. May modify either argument. doplist Macro: (doplist (key val plist &optional values) &body body) Iterates over elements of plist . body can be preceded by declarations, and is like a tagbody . return may be used to terminate the iteration early. If return is not used, returns values . circular-list-p Function: (circular-list-p object) Returns true if object is a circular list, nil otherwise. circular-tree-p Function: (circular-tree-p object) Returns true if object is a circular tree, nil otherwise. proper-list-p Function: (proper-list-p object) Returns true if object is a proper list. alist-plist Function: (alist-plist alist) Returns a property list containing the same keys and values as the association list alist in the same order. plist-alist Function: (plist-alist plist) Returns an association list containing the same keys and values as the property list plist in the same order. circular-list Function: (circular-list &rest elements) Creates a circular list of elements . make-circular-list Function: (make-circular-list length &key initial-element) Creates a circular list of length with the given initial-element . ensure-car Function: (ensure-car thing) If thing is a cons , its car is returned. Otherwise thing is returned. ensure-cons Function: (ensure-cons cons) If cons is a cons, it is returned. Otherwise returns a fresh cons with cons in the car, and nil in the cdr. ensure-list Function: (ensure-list list) If list is a list, it is returned. Otherwise returns the list designated by list . flatten Function: (flatten tree) Traverses the tree in order, collecting non-null leaves into a list. lastcar Function: (lastcar list) Returns the last element of list . Signals a type-error if list is not a proper list. (setf Function: ((setf lastcar)) Sets the last element of list . Signals a type-error if list is not a proper list. proper-list-length Function: (proper-list-length list) Returns length of list , signalling an error if it is not a proper list. mappend Function: (mappend function &rest lists) Applies function to respective element(s) of each list , appending all the all the result list to a single list. function must return a list. map-product Function: (map-product function list &rest more-lists) Returns a list containing the results of calling function with one argument from list , and one from each of more-lists for each combination of arguments. In other words, returns the product of list and more-lists using function . Example: (map-product 'list '(1 2) '(3 4) '(5 6)) =((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6)) remove-from-plist Function: (remove-from-plist plist &rest keys) Returns a propery-list with same keys and values as plist , except that keys in the list designated by keys and values corresponding to them are removed. The returned property-list may share structure with the plist , but plist is not destructively modified. Keys are compared using eq . delete-from-plist Function: (delete-from-plist plist &rest keys) Just like remove-from-plist , but this version may destructively modify the provided plist. set-equal Function: (set-equal list1 list2 &key test key) Returns true if every element of list1 matches some element of list2 and every element of list2 matches some element of list1 . Otherwise returns false. setp Function: (setp object &key test key) Returns true if object is a list that denotes a set, nil otherwise. A list denotes a set if each element of the list is unique under key and test . 4. SEQUENCES proper-sequence Type designator for proper sequences, that is proper lists and sequences that are not lists. deletef Macro: (deletef place item &rest remove-keywords env) Modify-macro for delete . Sets place designated by the first argument to the result of calling delete with item , place, and the remove-keywords . removef Macro: (removef place item &rest remove-keywords env) Modify-macro for remove . Sets place designated by the first argument to the result of calling remove with item , place, and the remove-keywords . rotate Function: (rotate sequence &optional n) Returns a sequence of the same type as sequence , with the elements of sequence rotated by n: n elements are moved from the end of the sequence to the front if n is positive, and -n elements moved from the front to the end if n is negative. sequence must be a proper sequence. n must be an integer, defaulting to 1 . If absolute value of n is greater then the length of the sequence, the results are identical to calling rotate with (* (signum n) (mod n (length sequence))). Note: the original sequence may be destructively altered, and result sequence may share structure with it. shuffle Function: (shuffle sequence &key start end) Returns a random permutation of sequence bounded by start and end . Original sequece may be destructively modified, and share storage with the original one. Signals an error if sequence is not a proper sequence. random-elt Function: (random-elt sequence &key start end) Returns a random element from sequence bounded by start and end . Signals an error if the sequence is not a proper non-empty sequence, or if end and start are not proper bounding index designators for sequence . emptyp Function: (emptyp sequence) Returns true if sequence is an empty sequence. Signals an error if sequence is not a sequence. sequence-of-length-p Function: (sequence-of-length-p sequence length) Return true if sequence is a sequence of length length . Signals an error if sequence is not a sequence. Returns false for circular lists. length= Function: (length= &rest sequences) Takes any number of sequences or integers in any order. Returns true iff the length of all the sequences and the integers are equal. Hint: there's a compiler macro that expands into more efficient code if the first argument is a literal integer. copy-sequence Function: (copy-sequence type sequence) Returns a fresh sequence of type , which has the same elements as sequence . first-elt Function: (first-elt sequence) Returns the first element of sequence . Signals a type-error if sequence is not a sequence, or is an empty sequence. (setf first-elt) Function: ((setf first-elt)) Sets the first element of sequence . Signals a type-error if sequence is not a sequence, is an empty sequence, or if object cannot be stored in sequence . last-elt Function: (last-elt sequence) Returns the last element of sequence . Signals a type-error if sequence is not a proper sequence, or is an empty sequence. (setf last-elt) Function: ((setf last-elt)) Sets the last element of sequence . Signals a type-error if sequence is not a proper sequence, is an empty sequence, or if object cannot be stored in sequence . starts-with Function: (starts-with object sequence &key test key) Returns true if sequence is a sequence whose first element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. starts-with-subseq Function: (starts-with-subseq prefix sequence &rest args &key return-suffix &allow-other-keys) Test whether the first elements of sequence are the same (as per TEST) as the elements of prefix . If return-suffix is t the functions returns, as a second value, a displaced array pointing to the sequence after prefix . ends-with Function: (ends-with object sequence &key test key) Returns true if sequence is a sequence whose last element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. Signals an error if sequence is an improper list. ends-with-subseq Function: (ends-with-subseq suffix sequence &key test) Test whether sequence ends with suffix . In other words: return true if the last (length SUFFIX) elements of sequence are equal to suffix . map-combinations Function: (map-combinations function sequence &key start end length copy) Calls function with each combination of length constructable from the elements of the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of sequence , and length to the length of the delimited subsequence. (So unless length is specified there is only a single combination, which has the same elements as the delimited subsequence.) If copy is true (the default) each combination is freshly allocated. If copy is false all combinations are eq to each other, in which case consequences are specified if a combination is modified by function . map-derangements Function: (map-derangements function sequence &key start end copy) Calls function with each derangement of the subsequence of sequence denoted by the bounding index designators start and end . Derangement is a permutation of the sequence where no element remains in place. sequence is not modified, but individual derangements are eq to each other. Consequences are unspecified if calling function modifies either the derangement or sequence . map-permutations Function: (map-permutations function sequence &key start end length copy) Calls function with each permutation of length constructable from the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of the sequence, and length to the length of the delimited subsequence. 5. IO read-file-into-string Function: (read-file-into-string pathname &key buffer-size external-format) Return the contents of the file denoted by pathname as a fresh string. The external-format parameter will be passed directly to with-open-file unless it's nil , which means the system default. Function: (read-file-into-byte-vector pathname) Read pathname into a freshly allocated (unsigned-byte 8) vector. 6. MACRO WRITING once-only Macro: (once-only specs &body forms) Evaluates forms with symbols specified in specs rebound to temporary variables, ensuring that each initform is evaluated only once. Each of specs must either be a symbol naming the variable to be rebound, or of the form: (symbol initform) Bare symbols in specs are equivalent to (symbol symbol) Example: (defmacro cons1 (x) (once-only (x) `(cons ,x ,x))) (let ((y 0)) (cons1 (incf y))) =(1 . 1) with-gensyms Macro: (with-gensyms names &body forms) Binds each variable named by a symbol in names to a unique symbol around forms . Each of names must either be either a symbol, or of the form: (symbol string-designator) Bare symbols appearing in names are equivalent to: (symbol symbol) The string-designator is used as the argument to gensym when constructing the unique symbol the named variable will be bound to. with-unique-names Macro: (with-unique-names names &body forms) Alias for with-gensyms . featurep Function: (featurep feature-expression) Returns t if the argument matches the state of the *features* list and nil if it does not. feature-expression can be any atom or list acceptable to the reader macros #+ and #- . parse-body Function: (parse-body body &key documentation whole) Parses body into (values remaining-forms declarations doc-string). Documentation strings are recognized only if documentation is true. Syntax errors in body are signalled and whole is used in the signal arguments when given. parse-ordinary-lambda-list Function: (parse-ordinary-lambda-list lambda-list &key normalize allow-specializers normalize-optional normalize-keyword normalize-auxilary) Parses an ordinary lambda-list, returning as multiple values: 1 . Required parameters. 2 . Optional parameter specifications, normalized into form: (name init suppliedp) 3 . Name of the rest parameter, or nil . 4 . Keyword parameter specifications, normalized into form: ((keyword-name name) init suppliedp) 5 . Boolean indicating &allow-other-keys presence. 6 . &aux parameter specifications, normalized into form (name init). Signals a program-error is the lambda-list is malformed. 7. SYMBOLS ensure-symbol Function: (ensure-symbol name &optional package) Returns a symbol with name designated by name , accessible in package designated by package . If symbol is not already accessible in package , it is interned there. Returns a secondary value reflecting the status of the symbol in the package, which matches the secondary return value of intern . Example: (ensure-symbol :cons :cl) =cl:cons, :external format-symbol Function: (format-symbol package control &rest arguments) Constructs a string by applying arguments to string designator control as if by format within with-standard-io-syntax , and then creates a symbol named by that string. If package is nil , returns an uninterned symbol, if package is t , returns a symbol interned in the current package, and otherwise returns a symbol interned in the package designated by package . make-keyword Function: (make-keyword name) Interns the string designated by name in the keyword package. make-gensym Function: (make-gensym name) If name is a non-negative integer, calls gensym using it. Otherwise name must be a string designator, in which case calls gensym using the designated string as the argument. make-gensym-list Function: (make-gensym-list length &optional x) Returns a list of length gensyms, each generated as if with a call to make-gensym , using the second (optional, defaulting to \"G\") argument. symbolicate Function: (symbolicate &rest things) Concatenate together the names of some strings and symbols, producing a symbol in the current package. 8. ARRAYS array-index Type designator for an index into array of `length:` an integer between `0` (inclusive) and `length` (exclusive). `length` defaults to `array-dimension-limit`. ### array-length Type designator for a dimension of an array of length: an integer between 0 (inclusive) and length (inclusive). length defaults to array-dimension-limit . copy-array Function: (copy-array array &key element-type fill-pointer adjustable) Returns an undisplaced copy of array , with same fill-pointer and adjustability (if any) as the original, unless overridden by the keyword arguments. 9. TYPES string-designator A string designator type. A string designator is either a string, a symbol, or a character. coercef Macro: (coercef place type-spec env) Modify-macro for coerce . of-type Function: (of-type type) Returns a function of one argument, which returns true when its argument is of type . type= Function: (type= type1 type2) Returns a primary value of t is type1 and type2 are the same type, and a secondary value that is true is the type equality could be reliably determined: primary value of nil and secondary value of t indicates that the types are not equivalent. 10. NUMBERS maxf Macro: (maxf place &rest numbers env) Modify-macro for max . Sets place designated by the first argument to the maximum of its original value and numbers . minf Macro: (minf place &rest numbers env) Modify-macro for min . Sets place designated by the first argument to the minimum of its original value and numbers . binomial-coefficient Function: (binomial-coefficient n k) Binomial coefficient of n and k , also expressed as n choose k . This is the number of k element combinations given n choises. n must be equal to or greater then k . count-permutations Function: (count-permutations n &optional k) Number of k element permutations for a sequence of n objects. k defaults to n clamp Function: (clamp number min max) Clamps the number into [min, max] range. Returns min if number is lesser then min and max if number is greater then max , otherwise returns number . lerp Function: (lerp v a b) Returns the result of linear interpolation between A and b , using the interpolation coefficient v . factorial Function: (factorial n) Factorial of non-negative integer n . subfactorial Function: (subfactorial n) Subfactorial of the non-negative integer n . gaussian-random Function: (gaussian-random &optional min max) Returns two gaussian random double floats as the primary and secondary value, optionally constrained by min and max . Gaussian random numbers form a standard normal distribution around 0 .0d0. Sufficiently positive min or negative max will cause the algorithm used to take a very long time. If min is positive it should be close to zero, and similarly if max is negative it should be close to zero. iota Function: (iota n &key start step) Return a list of n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Examples: (iota 4) =(0 1 2 3) (iota 3 :start 1 :step 1.0) =(1.0 2.0 3.0) (iota 3 :start -1 :step -1/2) =(-1 -3/2 -2) map-iota Function: (map-iota function n &key start step) Calls function with n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Returns n . Examples: (map-iota #'print 3 :start 1 :step 1.0) =3 ;;; 1.0 ;;; 2.0 ;;; 3.0 mean Function: (mean sample) Returns the mean of sample . sample must be a sequence of numbers. median Function: (median sample) Returns median of sample . sample must be a sequence of real numbers. variance Function: (variance sample &key biased) Variance of sample . Returns the biased variance if biased is true (the default), and the unbiased estimator of variance if biased is false. sample must be a sequence of numbers. standard-deviation Function: (standard-deviation sample &key biased) Standard deviation of sample . Returns the biased standard deviation if biased is true (the default), and the square root of the unbiased estimator for variance if biased is false (which is not the same as the unbiased estimator for standard deviation). sample must be a sequence of numbers.","title":"alexandria - Commonly Used Utilities"},{"location":"alexandria/#alexandria-commonly-used-utilities","text":"Version: 1.0.0 Repository: alexandria/alexandria - Gitlab This documentation is modified to markdown from here on 01 March, 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here .","title":"alexandria - Commonly Used Utilities"},{"location":"alexandria/#alexandria","text":"Alexandria software and associated documentation are in the public domain: Authors dedicate this work to public domain, for the benefit of the public at large and to the detriment of the authors' heirs and successors. Authors intends this dedication to be an overt act of relinquishment in perpetuity of all present and future rights under copyright law, whether vested or contingent, in the work. Authors understands that such relinquishment of all rights includes the relinquishment of all rights to enforce (by lawsuit or otherwise) those copyrights in the work. Authors recognize that, once placed in the public domain, the work may be freely reproduced, distributed, transmitted, used, modified, built upon, or otherwise exploited by anyone for any purpose, commercial or non-commercial, and in any way, including by methods that have not yet been invented or conceived. In those legislations where public domain dedications are not recognized or possible, Alexandria is distributed under the following terms and conditions: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"ALEXANDRIA"},{"location":"alexandria/#1-hash-tables","text":"","title":"1. HASH TABLES"},{"location":"alexandria/#ensure-gethash","text":"Macro: (ensure-gethash key hash-table &optional default) Like gethash , but if key is not found in the hash-table saves the default under key before returning it. Secondary return value is true if key was already in the table.","title":"ensure-gethash"},{"location":"alexandria/#copy-hash-table","text":"Function: (copy-hash-table table &key key test size rehash-size rehash-threshold) Returns a copy of hash table table , with the same keys and values as the table . The copy has the same properties as the original, unless overridden by the keyword arguments. Before each of the original values is set into the new hash-table, key is invoked on the value. As key defaults to cl:identity , a shallow copy is returned by default.","title":"copy-hash-table"},{"location":"alexandria/#maphash-keys","text":"Function: (maphash-keys function table) Like maphash , but calls function with each key in the hash table table .","title":"maphash-keys"},{"location":"alexandria/#maphash-values","text":"Function: (maphash-values function table) Like maphash , but calls function with each value in the hash table table .","title":"maphash-values"},{"location":"alexandria/#hash-table-keys","text":"Function: (hash-table-keys table) Returns a list containing the keys of hash table table .","title":"hash-table-keys"},{"location":"alexandria/#hash-table-values","text":"Function: (hash-table-values table) Returns a list containing the values of hash table table .","title":"hash-table-values"},{"location":"alexandria/#hash-table-alist","text":"Function: (hash-table-alist table) Returns an association list containing the keys and values of hash table table .","title":"hash-table-alist"},{"location":"alexandria/#hash-table-plist","text":"Function: (hash-table-plist table) Returns a property list containing the keys and values of hash table table .","title":"hash-table-plist"},{"location":"alexandria/#alist-hash-table","text":"Function: (alist-hash-table alist &rest hash-table-initargs) Returns a hash table containing the keys and values of the association list alist . Hash table is initialized using the hash-table-initargs .","title":"alist-hash-table"},{"location":"alexandria/#plist-hash-table","text":"Function: (plist-hash-table plist &rest hash-table-initargs) Returns a hash table containing the keys and values of the property list plist . Hash table is initialized using the hash-table-initargs .","title":"plist-hash-table"},{"location":"alexandria/#2-data-and-control-flow","text":"","title":"2. DATA AND CONTROL FLOW"},{"location":"alexandria/#define-constant","text":"Macro: (define-constant name initial-value &key test documentation) Ensures that the global variable named by name is a constant with a value that is equal under test to the result of evaluating initial-value . test is a /function designator/ that defaults to eql . If documentation is given, it becomes the documentation string of the constant. Signals an error if name is already a bound non-constant variable. Signals an error if name is already a constant variable whose value is not equal under test to result of evaluating initial-value .","title":"define-constant"},{"location":"alexandria/#destructuring-case","text":"Macro: (destructuring-case keyform &body clauses) destructuring-case , -ccase , and -ecase are a combination of case and destructuring-bind . keyform must evaluate to a cons . Clauses are of the form: ((CASE-KEYS . DESTRUCTURING-LAMBDA-LIST) FORM*) The clause whose case-keys matches car of key , as if by case , ccase , or ecase , is selected, and FORMs are then executed with cdr of key is destructured and bound by the destructuring-lambda-list . Example: (defun dcase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)) ((t &rest rest) (format nil \"unknown: ~S\" rest)))) (dcase (list :foo 1 2)) ; =\"foo: 1, 2\" (dcase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (dcase (list :alt1 1)) ; =\"alt: 1\" (dcase (list :alt2 2)) ; =\"alt: 2\" (dcase (list :quux 1 2 3)) ; =\"unknown: 1, 2, 3\" (defun decase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)))) (decase (list :foo 1 2)) ; =\"foo: 1, 2\" (decase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (decase (list :alt1 1)) ; =\"alt: 1\" (decase (list :alt2 2)) ; =\"alt: 2\" (decase (list :quux 1 2 3)) ; =| error","title":"destructuring-case"},{"location":"alexandria/#ensure-functionf","text":"Macro: (ensure-functionf &rest places) Multiple-place modify macro for ensure-function: ensures that each of places contains a function.","title":"ensure-functionf"},{"location":"alexandria/#multiple-value-prog2","text":"Macro: (multiple-value-prog2 first-form second-form &body forms) Evaluates first-form , then second-form , and then forms . Yields as its value all the value returned by second-form .","title":"multiple-value-prog2"},{"location":"alexandria/#named-lambda","text":"Macro: (named-lambda name lambda-list &body body) Expands into a lambda-expression within whose body name denotes the corresponding function.","title":"named-lambda"},{"location":"alexandria/#nth-value-or","text":"Macro: (nth-value-or nth-value &body forms) Evaluates form arguments one at a time, until the nth-value returned by one of the forms is true. It then returns all the values returned by evaluating that form. If none of the forms return a true nth value, this form returns nil .","title":"nth-value-or"},{"location":"alexandria/#if-let","text":"Macro: (if-let bindings &body (then-form &optional else-form)) Creates new variable bindings, and conditionally executes either then-form or else-form . else-form defaults to nil . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, the then-form is executed with the bindings in effect, otherwise the else-form is executed with the bindings in effect.","title":"if-let"},{"location":"alexandria/#when-let","text":"Macro: (when-let bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, then forms are executed as an implicit progn . Macro: (when-let* bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) Each initial-form is executed in turn, and the variable bound to the corresponding value. Initial-form expressions can refer to variables previously bound by the when-let* . Execution of when-let* stops immediately if any initial-form evaluates to nil . If all initial-forms evaluate to true, then forms are executed as an implicit progn .","title":"when-let"},{"location":"alexandria/#switch","text":"Macro: (switch whole (object &key test key) &body clauses) Evaluates first matching clause, returning its values, or evaluates and returns the values of default if no keys match.","title":"switch"},{"location":"alexandria/#cswitch","text":"Macro: (cswitch whole (object &key test key) &body clauses) Like switch , but signals a continuable error if no key matches.","title":"cswitch"},{"location":"alexandria/#eswitch","text":"Macro: (eswitch whole (object &key test key) &body clauses) Like switch , but signals an error if no key matches.","title":"eswitch"},{"location":"alexandria/#whichever","text":"Macro: (whichever &rest possibilities env) Evaluates exactly one of possibilities , chosen at random.","title":"whichever"},{"location":"alexandria/#xor","text":"Macro: (xor &rest datums) Evaluates its arguments one at a time, from left to right. If more then one argument evaluates to a true value no further datums are evaluated, and nil is returned as both primary and secondary value. If exactly one argument evaluates to true, its value is returned as the primary value after all the arguments have been evaluated, and t is returned as the secondary value. If no arguments evaluate to true nil is retuned as primary, and t as secondary value.","title":"xor"},{"location":"alexandria/#disjoin","text":"Function: (disjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning the primary value of the first predicate that returns true, without calling the remaining predicates. If none of the predicates returns true, nil is returned.","title":"disjoin"},{"location":"alexandria/#conjoin","text":"Function: (conjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning nil if any of the predicates returns false, without calling the remaining predicates. If none of the predicates returns false, returns the primary value of the last predicate.","title":"conjoin"},{"location":"alexandria/#compose","text":"Function: (compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to to each in turn, starting from the rightmost of more-functions , and then calling the next one with the primary value of the last. Function: (ensure-function function-designator) Returns the function designated by function-designator: if function-designator is a function, it is returned, otherwise it must be a function name and its fdefinition is returned.","title":"compose"},{"location":"alexandria/#multiple-value-compose","text":"Function: (multiple-value-compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to each in turn, starting from the rightmost of more-functions , and then calling the next one with all the return values of the last.","title":"multiple-value-compose"},{"location":"alexandria/#curry","text":"Function: (curry function &rest arguments) Returns a function that applies arguments and the arguments it is called with to function .","title":"curry"},{"location":"alexandria/#rcurry","text":"Function: (rcurry function &rest arguments) Returns a function that applies the arguments it is called with and arguments to function .","title":"rcurry"},{"location":"alexandria/#3-conses","text":"","title":"3. CONSES"},{"location":"alexandria/#proper-list","text":"Type designator for proper lists. Implemented as a satisfies type, hence not recommended for performance intensive use. Main usefullness as a type designator of the expected type in a type-error .","title":"proper-list"},{"location":"alexandria/#circular-list","text":"Type designator for circular lists. Implemented as a satisfies type, so not recommended for performance intensive use. Main usefullness as the expected-type designator of a type-error .","title":"circular-list"},{"location":"alexandria/#appendf","text":"Macro: (appendf place &rest lists env) Modify-macro for append . Appends lists to the place designated by the first argument.","title":"appendf"},{"location":"alexandria/#nconcf","text":"Macro: (nconcf place &rest lists env) Modify-macro for nconc . Concatenates lists to place designated by the first argument.","title":"nconcf"},{"location":"alexandria/#remove-from-plistf","text":"Macro: (remove-from-plistf place &rest keys env) Modify macro for remove-from-plist .","title":"remove-from-plistf"},{"location":"alexandria/#delete-from-plistf","text":"Macro: (delete-from-plistf place &rest keys env) Modify macro for delete-from-plist .","title":"delete-from-plistf"},{"location":"alexandria/#reversef","text":"Macro: (reversef place env) Modify-macro for reverse . Copies and reverses the list stored in the given place and saves back the result into the place.","title":"reversef"},{"location":"alexandria/#nreversef","text":"Macro: (nreversef place env) Modify-macro for nreverse . Reverses the list stored in the given place by destructively modifying it and saves back the result into the place.","title":"nreversef"},{"location":"alexandria/#unionf","text":"Macro: (unionf place list &rest args env) Modify-macro for union . Saves the union of list and the contents of the place designated by the first argument to the designated place.","title":"unionf"},{"location":"alexandria/#nunionf","text":"Macro: (nunionf place list &rest args env) Modify-macro for nunion . Saves the union of list and the contents of the place designated by the first argument to the designated place. May modify either argument.","title":"nunionf"},{"location":"alexandria/#doplist","text":"Macro: (doplist (key val plist &optional values) &body body) Iterates over elements of plist . body can be preceded by declarations, and is like a tagbody . return may be used to terminate the iteration early. If return is not used, returns values .","title":"doplist"},{"location":"alexandria/#circular-list-p","text":"Function: (circular-list-p object) Returns true if object is a circular list, nil otherwise.","title":"circular-list-p"},{"location":"alexandria/#circular-tree-p","text":"Function: (circular-tree-p object) Returns true if object is a circular tree, nil otherwise.","title":"circular-tree-p"},{"location":"alexandria/#proper-list-p","text":"Function: (proper-list-p object) Returns true if object is a proper list.","title":"proper-list-p"},{"location":"alexandria/#alist-plist","text":"Function: (alist-plist alist) Returns a property list containing the same keys and values as the association list alist in the same order.","title":"alist-plist"},{"location":"alexandria/#plist-alist","text":"Function: (plist-alist plist) Returns an association list containing the same keys and values as the property list plist in the same order.","title":"plist-alist"},{"location":"alexandria/#circular-list_1","text":"Function: (circular-list &rest elements) Creates a circular list of elements .","title":"circular-list"},{"location":"alexandria/#make-circular-list","text":"Function: (make-circular-list length &key initial-element) Creates a circular list of length with the given initial-element .","title":"make-circular-list"},{"location":"alexandria/#ensure-car","text":"Function: (ensure-car thing) If thing is a cons , its car is returned. Otherwise thing is returned.","title":"ensure-car"},{"location":"alexandria/#ensure-cons","text":"Function: (ensure-cons cons) If cons is a cons, it is returned. Otherwise returns a fresh cons with cons in the car, and nil in the cdr.","title":"ensure-cons"},{"location":"alexandria/#ensure-list","text":"Function: (ensure-list list) If list is a list, it is returned. Otherwise returns the list designated by list .","title":"ensure-list"},{"location":"alexandria/#flatten","text":"Function: (flatten tree) Traverses the tree in order, collecting non-null leaves into a list.","title":"flatten"},{"location":"alexandria/#lastcar","text":"Function: (lastcar list) Returns the last element of list . Signals a type-error if list is not a proper list.","title":"lastcar"},{"location":"alexandria/#setf","text":"Function: ((setf lastcar)) Sets the last element of list . Signals a type-error if list is not a proper list.","title":"(setf"},{"location":"alexandria/#proper-list-length","text":"Function: (proper-list-length list) Returns length of list , signalling an error if it is not a proper list.","title":"proper-list-length"},{"location":"alexandria/#mappend","text":"Function: (mappend function &rest lists) Applies function to respective element(s) of each list , appending all the all the result list to a single list. function must return a list.","title":"mappend"},{"location":"alexandria/#map-product","text":"Function: (map-product function list &rest more-lists) Returns a list containing the results of calling function with one argument from list , and one from each of more-lists for each combination of arguments. In other words, returns the product of list and more-lists using function . Example: (map-product 'list '(1 2) '(3 4) '(5 6)) =((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6))","title":"map-product"},{"location":"alexandria/#remove-from-plist","text":"Function: (remove-from-plist plist &rest keys) Returns a propery-list with same keys and values as plist , except that keys in the list designated by keys and values corresponding to them are removed. The returned property-list may share structure with the plist , but plist is not destructively modified. Keys are compared using eq .","title":"remove-from-plist"},{"location":"alexandria/#delete-from-plist","text":"Function: (delete-from-plist plist &rest keys) Just like remove-from-plist , but this version may destructively modify the provided plist.","title":"delete-from-plist"},{"location":"alexandria/#set-equal","text":"Function: (set-equal list1 list2 &key test key) Returns true if every element of list1 matches some element of list2 and every element of list2 matches some element of list1 . Otherwise returns false.","title":"set-equal"},{"location":"alexandria/#setp","text":"Function: (setp object &key test key) Returns true if object is a list that denotes a set, nil otherwise. A list denotes a set if each element of the list is unique under key and test .","title":"setp"},{"location":"alexandria/#4-sequences","text":"","title":"4. SEQUENCES"},{"location":"alexandria/#proper-sequence","text":"Type designator for proper sequences, that is proper lists and sequences that are not lists.","title":"proper-sequence"},{"location":"alexandria/#deletef","text":"Macro: (deletef place item &rest remove-keywords env) Modify-macro for delete . Sets place designated by the first argument to the result of calling delete with item , place, and the remove-keywords .","title":"deletef"},{"location":"alexandria/#removef","text":"Macro: (removef place item &rest remove-keywords env) Modify-macro for remove . Sets place designated by the first argument to the result of calling remove with item , place, and the remove-keywords .","title":"removef"},{"location":"alexandria/#rotate","text":"Function: (rotate sequence &optional n) Returns a sequence of the same type as sequence , with the elements of sequence rotated by n: n elements are moved from the end of the sequence to the front if n is positive, and -n elements moved from the front to the end if n is negative. sequence must be a proper sequence. n must be an integer, defaulting to 1 . If absolute value of n is greater then the length of the sequence, the results are identical to calling rotate with (* (signum n) (mod n (length sequence))). Note: the original sequence may be destructively altered, and result sequence may share structure with it.","title":"rotate"},{"location":"alexandria/#shuffle","text":"Function: (shuffle sequence &key start end) Returns a random permutation of sequence bounded by start and end . Original sequece may be destructively modified, and share storage with the original one. Signals an error if sequence is not a proper sequence.","title":"shuffle"},{"location":"alexandria/#random-elt","text":"Function: (random-elt sequence &key start end) Returns a random element from sequence bounded by start and end . Signals an error if the sequence is not a proper non-empty sequence, or if end and start are not proper bounding index designators for sequence .","title":"random-elt"},{"location":"alexandria/#emptyp","text":"Function: (emptyp sequence) Returns true if sequence is an empty sequence. Signals an error if sequence is not a sequence.","title":"emptyp"},{"location":"alexandria/#sequence-of-length-p","text":"Function: (sequence-of-length-p sequence length) Return true if sequence is a sequence of length length . Signals an error if sequence is not a sequence. Returns false for circular lists.","title":"sequence-of-length-p"},{"location":"alexandria/#length","text":"Function: (length= &rest sequences) Takes any number of sequences or integers in any order. Returns true iff the length of all the sequences and the integers are equal. Hint: there's a compiler macro that expands into more efficient code if the first argument is a literal integer.","title":"length="},{"location":"alexandria/#copy-sequence","text":"Function: (copy-sequence type sequence) Returns a fresh sequence of type , which has the same elements as sequence .","title":"copy-sequence"},{"location":"alexandria/#first-elt","text":"Function: (first-elt sequence) Returns the first element of sequence . Signals a type-error if sequence is not a sequence, or is an empty sequence.","title":"first-elt"},{"location":"alexandria/#setf-first-elt","text":"Function: ((setf first-elt)) Sets the first element of sequence . Signals a type-error if sequence is not a sequence, is an empty sequence, or if object cannot be stored in sequence .","title":"(setf first-elt)"},{"location":"alexandria/#last-elt","text":"Function: (last-elt sequence) Returns the last element of sequence . Signals a type-error if sequence is not a proper sequence, or is an empty sequence.","title":"last-elt"},{"location":"alexandria/#setf-last-elt","text":"Function: ((setf last-elt)) Sets the last element of sequence . Signals a type-error if sequence is not a proper sequence, is an empty sequence, or if object cannot be stored in sequence .","title":"(setf last-elt)"},{"location":"alexandria/#starts-with","text":"Function: (starts-with object sequence &key test key) Returns true if sequence is a sequence whose first element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence.","title":"starts-with"},{"location":"alexandria/#starts-with-subseq","text":"Function: (starts-with-subseq prefix sequence &rest args &key return-suffix &allow-other-keys) Test whether the first elements of sequence are the same (as per TEST) as the elements of prefix . If return-suffix is t the functions returns, as a second value, a displaced array pointing to the sequence after prefix .","title":"starts-with-subseq"},{"location":"alexandria/#ends-with","text":"Function: (ends-with object sequence &key test key) Returns true if sequence is a sequence whose last element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. Signals an error if sequence is an improper list.","title":"ends-with"},{"location":"alexandria/#ends-with-subseq","text":"Function: (ends-with-subseq suffix sequence &key test) Test whether sequence ends with suffix . In other words: return true if the last (length SUFFIX) elements of sequence are equal to suffix .","title":"ends-with-subseq"},{"location":"alexandria/#map-combinations","text":"Function: (map-combinations function sequence &key start end length copy) Calls function with each combination of length constructable from the elements of the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of sequence , and length to the length of the delimited subsequence. (So unless length is specified there is only a single combination, which has the same elements as the delimited subsequence.) If copy is true (the default) each combination is freshly allocated. If copy is false all combinations are eq to each other, in which case consequences are specified if a combination is modified by function .","title":"map-combinations"},{"location":"alexandria/#map-derangements","text":"Function: (map-derangements function sequence &key start end copy) Calls function with each derangement of the subsequence of sequence denoted by the bounding index designators start and end . Derangement is a permutation of the sequence where no element remains in place. sequence is not modified, but individual derangements are eq to each other. Consequences are unspecified if calling function modifies either the derangement or sequence .","title":"map-derangements"},{"location":"alexandria/#map-permutations","text":"Function: (map-permutations function sequence &key start end length copy) Calls function with each permutation of length constructable from the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of the sequence, and length to the length of the delimited subsequence.","title":"map-permutations"},{"location":"alexandria/#5-io","text":"","title":"5. IO"},{"location":"alexandria/#read-file-into-string","text":"Function: (read-file-into-string pathname &key buffer-size external-format) Return the contents of the file denoted by pathname as a fresh string. The external-format parameter will be passed directly to with-open-file unless it's nil , which means the system default. Function: (read-file-into-byte-vector pathname) Read pathname into a freshly allocated (unsigned-byte 8) vector.","title":"read-file-into-string"},{"location":"alexandria/#6-macro-writing","text":"","title":"6. MACRO WRITING"},{"location":"alexandria/#once-only","text":"Macro: (once-only specs &body forms) Evaluates forms with symbols specified in specs rebound to temporary variables, ensuring that each initform is evaluated only once. Each of specs must either be a symbol naming the variable to be rebound, or of the form: (symbol initform) Bare symbols in specs are equivalent to (symbol symbol) Example: (defmacro cons1 (x) (once-only (x) `(cons ,x ,x))) (let ((y 0)) (cons1 (incf y))) =(1 . 1)","title":"once-only"},{"location":"alexandria/#with-gensyms","text":"Macro: (with-gensyms names &body forms) Binds each variable named by a symbol in names to a unique symbol around forms . Each of names must either be either a symbol, or of the form: (symbol string-designator) Bare symbols appearing in names are equivalent to: (symbol symbol) The string-designator is used as the argument to gensym when constructing the unique symbol the named variable will be bound to.","title":"with-gensyms"},{"location":"alexandria/#with-unique-names","text":"Macro: (with-unique-names names &body forms) Alias for with-gensyms .","title":"with-unique-names"},{"location":"alexandria/#featurep","text":"Function: (featurep feature-expression) Returns t if the argument matches the state of the *features* list and nil if it does not. feature-expression can be any atom or list acceptable to the reader macros #+ and #- .","title":"featurep"},{"location":"alexandria/#parse-body","text":"Function: (parse-body body &key documentation whole) Parses body into (values remaining-forms declarations doc-string). Documentation strings are recognized only if documentation is true. Syntax errors in body are signalled and whole is used in the signal arguments when given.","title":"parse-body"},{"location":"alexandria/#parse-ordinary-lambda-list","text":"Function: (parse-ordinary-lambda-list lambda-list &key normalize allow-specializers normalize-optional normalize-keyword normalize-auxilary) Parses an ordinary lambda-list, returning as multiple values: 1 . Required parameters. 2 . Optional parameter specifications, normalized into form: (name init suppliedp) 3 . Name of the rest parameter, or nil . 4 . Keyword parameter specifications, normalized into form: ((keyword-name name) init suppliedp) 5 . Boolean indicating &allow-other-keys presence. 6 . &aux parameter specifications, normalized into form (name init). Signals a program-error is the lambda-list is malformed.","title":"parse-ordinary-lambda-list"},{"location":"alexandria/#7-symbols","text":"","title":"7. SYMBOLS"},{"location":"alexandria/#ensure-symbol","text":"Function: (ensure-symbol name &optional package) Returns a symbol with name designated by name , accessible in package designated by package . If symbol is not already accessible in package , it is interned there. Returns a secondary value reflecting the status of the symbol in the package, which matches the secondary return value of intern . Example: (ensure-symbol :cons :cl) =cl:cons, :external","title":"ensure-symbol"},{"location":"alexandria/#format-symbol","text":"Function: (format-symbol package control &rest arguments) Constructs a string by applying arguments to string designator control as if by format within with-standard-io-syntax , and then creates a symbol named by that string. If package is nil , returns an uninterned symbol, if package is t , returns a symbol interned in the current package, and otherwise returns a symbol interned in the package designated by package .","title":"format-symbol"},{"location":"alexandria/#make-keyword","text":"Function: (make-keyword name) Interns the string designated by name in the keyword package.","title":"make-keyword"},{"location":"alexandria/#make-gensym","text":"Function: (make-gensym name) If name is a non-negative integer, calls gensym using it. Otherwise name must be a string designator, in which case calls gensym using the designated string as the argument.","title":"make-gensym"},{"location":"alexandria/#make-gensym-list","text":"Function: (make-gensym-list length &optional x) Returns a list of length gensyms, each generated as if with a call to make-gensym , using the second (optional, defaulting to \"G\") argument.","title":"make-gensym-list"},{"location":"alexandria/#symbolicate","text":"Function: (symbolicate &rest things) Concatenate together the names of some strings and symbols, producing a symbol in the current package.","title":"symbolicate"},{"location":"alexandria/#8-arrays","text":"","title":"8. ARRAYS"},{"location":"alexandria/#array-index","text":"Type designator for an index into array of `length:` an integer between `0` (inclusive) and `length` (exclusive). `length` defaults to `array-dimension-limit`. ### array-length Type designator for a dimension of an array of length: an integer between 0 (inclusive) and length (inclusive). length defaults to array-dimension-limit .","title":"array-index"},{"location":"alexandria/#copy-array","text":"Function: (copy-array array &key element-type fill-pointer adjustable) Returns an undisplaced copy of array , with same fill-pointer and adjustability (if any) as the original, unless overridden by the keyword arguments.","title":"copy-array"},{"location":"alexandria/#9-types","text":"","title":"9. TYPES"},{"location":"alexandria/#string-designator","text":"A string designator type. A string designator is either a string, a symbol, or a character.","title":"string-designator"},{"location":"alexandria/#coercef","text":"Macro: (coercef place type-spec env) Modify-macro for coerce .","title":"coercef"},{"location":"alexandria/#of-type","text":"Function: (of-type type) Returns a function of one argument, which returns true when its argument is of type .","title":"of-type"},{"location":"alexandria/#type","text":"Function: (type= type1 type2) Returns a primary value of t is type1 and type2 are the same type, and a secondary value that is true is the type equality could be reliably determined: primary value of nil and secondary value of t indicates that the types are not equivalent.","title":"type="},{"location":"alexandria/#10-numbers","text":"","title":"10. NUMBERS"},{"location":"alexandria/#maxf","text":"Macro: (maxf place &rest numbers env) Modify-macro for max . Sets place designated by the first argument to the maximum of its original value and numbers .","title":"maxf"},{"location":"alexandria/#minf","text":"Macro: (minf place &rest numbers env) Modify-macro for min . Sets place designated by the first argument to the minimum of its original value and numbers .","title":"minf"},{"location":"alexandria/#binomial-coefficient","text":"Function: (binomial-coefficient n k) Binomial coefficient of n and k , also expressed as n choose k . This is the number of k element combinations given n choises. n must be equal to or greater then k .","title":"binomial-coefficient"},{"location":"alexandria/#count-permutations","text":"Function: (count-permutations n &optional k) Number of k element permutations for a sequence of n objects. k defaults to n","title":"count-permutations"},{"location":"alexandria/#clamp","text":"Function: (clamp number min max) Clamps the number into [min, max] range. Returns min if number is lesser then min and max if number is greater then max , otherwise returns number .","title":"clamp"},{"location":"alexandria/#lerp","text":"Function: (lerp v a b) Returns the result of linear interpolation between A and b , using the interpolation coefficient v .","title":"lerp"},{"location":"alexandria/#factorial","text":"Function: (factorial n) Factorial of non-negative integer n .","title":"factorial"},{"location":"alexandria/#subfactorial","text":"Function: (subfactorial n) Subfactorial of the non-negative integer n .","title":"subfactorial"},{"location":"alexandria/#gaussian-random","text":"Function: (gaussian-random &optional min max) Returns two gaussian random double floats as the primary and secondary value, optionally constrained by min and max . Gaussian random numbers form a standard normal distribution around 0 .0d0. Sufficiently positive min or negative max will cause the algorithm used to take a very long time. If min is positive it should be close to zero, and similarly if max is negative it should be close to zero.","title":"gaussian-random"},{"location":"alexandria/#iota","text":"Function: (iota n &key start step) Return a list of n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Examples: (iota 4) =(0 1 2 3) (iota 3 :start 1 :step 1.0) =(1.0 2.0 3.0) (iota 3 :start -1 :step -1/2) =(-1 -3/2 -2)","title":"iota"},{"location":"alexandria/#map-iota","text":"Function: (map-iota function n &key start step) Calls function with n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Returns n . Examples: (map-iota #'print 3 :start 1 :step 1.0) =3 ;;; 1.0 ;;; 2.0 ;;; 3.0","title":"map-iota"},{"location":"alexandria/#mean","text":"Function: (mean sample) Returns the mean of sample . sample must be a sequence of numbers.","title":"mean"},{"location":"alexandria/#median","text":"Function: (median sample) Returns median of sample . sample must be a sequence of real numbers.","title":"median"},{"location":"alexandria/#variance","text":"Function: (variance sample &key biased) Variance of sample . Returns the biased variance if biased is true (the default), and the unbiased estimator of variance if biased is false. sample must be a sequence of numbers.","title":"variance"},{"location":"alexandria/#standard-deviation","text":"Function: (standard-deviation sample &key biased) Standard deviation of sample . Returns the biased standard deviation if biased is true (the default), and the square root of the unbiased estimator for variance if biased is false (which is not the same as the unbiased estimator for standard deviation). sample must be a sequence of numbers.","title":"standard-deviation"},{"location":"asdf/","text":"asdf ASDF (Another System Definition Facility) is the de facto standard building and loading software in Common Lisp. Your Lisp implementation probably contains a copy of ASDF, which you can load using (require \"asdf\"). (See Supported Implementations for the list.) ASDF 3 is the current successor to Daniel Barlow's ASDF (created on August 1st 2001) and Fran\u00e7ois-Ren\u00e9 Rideau's ASDF 2 (released May 31st 2010). It was rewritten for improved portability, robustness, usability, extensibility, configurability, internal consistency, and the ability to deliver standalone executables, all while maintaining substantial backward compatibility. ASDF will not download missing software components. For this, you will want to use Quicklisp , that builds upon ASDF. Also see the value of ql:*local-project-directories* in quicklisp. ASDF 3 contains two parts: asdf/defsystem and uiop. asdf/defsystem asdf/defsystem is the part that people usually refer to as ASDF, with uiop being only a supporting library, that happens to be distributed at the same time, by necessity. asdf/defsystem is a tool to describe how Lisp source code is organized in systems, and how to build and load these systems. Typical actions consist in compiling a Lisp source file (unless already up to date) and loading the resulting compilation output (unless both already loaded and up to date). And you must typically compile and load files that define packages, macros, variables, before you may compile and load other files that use them. If you come from the C/C++ world, ASDF covers a bit of what each of make, autoconf, dlopen and libc do for C programs: it orchestrates the compilation and dependency management, handles some of the portability issues, dynamically finds and loads code, and offers some portable system access library (see uiop below for the latter). Except everything is different in Common Lisp, and ultimately much simpler overall, though it does require acquiring some basic concepts that do not exactly match those of the C and Unix world. Importantly, ASDF builds all software in the current Lisp image, as opposed to building software into separate processes. uiop The Utilities for Implementation- and OS- Portability, formerly known as asdf/driver, is a Common Lisp portability library and runtime support system that helps you write Common Lisp software in a portable way* In addition to many general-purpose Lisp utilities, it notably provides portable abstractions to gloss over implementation quirks, support hot-upgrade of code, manipulate pathnames, create programs, use command-line arguments, access the environment, use the filesystem, call other programs and parse their output, compile Lisp code, muffle conditions, or configure Lisp software. See its README.md for an overview, and the documentation as extracted from its docstrings by Declt or HE\u039bP (NB: in HE\u039bP, you can, though it's not obvious, scroll the list of packages with a scrollbar on the right of the top-left pane, and then click on the package you're interested in to browse its symbols). uiop is distributed as part of ASDF: its source code is transcluded in the single-file asdf.lisp being distributed and the precompiled fasls provided by Lisp implementations. ASDF relies heavily on it for its portability layer and runtime support, particularly so as to handle pathnames and filesystem access. uiop is useful on its own and can also be compiled and distributed separately. What it is not If you're unsatisfied with ASDF, beside helping with our TODO list, you might be interested in other build systems for Common-Lisp: Google's deterministic and scalable build system Bazel, for which Lisp support is available: bazelisp. Alastair Bridgewater's small and simple one-package-per-file quick-build (also reimplemented as the ASDF extension asdf-package-system, now part of ASDF 3; similar to faslpath below). Fran\u00e7ois-Ren\u00e9 Rideau's XCVB (building object and image files deterministically and in parallel, but not actively maintained and bitrotten since 2012; a hypothetical ASDF 4 could conceivably be evolved to support these features thanks to the groundwork laid by ASDF 3; or you could use Bazel). Drew McDermott's YTools (the polar opposite of XCVB, trying to maintain coherence of the current Lisp image at a fine grain). Dmitriy Ivanov's ASDlite (a somewhat improved incompatible variant of ASDF 1, much less featureful, robust or portable than ASDF 3), Mark Kantrowitz's mk-defsystem (free software successor of the old proprietary DEFSYSTEM's and predecessor of ASDF, obsolete), Sean Ross's mudballs (an attempt at making things cleaner than in ASDF 2, aborted), Peter von Etter's faslpath (a much simpler system establishing a mapping between packages and files, abandoned but see asdf-package-system and quick-build above), Alexander Kahl's evol (a reimplementation in Lisp of the GNU autotools stack, abandoned). There are probably more. However, none of these systems seems to ever have had the traction of ASDF, probably because none was technically superior and/or portable enough (if at all) to compensate for the first mover advantage. Supported Implementations ASDF 3 now supports all CL implementations that seem to have any current user base, and then some. But ASDF does not magically turn broken implementations into working ones, and some ASDF or UIOP features may not work on less-maintained implementations that do not support them (see below). Most implementations provide ASDF as a module, and you can simply (require \"asdf\"). (All of them but CLISP also accept :asdf, \"ASDF\" or 'asdf as an argument.) All these implementations provide ASDF 3.1 or later in their latest version, but your software distribution might have an older version. As for remaining implementations, they are obsolete and/or mostly unmaintained; ASDF was made to run with each of them at some point, but some hacking is probably required to make the latest ASDF work well with the latest release of these implementations: CLISP is generally well-tested with ASDF, though it has a few minor bugs. The implementation has received only minimal maintenance since 2010, and the last official release doesn't ship with ASDF, or often has antique version of ASDF tucked on it. However, ASDF has been recently updated in its source control system, and there is hope of a new release some day soon. If needs be, you can replace CLISP's provided ASDF with a newer one, or use an upgrade on top of that. CormanLisp was recently open-sourced. Its bundled ASDF has not yet been updated from 1.x; ASDF 3 should work fine with it, but several features were disabled because CormanLisp was insufficiently compliant with the CLHS, and requires some work in this regard. Ask the new CormanLisp maintainers for updates. ECL is generally well-tested with ASDF, but its bytecode compiler doesn't support the bundle operations, and support for Windows seems to be less stable. For instance, as of January 2017, cl:require and ext:system (and thus uiop:run-program) seem not to be working correctly on Windows. GCL is somewhat maintained but its maintainer doesn't seem to care about ASDF, and hasn't replied for years to requests for bug fixes or for providing ASDF via (require \"asdf\") Genera was never open-source and never bundled ASDF, but should otherwise just work with a recent ASDF 3, if you somehow have a license and a working version. There are rumors of people doing active development with it and having minor patches to improve ASDF on it. MCL similarly was open-sourced, but never bundled ASDF; ASDF 3 should work just fine with it, but Rosetta is not supported in the latest versions of MacOS X, so a lot of work is required to make something out of it \u2014 at which point, you might just use CCL. Mocl has its own heavily modified variant of ASDF2, and is the only implementation not currently supported by ASDF3. To make it work with ASDF 3 would require ASDF to be taught about natively supporting cross-compilation. SCL was seemingly abandoned and never open-sourced. It never bundled ASDF, but otherwise should just work with a recent ASDF 3, if you somehow have a license and a working version. XCL is now an abandoned experiment. It provides some old ASDF 2; but you can replace it with ASDF 3, which works well with it, inasmuch as anything works at all with XCL. Provide ASDF 3.1 or later No ASDF Unmaintained Free ABCL, CCL, Clasp, CLISP, CMUCL, ECL, Mezzano, MKCL, SBCL CormanLisp, GCL, MCL XCL Proprietary Allegro, LispWorks Genera, mocl, SCL To deal with an implementation that does not yet provide ASDF 3.1 or later, we provide a script that will install the ASDF from your git checkout to where your implementation goes looking for it when you (require \"asdf\"). Note that upgrading from an old version of ASDF 2 or earlier is possible, but quite complex to do right in a robust way, and we do not recommend it. Also note that mocl only supports a heavily modified variant of ASDF 2, and will require robust cross-compilation support to be added to ASDF before it is actually supported. If there is an old or new implementation that we are missing, it shouldn't be hard to adapt ASDF to support it. Ask us! Examples Download any of the many packages available through Quicklisp to see as many examples. Documentation You can read our manual: ASDF as one HTML file split into one HTML file per section as a PDF document as texinfo source UIOP as one HTML file as a PDF document The first few sections, Loading ASDF, Configuring ASDF and Using ASDF will get you started as a simple user. If you want to define your own systems, further read the section Defining systems with defsystem. There is now also a Best Practices document explaining recommended usage patterns when writing .asd files, and detailing common pitfalls or deprecated practices to avoid. About the latest developments in ASDF 3.2 and ASDF 3.3, see our demo Delivering Common Lisp Applications with ASDF 3.3 (2-page PDF, slides, git). Regarding the internal design of ASDF in general, and the work we did on ASDF 3, see the extended version (26 pages) of our paper ASDF 3, or Why Lisp is Now an Acceptable Scripting Language (PDF, git). The shorter version (8 pages), presented at ELS 2014, focuses on ASDF 3 and misses historical and technical information (PDF, HTML). Regarding ASDF 3, see also the slides of the ASDF 3 tutorial presented at ELS 2013, and for an introduction to the source code, this video: ASDF 3.1 walkthrough. For details about our previous work on ASDF 2, see our paper presented at ILC 2010, Evolving ASDF: More Cooperation, Less Coordination (git). Finally, while the manual covers all the basics, some advanced or new features remain underdocumented. Please contact our mailing-list (see below) regarding any feature that isn't well-documented enough. Until we write more documentation on the further innovations of ASDF, the documentation strings, the source code, the changelog and the git log are unfortunately your best chances for discovering the available functionality. Getting it Though they may lag behind the version here, ASDF comes bundled with most Lisps. To get the greatest and latest, you can: download just the latest release source for asdf.lisp; download the latest release tarball to get all bells and whistles; pull the latest development tree from our git repository git clone https://gitlab.common-lisp.net/asdf/asdf.git (note that our \"master\" branch is for current development; get our \"release\" branch for the latest stable release. Run make to create build/asdf.lisp); browse the latest development tree from our git repository: gitlab download the tarball of a past release: archives Extensions Known extensions to ASDF include: asdf-dependency-grovel, to compute the actual dependencies in a big ASDF system. asdf-encodings, to compile Lisp source files with character encodings other than UTF-8. asdf-finalizers, to allow macros to include code to be evaluated at the end of a file being compiled. asdf-flv, to bind file-local variables around the compilation of some files. asdf-system-connections, lets you specify systems that are automatically loaded when two other systems are loaded, to connect them. cffi, lets you interface between functions and datastructures written in C and functions written in Lisp, including support for automatically detecting constants from C macros, linking to dynamic (and now also static) libraries, and writing your own wrapper code in C. poiu, to compile a system in parallel on a multiprocessor machine. Former extensions, now superseded, include: asdf-binary-locations used to allow one to redirect where ASDF 1 created its output files, so they don't clash between implementations and don't pollute source directories. It is superseded by asdf/defsystem's builtin asdf-output-translations mechanism; a limited compatibility mode is available to easily convert your former ABL configuration into an AOT configuration. common-lisp-controller and cl-launch used to provide similar mechanisms, and have also been superseded by asdf-output-translations (built into ASDF 2 and later). asdf-bundle, n\u00e9e asdf-ecl, allowed you to create a single-file bundle out of a system, for easier delivery. It is now a builtin part of asdf/defsystem, and allows users to deliver a single FASL for a system, a standalone executable program (on supported implementations), or an image containing your system precompiled. asdf-condition-control, initially part of XCVB's xcvb-driver, allowed you to muffle uninteresting conditions during compilation. Is now superseded by equivalent functionality in uiop. asdf-contrib, an empty package that used to collect dependencies on other systems in the list above and below. asdf-package-system, to compile Lisp source files with one package per file that also determines dependencies, in the style of quick-build or faslpath (this functionality is built into recent versions of ASDF 3.1 and later, but this package exists for backward compatibility with earlier versions of ASDF 3; search the manual for package-inferred-system). asdf-utils was a collection of utilities that originated with ASDF. It is now superseded by uiop, aka asdf/driver, which is part of ASDF, and exports its functionality in its own package uiop. Contributing Join our mailing list, check the code out from git, send questions, ideas and patches! Reporting Bugs To report bugs, you can use our common-lisp.net project. If you're unsure about the bug or want to discuss how to fix it, you can send email to the project mailing-list below. Note that the most valuable thing you can send this way are test cases, if possible as .script files readily runnable by our test system. If you're courageous, send us merge requests on gitlab. While bug fixes are useful, they are not usually as valuable as test cases: small easy fixes will be obvious from the test case, and large fixes written by someone who isn't either a maintainer or working tightly with one will probably not be correct and not fit the codebase: any modification at one point is likely to have repercussions at other unobvious places in the codebase, for the code to be correct in a wider variety of scenarios than casual developers usually think about. Now, if you're willing to become a maintainer, you're welcome to join the team! Mailing Lists asdf-devel A list for questions, suggestions, bug reports, patches, and so on. It's for everyone and everything. Please join the conversation! asdf-devel mailman site to subscribe asdf-announce A low-volume mailing-list for announcements only, mostly regarding new releases. Posting is restricted to project administrators and to important notices. Please subscribe to it if you're a Lisp implementation or distribution vendor, who needs to know when to upgrade the ASDF you distribute, but are otherwise not interested in day to day design and development. asdf-announce mailman site to subscribe Contributing Join our mailing list, check the code out from git, send questions, ideas and patches! What is happening For a detailed description of changes see our Changelog","title":"asdf"},{"location":"asdf/#asdf","text":"ASDF (Another System Definition Facility) is the de facto standard building and loading software in Common Lisp. Your Lisp implementation probably contains a copy of ASDF, which you can load using (require \"asdf\"). (See Supported Implementations for the list.) ASDF 3 is the current successor to Daniel Barlow's ASDF (created on August 1st 2001) and Fran\u00e7ois-Ren\u00e9 Rideau's ASDF 2 (released May 31st 2010). It was rewritten for improved portability, robustness, usability, extensibility, configurability, internal consistency, and the ability to deliver standalone executables, all while maintaining substantial backward compatibility. ASDF will not download missing software components. For this, you will want to use Quicklisp , that builds upon ASDF. Also see the value of ql:*local-project-directories* in quicklisp. ASDF 3 contains two parts: asdf/defsystem and uiop.","title":"asdf"},{"location":"asdf/#asdfdefsystem","text":"asdf/defsystem is the part that people usually refer to as ASDF, with uiop being only a supporting library, that happens to be distributed at the same time, by necessity. asdf/defsystem is a tool to describe how Lisp source code is organized in systems, and how to build and load these systems. Typical actions consist in compiling a Lisp source file (unless already up to date) and loading the resulting compilation output (unless both already loaded and up to date). And you must typically compile and load files that define packages, macros, variables, before you may compile and load other files that use them. If you come from the C/C++ world, ASDF covers a bit of what each of make, autoconf, dlopen and libc do for C programs: it orchestrates the compilation and dependency management, handles some of the portability issues, dynamically finds and loads code, and offers some portable system access library (see uiop below for the latter). Except everything is different in Common Lisp, and ultimately much simpler overall, though it does require acquiring some basic concepts that do not exactly match those of the C and Unix world. Importantly, ASDF builds all software in the current Lisp image, as opposed to building software into separate processes.","title":"asdf/defsystem"},{"location":"asdf/#uiop","text":"The Utilities for Implementation- and OS- Portability, formerly known as asdf/driver, is a Common Lisp portability library and runtime support system that helps you write Common Lisp software in a portable way* In addition to many general-purpose Lisp utilities, it notably provides portable abstractions to gloss over implementation quirks, support hot-upgrade of code, manipulate pathnames, create programs, use command-line arguments, access the environment, use the filesystem, call other programs and parse their output, compile Lisp code, muffle conditions, or configure Lisp software. See its README.md for an overview, and the documentation as extracted from its docstrings by Declt or HE\u039bP (NB: in HE\u039bP, you can, though it's not obvious, scroll the list of packages with a scrollbar on the right of the top-left pane, and then click on the package you're interested in to browse its symbols). uiop is distributed as part of ASDF: its source code is transcluded in the single-file asdf.lisp being distributed and the precompiled fasls provided by Lisp implementations. ASDF relies heavily on it for its portability layer and runtime support, particularly so as to handle pathnames and filesystem access. uiop is useful on its own and can also be compiled and distributed separately. What it is not If you're unsatisfied with ASDF, beside helping with our TODO list, you might be interested in other build systems for Common-Lisp: Google's deterministic and scalable build system Bazel, for which Lisp support is available: bazelisp. Alastair Bridgewater's small and simple one-package-per-file quick-build (also reimplemented as the ASDF extension asdf-package-system, now part of ASDF 3; similar to faslpath below). Fran\u00e7ois-Ren\u00e9 Rideau's XCVB (building object and image files deterministically and in parallel, but not actively maintained and bitrotten since 2012; a hypothetical ASDF 4 could conceivably be evolved to support these features thanks to the groundwork laid by ASDF 3; or you could use Bazel). Drew McDermott's YTools (the polar opposite of XCVB, trying to maintain coherence of the current Lisp image at a fine grain). Dmitriy Ivanov's ASDlite (a somewhat improved incompatible variant of ASDF 1, much less featureful, robust or portable than ASDF 3), Mark Kantrowitz's mk-defsystem (free software successor of the old proprietary DEFSYSTEM's and predecessor of ASDF, obsolete), Sean Ross's mudballs (an attempt at making things cleaner than in ASDF 2, aborted), Peter von Etter's faslpath (a much simpler system establishing a mapping between packages and files, abandoned but see asdf-package-system and quick-build above), Alexander Kahl's evol (a reimplementation in Lisp of the GNU autotools stack, abandoned). There are probably more. However, none of these systems seems to ever have had the traction of ASDF, probably because none was technically superior and/or portable enough (if at all) to compensate for the first mover advantage. Supported Implementations ASDF 3 now supports all CL implementations that seem to have any current user base, and then some. But ASDF does not magically turn broken implementations into working ones, and some ASDF or UIOP features may not work on less-maintained implementations that do not support them (see below). Most implementations provide ASDF as a module, and you can simply (require \"asdf\"). (All of them but CLISP also accept :asdf, \"ASDF\" or 'asdf as an argument.) All these implementations provide ASDF 3.1 or later in their latest version, but your software distribution might have an older version. As for remaining implementations, they are obsolete and/or mostly unmaintained; ASDF was made to run with each of them at some point, but some hacking is probably required to make the latest ASDF work well with the latest release of these implementations: CLISP is generally well-tested with ASDF, though it has a few minor bugs. The implementation has received only minimal maintenance since 2010, and the last official release doesn't ship with ASDF, or often has antique version of ASDF tucked on it. However, ASDF has been recently updated in its source control system, and there is hope of a new release some day soon. If needs be, you can replace CLISP's provided ASDF with a newer one, or use an upgrade on top of that. CormanLisp was recently open-sourced. Its bundled ASDF has not yet been updated from 1.x; ASDF 3 should work fine with it, but several features were disabled because CormanLisp was insufficiently compliant with the CLHS, and requires some work in this regard. Ask the new CormanLisp maintainers for updates. ECL is generally well-tested with ASDF, but its bytecode compiler doesn't support the bundle operations, and support for Windows seems to be less stable. For instance, as of January 2017, cl:require and ext:system (and thus uiop:run-program) seem not to be working correctly on Windows. GCL is somewhat maintained but its maintainer doesn't seem to care about ASDF, and hasn't replied for years to requests for bug fixes or for providing ASDF via (require \"asdf\") Genera was never open-source and never bundled ASDF, but should otherwise just work with a recent ASDF 3, if you somehow have a license and a working version. There are rumors of people doing active development with it and having minor patches to improve ASDF on it. MCL similarly was open-sourced, but never bundled ASDF; ASDF 3 should work just fine with it, but Rosetta is not supported in the latest versions of MacOS X, so a lot of work is required to make something out of it \u2014 at which point, you might just use CCL. Mocl has its own heavily modified variant of ASDF2, and is the only implementation not currently supported by ASDF3. To make it work with ASDF 3 would require ASDF to be taught about natively supporting cross-compilation. SCL was seemingly abandoned and never open-sourced. It never bundled ASDF, but otherwise should just work with a recent ASDF 3, if you somehow have a license and a working version. XCL is now an abandoned experiment. It provides some old ASDF 2; but you can replace it with ASDF 3, which works well with it, inasmuch as anything works at all with XCL. Provide ASDF 3.1 or later No ASDF Unmaintained Free ABCL, CCL, Clasp, CLISP, CMUCL, ECL, Mezzano, MKCL, SBCL CormanLisp, GCL, MCL XCL Proprietary Allegro, LispWorks Genera, mocl, SCL To deal with an implementation that does not yet provide ASDF 3.1 or later, we provide a script that will install the ASDF from your git checkout to where your implementation goes looking for it when you (require \"asdf\"). Note that upgrading from an old version of ASDF 2 or earlier is possible, but quite complex to do right in a robust way, and we do not recommend it. Also note that mocl only supports a heavily modified variant of ASDF 2, and will require robust cross-compilation support to be added to ASDF before it is actually supported. If there is an old or new implementation that we are missing, it shouldn't be hard to adapt ASDF to support it. Ask us! Examples Download any of the many packages available through Quicklisp to see as many examples. Documentation You can read our manual: ASDF as one HTML file split into one HTML file per section as a PDF document as texinfo source UIOP as one HTML file as a PDF document The first few sections, Loading ASDF, Configuring ASDF and Using ASDF will get you started as a simple user. If you want to define your own systems, further read the section Defining systems with defsystem. There is now also a Best Practices document explaining recommended usage patterns when writing .asd files, and detailing common pitfalls or deprecated practices to avoid. About the latest developments in ASDF 3.2 and ASDF 3.3, see our demo Delivering Common Lisp Applications with ASDF 3.3 (2-page PDF, slides, git). Regarding the internal design of ASDF in general, and the work we did on ASDF 3, see the extended version (26 pages) of our paper ASDF 3, or Why Lisp is Now an Acceptable Scripting Language (PDF, git). The shorter version (8 pages), presented at ELS 2014, focuses on ASDF 3 and misses historical and technical information (PDF, HTML). Regarding ASDF 3, see also the slides of the ASDF 3 tutorial presented at ELS 2013, and for an introduction to the source code, this video: ASDF 3.1 walkthrough. For details about our previous work on ASDF 2, see our paper presented at ILC 2010, Evolving ASDF: More Cooperation, Less Coordination (git). Finally, while the manual covers all the basics, some advanced or new features remain underdocumented. Please contact our mailing-list (see below) regarding any feature that isn't well-documented enough. Until we write more documentation on the further innovations of ASDF, the documentation strings, the source code, the changelog and the git log are unfortunately your best chances for discovering the available functionality. Getting it Though they may lag behind the version here, ASDF comes bundled with most Lisps. To get the greatest and latest, you can: download just the latest release source for asdf.lisp; download the latest release tarball to get all bells and whistles; pull the latest development tree from our git repository git clone https://gitlab.common-lisp.net/asdf/asdf.git (note that our \"master\" branch is for current development; get our \"release\" branch for the latest stable release. Run make to create build/asdf.lisp); browse the latest development tree from our git repository: gitlab download the tarball of a past release: archives Extensions Known extensions to ASDF include: asdf-dependency-grovel, to compute the actual dependencies in a big ASDF system. asdf-encodings, to compile Lisp source files with character encodings other than UTF-8. asdf-finalizers, to allow macros to include code to be evaluated at the end of a file being compiled. asdf-flv, to bind file-local variables around the compilation of some files. asdf-system-connections, lets you specify systems that are automatically loaded when two other systems are loaded, to connect them. cffi, lets you interface between functions and datastructures written in C and functions written in Lisp, including support for automatically detecting constants from C macros, linking to dynamic (and now also static) libraries, and writing your own wrapper code in C. poiu, to compile a system in parallel on a multiprocessor machine. Former extensions, now superseded, include: asdf-binary-locations used to allow one to redirect where ASDF 1 created its output files, so they don't clash between implementations and don't pollute source directories. It is superseded by asdf/defsystem's builtin asdf-output-translations mechanism; a limited compatibility mode is available to easily convert your former ABL configuration into an AOT configuration. common-lisp-controller and cl-launch used to provide similar mechanisms, and have also been superseded by asdf-output-translations (built into ASDF 2 and later). asdf-bundle, n\u00e9e asdf-ecl, allowed you to create a single-file bundle out of a system, for easier delivery. It is now a builtin part of asdf/defsystem, and allows users to deliver a single FASL for a system, a standalone executable program (on supported implementations), or an image containing your system precompiled. asdf-condition-control, initially part of XCVB's xcvb-driver, allowed you to muffle uninteresting conditions during compilation. Is now superseded by equivalent functionality in uiop. asdf-contrib, an empty package that used to collect dependencies on other systems in the list above and below. asdf-package-system, to compile Lisp source files with one package per file that also determines dependencies, in the style of quick-build or faslpath (this functionality is built into recent versions of ASDF 3.1 and later, but this package exists for backward compatibility with earlier versions of ASDF 3; search the manual for package-inferred-system). asdf-utils was a collection of utilities that originated with ASDF. It is now superseded by uiop, aka asdf/driver, which is part of ASDF, and exports its functionality in its own package uiop. Contributing Join our mailing list, check the code out from git, send questions, ideas and patches! Reporting Bugs To report bugs, you can use our common-lisp.net project. If you're unsure about the bug or want to discuss how to fix it, you can send email to the project mailing-list below. Note that the most valuable thing you can send this way are test cases, if possible as .script files readily runnable by our test system. If you're courageous, send us merge requests on gitlab. While bug fixes are useful, they are not usually as valuable as test cases: small easy fixes will be obvious from the test case, and large fixes written by someone who isn't either a maintainer or working tightly with one will probably not be correct and not fit the codebase: any modification at one point is likely to have repercussions at other unobvious places in the codebase, for the code to be correct in a wider variety of scenarios than casual developers usually think about. Now, if you're willing to become a maintainer, you're welcome to join the team! Mailing Lists asdf-devel A list for questions, suggestions, bug reports, patches, and so on. It's for everyone and everything. Please join the conversation! asdf-devel mailman site to subscribe asdf-announce A low-volume mailing-list for announcements only, mostly regarding new releases. Posting is restricted to project administrators and to important notices. Please subscribe to it if you're a Lisp implementation or distribution vendor, who needs to know when to upgrade the ASDF you distribute, but are otherwise not interested in day to day design and development. asdf-announce mailman site to subscribe Contributing Join our mailing list, check the code out from git, send questions, ideas and patches! What is happening For a detailed description of changes see our Changelog","title":"uiop"},{"location":"bordeaux-threads/","text":"bordeaux-threads - Threading Version: 0.8.7 Repository: sionescu/bordeaux-threads - Github This page was possible due to the official documentation , albeit its a bit outdated. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . BORDEAUX-THREADS is a proposed standard for a minimal MP/threading interface. It is similar to the CLIM-SYS threading and lock support, but for the following broad differences: Some behaviours are defined in additional detail: attention has been given to special variable interaction, whether and when cleanup forms are run. Some behaviours are defined in less detail: an implementation that does not support multiple threads is not required to use a new list (nil) for a lock, for example. Many functions which would be difficult, dangerous or inefficient to provide on some implementations have been removed. Chiefly these are functions such as thread-wait which expect for efficiency that the thread scheduler is written in Lisp and 'hookable', which can't sensibly be done if the scheduler is external to the Lisp image, or the system has more than one CPU. Unbalanced ACQUIRE-LOCK and RELEASE-LOCK functions have been added. Posix-style condition variables have been added, as it's not otherwise possible to implement them correctly using the other operations that are specified. Threads may be implemented using whatever applicable techniques are provided by the operating system: user-space scheduling, kernel-based LWPs or anything else that does the job. Some parts of this specification can also be implemented in a Lisp that does not support multiple threads. Thread creation and some thread inspection operations will not work, but the locking functions are still present (though they may do nothing) so that thread-safe code can be compiled on both multithread and single-thread implementations without need of conditionals. To avoid conflict with existing MP/threading interfaces in implementations, these symbols live in the BORDEAUX-THREADS package. Implementations and/or users may also make them visible or exported in other more traditionally named packages. *default-special-bindings* Variable This variable holds an alist associating special variable symbols to forms to evaluate. Special variables named in this list will be locally bound in the new thread before it begins executing user code. This variable may be rebound around calls to make-thread to add/alter default bindings. The effect of mutating this list is undefined, but earlier forms take precedence over later forms for the same symbol, so defaults may be overridden by consing to the head of the list. *standard-io-bindings* Variable Standard bindings of printer/reader control variables as per CL:WITH-STANDARD-IO-SYNTAX. *supports-threads-p* Variable This should be set to T if the running instance has thread support. acquire-lock Function: (acquire-lock lock &optional (wait-p t)) Acquire the lock lock for the calling thread. wait-p governs what happens if the lock is not available: if wait-p is true, the calling thread will wait until the lock is available and then acquire it; if wait-p is NIL, acquire-lock will return immediately. acquire-lock returns true if the lock was acquired and NIL otherwise. This specification does not define what happens if a thread attempts to acquire a lock that it already holds. For applications that require locks to be safe when acquired recursively, see instead make-recursive-lock and friends. acquire-recursive-lock Function: (acquire-recursive-lock lock) As for acquire-lock , but for recursive locks. all-threads Function: (all-threads) Returns a sequence of all of the threads. This may not be freshly-allocated, so the caller should not modify it. condition-notify Function: (condition-notify condition-variable) Notify at least one of the threads waiting for condition-variable . It is implementation-dependent whether one or more than one (and possibly all) threads are woken, but if the implementation is capable of waking only a single thread (not all are) this is probably preferable for efficiency reasons. The order of wakeup is unspecified and does not necessarily relate to the order that the threads went to sleep in. condition-notify has no useful return value. In an implementation that does not support multiple threads, it has no effect. condition-wait Function: (condition-wait condition-variable lock &key timeout) Atomically release lock and enqueue the calling thread waiting for condition-variable . The thread will resume when another thread has notified it using condition-notify ; it may also resume if interrupted by some external event or in other implementation-dependent circumstances: the caller must always test on waking that there is threading to be done, instead of assuming that it can go ahead. It is an error to call function this unless from the thread that holds lock . If timeout is nil or not provided, the system always reacquires lock before returning to the caller. In this case T is returned. If timeout is non-nil, the call will return after at most timeout seconds (approximately), whether or not a notification has occurred. Either NIL or T will be returned. A return of NIL indicates that the lock is no longer held and that the timeout has expired. A return of T indicates that the lock is held, in which case the timeout may or may not have expired. NOTE : The behavior of condition-wait with timeout diverges from the POSIX function pthread_cond_timedwait. The former may return without the lock being held while the latter always returns with the lock held. In an implementation that does not support multiple threads, this function signals an error. current-thread Function: (current-thread) Returns the thread object for the calling thread. This is the same kind of object as would be returned by make-thread . destroy-thread Function: (destroy-thread thread) Terminates the thread thread , which is an object as returned by make-thread . This should be used with caution: it is implementation-defined whether the thread runs cleanup forms or releases its locks first. Destroying the calling thread is an error. interrupt-thread Function: (interrupt-thread thread function &rest args) Interrupt thread and cause it to evaluate function before continuing with the interrupted path of execution. This may not be a good idea if thread is holding locks or doing anything important. On systems that do not support multiple threads, this function signals an error. join-thread Function: (join-thread thread) Wait until thread terminates. If thread has already terminated, return immediately. The return values of the thread function are returned. lock lock-p Function: (lock-p object) Returns T if object is a lock; returns NIL otherwise. make-condition-variable Function: (make-condition-variable &key name) Returns a new condition-variable object for use with condition-wait and condition-notify . make-lock Function: (make-lock &optional name) Creates a lock (a mutex) whose name is name . If the system does not support multiple threads this will still return some object, but it may not be used for very much. make-recursive-lock Function: (make-recursive-lock &optional name) Create and return a recursive lock whose name is name . A recursive lock differs from an ordinary lock in that a thread that already holds the recursive lock can acquire it again without blocking. The thread must then release the lock twice before it becomes available for another thread. make-semaphore Function: (make-semaphore &key name (count 0)) Create a semaphore with the supplied name and initial counter value count . make-thread Function: (make-thread function &key name (initial-bindings *default-special-bindings*)) Creates and returns a thread named name , which will call the function function with no arguments: when function returns, the thread terminates. name defaults to \"Anonymous thread\" if unsupplied. On systems that do not support multi-threading, make-thread will signal an error. The interaction between threads and dynamic variables is in some cases complex, and depends on whether the variable has only a global binding (as established by e.g. DEFVAR/DEFPARAMETER/top-level SETQ) or has been bound locally (e.g. with LET or LET*) in the calling thread. Global bindings are shared between threads: the initial value of a global variable in the new thread will be the same as in the parent, and an assignment to such a variable in any thread will be visible to all threads in which the global binding is visible. Local bindings, such as the ones introduced by initial-bindings , are local to the thread they are introduced in, except that Local bindings in the the caller of make-thread may or may not be shared with the new thread that it creates: this is implementation-defined. Portable code should not depend on particular behaviour in this case, nor should it assign to such variables without first rebinding them in the new thread. recursive-lock recursive-lock-p Function: (recursive-lock-p object) Returns T if object is a recursive lock; returns NIL otherwise. release-lock Function: (release-lock lock) Release lock . It is an error to call this unless the lock has previously been acquired (and not released) by the same thread. If other threads are waiting for the lock, the acquire-lock call in one of them will now be able to continue. This function has no interesting return value. release-recursive-lock Function: (release-recursive-lock lock) Release the recursive lock . The lock will only become free after as many Release operations as there have been Acquire operations. See release-lock for other information. semaphore semaphore-p Function: (semaphore-p object) Returns T if object is a semaphore; returns NIL otherwise. signal-semaphore Function: (signal-semaphore semaphore &key (count 1)) Increment semaphore by count . If there are threads waiting on this semaphore, then count of them are woken up. start-multiprocessing Function: (start-multiprocessing) If the host implementation uses user-level threads, start the scheduler and multiprocessing, otherwise do nothing. It is safe to call repeatedly. thread thread-alive-p Function: (thread-alive-p thread) Returns true if thread is alive, that is, if destroy-thread has not been called on it. thread-name Function: (thread-name thread) Returns the name of the thread, as supplied to make-thread . thread-yield Function: (thread-yield) Allows other threads to run. It may be necessary or desirable to call this periodically in some implementations; others may schedule threads automatically. On systems that do not support multi-threading, this does nothing. threadp Function: (threadp object) Returns true if object is a thread, otherwise NIL. timeout wait-on-semaphore Function: (wait-on-semaphore semaphore &key timeout) Decrement the count of semaphore by 1 if the count would not be negative. Else blocks until the semaphore can be decremented. Returns generalized boolean T on success. If timeout is given, it is the maximum number of seconds to wait. If the count cannot be decremented in that time, returns NIL without decrementing the count. with-lock-held Macro: (with-lock-held (place) &body body) Evaluates body with the lock named by place , the value of which is a lock created by make-lock . Before the forms in body are evaluated, the lock is acquired as if by using acquire-lock . After the forms in body have been evaluated, or if a non-local control transfer is caused (e.g. by THROW or SIGNAL), the lock is released as if by release-lock . Note that if the debugger is entered, it is unspecified whether the lock is released at debugger entry or at debugger exit when execution is restarted. with-recursive-lock-held Macro: (with-recursive-lock-held (place) &body body) Evaluates body with the recursive lock named by place , which is a reference to a recursive lock created by make-recursive-lock . See with-lock-held etc etc with-timeout Macro: (with-timeout (timeout) &body body)","title":"bordeaux-threads - Threading"},{"location":"bordeaux-threads/#bordeaux-threads-threading","text":"Version: 0.8.7 Repository: sionescu/bordeaux-threads - Github This page was possible due to the official documentation , albeit its a bit outdated. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . BORDEAUX-THREADS is a proposed standard for a minimal MP/threading interface. It is similar to the CLIM-SYS threading and lock support, but for the following broad differences: Some behaviours are defined in additional detail: attention has been given to special variable interaction, whether and when cleanup forms are run. Some behaviours are defined in less detail: an implementation that does not support multiple threads is not required to use a new list (nil) for a lock, for example. Many functions which would be difficult, dangerous or inefficient to provide on some implementations have been removed. Chiefly these are functions such as thread-wait which expect for efficiency that the thread scheduler is written in Lisp and 'hookable', which can't sensibly be done if the scheduler is external to the Lisp image, or the system has more than one CPU. Unbalanced ACQUIRE-LOCK and RELEASE-LOCK functions have been added. Posix-style condition variables have been added, as it's not otherwise possible to implement them correctly using the other operations that are specified. Threads may be implemented using whatever applicable techniques are provided by the operating system: user-space scheduling, kernel-based LWPs or anything else that does the job. Some parts of this specification can also be implemented in a Lisp that does not support multiple threads. Thread creation and some thread inspection operations will not work, but the locking functions are still present (though they may do nothing) so that thread-safe code can be compiled on both multithread and single-thread implementations without need of conditionals. To avoid conflict with existing MP/threading interfaces in implementations, these symbols live in the BORDEAUX-THREADS package. Implementations and/or users may also make them visible or exported in other more traditionally named packages.","title":"bordeaux-threads - Threading"},{"location":"bordeaux-threads/#default-special-bindings","text":"Variable This variable holds an alist associating special variable symbols to forms to evaluate. Special variables named in this list will be locally bound in the new thread before it begins executing user code. This variable may be rebound around calls to make-thread to add/alter default bindings. The effect of mutating this list is undefined, but earlier forms take precedence over later forms for the same symbol, so defaults may be overridden by consing to the head of the list.","title":"*default-special-bindings*"},{"location":"bordeaux-threads/#standard-io-bindings","text":"Variable Standard bindings of printer/reader control variables as per CL:WITH-STANDARD-IO-SYNTAX.","title":"*standard-io-bindings*"},{"location":"bordeaux-threads/#supports-threads-p","text":"Variable This should be set to T if the running instance has thread support.","title":"*supports-threads-p*"},{"location":"bordeaux-threads/#acquire-lock","text":"Function: (acquire-lock lock &optional (wait-p t)) Acquire the lock lock for the calling thread. wait-p governs what happens if the lock is not available: if wait-p is true, the calling thread will wait until the lock is available and then acquire it; if wait-p is NIL, acquire-lock will return immediately. acquire-lock returns true if the lock was acquired and NIL otherwise. This specification does not define what happens if a thread attempts to acquire a lock that it already holds. For applications that require locks to be safe when acquired recursively, see instead make-recursive-lock and friends.","title":"acquire-lock"},{"location":"bordeaux-threads/#acquire-recursive-lock","text":"Function: (acquire-recursive-lock lock) As for acquire-lock , but for recursive locks.","title":"acquire-recursive-lock"},{"location":"bordeaux-threads/#all-threads","text":"Function: (all-threads) Returns a sequence of all of the threads. This may not be freshly-allocated, so the caller should not modify it.","title":"all-threads"},{"location":"bordeaux-threads/#condition-notify","text":"Function: (condition-notify condition-variable) Notify at least one of the threads waiting for condition-variable . It is implementation-dependent whether one or more than one (and possibly all) threads are woken, but if the implementation is capable of waking only a single thread (not all are) this is probably preferable for efficiency reasons. The order of wakeup is unspecified and does not necessarily relate to the order that the threads went to sleep in. condition-notify has no useful return value. In an implementation that does not support multiple threads, it has no effect.","title":"condition-notify"},{"location":"bordeaux-threads/#condition-wait","text":"Function: (condition-wait condition-variable lock &key timeout) Atomically release lock and enqueue the calling thread waiting for condition-variable . The thread will resume when another thread has notified it using condition-notify ; it may also resume if interrupted by some external event or in other implementation-dependent circumstances: the caller must always test on waking that there is threading to be done, instead of assuming that it can go ahead. It is an error to call function this unless from the thread that holds lock . If timeout is nil or not provided, the system always reacquires lock before returning to the caller. In this case T is returned. If timeout is non-nil, the call will return after at most timeout seconds (approximately), whether or not a notification has occurred. Either NIL or T will be returned. A return of NIL indicates that the lock is no longer held and that the timeout has expired. A return of T indicates that the lock is held, in which case the timeout may or may not have expired. NOTE : The behavior of condition-wait with timeout diverges from the POSIX function pthread_cond_timedwait. The former may return without the lock being held while the latter always returns with the lock held. In an implementation that does not support multiple threads, this function signals an error.","title":"condition-wait"},{"location":"bordeaux-threads/#current-thread","text":"Function: (current-thread) Returns the thread object for the calling thread. This is the same kind of object as would be returned by make-thread .","title":"current-thread"},{"location":"bordeaux-threads/#destroy-thread","text":"Function: (destroy-thread thread) Terminates the thread thread , which is an object as returned by make-thread . This should be used with caution: it is implementation-defined whether the thread runs cleanup forms or releases its locks first. Destroying the calling thread is an error.","title":"destroy-thread"},{"location":"bordeaux-threads/#interrupt-thread","text":"Function: (interrupt-thread thread function &rest args) Interrupt thread and cause it to evaluate function before continuing with the interrupted path of execution. This may not be a good idea if thread is holding locks or doing anything important. On systems that do not support multiple threads, this function signals an error.","title":"interrupt-thread"},{"location":"bordeaux-threads/#join-thread","text":"Function: (join-thread thread) Wait until thread terminates. If thread has already terminated, return immediately. The return values of the thread function are returned.","title":"join-thread"},{"location":"bordeaux-threads/#lock","text":"","title":"lock"},{"location":"bordeaux-threads/#lock-p","text":"Function: (lock-p object) Returns T if object is a lock; returns NIL otherwise.","title":"lock-p"},{"location":"bordeaux-threads/#make-condition-variable","text":"Function: (make-condition-variable &key name) Returns a new condition-variable object for use with condition-wait and condition-notify .","title":"make-condition-variable"},{"location":"bordeaux-threads/#make-lock","text":"Function: (make-lock &optional name) Creates a lock (a mutex) whose name is name . If the system does not support multiple threads this will still return some object, but it may not be used for very much.","title":"make-lock"},{"location":"bordeaux-threads/#make-recursive-lock","text":"Function: (make-recursive-lock &optional name) Create and return a recursive lock whose name is name . A recursive lock differs from an ordinary lock in that a thread that already holds the recursive lock can acquire it again without blocking. The thread must then release the lock twice before it becomes available for another thread.","title":"make-recursive-lock"},{"location":"bordeaux-threads/#make-semaphore","text":"Function: (make-semaphore &key name (count 0)) Create a semaphore with the supplied name and initial counter value count .","title":"make-semaphore"},{"location":"bordeaux-threads/#make-thread","text":"Function: (make-thread function &key name (initial-bindings *default-special-bindings*)) Creates and returns a thread named name , which will call the function function with no arguments: when function returns, the thread terminates. name defaults to \"Anonymous thread\" if unsupplied. On systems that do not support multi-threading, make-thread will signal an error. The interaction between threads and dynamic variables is in some cases complex, and depends on whether the variable has only a global binding (as established by e.g. DEFVAR/DEFPARAMETER/top-level SETQ) or has been bound locally (e.g. with LET or LET*) in the calling thread. Global bindings are shared between threads: the initial value of a global variable in the new thread will be the same as in the parent, and an assignment to such a variable in any thread will be visible to all threads in which the global binding is visible. Local bindings, such as the ones introduced by initial-bindings , are local to the thread they are introduced in, except that Local bindings in the the caller of make-thread may or may not be shared with the new thread that it creates: this is implementation-defined. Portable code should not depend on particular behaviour in this case, nor should it assign to such variables without first rebinding them in the new thread.","title":"make-thread"},{"location":"bordeaux-threads/#recursive-lock","text":"","title":"recursive-lock"},{"location":"bordeaux-threads/#recursive-lock-p","text":"Function: (recursive-lock-p object) Returns T if object is a recursive lock; returns NIL otherwise.","title":"recursive-lock-p"},{"location":"bordeaux-threads/#release-lock","text":"Function: (release-lock lock) Release lock . It is an error to call this unless the lock has previously been acquired (and not released) by the same thread. If other threads are waiting for the lock, the acquire-lock call in one of them will now be able to continue. This function has no interesting return value.","title":"release-lock"},{"location":"bordeaux-threads/#release-recursive-lock","text":"Function: (release-recursive-lock lock) Release the recursive lock . The lock will only become free after as many Release operations as there have been Acquire operations. See release-lock for other information.","title":"release-recursive-lock"},{"location":"bordeaux-threads/#semaphore","text":"","title":"semaphore"},{"location":"bordeaux-threads/#semaphore-p","text":"Function: (semaphore-p object) Returns T if object is a semaphore; returns NIL otherwise.","title":"semaphore-p"},{"location":"bordeaux-threads/#signal-semaphore","text":"Function: (signal-semaphore semaphore &key (count 1)) Increment semaphore by count . If there are threads waiting on this semaphore, then count of them are woken up.","title":"signal-semaphore"},{"location":"bordeaux-threads/#start-multiprocessing","text":"Function: (start-multiprocessing) If the host implementation uses user-level threads, start the scheduler and multiprocessing, otherwise do nothing. It is safe to call repeatedly.","title":"start-multiprocessing"},{"location":"bordeaux-threads/#thread","text":"","title":"thread"},{"location":"bordeaux-threads/#thread-alive-p","text":"Function: (thread-alive-p thread) Returns true if thread is alive, that is, if destroy-thread has not been called on it.","title":"thread-alive-p"},{"location":"bordeaux-threads/#thread-name","text":"Function: (thread-name thread) Returns the name of the thread, as supplied to make-thread .","title":"thread-name"},{"location":"bordeaux-threads/#thread-yield","text":"Function: (thread-yield) Allows other threads to run. It may be necessary or desirable to call this periodically in some implementations; others may schedule threads automatically. On systems that do not support multi-threading, this does nothing.","title":"thread-yield"},{"location":"bordeaux-threads/#threadp","text":"Function: (threadp object) Returns true if object is a thread, otherwise NIL.","title":"threadp"},{"location":"bordeaux-threads/#timeout","text":"","title":"timeout"},{"location":"bordeaux-threads/#wait-on-semaphore","text":"Function: (wait-on-semaphore semaphore &key timeout) Decrement the count of semaphore by 1 if the count would not be negative. Else blocks until the semaphore can be decremented. Returns generalized boolean T on success. If timeout is given, it is the maximum number of seconds to wait. If the count cannot be decremented in that time, returns NIL without decrementing the count.","title":"wait-on-semaphore"},{"location":"bordeaux-threads/#with-lock-held","text":"Macro: (with-lock-held (place) &body body) Evaluates body with the lock named by place , the value of which is a lock created by make-lock . Before the forms in body are evaluated, the lock is acquired as if by using acquire-lock . After the forms in body have been evaluated, or if a non-local control transfer is caused (e.g. by THROW or SIGNAL), the lock is released as if by release-lock . Note that if the debugger is entered, it is unspecified whether the lock is released at debugger entry or at debugger exit when execution is restarted.","title":"with-lock-held"},{"location":"bordeaux-threads/#with-recursive-lock-held","text":"Macro: (with-recursive-lock-held (place) &body body) Evaluates body with the recursive lock named by place , which is a reference to a recursive lock created by make-recursive-lock . See with-lock-held etc etc","title":"with-recursive-lock-held"},{"location":"bordeaux-threads/#with-timeout","text":"Macro: (with-timeout (timeout) &body body)","title":"with-timeout"},{"location":"cl-ppcre/","text":"cl-ppcre - Regular Expressions Version: 2.1.1 Nickname: ppcre Repository: edicl/cl-ppcre - Github This documentation is possible the excellent official documentation as of 4th May 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . CL-PPCRE is a Portable Perl-Compatible Regular Expressions library for Common Lisp. This is also thread-safe, and allows specifying regular expressions using S-expressions . GETTING STARTED Using perl regex Per the name, cl-ppcre is more or less compatible with perl 5.8 including extended features like non-greedy repetitions, positive and negative look-ahead and look-behind assertions, \"standalone\" subexpressions, and conditional subpatterns. The following Perl features are (currently) not supported: (?{ code }) and (??{ code }) because they obviously don't make sense in Lisp. \\N{name} (named characters), \\x{263a} (wide hex characters), \\l , \\u , \\L , and \\U because they're actually not part of Perl's regex syntax - but see CL-INTERPOL . \\X (extended Unicode), and \\C (single character). But you can of course use all characters supported by your CL implementation. Posix character classes like [[:alpha]] . Load (asdf:load-system :cl-ppcre-unicode) to install unicode-preperty-resolver as your property-resolver . See cl-unicode for the supported unicode properties and their naming conventions. \\G for Perl's pos() because we don't have it. Note, however, that \\t , \\n , \\r , \\f , \\a , \\e , \\033 (octal character codes), \\x1B (hexadecimal character codes), \\c[ (control characters), \\w , \\W , \\s , \\S , \\d , \\D , \\b , \\B , \\A , \\Z , and \\z are supported. Users can straightaway start with: scan scan-to-strings split quote-meta-chars register-groups-bind regex-replace Register groups simply refer to the captured groups. For instance: CL-USER> (register-groups-bind (a b) (\"([^ ]+) ([^ ]+)\" \"hello world\") (list a b)) (\"hello\" \"world\") See the other macros for iterative versions of these. Those wanting to get into perl regular expressions, might find their official documentation useful. Users comfortable with regular expressions might also want to try cl-interpol - which provides string interpolation facilities to the lisp reader. (Yes, it's defacto!) Using s-expressions The basics: +------- Common Lisp Equivalent -------+----------- Perl Equivalent -----------+ | String / Character | Literal treatment | | :void | Empty string | | :everything | Dot | | :(non-)word-boundary | \\b, \\B (non) | | :(non-)digit-class | \\d, \\D (non) | | :(non-)word-char-class | \\w, \\W (non) | | :(non-)whitespace-char-class | \\s, \\S (non) | | :start/end-anchor | ^ [start], $ [end | | :modeless-start/end-anchor | \\A [start], \\Z [end] | | :modeless-end-anchor-no-newline | \\z | | :case-(in)sensitive-p | (?i), (?-i) [insensitive] | | :(not)-multi-line-mode-p | (?m), (?-m) [not] | | :(not)-single-line-mode-p | (?s), (?-s) [not] | | (anything else) | Syntax Error | +--------------------------------------+---------------------------------------+ Simple combinations include :sequence , :group , :flags , :register , :greedy-repetition , :non-greedy-repetition . You could play around with parse-string to learn more about the equivalence. For instance: * (parse-string \"(ab)*\") (:GREEDY-REPETITION 0 `NIL` (:REGISTER \"ab\")) * (parse-string \"(a(b))\") (:REGISTER (:SEQUENCE #\\a (:REGISTER #\\b))) * (parse-string \"(?:abc){3,5}\") (:GREEDY-REPETITION 3 5 (:GROUP \"abc\")) ;; (:GREEDY-REPETITION 3 5 \"abc\") would also be OK * (parse-string \"a(?i)b(?-i)c\") (:SEQUENCE #\\a (:SEQUENCE (:FLAGS :CASE-INSENSITIVE-P) (:SEQUENCE #\\b (:SEQUENCE (:FLAGS :CASE-SENSITIVE-P) #\\c)))) ;; same as (:SEQUENCE #\\a :CASE-INSENSITIVE-P #\\b :CASE-SENSITIVE-P #\\c) * (parse-string \"(?=a)b\") (:SEQUENCE (:POSITIVE-LOOKAHEAD #\\a) #\\b) * (parse-string \"aa|aaa\") (:ALTERNATION \"aa\" \"aaa\") See the manual for the more detailed equivalence. Thus, you could equivalently use parse-trees for the functions and macros that expect regex. * (all-matches-as-strings '(:greedy-repetition 1 nil #\\a) \"aaaa\") (\"aaaa\") Performance Aspects cl-ppcre was intended to be fast. Indeed, when it first appeared, it was perhaps the fastest . However, in 2020, it can be five times as slow as Perl: time perl -e '\"@{['x' x 50000000]}\" =~ /([xy])*/' real 0m0.245s user 0m0.161s sys 0m0.084s CL-USER> (time (progn (scan \"([xy])*\" (make-string 50000000 :element-type 'base-char :initial-element #\\x)) nil)) Evaluation took: 1.116 seconds of real time 1.115901 seconds of total run time (1.111972 user, 0.003929 system) 100.00% CPU 2,463,959,814 processor cycles 50,000,032 bytes consed But still (more than) 5 times faster than python: time python3 -c 'import re; x = re.search(\"([xy])*\", \"x\"*50000000)' real 0m7.458s user 0m4.563s sys 0m2.892s Or slower as well: $ ~ time python3 -c 'import re; x = re.search(\"x*\", \"x\"*50000000)' real 0m0.146s user 0m0.109s sys 0m0.036s Honestly, though, it should be possible to use implementation specific means to speed things up - or copying the developments in the perl and/or python world. Perhaps, see the manual for hints on speeding things up. FUNCTIONS AND MACROS all-matches Function: (all-matches regex target-string &key (start 0) (end (length target-string))) Returns a list containing the start and end positions of all matches of regex against target-string , i.e. if there are N matches the list contains (* 2 N) elements. If regex matches an empty string the scan is continued one position behind this match. all-matches-as-strings Function: (all-matches-as-strings regex target-string &key (start 0) (end (length target-string)) sharedp) Returns a list containing all substrings of target-string which match regex . If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . create-optimized-test-function Function: (create-optimized-test-function test-function &key (start 0) (end *regex-char-code-limit*) (kind *optimize-char-classes*)) Given a unary test function which is applicable to characters returns a function which yields the same boolean results for all characters with character codes from start to (excluding) end . If kind is nil , test-function will simply be returned. Otherwise, kind should be one of: :hash-table - builds a hash table representing all characters which satisfy the test and returns a closure which checks if a character is in that hash table :charset - instead of a hash table uses a \"charset\" which is a data structure using non-linear hashing and optimized to represent (sparse) sets of characters in a fast and space-efficient way (contributed by Nikodemus Siivola) :charmap - instead of a hash table uses a bit vector to represent the set of characters You can also use :hash-table* or :charset* which are like :hash-table and :charset but use the complement of the set if the set contains more than half of all characters between start and end . This saves space but needs an additional pass across all characters to create the data structure. There is no corresponding :charmap* kind as the bit vectors are already created to cover the smallest possible interval which contains either the set or its complement. create-scanner Function: (create-scanner regex &key case-insensitive-mode multi-line-mode single-line-mode extended-mode destructive) Accepts a regular expression - either as a parse-tree or as a string - and returns a scan closure which will scan strings for this regular expression and a list mapping registers to their names ( nil stands for unnamed ones). The \"mode\" keyword arguments are equivalent to the imsx modifiers in Perl. If destructive is not nil , the function is allowed to destructively modify its first argument (but only if it's a parse tree). (More in the manual!) define-parse-tree-synonym Macro: (define-parse-tree-synonym name parse-tree) Defines the symbol name to be a synonym for the parse tree parse-tree . Both arguments are quoted. do-matches Macro: (do-matches (match-start match-end regex target-string &optional result-form &key start end) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with match-start and match-end bound to the start/end positions of each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-matches ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. body may start with declarations. do-matches-as-strings Macro: (do-matches-as-strings (match-var regex target-string &optional result-form &key start end sharedp) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with match-var bound to the substring of target-string corresponding to each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-matches-as-strings ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . body may start with declarations. do-register-groups Macro: (do-register-groups var-list (regex target-string &optional result-form &key start end sharedp) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with the variables in var-list bound to the corresponding register groups for each match in turn, i.e. each variable is either bound to a string or to nil . For each element of var-list which is nil there's no binding to the corresponding register group. The number of variables in var-list must not be greater than the number of register groups. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-register-groups ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . body may start with declarations. do-scans Macro: (do-scans (match-start match-end reg-starts reg-ends regex target-string &optional result-form &key start end) &body body) Iterates over target-string and tries to match regex as often as possible evaluating BODY with match-start , match-end , reg-starts , and reg-ends bound to the four return values of each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-scans ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. body may start with declarations. parse-string Function: (parse-string string) Translate the regex string string into a parse tree. parse-tree-synonym Function: (parse-tree-synonym symbol) Returns the parse tree the symbol symbol is a synonym for. Returns nil is symbol wasn't yet defined to be a synonym. ppcre-error Every error signaled by CL-PPCRE is of type ppcre-error . This is a direct subtype of simple-error without any additional slots or options. ppcre-invocation-error Errors of type ppcre-invocation-error are signaled if one of the exported functions of CL-PPCRE is called with wrong or inconsistent arguments. This is a direct subtype of ppcre-error without any additional slots or options. ppcre-syntax-error An error of type ppcre-syntax-error is signaled if CL-PPCRE's parser encounters an error when trying to parse a regex string or to convert a parse tree into its internal representation. This is a direct subtype of ppcre-error with two additional slots. These denote the regex string which HTML-PPCRE was parsing and the position within the string where the error occurred. If the error happens while CL-PPCRE is converting a parse tree, both of these slots contain NIL. (See the next two entries on how to access these slots.) ppcre-syntax-error-pos Function: (ppcre-syntax-error-pos condition) Returns the position within the string where the error occurred (or nil if the error happened while trying to convert a parse tree ppcre-syntax-error-string Function: (ppcre-syntax-error-string condition) Returns the string the parser was parsing when the error was encountered (or nil if the error happened while trying to convert a parse tree). quote-meta-chars Function: (quote-meta-chars string &key (start 0) (end (length string))) Quote, i.e. prefix all non-word characters in string with #\\\\ . regex-apropos Function: (regex-apropos regex &optional packages &key (case-insensitive t)) Similar to the standard function apropos but returns a list of all symbols which match the regular expression REGEX. If case-insensitive is true and regex isn't already a scanner, a case-insensitive scanner is used. regex-apropos-list Function: (regex-apropos-list regex &optional packages &key (case-insensitive t)) Similar to the standard function apropos-list but returns a list of all symbols which match the regular expression regex . If case-insensitive is true and regex isn't already a scanner, a case-insensitive scanner is used. regex-replace Function: (regex-replace regex target-string replacement &key (start 0) (end (length target-string)) preserve-case simple-calls (element-type 'character)) Try to match target-string between start and end against regex and replace the first match with replacement . Two values are returned; the modified string, and t if regex matched or nil otherwise. replacement can be a string which may contain the special substrings \"\\&\" for the whole match, \"`\" for the part of target-string before the match, \"\\'\" for the part of target-string after the match, \"\\N\" or \"{N}\" for the Nth register where N is a positive integer. replacement can also be a function designator in which case the match will be replaced with the result of calling the function designated by replacement with the arguments target-string , start , end , match-start , match-end , reg-starts , and reg-ends . ( reg-starts and reg-ends are arrays holding the start and end positions of matched registers or nil - the meaning of the other arguments should be obvious.) Finally, replacement can be a list where each element is a string, one of the symbols :match , :before-match , or :after-match - corresponding to \"\\&\", \"`\", and \"\\'\" above -, an integer N - representing register (1+ N) -, or a function designator. If preserve-case is true, the replacement will try to preserve the case (all upper case, all lower case, or capitalized) of the match. The result will always be a fresh string, even if regex doesn't match. element-type is the element type of the resulting string. regex-replace-all Function: (regex-replace-all regex target-string replacement &key (start 0) (end (length target-string)) preserve-case simple-calls (element-type 'character)) Try to match target-string between start and end against regex and replace all matches with replacement . Two values are returned; the modified string, and T if regex matched or nil otherwise. replacement can be a string which may contain the special substrings \"\\&\" for the whole match, \"`\" for the part of target-string before the match, \"\\'\" for the part of target-string after the match, \"\\N\" or \"{N}\" for the Nth register where N is a positive integer. replacement can also be a function designator in which case the match will be replaced with the result of calling the function designated by replacement with the arguments target-string , start , end , match-start , match-end , reg-starts , and reg-ends . ( reg-starts and reg-ends are arrays holding the start and end positions of matched registers or nil - the meaning of the other arguments should be obvious.) Finally, replacement can be a list where each element is a string, one of the symbols :match , :before-match , or :after-match - corresponding to \"\\&\", \"`\", and \"\\'\" above -, an integer N - representing register (1+ N) -, or a function designator. If preserve-case is true, the replacement will try to preserve the case (all upper case, all lower case, or capitalized) of the match. The result will always be a fresh string, even if regex doesn't match. element-type is the element type of the resulting string. register-groups-bind Macro: (register-groups-bind var-list (regex target-string &key start end sharedp) &body body) Executes body with the variables in var-list bound to the corresponding register groups after target-string has been matched against regex , i.e. each variable is either bound to a string or to nil . If there is no match, body is not executed. For each element of var-list which is nil there's no binding to the corresponding register group. The number of variables in var-list must not be greater than the number of register groups. If sharedp is true, the substrings may share structure with target-string . scan Function: (scan regex target-string &key start end real-start-pos) Searches target-string from start to end and tries to match regex . On success returns four values - the start of the match, the end of the match, and two arrays denoting the beginnings and ends of register matches. On failure returns nil . regex can be a string which will be parsed according to Perl syntax, a parse tree, or a pre-compiled scanner created by create-scanner . target-string will be coerced to a simple string if it isn't one already. The real-start-pos parameter should be ignored - it exists only for internal purposes. scan-to-strings Function: (scan-to-strings regex target-string &key (start 0) (end (length target-string)) sharedp) Like scan but returns substrings of target-string instead of positions, i.e. this function returns two values on success: the whole match as a string plus an array of substrings (or nil s) corresponding to the matched registers. If sharedp is true, the substrings may share structure with target-string . split Function: (split regex target-string &key (start 0) (end (length target-string)) limit with-registers-p omit-unmatched-p sharedp) Matches regex against target-string as often as possible and returns a list of the substrings between the matches. If with-registers-p is true, substrings corresponding to matched registers are inserted into the list as well. If omit-unmatched-p is true, unmatched registers will simply be left out, otherwise they will show up as nil . limit limits the number of elements returned - registers aren't counted. If limit is nil (or 0 which is equivalent), trailing empty strings are removed from the result list. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . CONFIGURATION VARIABLES *allow-named-registers* Whether the parser should support AllegroCL's named registers (?<name>\"<regex>\") and back-reference \\k syntax. *allow-quoting* Whether the parser should support Perl's \\Q and \\E. *look-ahead-for-suffix* Controls whether scanners will optimistically look ahead for a constant suffix of a regular expression, if there is one. *optimize-char-classes* Whether character classes should be compiled into look-ups into O(1) data structures. This is usually fast but will be costly in terms of scanner creation time and might be costly in terms of size if *regex-char-code-limit* is high. This value will be used as the :kind keyword argument to create-optimized-test-function - see there for the possible non- NIL values. *property-resolver* Should be NIL or a designator for a function which accepts strings and returns unary character test functions or NIL . This 'resolver' is intended to handle character properties' like \\p{IsAlpha}. If *property-resolver* is NIL , then the parser will simply treat \\p and \\P as #\\p and #\\P as in older versions of CL-PPCRE. *regex-char-code-limit* The upper exclusive bound on the char-codes of characters which can occur in character classes. Change this value BEFORE creating scanners if you don't need the (full) Unicode support of implementations like AllegroCL, CLISP, LispWorks, or SBCL. *use-bmh-matchers* Whether the scanners created by create-scanner should use the (fast but large) Boyer-Moore-Horspool matchers. SUPPORT The development version of cl-ppcre can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"cl-ppcre - Regular Expressions"},{"location":"cl-ppcre/#cl-ppcre-regular-expressions","text":"Version: 2.1.1 Nickname: ppcre Repository: edicl/cl-ppcre - Github This documentation is possible the excellent official documentation as of 4th May 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . CL-PPCRE is a Portable Perl-Compatible Regular Expressions library for Common Lisp. This is also thread-safe, and allows specifying regular expressions using S-expressions .","title":"cl-ppcre - Regular Expressions"},{"location":"cl-ppcre/#getting-started","text":"","title":"GETTING STARTED"},{"location":"cl-ppcre/#using-perl-regex","text":"Per the name, cl-ppcre is more or less compatible with perl 5.8 including extended features like non-greedy repetitions, positive and negative look-ahead and look-behind assertions, \"standalone\" subexpressions, and conditional subpatterns. The following Perl features are (currently) not supported: (?{ code }) and (??{ code }) because they obviously don't make sense in Lisp. \\N{name} (named characters), \\x{263a} (wide hex characters), \\l , \\u , \\L , and \\U because they're actually not part of Perl's regex syntax - but see CL-INTERPOL . \\X (extended Unicode), and \\C (single character). But you can of course use all characters supported by your CL implementation. Posix character classes like [[:alpha]] . Load (asdf:load-system :cl-ppcre-unicode) to install unicode-preperty-resolver as your property-resolver . See cl-unicode for the supported unicode properties and their naming conventions. \\G for Perl's pos() because we don't have it. Note, however, that \\t , \\n , \\r , \\f , \\a , \\e , \\033 (octal character codes), \\x1B (hexadecimal character codes), \\c[ (control characters), \\w , \\W , \\s , \\S , \\d , \\D , \\b , \\B , \\A , \\Z , and \\z are supported. Users can straightaway start with: scan scan-to-strings split quote-meta-chars register-groups-bind regex-replace Register groups simply refer to the captured groups. For instance: CL-USER> (register-groups-bind (a b) (\"([^ ]+) ([^ ]+)\" \"hello world\") (list a b)) (\"hello\" \"world\") See the other macros for iterative versions of these. Those wanting to get into perl regular expressions, might find their official documentation useful. Users comfortable with regular expressions might also want to try cl-interpol - which provides string interpolation facilities to the lisp reader. (Yes, it's defacto!)","title":"Using perl regex"},{"location":"cl-ppcre/#using-s-expressions","text":"The basics: +------- Common Lisp Equivalent -------+----------- Perl Equivalent -----------+ | String / Character | Literal treatment | | :void | Empty string | | :everything | Dot | | :(non-)word-boundary | \\b, \\B (non) | | :(non-)digit-class | \\d, \\D (non) | | :(non-)word-char-class | \\w, \\W (non) | | :(non-)whitespace-char-class | \\s, \\S (non) | | :start/end-anchor | ^ [start], $ [end | | :modeless-start/end-anchor | \\A [start], \\Z [end] | | :modeless-end-anchor-no-newline | \\z | | :case-(in)sensitive-p | (?i), (?-i) [insensitive] | | :(not)-multi-line-mode-p | (?m), (?-m) [not] | | :(not)-single-line-mode-p | (?s), (?-s) [not] | | (anything else) | Syntax Error | +--------------------------------------+---------------------------------------+ Simple combinations include :sequence , :group , :flags , :register , :greedy-repetition , :non-greedy-repetition . You could play around with parse-string to learn more about the equivalence. For instance: * (parse-string \"(ab)*\") (:GREEDY-REPETITION 0 `NIL` (:REGISTER \"ab\")) * (parse-string \"(a(b))\") (:REGISTER (:SEQUENCE #\\a (:REGISTER #\\b))) * (parse-string \"(?:abc){3,5}\") (:GREEDY-REPETITION 3 5 (:GROUP \"abc\")) ;; (:GREEDY-REPETITION 3 5 \"abc\") would also be OK * (parse-string \"a(?i)b(?-i)c\") (:SEQUENCE #\\a (:SEQUENCE (:FLAGS :CASE-INSENSITIVE-P) (:SEQUENCE #\\b (:SEQUENCE (:FLAGS :CASE-SENSITIVE-P) #\\c)))) ;; same as (:SEQUENCE #\\a :CASE-INSENSITIVE-P #\\b :CASE-SENSITIVE-P #\\c) * (parse-string \"(?=a)b\") (:SEQUENCE (:POSITIVE-LOOKAHEAD #\\a) #\\b) * (parse-string \"aa|aaa\") (:ALTERNATION \"aa\" \"aaa\") See the manual for the more detailed equivalence. Thus, you could equivalently use parse-trees for the functions and macros that expect regex. * (all-matches-as-strings '(:greedy-repetition 1 nil #\\a) \"aaaa\") (\"aaaa\")","title":"Using s-expressions"},{"location":"cl-ppcre/#performance-aspects","text":"cl-ppcre was intended to be fast. Indeed, when it first appeared, it was perhaps the fastest . However, in 2020, it can be five times as slow as Perl: time perl -e '\"@{['x' x 50000000]}\" =~ /([xy])*/' real 0m0.245s user 0m0.161s sys 0m0.084s CL-USER> (time (progn (scan \"([xy])*\" (make-string 50000000 :element-type 'base-char :initial-element #\\x)) nil)) Evaluation took: 1.116 seconds of real time 1.115901 seconds of total run time (1.111972 user, 0.003929 system) 100.00% CPU 2,463,959,814 processor cycles 50,000,032 bytes consed But still (more than) 5 times faster than python: time python3 -c 'import re; x = re.search(\"([xy])*\", \"x\"*50000000)' real 0m7.458s user 0m4.563s sys 0m2.892s Or slower as well: $ ~ time python3 -c 'import re; x = re.search(\"x*\", \"x\"*50000000)' real 0m0.146s user 0m0.109s sys 0m0.036s Honestly, though, it should be possible to use implementation specific means to speed things up - or copying the developments in the perl and/or python world. Perhaps, see the manual for hints on speeding things up.","title":"Performance Aspects"},{"location":"cl-ppcre/#functions-and-macros","text":"","title":"FUNCTIONS AND MACROS"},{"location":"cl-ppcre/#all-matches","text":"Function: (all-matches regex target-string &key (start 0) (end (length target-string))) Returns a list containing the start and end positions of all matches of regex against target-string , i.e. if there are N matches the list contains (* 2 N) elements. If regex matches an empty string the scan is continued one position behind this match.","title":"all-matches"},{"location":"cl-ppcre/#all-matches-as-strings","text":"Function: (all-matches-as-strings regex target-string &key (start 0) (end (length target-string)) sharedp) Returns a list containing all substrings of target-string which match regex . If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string .","title":"all-matches-as-strings"},{"location":"cl-ppcre/#create-optimized-test-function","text":"Function: (create-optimized-test-function test-function &key (start 0) (end *regex-char-code-limit*) (kind *optimize-char-classes*)) Given a unary test function which is applicable to characters returns a function which yields the same boolean results for all characters with character codes from start to (excluding) end . If kind is nil , test-function will simply be returned. Otherwise, kind should be one of: :hash-table - builds a hash table representing all characters which satisfy the test and returns a closure which checks if a character is in that hash table :charset - instead of a hash table uses a \"charset\" which is a data structure using non-linear hashing and optimized to represent (sparse) sets of characters in a fast and space-efficient way (contributed by Nikodemus Siivola) :charmap - instead of a hash table uses a bit vector to represent the set of characters You can also use :hash-table* or :charset* which are like :hash-table and :charset but use the complement of the set if the set contains more than half of all characters between start and end . This saves space but needs an additional pass across all characters to create the data structure. There is no corresponding :charmap* kind as the bit vectors are already created to cover the smallest possible interval which contains either the set or its complement.","title":"create-optimized-test-function"},{"location":"cl-ppcre/#create-scanner","text":"Function: (create-scanner regex &key case-insensitive-mode multi-line-mode single-line-mode extended-mode destructive) Accepts a regular expression - either as a parse-tree or as a string - and returns a scan closure which will scan strings for this regular expression and a list mapping registers to their names ( nil stands for unnamed ones). The \"mode\" keyword arguments are equivalent to the imsx modifiers in Perl. If destructive is not nil , the function is allowed to destructively modify its first argument (but only if it's a parse tree). (More in the manual!)","title":"create-scanner"},{"location":"cl-ppcre/#define-parse-tree-synonym","text":"Macro: (define-parse-tree-synonym name parse-tree) Defines the symbol name to be a synonym for the parse tree parse-tree . Both arguments are quoted.","title":"define-parse-tree-synonym"},{"location":"cl-ppcre/#do-matches","text":"Macro: (do-matches (match-start match-end regex target-string &optional result-form &key start end) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with match-start and match-end bound to the start/end positions of each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-matches ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. body may start with declarations.","title":"do-matches"},{"location":"cl-ppcre/#do-matches-as-strings","text":"Macro: (do-matches-as-strings (match-var regex target-string &optional result-form &key start end sharedp) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with match-var bound to the substring of target-string corresponding to each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-matches-as-strings ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . body may start with declarations.","title":"do-matches-as-strings"},{"location":"cl-ppcre/#do-register-groups","text":"Macro: (do-register-groups var-list (regex target-string &optional result-form &key start end sharedp) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with the variables in var-list bound to the corresponding register groups for each match in turn, i.e. each variable is either bound to a string or to nil . For each element of var-list which is nil there's no binding to the corresponding register group. The number of variables in var-list must not be greater than the number of register groups. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-register-groups ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . body may start with declarations.","title":"do-register-groups"},{"location":"cl-ppcre/#do-scans","text":"Macro: (do-scans (match-start match-end reg-starts reg-ends regex target-string &optional result-form &key start end) &body body) Iterates over target-string and tries to match regex as often as possible evaluating BODY with match-start , match-end , reg-starts , and reg-ends bound to the four return values of each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-scans ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. body may start with declarations.","title":"do-scans"},{"location":"cl-ppcre/#parse-string","text":"Function: (parse-string string) Translate the regex string string into a parse tree.","title":"parse-string"},{"location":"cl-ppcre/#parse-tree-synonym","text":"Function: (parse-tree-synonym symbol) Returns the parse tree the symbol symbol is a synonym for. Returns nil is symbol wasn't yet defined to be a synonym.","title":"parse-tree-synonym"},{"location":"cl-ppcre/#ppcre-error","text":"Every error signaled by CL-PPCRE is of type ppcre-error . This is a direct subtype of simple-error without any additional slots or options.","title":"ppcre-error"},{"location":"cl-ppcre/#ppcre-invocation-error","text":"Errors of type ppcre-invocation-error are signaled if one of the exported functions of CL-PPCRE is called with wrong or inconsistent arguments. This is a direct subtype of ppcre-error without any additional slots or options.","title":"ppcre-invocation-error"},{"location":"cl-ppcre/#ppcre-syntax-error","text":"An error of type ppcre-syntax-error is signaled if CL-PPCRE's parser encounters an error when trying to parse a regex string or to convert a parse tree into its internal representation. This is a direct subtype of ppcre-error with two additional slots. These denote the regex string which HTML-PPCRE was parsing and the position within the string where the error occurred. If the error happens while CL-PPCRE is converting a parse tree, both of these slots contain NIL. (See the next two entries on how to access these slots.)","title":"ppcre-syntax-error"},{"location":"cl-ppcre/#ppcre-syntax-error-pos","text":"Function: (ppcre-syntax-error-pos condition) Returns the position within the string where the error occurred (or nil if the error happened while trying to convert a parse tree","title":"ppcre-syntax-error-pos"},{"location":"cl-ppcre/#ppcre-syntax-error-string","text":"Function: (ppcre-syntax-error-string condition) Returns the string the parser was parsing when the error was encountered (or nil if the error happened while trying to convert a parse tree).","title":"ppcre-syntax-error-string"},{"location":"cl-ppcre/#quote-meta-chars","text":"Function: (quote-meta-chars string &key (start 0) (end (length string))) Quote, i.e. prefix all non-word characters in string with #\\\\ .","title":"quote-meta-chars"},{"location":"cl-ppcre/#regex-apropos","text":"Function: (regex-apropos regex &optional packages &key (case-insensitive t)) Similar to the standard function apropos but returns a list of all symbols which match the regular expression REGEX. If case-insensitive is true and regex isn't already a scanner, a case-insensitive scanner is used.","title":"regex-apropos"},{"location":"cl-ppcre/#regex-apropos-list","text":"Function: (regex-apropos-list regex &optional packages &key (case-insensitive t)) Similar to the standard function apropos-list but returns a list of all symbols which match the regular expression regex . If case-insensitive is true and regex isn't already a scanner, a case-insensitive scanner is used.","title":"regex-apropos-list"},{"location":"cl-ppcre/#regex-replace","text":"Function: (regex-replace regex target-string replacement &key (start 0) (end (length target-string)) preserve-case simple-calls (element-type 'character)) Try to match target-string between start and end against regex and replace the first match with replacement . Two values are returned; the modified string, and t if regex matched or nil otherwise. replacement can be a string which may contain the special substrings \"\\&\" for the whole match, \"`\" for the part of target-string before the match, \"\\'\" for the part of target-string after the match, \"\\N\" or \"{N}\" for the Nth register where N is a positive integer. replacement can also be a function designator in which case the match will be replaced with the result of calling the function designated by replacement with the arguments target-string , start , end , match-start , match-end , reg-starts , and reg-ends . ( reg-starts and reg-ends are arrays holding the start and end positions of matched registers or nil - the meaning of the other arguments should be obvious.) Finally, replacement can be a list where each element is a string, one of the symbols :match , :before-match , or :after-match - corresponding to \"\\&\", \"`\", and \"\\'\" above -, an integer N - representing register (1+ N) -, or a function designator. If preserve-case is true, the replacement will try to preserve the case (all upper case, all lower case, or capitalized) of the match. The result will always be a fresh string, even if regex doesn't match. element-type is the element type of the resulting string.","title":"regex-replace"},{"location":"cl-ppcre/#regex-replace-all","text":"Function: (regex-replace-all regex target-string replacement &key (start 0) (end (length target-string)) preserve-case simple-calls (element-type 'character)) Try to match target-string between start and end against regex and replace all matches with replacement . Two values are returned; the modified string, and T if regex matched or nil otherwise. replacement can be a string which may contain the special substrings \"\\&\" for the whole match, \"`\" for the part of target-string before the match, \"\\'\" for the part of target-string after the match, \"\\N\" or \"{N}\" for the Nth register where N is a positive integer. replacement can also be a function designator in which case the match will be replaced with the result of calling the function designated by replacement with the arguments target-string , start , end , match-start , match-end , reg-starts , and reg-ends . ( reg-starts and reg-ends are arrays holding the start and end positions of matched registers or nil - the meaning of the other arguments should be obvious.) Finally, replacement can be a list where each element is a string, one of the symbols :match , :before-match , or :after-match - corresponding to \"\\&\", \"`\", and \"\\'\" above -, an integer N - representing register (1+ N) -, or a function designator. If preserve-case is true, the replacement will try to preserve the case (all upper case, all lower case, or capitalized) of the match. The result will always be a fresh string, even if regex doesn't match. element-type is the element type of the resulting string.","title":"regex-replace-all"},{"location":"cl-ppcre/#register-groups-bind","text":"Macro: (register-groups-bind var-list (regex target-string &key start end sharedp) &body body) Executes body with the variables in var-list bound to the corresponding register groups after target-string has been matched against regex , i.e. each variable is either bound to a string or to nil . If there is no match, body is not executed. For each element of var-list which is nil there's no binding to the corresponding register group. The number of variables in var-list must not be greater than the number of register groups. If sharedp is true, the substrings may share structure with target-string .","title":"register-groups-bind"},{"location":"cl-ppcre/#scan","text":"Function: (scan regex target-string &key start end real-start-pos) Searches target-string from start to end and tries to match regex . On success returns four values - the start of the match, the end of the match, and two arrays denoting the beginnings and ends of register matches. On failure returns nil . regex can be a string which will be parsed according to Perl syntax, a parse tree, or a pre-compiled scanner created by create-scanner . target-string will be coerced to a simple string if it isn't one already. The real-start-pos parameter should be ignored - it exists only for internal purposes.","title":"scan"},{"location":"cl-ppcre/#scan-to-strings","text":"Function: (scan-to-strings regex target-string &key (start 0) (end (length target-string)) sharedp) Like scan but returns substrings of target-string instead of positions, i.e. this function returns two values on success: the whole match as a string plus an array of substrings (or nil s) corresponding to the matched registers. If sharedp is true, the substrings may share structure with target-string .","title":"scan-to-strings"},{"location":"cl-ppcre/#split","text":"Function: (split regex target-string &key (start 0) (end (length target-string)) limit with-registers-p omit-unmatched-p sharedp) Matches regex against target-string as often as possible and returns a list of the substrings between the matches. If with-registers-p is true, substrings corresponding to matched registers are inserted into the list as well. If omit-unmatched-p is true, unmatched registers will simply be left out, otherwise they will show up as nil . limit limits the number of elements returned - registers aren't counted. If limit is nil (or 0 which is equivalent), trailing empty strings are removed from the result list. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string .","title":"split"},{"location":"cl-ppcre/#configuration-variables","text":"","title":"CONFIGURATION VARIABLES"},{"location":"cl-ppcre/#allow-named-registers","text":"Whether the parser should support AllegroCL's named registers (?<name>\"<regex>\") and back-reference \\k syntax.","title":"*allow-named-registers*"},{"location":"cl-ppcre/#allow-quoting","text":"Whether the parser should support Perl's \\Q and \\E.","title":"*allow-quoting*"},{"location":"cl-ppcre/#look-ahead-for-suffix","text":"Controls whether scanners will optimistically look ahead for a constant suffix of a regular expression, if there is one.","title":"*look-ahead-for-suffix*"},{"location":"cl-ppcre/#optimize-char-classes","text":"Whether character classes should be compiled into look-ups into O(1) data structures. This is usually fast but will be costly in terms of scanner creation time and might be costly in terms of size if *regex-char-code-limit* is high. This value will be used as the :kind keyword argument to create-optimized-test-function - see there for the possible non- NIL values.","title":"*optimize-char-classes*"},{"location":"cl-ppcre/#property-resolver","text":"Should be NIL or a designator for a function which accepts strings and returns unary character test functions or NIL . This 'resolver' is intended to handle character properties' like \\p{IsAlpha}. If *property-resolver* is NIL , then the parser will simply treat \\p and \\P as #\\p and #\\P as in older versions of CL-PPCRE.","title":"*property-resolver*"},{"location":"cl-ppcre/#regex-char-code-limit","text":"The upper exclusive bound on the char-codes of characters which can occur in character classes. Change this value BEFORE creating scanners if you don't need the (full) Unicode support of implementations like AllegroCL, CLISP, LispWorks, or SBCL.","title":"*regex-char-code-limit*"},{"location":"cl-ppcre/#use-bmh-matchers","text":"Whether the scanners created by create-scanner should use the (fast but large) Boyer-Moore-Horspool matchers.","title":"*use-bmh-matchers*"},{"location":"cl-ppcre/#support","text":"The development version of cl-ppcre can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"SUPPORT"},{"location":"cl-who/","text":"cl-who - DSL for Markup Version: 1.1.4 Nickname: who Repository: edicl/cl-who - Github This documentation is possible due to the excellent official documentation as of 5th May 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . CL-WHO primarily provides a single macro with-html-output to convert S-expressions intermingled with code into (X)HTML, XML and the likes. GETTING STARTED with-html-output and with-html-output-to-string are the basic macros to get going: CL-USER> (defparameter *site-alist* '((\"http://zappa.com/\" . \"Frank Zappa\") (\"http://marcusmiller.com/\" . \"Marcus Miller\") (\"http://www.milesdavis.com/\" . \"Miles Davis\"))) *SITE-ALIST* CL-USER> (format t (with-html-output-to-string (s nil :indent t) (loop for (link . title) in *site-alist* do (htm (:a :href link (:b (str title))) ; <- note the str! :br)))) <a href='http://zappa.com/'> <b>Frank Zappa </b> </a> <br /> <a href='http://marcusmiller.com/'> <b>Marcus Miller </b> </a> <br /> <a href='http://www.milesdavis.com/'> <b>Miles Davis </b> </a> <br /> NIL CL-USER> (format t (with-output-to-string (s) (with-html-output (s s :indent t) (loop for (link . title) in *site-alist* do (htm (:a :href link (:b (str title))) ; <- note the str! :br))))) <a href='http://zappa.com/'> <b>Frank Zappa </b> </a> <br /> <a href='http://marcusmiller.com/'> <b>Marcus Miller </b> </a> <br /> <a href='http://www.milesdavis.com/'> <b>Miles Davis </b> </a> <br /> Inside these macros, there exist the lexically scoped macros: esc as short-hand for escape-string fmt as short-hand for cl:format htm as short-hand for (another) with-html-output . str as short-hand for, well, writing to the \"inner html\" rather than attributes; basically the difference between these two: CL-USER> (let ((string \"hello\") (class \"world\")) (with-html-output-to-string (s nil :indent t) (htm (:div :class class string)))) \" <div class='world'> </div>\" CL-USER> (let ((string \"hello\") (class \"world\")) (with-html-output-to-string (s nil :indent t) (htm (:div :class class (str string))))) \" <div class='world'>hello </div>\" In this case, str could equivalently be replaced by fmt or esc . Also see html-mode . Detailed transformation rules are available in the official documentation . CONFIGURATION VARIABLES *attribute-quote-char* Variable Quote character for attributes. *downcase-tokens-p* Variable If NIL, a keyword symbol representing a tag or attribute name will not be automatically converted to lowercase. If T, the tag and attribute name will be converted to lowercase only if it is in the same case. This is useful when one needs to output case sensitive XML. *empty-attribute-syntax* Variable Set this to t to enable attribute minimization (also called \"boolean attributes\", or \"empty attribute syntax\" according to the w3 html standard ). In XHTML attribute minimization is forbidden, and all attributes must have a value. Thus in XHTML boolean attributes must be defined as <input disabled='disabled' />. In HTML5 boolean attributes can be defined as <input disabled> If it is NIL the attribute will be left out completely. (:td :nowrap nil) => \"<td />\" *escape-char-p* Variable Used by escape-string to test whether a character should be escaped. *html-empty-tag-aware-p* Variable Set this to NIL to if you want to use CL-WHO as a strict XML generator. Otherwise, CL-WHO will only write empty tags listed in *html-empty-tags* as <tag/> (XHTML mode) or <tag> (SGML mode and HTML5 mode). For all other tags, it will always generate <tag></tag>. *html-empty-tags* Variable The list of HTML tags that should be output as empty tags. See *html-empty-tag-aware-p* . *html-no-indent-tags* Variable The list of HTML tags that should disable indentation inside them. The initial value is a list containing only :pre and :textarea . *prologue* Variable This is the first line that'll be printed if the :prologue keyword argument is T FUNCTIONS AND MACROS conc Function: (conc &rest string-list) Concatenates all arguments which should be string into one string. convert-attributes Function: (convert-attributes attr-list) Helper function for convert-tag-to-string-list which converts the alist attr-list of attributes into a list of strings and/or Lisp forms. convert-tag-to-string-list Generic Function: (convert-tag-to-string-list tag attr-list body body-fn) Used by cl-who::process-tag to convert HTML into a list of strings. tag is a keyword symbol naming the outer tag, attr-list is an alist of its attributes (the car is the attribute's name as a keyword, the cdr is its value), body is the tag's body, and body-fn is a function which should be applied to body . The function must return a list of strings or Lisp forms. esc escape-char Function: (escape-char char &key (test *escape-char-p*)) Returns an escaped version of the character char if char satisfies the predicate test . Always returns a string. escape-char-all Function: (escape-char-all char) Escapes characters which aren't in the 7-bit ASCII character set. escape-char-iso-8859-1 Function: (escape-char-iso-8859-1 char) Escapes characters that aren't defined in ISO-8859-9. escape-char-minimal Function: (escape-char-minimal char) Escapes only #<, #>, and #& characters. escape-char-minimal-plus-quotes Function: (escape-char-minimal-plus-quotes char) Like escape-char-minimal but also escapes quotes. escape-string Function: (escape-string string &key (test *escape-char-p*)) Escape all characters in string which pass test . This function is not guaranteed to return a fresh string. Note that you can pass NIL for string which'll just be returned. escape-string-all Function: (escape-string-all string) Escapes all characters in string which aren't in the 7-bit ASCII character set. escape-string-iso-8859-1 Function: (escape-string-iso-8859-1 string) Escapes all characters in string which aren't defined in ISO-8859-1. escape-string-minimal Function: (escape-string-minimal string) Escapes only #<, #>, and #& in string . escape-string-minimal-plus-quotes Function: (escape-string-minimal-plus-quotes string) Like escape-string-minimal but also escapes quotes. fmt htm html-mode Function: (html-mode) Returns the current HTML mode. :SGML for (SGML-)HTML, :XML for XHTML and :HTML5 for HTML5 (HTML syntax). Function: (setf (html-mode) mode) Sets the output mode to XHTML or (SGML-)HTML. MODE can be :SGML for HTML, :XML for XHTML or :HTML5 for HTML5 (HTML syntax). str with-html-output Macro: (with-html-output (var &optional stream &rest rest &key prologue indent) &body body) Transform the enclosed body consisting of HTML as s-expressions into Lisp code to write the corresponding HTML as strings to var - which should either hold a stream or which'll be bound to STREAM if supplied. with-html-output-to-string Macro: (with-html-output-to-string (var &optional string-form &key prologue indent) &body body) Transform the enclosed body consisting of HTML as s-expressions into Lisp code which creates the corresponding HTML as a string.","title":"cl-who - DSL for Markup"},{"location":"cl-who/#cl-who-dsl-for-markup","text":"Version: 1.1.4 Nickname: who Repository: edicl/cl-who - Github This documentation is possible due to the excellent official documentation as of 5th May 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . CL-WHO primarily provides a single macro with-html-output to convert S-expressions intermingled with code into (X)HTML, XML and the likes.","title":"cl-who - DSL for Markup"},{"location":"cl-who/#getting-started","text":"with-html-output and with-html-output-to-string are the basic macros to get going: CL-USER> (defparameter *site-alist* '((\"http://zappa.com/\" . \"Frank Zappa\") (\"http://marcusmiller.com/\" . \"Marcus Miller\") (\"http://www.milesdavis.com/\" . \"Miles Davis\"))) *SITE-ALIST* CL-USER> (format t (with-html-output-to-string (s nil :indent t) (loop for (link . title) in *site-alist* do (htm (:a :href link (:b (str title))) ; <- note the str! :br)))) <a href='http://zappa.com/'> <b>Frank Zappa </b> </a> <br /> <a href='http://marcusmiller.com/'> <b>Marcus Miller </b> </a> <br /> <a href='http://www.milesdavis.com/'> <b>Miles Davis </b> </a> <br /> NIL CL-USER> (format t (with-output-to-string (s) (with-html-output (s s :indent t) (loop for (link . title) in *site-alist* do (htm (:a :href link (:b (str title))) ; <- note the str! :br))))) <a href='http://zappa.com/'> <b>Frank Zappa </b> </a> <br /> <a href='http://marcusmiller.com/'> <b>Marcus Miller </b> </a> <br /> <a href='http://www.milesdavis.com/'> <b>Miles Davis </b> </a> <br /> Inside these macros, there exist the lexically scoped macros: esc as short-hand for escape-string fmt as short-hand for cl:format htm as short-hand for (another) with-html-output . str as short-hand for, well, writing to the \"inner html\" rather than attributes; basically the difference between these two: CL-USER> (let ((string \"hello\") (class \"world\")) (with-html-output-to-string (s nil :indent t) (htm (:div :class class string)))) \" <div class='world'> </div>\" CL-USER> (let ((string \"hello\") (class \"world\")) (with-html-output-to-string (s nil :indent t) (htm (:div :class class (str string))))) \" <div class='world'>hello </div>\" In this case, str could equivalently be replaced by fmt or esc . Also see html-mode . Detailed transformation rules are available in the official documentation .","title":"GETTING STARTED"},{"location":"cl-who/#configuration-variables","text":"","title":"CONFIGURATION VARIABLES"},{"location":"cl-who/#attribute-quote-char","text":"Variable Quote character for attributes.","title":"*attribute-quote-char*"},{"location":"cl-who/#downcase-tokens-p","text":"Variable If NIL, a keyword symbol representing a tag or attribute name will not be automatically converted to lowercase. If T, the tag and attribute name will be converted to lowercase only if it is in the same case. This is useful when one needs to output case sensitive XML.","title":"*downcase-tokens-p*"},{"location":"cl-who/#empty-attribute-syntax","text":"Variable Set this to t to enable attribute minimization (also called \"boolean attributes\", or \"empty attribute syntax\" according to the w3 html standard ). In XHTML attribute minimization is forbidden, and all attributes must have a value. Thus in XHTML boolean attributes must be defined as <input disabled='disabled' />. In HTML5 boolean attributes can be defined as <input disabled> If it is NIL the attribute will be left out completely. (:td :nowrap nil) => \"<td />\"","title":"*empty-attribute-syntax*"},{"location":"cl-who/#escape-char-p","text":"Variable Used by escape-string to test whether a character should be escaped.","title":"*escape-char-p*"},{"location":"cl-who/#html-empty-tag-aware-p","text":"Variable Set this to NIL to if you want to use CL-WHO as a strict XML generator. Otherwise, CL-WHO will only write empty tags listed in *html-empty-tags* as <tag/> (XHTML mode) or <tag> (SGML mode and HTML5 mode). For all other tags, it will always generate <tag></tag>.","title":"*html-empty-tag-aware-p*"},{"location":"cl-who/#html-empty-tags","text":"Variable The list of HTML tags that should be output as empty tags. See *html-empty-tag-aware-p* .","title":"*html-empty-tags*"},{"location":"cl-who/#html-no-indent-tags","text":"Variable The list of HTML tags that should disable indentation inside them. The initial value is a list containing only :pre and :textarea .","title":"*html-no-indent-tags*"},{"location":"cl-who/#prologue","text":"Variable This is the first line that'll be printed if the :prologue keyword argument is T","title":"*prologue*"},{"location":"cl-who/#functions-and-macros","text":"","title":"FUNCTIONS AND MACROS"},{"location":"cl-who/#conc","text":"Function: (conc &rest string-list) Concatenates all arguments which should be string into one string.","title":"conc"},{"location":"cl-who/#convert-attributes","text":"Function: (convert-attributes attr-list) Helper function for convert-tag-to-string-list which converts the alist attr-list of attributes into a list of strings and/or Lisp forms.","title":"convert-attributes"},{"location":"cl-who/#convert-tag-to-string-list","text":"Generic Function: (convert-tag-to-string-list tag attr-list body body-fn) Used by cl-who::process-tag to convert HTML into a list of strings. tag is a keyword symbol naming the outer tag, attr-list is an alist of its attributes (the car is the attribute's name as a keyword, the cdr is its value), body is the tag's body, and body-fn is a function which should be applied to body . The function must return a list of strings or Lisp forms.","title":"convert-tag-to-string-list"},{"location":"cl-who/#esc","text":"","title":"esc"},{"location":"cl-who/#escape-char","text":"Function: (escape-char char &key (test *escape-char-p*)) Returns an escaped version of the character char if char satisfies the predicate test . Always returns a string.","title":"escape-char"},{"location":"cl-who/#escape-char-all","text":"Function: (escape-char-all char) Escapes characters which aren't in the 7-bit ASCII character set.","title":"escape-char-all"},{"location":"cl-who/#escape-char-iso-8859-1","text":"Function: (escape-char-iso-8859-1 char) Escapes characters that aren't defined in ISO-8859-9.","title":"escape-char-iso-8859-1"},{"location":"cl-who/#escape-char-minimal","text":"Function: (escape-char-minimal char) Escapes only #<, #>, and #& characters.","title":"escape-char-minimal"},{"location":"cl-who/#escape-char-minimal-plus-quotes","text":"Function: (escape-char-minimal-plus-quotes char) Like escape-char-minimal but also escapes quotes.","title":"escape-char-minimal-plus-quotes"},{"location":"cl-who/#escape-string","text":"Function: (escape-string string &key (test *escape-char-p*)) Escape all characters in string which pass test . This function is not guaranteed to return a fresh string. Note that you can pass NIL for string which'll just be returned.","title":"escape-string"},{"location":"cl-who/#escape-string-all","text":"Function: (escape-string-all string) Escapes all characters in string which aren't in the 7-bit ASCII character set.","title":"escape-string-all"},{"location":"cl-who/#escape-string-iso-8859-1","text":"Function: (escape-string-iso-8859-1 string) Escapes all characters in string which aren't defined in ISO-8859-1.","title":"escape-string-iso-8859-1"},{"location":"cl-who/#escape-string-minimal","text":"Function: (escape-string-minimal string) Escapes only #<, #>, and #& in string .","title":"escape-string-minimal"},{"location":"cl-who/#escape-string-minimal-plus-quotes","text":"Function: (escape-string-minimal-plus-quotes string) Like escape-string-minimal but also escapes quotes.","title":"escape-string-minimal-plus-quotes"},{"location":"cl-who/#fmt","text":"","title":"fmt"},{"location":"cl-who/#htm","text":"","title":"htm"},{"location":"cl-who/#html-mode","text":"Function: (html-mode) Returns the current HTML mode. :SGML for (SGML-)HTML, :XML for XHTML and :HTML5 for HTML5 (HTML syntax). Function: (setf (html-mode) mode) Sets the output mode to XHTML or (SGML-)HTML. MODE can be :SGML for HTML, :XML for XHTML or :HTML5 for HTML5 (HTML syntax).","title":"html-mode"},{"location":"cl-who/#str","text":"","title":"str"},{"location":"cl-who/#with-html-output","text":"Macro: (with-html-output (var &optional stream &rest rest &key prologue indent) &body body) Transform the enclosed body consisting of HTML as s-expressions into Lisp code to write the corresponding HTML as strings to var - which should either hold a stream or which'll be bound to STREAM if supplied.","title":"with-html-output"},{"location":"cl-who/#with-html-output-to-string","text":"Macro: (with-html-output-to-string (var &optional string-form &key prologue indent) &body body) Transform the enclosed body consisting of HTML as s-expressions into Lisp code which creates the corresponding HTML as a string.","title":"with-html-output-to-string"},{"location":"fiveam/","text":"fiveam - Regression Testing Framework Version: 1.4.1 Nickname: 5am Repository: sionescu/fiveam - Github This documentation was possible due to Tomek Kurez's tutorial on fiveam and the excellent official documentation . In case of any inaccuracies, ambiguities or suggestions, please create an issue here . GETTING STARTED Checks and Tests A check, defined using the macro is , is a line of code that makes sure something is indeed true. A basic check definition is of the form (is test &rest reason-args) . However, checks can only be defined in the context of tests: (test test-demo \"This demonstrates the basic use of test and check.\" (is (listp (list 1 2))) (is (= 5 (+ 2 3)) \"This should pass.\") ; &rest reason-args (is (= 4 4.1) \"~D and ~D are not = to each other.\" 4 4.1)) To run the test, simply, call run! : (run! 'test-demo) ;; Running test TEST-DEMO ..f ;; Did 3 checks. ;; Pass: 2 (66%) ;; Skip: 0 ( 0%) ;; Fail: 1 (33%) ;; ;; Failure Details: ;; -------------------------------- ;; TEST-DEMO [This demonstrates the basic use of test and check.]: ;; 4 and 4.1 are not = to each other. ;; ;; (= 4 4.1) ;; ;; was NIL.. ;; -------------------------------- Tests can automatically be run on (re)compilation by setting *run-test-when-defined* to t . So, simply compiling (test another-test (is (eq t t))) ;; ;; Running test ANOTHER-TEST . ;; Did 1 check. ;; Pass: 1 (100%) ;; Skip: 0 ( 0%) ;; Fail: 0 ( 0%) runs the test. (Also see other Configuration Variables .) (run!) can be called without arguments to run all the tests. Suites Tests can be grouped into suites. In fact, suites can also parent other suites. Suites can be defined using def-suite , and similar to* in-package , the current suite can be specified using in-suite . (def-suite suite-one) (def-suite suite-two) (in-suite suite-one) (test first-test (is (= 1 1))) (test (second-test :suite suite-two) ; perhaps, not recommended (is (null nil))) (in-suite suite-two) (test third-test (is (eq 'done 'done))) All tests can be run with run-all-tests . Also see the arguments to run! . (run-all-tests) ;; Running test suite NIL ;; Running test FIRST-TEST . ;; Running test THIRD-TEST . ;; Running test suite SUITE-TWO ;; Running test SECOND-TEST . ;; Did 3 checks. ;; Pass: 3 (100%) ;; Skip: 0 ( 0%) ;; Fail: 0 ( 0%) More Things Tests can be removed using rem-test . See generators for utilities for generating random data. These are to be used in conjunction with the for-all macro. Generators are merely closures and you can define your own. fiveam also provides the ability to def-fixture and with-fixture ; however, (as of 2016) it is recommended to just use macros instead . The signals macro can be used to check if conditions are signalled appropriately. CONFIGURATION VARIABLES *debug-on-error* T if we should drop into the debugger on error, NIL otherwise. OBSOLETE: superseded by *ON-ERROR* *debug-on-failure* T if we should drop into the debugger on a failing check, NIL otherwise. OBSOLETE: superseded by *ON-FAILURE* *default-test-compilation-time* *max-trials* Number of total times we attempt to run the body of the FOR-ALL test including when the body is skipped due to failed guard conditions. Since we have guard conditions we may get into infinite loops where the test code is never run due to the guards never returning true. This second run limit prevents that. *num-trials* Number of times we attempt to run the body of the FOR-ALL test. *on-error* The action to perform on error: - :DEBUG if we should drop into the debugger - :BACKTRACE to print a backtrace - NIL to simply continue *on-failure* The action to perform on check failure: - :DEBUG if we should drop into the debugger - :BACKTRACE to print a backtrace - NIL to simply continue *print-names* T if we should print test running progress, NIL otherwise. *run-test-when-defined* When non-NIL tests are run as soon as they are defined. *test-dribble* *verbose-failures* T if we should print the expression failing, NIL otherwise. FUNCTIONS AND MACROS ! Function: (!) Rerun the most recently run test and explain the results. !! Function: (!!) Rerun the second most recently run test and explain the results. !!! Function: (!!!) Rerun the third most recently run test and explain the results. debug! Function: (debug! &optional (test-spec *suite*)) Calls (run! test-spec) but enters the debugger if any kind of error happens. def-fixture Macro: (def-fixture name (&rest args) &body body) Defines a fixture named NAME. A fixture is very much like a macro but is used only for simple templating. A fixture created with DEF-FIXTURE is a macro which can use the special macrolet &BODY to specify where the body should go. See Also: WITH-FIXTURE . def-suite Macro: (def-suite name &key description in) Define a new test-suite named NAME. IN (a symbol), if provided, causes this suite te be nested in the suite named by IN. NB: This macro is built on top of make-suite, as such it, like make-suite, will overrwrite any existing suite named NAME. def-suite* Macro: (def-suite* name &rest def-suite-args) def-test Macro: (def-test name (&key depends-on (suite) fixture (compile-at) profile) &body body) Create a test named NAME. NAME is the symbol which names the test. DEPENDS-ON is a list of the form: (AND . test-names) - This test is run only if all of the tests in TEST-NAMES have passed, otherwise a single test-skipped result is generated. (OR . test-names) - If any of TEST-NAMES has passed this test is run, otherwise a test-skipped result is generated. (NOT test-name) - This is test is run only if TEST-NAME failed. AND, OR and NOT can be combined to produce complex dependencies. If DEPENDS-ON is a symbol it is interpreted as `(AND ,depends-on), this is accomadate the common case of one test depending on another. FIXTURE specifies a fixture to wrap the body in. If PROFILE is T profiling information will be collected as well. explain! Function: (explain! result-list) Explain the results of RESULT-LIST using a detailed-text-explainer with output going to test-dribble . Return a boolean indicating whether no tests failed. fail Macro: (fail &rest message-args) Simply generate a FAIL. finishes Macro: (finishes &body body) Generates a pass if BODY executes to normal completion. In other words if body does signal, return-from or throw this test fails. for-all Macro: (for-all bindings &body body) Bind BINDINGS to random variables and test BODY num-trials times. BINDINGS is a list of binding forms, each element is a list of (BINDING VALUE &optional GUARD) . Value, which is evaluated once when the for-all is evaluated, must return a generator which be called each time BODY is evaluated. BINDING is either a symbol or a list which will be passed to destructuring-bind. GUARD is a form which, if present, stops BODY from executing when IT returns NIL. The GUARDS are evaluated after all the random data has been generated and they can refer to the current value of any binding. NB: Generator forms, unlike guard forms, can not contain references to the bound variables. Examples: (for-all ((a (gen-integer))) (is (integerp a))) (for-all ((a (gen-integer) (plusp a))) (is (integerp a)) (is (plusp a))) (for-all ((less (gen-integer)) (more (gen-integer) (< less more))) (is (<= less more))) (for-all (((a b) (gen-two-integers))) (is (integerp a)) (is (integerp b))) gen-buffer Function: (gen-buffer &key (length (gen-integer min 0 max 50)) (element-type '(unsigned-byte 8)) (elements (gen-integer :min 0 :max (1- (expt 2 8))))) gen-character Function: (gen-character &key (code-limit char-code-limit) (code (gen-integer :min 0 :max (1- code-limit))) (alphanumericp nil)) Returns a generator of characters. CODE must be a generator of random integers. ALPHANUMERICP, if non-NIL, limits the returned chars to those which pass alphanumericp. gen-float Function: (gen-float &key bound (type 'short-float)) Returns a generator which produces floats of type TYPE. BOUND, if specified, constrains the results to be in the range (-BOUND, BOUND). gen-integer Function: (gen-integer &key (max (1+ most-positive-fixnum)) (min (1- most-negative-fixnum))) Returns a generator which produces random integers greater than or equal to MIN and less than or equal to MAX. gen-list Function: (gen-list &key (length (gen-integer :min 0 :max 10)) (elements (gen-integer :min -10 :max 10))) Returns a generator which produces random lists. LENGTH must be an integer generator and ELEMENTS must be a generator which produces objects. gen-one-element Function: (gen-one-element &rest elements) gen-string Function: (gen-string &key (length (gen-integer :min 0 :max 80)) (elements (gen-character)) (element-type 'character)) Returns a generator which produces random strings. LENGTH must be a generator which produces integers, ELEMENTS must be a generator which produces characters of type ELEMENT-TYPE. gen-tree Function: (gen-tree &key (size 20) (elements (gen-integer :min -10 :max 10))) Returns a generator which produces random trees. SIZE controls the approximate size of the tree, but don't try anything above 30, you have been warned. ELEMENTS must be a generator which will produce the elements. get-fixture Function: (get-fixture key &optional default) get-test Function: (get-test key &optional default) in-suite Macro: (in-suite suite-name) Set the suite special variable so that all tests defined after the execution of this form are, unless specified otherwise, in the test-suite named SUITE-NAME. See also: DEF-SUITE SUITE in-suite* Macro: (in-suite* suite-name &key in) Just like in-suite, but silently creates missing suites. is Macro: (is test &rest reason-args) The DWIM checking operator. If TEST returns a true value a test-passed result is generated, otherwise a test-failure result is generated. The reason, unless REASON-ARGS is provided, is generated based on the form of TEST: (predicate expected actual) - Means that we want to check whether, according to PREDICATE, the ACTUAL value is in fact what we EXPECTED. (predicate value) - Means that we want to ensure that VALUE satisfies PREDICATE. Wrapping the TEST form in a NOT simply produces a negated reason string. is-every Macro: (is-every predicate &body clauses) The input is either a list of lists, or a list of pairs. Generates (is (,predicate ,expr ,value)) for each pair of elements or (is (,predicate ,expr ,value) ,@reason) for each list. is-false Macro: (is-false condition &rest reason-args) Generates a pass if CONDITION returns false, generates a failure otherwise. Like IS-TRUE, and unlike IS, IS-FALSE does not inspect CONDITION to determine what reason to give it case of test failure is-true Macro: (is-true condition &rest reason-args) Like IS this check generates a pass if CONDITION returns true and a failure if CONDITION returns false. Unlike IS this check does not inspect CONDITION to determine how to report the failure. make-fixture make-suite Function: (make-suite name &key description ((in parent-suite))) Create a new test suite object. Overrides any existing suite named NAME. make-test pass Macro: (pass &rest message-args) Simply generate a PASS. rem-fixture Function: (rem-fixture key) rem-test Function: (rem-test key) results-status Function: (results-status result-list) Given a list of test results (generated while running a test) return true if no results are of type TEST-FAILURE. Returns second and third values, which are the set of failed tests and skipped tests respectively. run Function: (run test-spec &key (print-names *print-names*)) Run the test specified by TEST-SPEC. TEST-SPEC can be either a symbol naming a test or test suite, or a testable-object object. This function changes the operations performed by the !, !! and !!! functions. run! Function: (run! &optional (test-spec *suite*) &key (print-names *print-names*)) Equivalent to (explain! (run TEST-SPEC)). run-all-tests Function: (run-all-tests &key (summary :end)) Runs all defined test suites, T if all tests passed and NIL otherwise. SUMMARY can be :END to print a summary at the end, :SUITE to print it after each suite or NIL to skip explanations. signals Macro: (signals condition-spec &body body) Generates a pass if BODY signals a condition of type CONDITION. BODY is evaluated in a block named NIL, CONDITION is not evaluated. skip Macro: (skip &rest reason) Generates a TEST-SKIPPED result. test Macro: (test name &body body) Create a test named NAME. If NAME is a list it must be of the form: (name &key depends-on suite fixture compile-at profile) NAME is the symbol which names the test. DEPENDS-ON is a list of the form: (AND . test-names) - This test is run only if all of the tests in TEST-NAMES have passed, otherwise a single test-skipped result is generated. (OR . test-names) - If any of TEST-NAMES has passed this test is run, otherwise a test-skipped result is generated. (NOT test-name) - This is test is run only if TEST-NAME failed. AND, OR and NOT can be combined to produce complex dependencies. If DEPENDS-ON is a symbol it is interpreted as `(AND ,depends-on), this is accomadate the common case of one test depending on another. FIXTURE specifies a fixture to wrap the body in. If PROFILE is T profiling information will be collected as well. test-names Function: (test-names) with-fixture Macro: (with-fixture fixture-name (&rest args) &body body) Insert BODY into the fixture named FIXTURE-NAME. See Also: DEF-FIXTURE .","title":"fiveam - Regression Testing Framework"},{"location":"fiveam/#fiveam-regression-testing-framework","text":"Version: 1.4.1 Nickname: 5am Repository: sionescu/fiveam - Github This documentation was possible due to Tomek Kurez's tutorial on fiveam and the excellent official documentation . In case of any inaccuracies, ambiguities or suggestions, please create an issue here .","title":"fiveam - Regression Testing Framework"},{"location":"fiveam/#getting-started","text":"","title":"GETTING STARTED"},{"location":"fiveam/#checks-and-tests","text":"A check, defined using the macro is , is a line of code that makes sure something is indeed true. A basic check definition is of the form (is test &rest reason-args) . However, checks can only be defined in the context of tests: (test test-demo \"This demonstrates the basic use of test and check.\" (is (listp (list 1 2))) (is (= 5 (+ 2 3)) \"This should pass.\") ; &rest reason-args (is (= 4 4.1) \"~D and ~D are not = to each other.\" 4 4.1)) To run the test, simply, call run! : (run! 'test-demo) ;; Running test TEST-DEMO ..f ;; Did 3 checks. ;; Pass: 2 (66%) ;; Skip: 0 ( 0%) ;; Fail: 1 (33%) ;; ;; Failure Details: ;; -------------------------------- ;; TEST-DEMO [This demonstrates the basic use of test and check.]: ;; 4 and 4.1 are not = to each other. ;; ;; (= 4 4.1) ;; ;; was NIL.. ;; -------------------------------- Tests can automatically be run on (re)compilation by setting *run-test-when-defined* to t . So, simply compiling (test another-test (is (eq t t))) ;; ;; Running test ANOTHER-TEST . ;; Did 1 check. ;; Pass: 1 (100%) ;; Skip: 0 ( 0%) ;; Fail: 0 ( 0%) runs the test. (Also see other Configuration Variables .) (run!) can be called without arguments to run all the tests.","title":"Checks and Tests"},{"location":"fiveam/#suites","text":"Tests can be grouped into suites. In fact, suites can also parent other suites. Suites can be defined using def-suite , and similar to* in-package , the current suite can be specified using in-suite . (def-suite suite-one) (def-suite suite-two) (in-suite suite-one) (test first-test (is (= 1 1))) (test (second-test :suite suite-two) ; perhaps, not recommended (is (null nil))) (in-suite suite-two) (test third-test (is (eq 'done 'done))) All tests can be run with run-all-tests . Also see the arguments to run! . (run-all-tests) ;; Running test suite NIL ;; Running test FIRST-TEST . ;; Running test THIRD-TEST . ;; Running test suite SUITE-TWO ;; Running test SECOND-TEST . ;; Did 3 checks. ;; Pass: 3 (100%) ;; Skip: 0 ( 0%) ;; Fail: 0 ( 0%)","title":"Suites"},{"location":"fiveam/#more-things","text":"Tests can be removed using rem-test . See generators for utilities for generating random data. These are to be used in conjunction with the for-all macro. Generators are merely closures and you can define your own. fiveam also provides the ability to def-fixture and with-fixture ; however, (as of 2016) it is recommended to just use macros instead . The signals macro can be used to check if conditions are signalled appropriately.","title":"More Things"},{"location":"fiveam/#configuration-variables","text":"","title":"CONFIGURATION VARIABLES"},{"location":"fiveam/#debug-on-error","text":"T if we should drop into the debugger on error, NIL otherwise. OBSOLETE: superseded by *ON-ERROR*","title":"*debug-on-error*"},{"location":"fiveam/#debug-on-failure","text":"T if we should drop into the debugger on a failing check, NIL otherwise. OBSOLETE: superseded by *ON-FAILURE*","title":"*debug-on-failure*"},{"location":"fiveam/#default-test-compilation-time","text":"","title":"*default-test-compilation-time*"},{"location":"fiveam/#max-trials","text":"Number of total times we attempt to run the body of the FOR-ALL test including when the body is skipped due to failed guard conditions. Since we have guard conditions we may get into infinite loops where the test code is never run due to the guards never returning true. This second run limit prevents that.","title":"*max-trials*"},{"location":"fiveam/#num-trials","text":"Number of times we attempt to run the body of the FOR-ALL test.","title":"*num-trials*"},{"location":"fiveam/#on-error","text":"The action to perform on error: - :DEBUG if we should drop into the debugger - :BACKTRACE to print a backtrace - NIL to simply continue","title":"*on-error*"},{"location":"fiveam/#on-failure","text":"The action to perform on check failure: - :DEBUG if we should drop into the debugger - :BACKTRACE to print a backtrace - NIL to simply continue","title":"*on-failure*"},{"location":"fiveam/#print-names","text":"T if we should print test running progress, NIL otherwise.","title":"*print-names*"},{"location":"fiveam/#run-test-when-defined","text":"When non-NIL tests are run as soon as they are defined.","title":"*run-test-when-defined*"},{"location":"fiveam/#test-dribble","text":"","title":"*test-dribble*"},{"location":"fiveam/#verbose-failures","text":"T if we should print the expression failing, NIL otherwise.","title":"*verbose-failures*"},{"location":"fiveam/#functions-and-macros","text":"","title":"FUNCTIONS AND MACROS"},{"location":"fiveam/#_1","text":"Function: (!) Rerun the most recently run test and explain the results.","title":"!"},{"location":"fiveam/#_2","text":"Function: (!!) Rerun the second most recently run test and explain the results.","title":"!!"},{"location":"fiveam/#_3","text":"Function: (!!!) Rerun the third most recently run test and explain the results.","title":"!!!"},{"location":"fiveam/#debug","text":"Function: (debug! &optional (test-spec *suite*)) Calls (run! test-spec) but enters the debugger if any kind of error happens.","title":"debug!"},{"location":"fiveam/#def-fixture","text":"Macro: (def-fixture name (&rest args) &body body) Defines a fixture named NAME. A fixture is very much like a macro but is used only for simple templating. A fixture created with DEF-FIXTURE is a macro which can use the special macrolet &BODY to specify where the body should go. See Also: WITH-FIXTURE .","title":"def-fixture"},{"location":"fiveam/#def-suite","text":"Macro: (def-suite name &key description in) Define a new test-suite named NAME. IN (a symbol), if provided, causes this suite te be nested in the suite named by IN. NB: This macro is built on top of make-suite, as such it, like make-suite, will overrwrite any existing suite named NAME.","title":"def-suite"},{"location":"fiveam/#def-suite_1","text":"Macro: (def-suite* name &rest def-suite-args)","title":"def-suite*"},{"location":"fiveam/#def-test","text":"Macro: (def-test name (&key depends-on (suite) fixture (compile-at) profile) &body body) Create a test named NAME. NAME is the symbol which names the test. DEPENDS-ON is a list of the form: (AND . test-names) - This test is run only if all of the tests in TEST-NAMES have passed, otherwise a single test-skipped result is generated. (OR . test-names) - If any of TEST-NAMES has passed this test is run, otherwise a test-skipped result is generated. (NOT test-name) - This is test is run only if TEST-NAME failed. AND, OR and NOT can be combined to produce complex dependencies. If DEPENDS-ON is a symbol it is interpreted as `(AND ,depends-on), this is accomadate the common case of one test depending on another. FIXTURE specifies a fixture to wrap the body in. If PROFILE is T profiling information will be collected as well.","title":"def-test"},{"location":"fiveam/#explain","text":"Function: (explain! result-list) Explain the results of RESULT-LIST using a detailed-text-explainer with output going to test-dribble . Return a boolean indicating whether no tests failed.","title":"explain!"},{"location":"fiveam/#fail","text":"Macro: (fail &rest message-args) Simply generate a FAIL.","title":"fail"},{"location":"fiveam/#finishes","text":"Macro: (finishes &body body) Generates a pass if BODY executes to normal completion. In other words if body does signal, return-from or throw this test fails.","title":"finishes"},{"location":"fiveam/#for-all","text":"Macro: (for-all bindings &body body) Bind BINDINGS to random variables and test BODY num-trials times. BINDINGS is a list of binding forms, each element is a list of (BINDING VALUE &optional GUARD) . Value, which is evaluated once when the for-all is evaluated, must return a generator which be called each time BODY is evaluated. BINDING is either a symbol or a list which will be passed to destructuring-bind. GUARD is a form which, if present, stops BODY from executing when IT returns NIL. The GUARDS are evaluated after all the random data has been generated and they can refer to the current value of any binding. NB: Generator forms, unlike guard forms, can not contain references to the bound variables. Examples: (for-all ((a (gen-integer))) (is (integerp a))) (for-all ((a (gen-integer) (plusp a))) (is (integerp a)) (is (plusp a))) (for-all ((less (gen-integer)) (more (gen-integer) (< less more))) (is (<= less more))) (for-all (((a b) (gen-two-integers))) (is (integerp a)) (is (integerp b)))","title":"for-all"},{"location":"fiveam/#gen-buffer","text":"Function: (gen-buffer &key (length (gen-integer min 0 max 50)) (element-type '(unsigned-byte 8)) (elements (gen-integer :min 0 :max (1- (expt 2 8)))))","title":"gen-buffer"},{"location":"fiveam/#gen-character","text":"Function: (gen-character &key (code-limit char-code-limit) (code (gen-integer :min 0 :max (1- code-limit))) (alphanumericp nil)) Returns a generator of characters. CODE must be a generator of random integers. ALPHANUMERICP, if non-NIL, limits the returned chars to those which pass alphanumericp.","title":"gen-character"},{"location":"fiveam/#gen-float","text":"Function: (gen-float &key bound (type 'short-float)) Returns a generator which produces floats of type TYPE. BOUND, if specified, constrains the results to be in the range (-BOUND, BOUND).","title":"gen-float"},{"location":"fiveam/#gen-integer","text":"Function: (gen-integer &key (max (1+ most-positive-fixnum)) (min (1- most-negative-fixnum))) Returns a generator which produces random integers greater than or equal to MIN and less than or equal to MAX.","title":"gen-integer"},{"location":"fiveam/#gen-list","text":"Function: (gen-list &key (length (gen-integer :min 0 :max 10)) (elements (gen-integer :min -10 :max 10))) Returns a generator which produces random lists. LENGTH must be an integer generator and ELEMENTS must be a generator which produces objects.","title":"gen-list"},{"location":"fiveam/#gen-one-element","text":"Function: (gen-one-element &rest elements)","title":"gen-one-element"},{"location":"fiveam/#gen-string","text":"Function: (gen-string &key (length (gen-integer :min 0 :max 80)) (elements (gen-character)) (element-type 'character)) Returns a generator which produces random strings. LENGTH must be a generator which produces integers, ELEMENTS must be a generator which produces characters of type ELEMENT-TYPE.","title":"gen-string"},{"location":"fiveam/#gen-tree","text":"Function: (gen-tree &key (size 20) (elements (gen-integer :min -10 :max 10))) Returns a generator which produces random trees. SIZE controls the approximate size of the tree, but don't try anything above 30, you have been warned. ELEMENTS must be a generator which will produce the elements.","title":"gen-tree"},{"location":"fiveam/#get-fixture","text":"Function: (get-fixture key &optional default)","title":"get-fixture"},{"location":"fiveam/#get-test","text":"Function: (get-test key &optional default)","title":"get-test"},{"location":"fiveam/#in-suite","text":"Macro: (in-suite suite-name) Set the suite special variable so that all tests defined after the execution of this form are, unless specified otherwise, in the test-suite named SUITE-NAME. See also: DEF-SUITE SUITE","title":"in-suite"},{"location":"fiveam/#in-suite_1","text":"Macro: (in-suite* suite-name &key in) Just like in-suite, but silently creates missing suites.","title":"in-suite*"},{"location":"fiveam/#is","text":"Macro: (is test &rest reason-args) The DWIM checking operator. If TEST returns a true value a test-passed result is generated, otherwise a test-failure result is generated. The reason, unless REASON-ARGS is provided, is generated based on the form of TEST: (predicate expected actual) - Means that we want to check whether, according to PREDICATE, the ACTUAL value is in fact what we EXPECTED. (predicate value) - Means that we want to ensure that VALUE satisfies PREDICATE. Wrapping the TEST form in a NOT simply produces a negated reason string.","title":"is"},{"location":"fiveam/#is-every","text":"Macro: (is-every predicate &body clauses) The input is either a list of lists, or a list of pairs. Generates (is (,predicate ,expr ,value)) for each pair of elements or (is (,predicate ,expr ,value) ,@reason) for each list.","title":"is-every"},{"location":"fiveam/#is-false","text":"Macro: (is-false condition &rest reason-args) Generates a pass if CONDITION returns false, generates a failure otherwise. Like IS-TRUE, and unlike IS, IS-FALSE does not inspect CONDITION to determine what reason to give it case of test failure","title":"is-false"},{"location":"fiveam/#is-true","text":"Macro: (is-true condition &rest reason-args) Like IS this check generates a pass if CONDITION returns true and a failure if CONDITION returns false. Unlike IS this check does not inspect CONDITION to determine how to report the failure.","title":"is-true"},{"location":"fiveam/#make-fixture","text":"","title":"make-fixture"},{"location":"fiveam/#make-suite","text":"Function: (make-suite name &key description ((in parent-suite))) Create a new test suite object. Overrides any existing suite named NAME.","title":"make-suite"},{"location":"fiveam/#make-test","text":"","title":"make-test"},{"location":"fiveam/#pass","text":"Macro: (pass &rest message-args) Simply generate a PASS.","title":"pass"},{"location":"fiveam/#rem-fixture","text":"Function: (rem-fixture key)","title":"rem-fixture"},{"location":"fiveam/#rem-test","text":"Function: (rem-test key)","title":"rem-test"},{"location":"fiveam/#results-status","text":"Function: (results-status result-list) Given a list of test results (generated while running a test) return true if no results are of type TEST-FAILURE. Returns second and third values, which are the set of failed tests and skipped tests respectively.","title":"results-status"},{"location":"fiveam/#run","text":"Function: (run test-spec &key (print-names *print-names*)) Run the test specified by TEST-SPEC. TEST-SPEC can be either a symbol naming a test or test suite, or a testable-object object. This function changes the operations performed by the !, !! and !!! functions.","title":"run"},{"location":"fiveam/#run_1","text":"Function: (run! &optional (test-spec *suite*) &key (print-names *print-names*)) Equivalent to (explain! (run TEST-SPEC)).","title":"run!"},{"location":"fiveam/#run-all-tests","text":"Function: (run-all-tests &key (summary :end)) Runs all defined test suites, T if all tests passed and NIL otherwise. SUMMARY can be :END to print a summary at the end, :SUITE to print it after each suite or NIL to skip explanations.","title":"run-all-tests"},{"location":"fiveam/#signals","text":"Macro: (signals condition-spec &body body) Generates a pass if BODY signals a condition of type CONDITION. BODY is evaluated in a block named NIL, CONDITION is not evaluated.","title":"signals"},{"location":"fiveam/#skip","text":"Macro: (skip &rest reason) Generates a TEST-SKIPPED result.","title":"skip"},{"location":"fiveam/#test","text":"Macro: (test name &body body) Create a test named NAME. If NAME is a list it must be of the form: (name &key depends-on suite fixture compile-at profile) NAME is the symbol which names the test. DEPENDS-ON is a list of the form: (AND . test-names) - This test is run only if all of the tests in TEST-NAMES have passed, otherwise a single test-skipped result is generated. (OR . test-names) - If any of TEST-NAMES has passed this test is run, otherwise a test-skipped result is generated. (NOT test-name) - This is test is run only if TEST-NAME failed. AND, OR and NOT can be combined to produce complex dependencies. If DEPENDS-ON is a symbol it is interpreted as `(AND ,depends-on), this is accomadate the common case of one test depending on another. FIXTURE specifies a fixture to wrap the body in. If PROFILE is T profiling information will be collected as well.","title":"test"},{"location":"fiveam/#test-names","text":"Function: (test-names)","title":"test-names"},{"location":"fiveam/#with-fixture","text":"Macro: (with-fixture fixture-name (&rest args) &body body) Insert BODY into the fixture named FIXTURE-NAME. See Also: DEF-FIXTURE .","title":"with-fixture"},{"location":"hunchentoot/","text":"hunchentoot - Web Server Version: 1.2.38 Repository: edicl/hunchentoot - Github This page was possible due to the excellent official documentation as well as the page on Web Development on The Common Lisp Cookbook . In case of any inaccuracies, ambiguities or suggestions, please create an issue here . *hunchentoot was formerly known as TBNL. INTRODUCTION Hunchentoot is a web server written in Common Lisp and a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. Hunchentoot provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client. It does not include functionality to programmatically generate HTML output. For this task you can use any library you like, e.g. CL-WHO or HTML-TEMPLATE . Hunchentoot should work with most popular lisp implementations including SBCL, CCL, LispWorks and all Lisps which are supported by the compatibility layers usocket and Bordeaux Threads . Hunchentoot talks with its front-end or with the client over TCP/IP sockets and optionally uses multiprocessing to handle several requests at the same time. Therefore, it cannot be implemented completely in portable Common Lisp . Hunchentoot comes with a BSD-style license so you can basically do with it whatever you want. Official documentation for Hunchentoot can be found in the docs directory or at the project website . GETTING STARTED Installation using quicklisp See the section on Installation under Defacto Libraries on Home Page . Serving local files To start the server, simply (defvar *acceptor*) (setq *acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4242)) (hunchentoot:start *acceptor*) You should see something - but not very interesting - at \" http://127.0.0.1:4242/ \" in your browser. By default, Hunchentoot serves files from the www/ directory from its source tree. In the distribution, that directory contains a HTML version of the documentation as well as the error templates. If installed via quicklisp, see (ql:where-is-system \"hunchentoot\") . See acceptor slots for a list of various slots (with or without initargs ). And configuration variables for a list of various configuration options for hunchentoot, such as whether to *catch-errors-p or *log-lisp-errors-p* and more. Acceptors provided with hunchentoot: acceptor easy-acceptor ssl-acceptor easy-ssl-acceptor Going dynamic create-X-dispatcher To bind an existing function to a route, we create-prefix-dispatcher that we push onto the *dispatch-table* (just a global list of dispatch functions): (defun hello () (format nil \"Hello, it works!\")) (push (hunchentoot:create-prefix-dispatcher \"/hello.html\" 'hello) hunchentoot:*dispatch-table*) To create a route with a regexp, we use create-regex-dispatcher , where the url-as-regexp can be a string, an s-expression or a cl-ppcre scanner. In all, there exist create-folder-dispatcher-and-handler create-prefix-dispatcher create-regex-dispatcher create-static-file-dispatcher-and-handler define-easy-handler define-easy-handler allows to create a function and to bind it to an uri at once. For instance: (hunchentoot:define-easy-handler (say-yo :uri \"/yo\") (name) (setf (hunchentoot:content-type*) \"text/plain\") (format nil \"Hey~@[ ~A~]!\" name)) Visit http://localhost:4242/yo or add parameters to the url: http://localhost:4242/yo?name=Alice . Note that we didn't explicitly ask Hunchentoot to add this route to our first acceptor of the port 4242. This handler also works for another acceptor, say another one opened at port 4444: http://localhost:4444/yo?name=Bob In fact, define-easy-handler accepts an acceptor-names parameter that defines which acceptors it works for. Accessing GET and POST parameters Query parameters are accessible with (hunchentoot:parameter \"my-param\") while in the context of a request . It acts on the default *request* object which is passed to all handlers. There also are get-paramater and post-parameter . See also the Variables in the context of a request . More documentation, tutorials and add-ons Adam Petersen has written a book called \"Lisp for the Web\" which explains how Hunchentoot and some other libraries can be used to build web sites. See also the Web Development - Cookbook . Implementing a blog in Common Lisp - Vetle Roeim Extensions and related softwares: Clack is a web server abstraction layer, defaulting to Hunchentoot. hunchentoot-cgi (by Cyrus Harmo) provides CGI handlers for Hunchentoot. CL-WEBDAV is a WebDAV server based on Hunchentoot. RESTAS is a web framework based on Hunchentoot. Caveman , Radiance , Snooze or again Weblocks are frameworks compatible with it. API REFERENCE 1. ACCEPTOR Class To create a Hunchentoot webserver, you make an instance of this class and use the generic function START to start it (and STOP to stop it). Use the :PORT initarg if you don't want to listen on the default http port 80. There are other initargs most of which you probably won't need very often. They are explained in detail in the docstrings of the slot definitions for this class. Unless you are in a Lisp without MP capabilities, you can have several active instances of ACCEPTOR (listening on different ports) at the same time. Direct superclasses: STANDARD-OBJECT Direct subclasses: EASY-ACCEPTOR , SSL-ACCEPTOR RELEVANT METHODS accept-connections Function: (accept-connections acceptor) In a loop, accepts a connection and hands it over to the acceptor's taskmaster for processing using HANDLE-INCOMING-CONNECTION. On LispWorks, this function returns immediately, on other Lisps it retusn only once the acceptor has been stopped. acceptor-log-access Function: (acceptor-log-access acceptor &key return-code) Function to call to log access to the acceptor. The RETURN-CODE, CONTENT and CONTENT-LENGTH keyword arguments contain additional information about the request to log. In addition, it can use the standard request accessor functions that are available to handler functions to find out more information about the request. acceptor-log-message Function: (acceptor-log-message acceptor log-level format-string &rest format-arguments) Function to call to log messages by the ACCEPTOR. It must accept a severity level for the message, which will be one of :ERROR, :INFO, or :WARNING, a format string and an arbitary number of formatting arguments. acceptor-status-message Function: (acceptor-status-message acceptor http-status-code &key &allow-other-keys) This function is called after the request's handler has been invoked to convert the HTTP-STATUS-CODE to a HTML message to be displayed to the user. If this function returns a string, that string is sent to the client instead of the content produced by the handler, if any. If an ERROR-TEMPLATE-DIRECTORY is set in the current acceptor and the directory contains a file corresponding to HTTP-STATUS-CODE named \\<code>.html, that file is sent to the client after variable substitution. Variables are referenced by ${ }. Additional keyword arguments may be provided which are made available to the templating logic as substitution variables. These variables can be interpolated into error message templates in, which contains the current URL relative to the server and without GET parameters. In addition to the variables corresponding to keyword arguments, the script-name, lisp-implementation-type, lisp-implementation-version and hunchentoot-version variables are available. detach-socket Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function. initialize-connection-stream Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use. process-connection Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. Handlers may call to the DETACH-SOCKET generic function to indicate that no further requests should be handled on the connection by Hunchentoot, and that responsibility for the socket is assumed by third-party software. This can be used by specialized handlers that wish to hand over connection polling or processing to functions outside of Hunchentoot, i.e. for connection multiplexing or implementing specialized client protocols. Hunchentoot will finish processing the request and the PROCESS-CONNECTION function will return without closing the connection. At that point, the acceptor may interact with the socket in whatever fashion required. reset-connection-stream Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream. start Function: (start acceptor) Starts the ACCEPTOR so that it begins accepting connections. Returns the acceptor. start-listening Function: (start-listening acceptor) Sets up a listen socket for the given ACCEPTOR and enables it to listen to incoming connections. This function is called from the thread that starts the acceptor initially and may return errors resulting from the listening operation (like 'address in use' or similar). stop Function: (stop acceptor &key soft) Stops the ACCEPTOR so that it no longer accepts requests. If SOFT is true, and there are any requests in progress, wait until all requests are fully processed, but meanwhile do not accept new requests. Note that SOFT must not be set when calling STOP from within a request handler, as that will deadlock. started-p Function: (started-p acceptor) Tells if ACCEPTOR has been started. The default implementation simply queries ACCEPTOR for its listening status, so if T is returned to the calling thread, then some thread has called START or some thread's call to STOP hasn't finished. If NIL is returned either some thread has called STOP, or some thread's call to START hasn't finished or START was never called at all for ACCEPTOR. SLOTS acceptor-shutdown-p Initform: T A flag that makes the acceptor shutdown itself when set to something other than NIL. access-log-destination Initargs: :access-log-destination Readers: hunchentoot:acceptor-access-log-destination Writers: (setf hunchentoot:acceptor-access-log-destination) Destination of the access log which contains one log entry per request handled in a format similar to Apache's access.log. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging. address Initargs: :address Readers: hunchentoot:acceptor-address The address the acceptor is listening on. If address is a string denoting an IP address, then the server only receives connections for that address. This must be one of the addresses associated with the machine and allowed values are host names such as \"www.zappa.com\" and address strings such as \"72.3.247.29\". If address is NIL, then the server will receive connections to all IP addresses on the machine. This is the default. document-root Initargs: :document-root Readers: hunchentoot:acceptor-document-root Writers: (setf hunchentoot:acceptor-document-root) Directory pathname that points to files that are served by the acceptor if no more specific acceptor-dispatch-request method handles the request. error-template-directory Initargs: :error-template-directory Readers: hunchentoot:acceptor-error-template-directory Writers: (setf hunchentoot:acceptor-error-template-directory) Directory pathname that contains error message template files for server-generated error messages. Files must be named .html with representing the HTTP return code that the file applies to, i.e. 404.html would be used as the content for a HTTP 404 Not found response. listen-backlog Initargs: :listen-backlog Readers: hunchentoot:acceptor-listen-backlog Number of pending connections allowed in the listen socket before the kernel rejects further incoming connections. listen-socket The socket listening for incoming connections. message-log-destination Initargs: :message-log-destination Readers: hunchentoot:acceptor-message-log-destination Writers: (setf hunchentoot:acceptor-message-log-destination) Destination of the server error log which is used to log informational, warning and error messages in a free-text format intended for human inspection. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging. input-chunking-p Initargs: :input-chunking-p Readers: hunchentoot:acceptor-input-chunking-p Writers: (setf hunchentoot:acceptor-input-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for input, i.e. when accepting request bodies from the client. The default is T and there's usually no reason to change this to NIL. name Initargs: :name Readers: hunchentoot:acceptor-name Writers: (setf hunchentoot:acceptor-name) The optional name of the acceptor, a symbol. This name can be utilized when defining \"easy handlers\" - see DEFINE-EASY-HANDLER. The default name is an uninterned symbol as returned by GENSYM. output-chunking-p Initargs: :output-chunking-p Readers: hunchentoot:acceptor-output-chunking-p Writers: (setf hunchentoot:acceptor-output-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for output, i.e. when sending data to the client. The default is T and there's usually no reason to change this to NIL. persistent-connections-p Initargs: :persistent-connections-p Readers: hunchentoot:acceptor-persistent-connections-p Writers: (setf hunchentoot:acceptor-persistent-connections-p) A generalized boolean denoting whether the acceptor supports persistent connections, which is the default for threaded acceptors. If this property is NIL, Hunchentoot closes each incoming connection after having processed one request. This is the default for non-threaded acceptors. port Initargs: :port Readers: hunchentoot:acceptor-port The port the acceptor is listening on. The default is 80. Note that depending on your operating system you might need special privileges to listen on port 80. When 0, the port will be chosen by the system the first time the acceptor is started. read-timeout Initargs: :read-timeout Readers: hunchentoot:acceptor-read-timeout The read timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout. reply-class Initargs: :reply-class Readers: hunchentoot:acceptor-reply-class Writers: (setf hunchentoot:acceptor-reply-class) Determines which class of reply objects is created when a request is served in and should be (a symbol naming) a class which inherits from REPLY. The default is the symbol REPLY. request-class Initargs: :request-class Readers: hunchentoot:acceptor-request-class Writers: (setf hunchentoot:acceptor-request-class) Determines which class of request objects is created when a request comes in and should be (a symbol naming) a class which inherits from REQUEST. The default is the symbol REQUEST. requests-in-progress Initform: 0 The number of requests currently in progress. shutdown-lock The lock protecting the shutdown-queue condition variable and the requests-in-progress counter. shutdown-queue A condition variable used with soft shutdown, signaled when all requests have been processed. taskmaster Initargs: :taskmaster The taskmaster (i.e. an instance of a subclass of TASKMASTER) that is responsible for scheduling the work for this acceptor. The default depends on the MP capabilities of the underlying Lisp. write-timeout Initargs: :write-timeout Readers: hunchentoot:acceptor-write-timeout The write timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout. 2. EASY-ACCEPTOR Class This is the acceptor of the \"easy\" Hunchentoot framework. Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR 3. DEFINE-EASY-HANDLER Macro: (define-easy-handler description lambda-list &body body) Defines a handler with the body BODY and optionally registers it with a URI so that it will be found by DISPATCH-EASY-HANDLERS . DESCRIPTION is either a symbol NAME or a list matching the destructuring lambda list (name &key uri acceptor-names default-parameter-type default-request-type) LAMBDA-LIST is a list the elements of which are either a symbol VAR or a list matching the destructuring lambda list (var &key real-name parameter-type init-form request-type) The resulting handler will be a Lisp function with the name NAME and keyword parameters named by the VAR symbols. Each VAR will be bound to the value of the GET or POST parameter called REAL-NAME (a string) before BODY is executed. If REAL-NAME is not provided, it will be computed by downcasing the symbol name of VAR. If URI (which is evaluated) is provided, then it must be a string or a function designator for a function of one argument. In this case, the handler will be returned by DISPATCH-EASY-HANDLERS, if URI is a string and the script name of a request is URI, or if URI designates a function and applying this function to the current request object returns a true value. ACCEPTOR-NAMES (which is evaluated) can be a list of symbols which means that the handler will be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). ACCEPTOR-NAMES can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor. Whether the GET or POST parameter (or both) will be taken into consideration, depends on REQUEST-TYPE which can be :GET, :POST, :BOTH, or NIL. In the last case, the value of DEFAULT-REQUEST-TYPE (the default of which is :BOTH) will be used. The value of VAR will usually be a string (unless it resulted from a file upload in which case it won't be converted at all), but if PARAMETER-TYPE (which is evaluated) is provided, the string will be converted to another Lisp type by the following rules: If the corresponding GET or POST parameter wasn't provided by the client, VAR's value will be NIL. If PARAMETER-TYPE is 'STRING, VAR's value remains as is. If PARAMETER-TYPE is 'INTEGER and the parameter string consists solely of decimal digits, VAR's value will be the corresponding integer, otherwise NIL. If PARAMETER-TYPE is 'KEYWORD, VAR's value will be the keyword obtained by interning the upcased parameter string into the keyword package. If PARAMETER-TYPE is 'CHARACTER and the parameter string is of length one, VAR's value will be the single character of this string, otherwise NIL. If PARAMETER-TYPE is 'BOOLEAN, VAR's value will always be T (unless it is NIL by the first rule above, of course). If PARAMETER-TYPE is any other atom, it is supposed to be a function designator for a unary function which will be called to convert the string to something else. Those were the rules for simple' types, but PARAMETER-TYPE can also be a list starting with one of the symbols LIST, ARRAY, or HASH-TABLE. The second value of the list must always be a simple parameter type as in the last paragraph - we'll call it the inner type' below. In the case of 'LIST, all GET/POST parameters called REAL-NAME will be collected, converted to the inner type, and assembled into a list which will be the value of VAR. In the case of 'ARRAY, all GET/POST parameters which have a name like the result of (format nil \"~A[~A]\" real-name n) where N is a non-negative integer, will be assembled into an array where the Nth element will be set accordingly, after conversion to the inner type. The array, which will become the value of VAR, will be big enough to hold all matching parameters, but not bigger. Array elements not set as described above will be NIL. Note that VAR will always be bound to an array, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. The full form of a 'HASH-TABLE parameter type is (hash-table inner-type key-type test-function), but KEY-TYPE and TEST-FUNCTION can be left out in which case they default to 'STRING and 'EQUAL, respectively. For this parameter type, all GET/POST parameters which have a name like the result of (format nil \"~A{~A}\" real-name key) (where KEY is a string that doesn't contain curly brackets) will become the values (after conversion to INNER-TYPE) of a hash table with test function TEST-FUNCTION where KEY (after conversion to KEY-TYPE) will be the corresponding key. Note that VAR will always be bound to a hash table, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. To make matters even more complicated, the three compound parameter types also have an abbreviated form - just one of the symbols LIST, ARRAY, or HASH-TABLE. In this case, the inner type will default to 'STRING. If PARAMETER-TYPE is not provided or NIL, DEFAULT-PARAMETER-TYPE (the default of which is 'STRING) will be used instead. If the result of the computations above would be that VAR would be bound to NIL, then INIT-FORM (if provided) will be evaluated instead, and VAR will be bound to the result of this evaluation. Handlers built with this macro are constructed in such a way that the resulting Lisp function is useful even outside of Hunchentoot. Specifically, all the parameter computations above will only happen if *REQUEST* is bound, i.e. if we're within a Hunchentoot request. Otherwise, VAR will always be bound to the result of evaluating INIT-FORM unless a corresponding keyword argument is provided. 4. SSL-ACCEPTOR Class Create and START an instance of this class (instead of ACCEPTOR) if you want an https server. There are two required initargs, :SSL-CERTIFICATE-FILE and :SSL-PRIVATEKEY-FILE, for pathname designators denoting the certificate file and the key file in PEM format. On LispWorks, you can have both in one file in which case the second initarg is optional. You can also use the :SSL-PRIVATEKEY-PASSWORD initarg to provide a password (as a string) for the key file (or NIL, the default, for no password). The default port for SSL-ACCEPTOR instances is 443 instead of 80 Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR DIRECT SLOTS Also see slots for the superclass. ssl-certificate-file Initargs: :ssl-certificate-file Readers: hunchentoot:acceptor-ssl-certificate-file A pathname designator for a certificate file in PEM format. ssl-privatekey-file Initargs: :ssl-privatekey-file Readers: hunchentoot:acceptor-ssl-privatekey-file A pathname designator for a private key file in PEM format, or (only on LispWorks) NIL if the certificate file contains the private key. ssl-privatekey-password Initargs: :ssl-privatekey-password Readers: hunchentoot:acceptor-ssl-privatekey-password The password for the private key file or NIL for no password. 5. EASY-SSL-ACCEPTOR Class This is an acceptor that mixes the \"easy\" Hunchentoot with SSL connections. Direct superclasses: EASY-ACCEPTOR , SSL-ACCEPTOR No subclasses. 6. REPLY Class Objects of this class hold all the information about an outgoing reply. They are created automatically by Hunchentoot and can be accessed and modified by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REPLY in order to implement your own behaviour. See the REPLY-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses. RELEVANT METHODS headers-out* Function: (headers-out* &optional (reply *reply*)) Returns an alist of the outgoing headers associated with the REPLY object REPLY. content-length* Function: (content-length* &optional (reply *reply*)) The outgoing 'Content-Length' http header of REPLY. content-type* Function: (content-type* &optional (reply *reply*)) The outgoing 'Content-Type' http header of REPLY. cookie-out Function: (cookie-out name &optional (reply *reply*)) Returns the current value of the outgoing cookie named NAME. Search is case-sensitive. cookies-out* Function: (cookies-out* &optional (reply *reply*)) Returns an alist of the outgoing cookies associated with the REPLY object REPLY. return-code* Function: (return-code* &optional (reply *reply*)) The http return code of REPLY. The return codes Hunchentoot can handle are defined in specials.lisp. send-headers Function: (send-headers) Sends the initial status line and all headers as determined by the REPLY object *REPLY*. Returns a binary stream to which the body of the reply can be written. Once this function has been called, further changes to *REPLY* don't have any effect. Also, automatic handling of errors (i.e. sending the corresponding status code to the browser, etc.) is turned off for this request. If your handlers return the full body as a string or as an array of octets you should NOT call this function. This function does not return control to the caller during HEAD request processing. reply-external-format* Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output. SLOTS content-type Readers: hunchentoot:content-type The outgoing 'Content-Type' http header which defaults to the value of *DEFAULT-CONTENT-TYPE*. content-length Readers: hunchentoot:content-length The outgoing 'Content-Length' http header which defaults NIL. If this is NIL, Hunchentoot will compute the content length. headers-out Readers: hunchentoot:headers-out An alist of the outgoing http headers not including the 'Set-Cookie', 'Content-Length', and 'Content-Type' headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot. return-code Initform: hunchentoot:+http-ok+ Readers: hunchentoot:return-code Writers: (setf hunchentoot:return-code) The http return code of this reply. The return codes Hunchentoot can handle are defined in specials.lisp. external-format Initform: hunchentoot:*hunchentoot-default-external-format* Readers: hunchentoot:reply-external-format Writers: (setf hunchentoot:reply-external-format) The external format of the reply - used for character output. cookies-out Readers: hunchentoot:cookies-out Writers: (setf hunchentoot:cookies-out) The outgoing cookies. This slot's value should only be modified by the functions defined in cookies.lisp. 7. REQUEST Class Objects of this class hold all the information about an incoming request. They are created automatically by acceptors and can be accessed by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REQUEST in order to implement your own behaviour. See the REQUEST-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses. RELEVANT METHODS real-remote-addr Function: (real-remote-addr &optional (request *request*)) Returns the 'X-Forwarded-For' incoming http header as the second value in the form of a list of IP addresses and the first element of this list as the first value if this header exists. Otherwise returns the value of REMOTE-ADDR as the only value. parameter Function: (parameter name &optional (request *request*)) Returns the GET or the POST parameter with name NAME (a string) - or NIL if there is none. If both a GET and a POST parameter with the same name exist the GET parameter is returned. Search is case-sensitive. get-parameter Function: (get-parameter name &optional (request *request*)) Returns the GET parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive. get-parameters* Function: (get-parameters* &optional (request *request*)) Returns an alist of the GET parameters associated with the REQUEST object REQUEST. post-parameter Function: (post-parameter name &optional (request *request*)) Returns the POST parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive. post-parameters* Function: (post-parameters* &optional (request *request*)) Returns an alist of the POST parameters associated with the REQUEST object REQUEST. cookie-in Function: (cookie-in name &optional (request *request*)) Returns the cookie with the name NAME (a string) as sent by the browser - or NIL if there is none. cookies-in* Function: (cookies-in* &optional (request *request*)) Returns an alist of all cookies associated with the REQUEST object REQUEST. host Function: (host &optional (request *request*)) Returns the 'Host' incoming http header value. query-string* Function: (query-string* &optional (request *request*)) Returns the query string of the REQUEST object REQUEST. That's the part behind the question mark (i.e. the GET parameters). referer Function: (referer &optional (request *request*)) Returns the 'Referer' (sic!) http header. request-method* Function: (request-method* &optional (request *request*)) Returns the request method as a Lisp keyword. request-uri* Function: (request-uri* &optional (request *request*)) Returns the request URI. server-protocol* Function: (server-protocol* &optional (request *request*)) Returns the request protocol as a Lisp keyword. user-agent Function: (user-agent &optional (request *request*)) Returns the 'User-Agent' http header. header-in* Function: (header-in* name &optional (request *request*)) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string. headers-in* Function: (headers-in* &optional (request *request*)) Returns an alist of the incoming headers associated with the REQUEST object REQUEST. remote-addr* Function: (remote-addr* &optional (request *request*)) Returns the address the current request originated from. remote-port* Function: (remote-port* &optional (request *request*)) Returns the port the current request originated from. local-addr* Function: (local-addr* &optional (request *request*)) Returns the address the current request connected to. local-port* Function: (local-port* &optional (request *request*)) Returns the port the current request connected to. script-name* Function: (script-name* &optional (request *request*)) Returns the file name of the REQUEST object REQUEST. That's the requested URI without the query string (i.e the GET parameters). aux-request-value Function: (aux-request-value symbol &optional (request *request*)) Returns the value associated with SYMBOL from the request object REQUEST (the default is the current request) if it exists. The second return value is true if such a value was found. Sets the value associated with SYMBOL from the request object REQUEST (default is *REQUEST*). If there is already a value associated with SYMBOL it will be replaced. delete-aux-request-value Function: (delete-aux-request-value symbol &optional (request *request*)) Removes the value associated with SYMBOL from the request object REQUEST. authorization Function: (authorization &optional (request *request*)) Returns as two values the user and password (if any) as encoded in the 'AUTHORIZATION' header. Returns NIL if there is no such header. raw-post-data Function: (raw-post-data &key (request *request*) external-format force-text force-binary want-stream) Returns the content sent by the client if there was any (unless the content type was \"multipart/form-data\"). By default, the result is a string if the type of the Content-Type' media type is \"text\", and a vector of octets otherwise. In the case of a string, the external format to be used to decode the content will be determined from the charset' parameter sent by the client (or otherwise *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used). You can also provide an external format explicitly (through EXTERNAL-FORMAT) in which case the result will unconditionally be a string. Likewise, you can provide a true value for FORCE-TEXT which will force Hunchentoot to act as if the type of the media type had been \"text\". Or you can provide a true value for FORCE-BINARY which means that you want a vector of octets at any rate. If, however, you provide a true value for WANT-STREAM, the other parameters are ignored and you'll get the content (flexi) stream to read from it yourself. It is then your responsibility to read the correct amount of data, because otherwise you won't be able to return a response to the client. If the content type of the request was multipart/form-data' or application/x-www-form-urlencoded', the content has been read by Hunchentoot already and you can't read from the stream anymore. You can call RAW-POST-DATA more than once per request, but you can't mix calls which have different values for WANT-STREAM. Note that this function is slightly misnamed because a client can send content even if the request method is not POST. recompute-request-parameters Function: (recompute-request-parameters &key (request *request*) (external-format *hunchentoot-default-external-format*)) Recomputes the GET and POST parameters for the REQUEST object REQUEST. This only makes sense if you're switching external formats during the request. process-request Function: (process-request request) This function is called by PROCESS-CONNECTION after the incoming headers have been read. It calls HANDLE-REQUEST to select and call a handler and sends the output of this handler to the client using START-OUTPUT. Note that PROCESS-CONNECTION is called once per connection and loops in case of a persistent connection while PROCESS-REQUEST is called anew for each request. Essentially, you can view process-request as a thin wrapper around HANDLE-REQUEST. The return value of this function is ignored. handle-request Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers. handle-request Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers. acceptor-dispatch-request Function: (acceptor-dispatch-request acceptor request) This function is called to actually dispatch the request once the standard logging and error handling has been set up. ACCEPTOR subclasses implement methods for this function in order to perform their own request routing. If a method does not want to handle the request, it is supposed to invoke CALL-NEXT-METHOD so that the next ACCEPTOR in the inheritance chain gets a chance to handle the request. SLOTS acceptor Initargs: :acceptor Readers: hunchentoot:request-acceptor The acceptor which created this request object. headers-in Initargs: :headers-in Readers: hunchentoot:headers-in An alist of the incoming headers. method Initargs: :method Readers: hunchentoot:request-method The request method as a keyword. uri Initargs: :uri Readers: hunchentoot:request-uri The request URI as a string. server-protocol Initargs: :server-protocol Readers: hunchentoot:server-protocol The HTTP protocol as a keyword. local-addr Initargs: :local-addr Readers: hunchentoot:local-addr The IP address of the local system that the client connected to. local-port Initargs: :local-port Readers: hunchentoot:local-port The TCP port number of the local system that the client connected to. remote-addr Initargs: :remote-addr Readers: hunchentoot:remote-addr The IP address of the client that initiated this request. remote-port Initargs: :remote-port Readers: hunchentoot:remote-port The TCP port number of the client socket from which this request originated. content-stream Initargs: :content-stream A stream from which the request body can be read if there is one. cookies-in Readers: hunchentoot:cookies-in An alist of the cookies sent by the client. get-parameters Readers: hunchentoot:get-parameters An alist of the GET parameters sent by the client. post-parameters Readers: hunchentoot:post-parameters An alist of the POST parameters sent by the client. script-name Readers: hunchentoot:script-name The URI requested by the client without the query string. query-string Readers: hunchentoot:query-string The query string of this request. session Readers: hunchentoot:session Writers: (setf hunchentoot:session) The session object associated with this request. aux-data Used to keep a user-modifiable alist with arbitrary data during the request. raw-post-data The raw string sent as the body of a POST request, populated only if not a multipart/form-data request. 8. SESSION Class SESSION objects are automatically maintained by Hunchentoot. They should not be created explicitly with MAKE-INSTANCE but implicitly with START-SESSION and they should be treated as opaque objects. You can ignore Hunchentoot's SESSION objects altogether and implement your own sessions if you provide corresponding methods for SESSION-COOKIE-VALUE and SESSION-VERIFY. Direct superclasses: STANDARD-OBJECT No subclasses. Hunchentoot supports sessions : Once a request handler has called START-SESSION , Hunchentoot uses either cookies or (if the client doesn't send the cookies back) rewrites URLs to keep track of this client, i.e. to provide a kind of 'state' for the stateless http protocol. Hunchentoot makes some reasonable effort to prevent eavesdroppers from hijacking sessions (see below), but this should not be considered really secure. Don't store sensitive data in sessions and rely solely on the session mechanism as a safeguard against malicious users who want to get at this data! For each request there's one SESSION object which is accessible to the handler via the special variable *SESSION* . This object holds all the information available about the session and can be accessed with the functions described in this chapter. Note that the internal structure of SESSION objects should be considered opaque and may change in future releases of Hunchentoot. Sessions are automatically verified for validity and age when the REQUEST object is instantiated, i.e. if *SESSION* is not NIL then this session is valid (as far as Hunchentoot is concerned) and not too old . Old sessions are automatically removed . Hunchentoot also provides a SESSION-REGENERATE-COOKIE-VALUE function that creates a new cookie value. This helps to prevent against session fixation attacks , and should be used when a user logs in according to the application. RELEVANT METHODS start-session Function: (start-session) Returns the current SESSION object. If there is no current session, creates one and updates the corresponding data structures. In this case the function will also send a session cookie to the browser. session-value Function: (session-value symbol &optional (session *session*)) Returns the value associated with SYMBOL from the session object SESSION (the default is the current session) if it exists. Sets the value associated with SYMBOL from the session object SESSION. If there is already a value associated with SYMBOL it will be replaced. Will automatically start a session if none was supplied and there's no session for the current request. delete-session-value Function: (delete-session-value symbol &optional (session *session*)) Removes the value associated with SYMBOL from SESSION if there is one. remove-session Function: (remove-session session) Completely removes the SESSION object SESSION from Hunchentoot's internal session database. SLOTS session-id Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session. session-string The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter. user-agent Initform: (hunchentoot:user-agent hunchentoot:*request*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created. remote-addr Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR. session-start Initform: (GET-UNIVERSAL-TIME) Readers: hunchentoot:session-start The time this session was started. last-click The last time this session was used. session-data Initargs: :session-data Data associated with this session - see SESSION-VALUE. max-time Type: fixnum Initargs: :max-time Initform: hunchentoot:*session-max-time* Readers: hunchentoot:session-max-time Writers: (setf hunchentoot:session-max-time) The time (in seconds) after which this session expires if it's not used. session-id Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session. session-string The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter. user-agent Initform: (HUNCHENTOOT:USER-AGENT HUNCHENTOOT:*REQUEST*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created. remote-addr Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR. session-start Initform: (get-universal-time) Readers: hunchentoot:session-start The time this session was started. 9. MISCELLANEOUS FUNCTIONS bad-request Class Direct superclasses: HUNCHENTOOT-ERROR No subclasses. client-as-string Function: (client-as-string socket) A helper function which returns the client's address and port as a string and tries to act robustly in the presence of network problems. create-folder-dispatcher-and-handler Function: (create-folder-dispatcher-and-handler uri-prefix base-path &optional content-type) Creates and returns a dispatch function which will dispatch to a handler function which emits the file relative to BASE-PATH that is denoted by the URI of the request relative to URI-PREFIX. URI-PREFIX must be a string ending with a slash, BASE-PATH must be a pathname designator for an existing directory. If CONTENT-TYPE is not NIL, it'll be the content type used for all files in the folder. create-prefix-dispatcher Function: (create-prefix-dispatcher prefix handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request starts with the string PREFIX. create-regex-dispatcher Function: (create-regex-dispatcher regex handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request matches the CL-PPCRE regular expression REGEX. create-request-handler-thread Function: (create-request-handler-thread taskmaster socket) Create a new thread in which to process the request. This thread will call PROCESS-CONNECTION to process the request. create-static-file-dispatcher-and-handler Function: (create-static-file-dispatcher-and-handler uri path &optional content-type) Creates and returns a request dispatch function which will dispatch to a handler function which emits the file denoted by the pathname designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of the request matches the string URI. If CONTENT-TYPE is NIL, tries to determine the content type via the file's suffix. decrement-taskmaster-thread-count Function: (decrement-taskmaster-thread-count taskmaster) Atomically decrement the number of taskmaster requests default-document-directory Function: (default-document-directory &optional sub-directory) detach-socket Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function. dispatch-easy-handlers Function: (dispatch-easy-handlers request) This is a dispatcher which returns the appropriate handler defined with DEFINE-EASY-HANDLER, if there is one. escape-for-html Function: (escape-for-html string) Escapes the characters #\\<, #>, #\\', #\\\", and #\\& for HTML output. handle-if-modified-since Function: (handle-if-modified-since time &optional (request *request*)) Handles the 'If-Modified-Since' header of REQUEST. The date string is compared to the one generated from the supplied universal time TIME. handle-static-file Function: (handle-static-file pathname &optional content-type) A function which acts like a Hunchentoot handler for the file denoted by PATHNAME. Sends a content type header corresponding to CONTENT-TYPE or (if that is NIL) tries to determine the content type via the file's suffix. http-token-p Function: (http-token-p token) This function tests whether OBJECT is a non-empty string which is a TOKEN according to RFC 2068 (i.e. whether it may be used for, say, cookie names). hunchentoot-error Function: (hunchentoot-error format-control &rest format-arguments) Signals an error of type HUNCHENTOOT-SIMPLE-ERROR with the provided format control and arguments. Superclass for all errors related to Hunchentoot. increment-taskmaster-thread-count Function: (increment-taskmaster-thread-count taskmaster) Atomically increment the number of taskmaster requests. initialize-connection-stream Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use. log-message* Function: (log-message* log-level format-string &rest format-arguments) Convenience function which calls the message logger of the current acceptor (if there is one) with the same arguments it accepts. This is the function which Hunchentoot itself uses to log errors it catches during request processing. maybe-invoke-debugger Function: (maybe-invoke-debugger condition) This generic function is called whenever a condition CONDITION is signaled in Hunchentoot. You might want to specialize it on specific condition classes for debugging purposes. mime-type Function: (mime-type pathspec) Given a pathname designator PATHSPEC returns the MIME type (as a string) corresponding to the suffix of the file denoted by PATHSPEC (or NIL). next-session-id Function: (next-session-id acceptor) Returns the next sequential session ID, an integer, which should be unique per session. The default method uses a simple global counter and isn't guarded by a lock. For a high-performance production environment you might consider using a more robust implementation. no-cache Function: (no-cache) Adds appropriate headers to completely prevent caching on most browsers. parameter-error Function: (parameter-error format-control &rest format-arguments) Signals an error of type PARAMETER-ERROR with the provided format control and arguments. Signalled if a function was called with incosistent or illegal parameters. process-connection Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. reason-phrase Function: (reason-phrase return-code) Returns a reason phrase for the HTTP return code RETURN-CODE (which should be an integer) or NIL for return codes Hunchentoot doesn't know. redirect Function: (redirect target &key (host (host *request*) host-provided-p) port (protocol (if (ssl-p) :https :http)) (add-session-id (not (or host-provided-p (starts-with-scheme-p target) (cookie-in (session-cookie-name *acceptor*))))) (code +http-moved-temporarily+)) Redirects the browser to TARGET which should be a string. If TARGET is a full URL starting with a scheme, HOST, PORT and PROTOCOL are ignored. Otherwise, TARGET should denote the path part of a URL, PROTOCOL must be one of the keywords :HTTP or :HTTPS, and the URL to redirect to will be constructed from HOST, PORT, PROTOCOL, and TARGET. Adds a session ID if ADD-SESSION-ID is true. If CODE is a 3xx redirection code, it will be sent as status code. regenerate-session-cookie-value Function: (regenerate-session-cookie-value session) Regenerates the cookie value. This should be used when a user logs in according to the application to prevent against session fixation attacks. The cookie value being dependent on ID, USER-AGENT, REMOTE-ADDR, START, and *SESSION-SECRET*, the only value we can change is START to regenerate a new value. Since we're generating a new cookie, it makes sense to have the session being restarted, in time. That said, because of this fact, calling this function twice in the same second will regenerate twice the same value. reply-external-format* Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output. request-pathname Function: (request-pathname &optional (request *request*) drop-prefix) Construct a relative pathname from the request's SCRIPT-NAME. If DROP-PREFIX is given, pathname construction starts at the first path segment after the prefix. require-authorization Function: (require-authorization &optional (realm hunchentoot)) Sends back appropriate headers to require basic HTTP authentication (see RFC 2617) for the realm REALM. reset-connection-stream Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream. reset-session-secret Function: (reset-session-secret) Sets *SESSION-SECRET* to a new random value. All old sessions will cease to be valid. reset-sessions Function: (reset-sessions &optional (acceptor *acceptor*)) Removes ALL stored sessions of ACCEPTOR. rfc-1123-date Function: (rfc-1123-date &optional (time (get-universal-time))) Generates a time string according to RFC 1123. Default is current time. This can be used to send a 'Last-Modified' header - see HANDLE-IF-MODIFIED-SINCE. script-name Function: (script-name object) server-protocol Function: (server-protocol object) session-cookie-name Function: (session-cookie-name acceptor) Returns the name (a string) of the cookie (or the GET parameter) which is used to store a session on the client side. The default is to use the string \"hunchentoot-session\", but you can specialize this function if you want another name. session-cookie-value Function: (session-cookie-value session) Returns a string which can be used to safely restore the session SESSION if as session has already been established. This is used as the value stored in the session cookie or in the corresponding GET parameter and verified by SESSION-VERIFY. A default method is provided and there's no reason to change it unless you want to use your own session objects. session-created Function: (session-created acceptor new-session) This function is called whenever a new session has been created. There's a default method which might trigger a session GC based on the value of *SESSION-GC-FREQUENCY*. The return value is ignored. session-db Function: (session-db acceptor) Returns the current session database which is an alist where each car is a session's ID and the cdr is the corresponding SESSION object itself. The default is to use a global list for all acceptors. session-db-lock Function: (session-db-lock acceptor &key whole-db-p) A function which returns a lock that will be used to prevent concurrent access to sessions. The first argument will be the acceptor that handles the current request, the second argument is true if the whole (current) session database is modified. If it is NIL, only one existing session in the database is modified. This function can return NIL which means that sessions or session databases will be modified without a lock held (for example for single-threaded environments). The default is to always return a global lock (ignoring the ACCEPTOR argument) for Lisps that support threads and NIL otherwise. session-gc Function: (session-gc) Removes sessions from the current session database which are too old - see SESSION-TOO-OLD-P. session-too-old-p Function: (session-too-old-p session) Returns true if the SESSION object SESSION has not been active in the last (SESSION-MAX-TIME SESSION) seconds. session-verify Function: (session-verify request) Tries to get a session identifier from the cookies (or alternatively from the GET parameters) sent by the client (see SESSION-COOKIE-NAME and SESSION-COOKIE-VALUE). This identifier is then checked for validity against the REQUEST object REQUEST. On success the corresponding session object (if not too old) is returned (and updated). Otherwise NIL is returned. A default method is provided and you only need to write your own one if you want to maintain your own sessions. set-cookie Function: (set-cookie name &key (value \"\") expires max-age path domain secure http-only (reply *reply*)) Creates a cookie object from the parameters provided and adds it to the outgoing cookies of the REPLY object REPLY. If a cookie with the name NAME (case-sensitive) already exists, it is replaced. set-cookie* Function: (set-cookie* cookie &optional (reply *reply*)) Adds the COOKIE object COOKIE to the outgoing cookies of the REPLY object REPLY. If a cookie with the same name (case-sensitive) already exists, it is replaced. ssl-p Function: (ssl-p &optional (acceptor *acceptor*)) Whether the current connection to the client is secure. See ACCEPTOR-SSL-P. taskmaster-max-accept-count Function: (taskmaster-max-accept-count taskmaster) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT. taskmaster-max-thread-count Function: (taskmaster-max-thread-count taskmaster) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit. taskmaster-thread-count Function: (taskmaster-thread-count taskmaster) Returns the current number of taskmaster requests. too-many-taskmaster-requests Function: (too-many-taskmaster-requests taskmaster socket) Signal a \"too many requests\" error, just prior to closing the connection. url-decode Function: (url-decode string &optional (external-format *hunchentoot-default-external-format*)) Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. url-encode Function: (url-encode string &optional (external-format *hunchentoot-default-external-format*)) URL-encodes a string using the external format EXTERNAL-FORMAT. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. within-request-p Function: (within-request-p) True if we're in the context of a request, otherwise nil. 10. CONFIGURATION VARIABLES *catch-errors-p* Variable Whether Hunchentoot should catch and log errors (or rather invoke the debugger). *content-types-for-url-rewrite* Variable The content types for which url-rewriting is OK. See *REWRITE-FOR-SESSION-URLS* . *default-connection-timeout* Variable The default connection timeout used when an acceptor is reading from and writing to a socket stream. *default-content-type* Variable The default content-type header which is returned to the client. If this is text content type, the character set used for encoding the response will automatically be added to the content type in a ``charset'' attribute. *dispatch-table* Variable A global list of dispatch functions. *file-upload-hook* Variable If this is not NIL, it should be a unary function which will be called with a pathname for each file which is uploaded to Hunchentoot. The pathname denotes the temporary file to which the uploaded file is written. The hook is called directly before the file is created. *handle-http-errors-p* *header-stream* Variable If this variable is not NIL, it should be bound to a stream to which incoming and outgoing headers will be written for debugging purposes. *http-error-handler* *hunchentoot-default-external-format* Variable The external format used to compute the REQUEST object. *hunchentoot-version* *lisp-errors-log-level* Variable Log level for Lisp errors. Should be one of :ERROR (the default), :WARNING, or :INFO. *lisp-warnings-log-level* Variable Log level for Lisp warnings. Should be one of :ERROR, :WARNING (the default), or :INFO. *log-lisp-backtraces-p* Variable Whether Lisp backtraces should be logged. Only has an effect if [*LOG-LISP-ERRORS-P*](#log-lisp-errors-p] is true as well. *log-lisp-errors-p* Variable Whether Lisp errors in request handlers should be logged. *log-lisp-warnings-p* Variable Whether Lisp warnings in request handlers should be logged. *methods-for-post-parameters* Variable A list of the request method types (as keywords) for which Hunchentoot will try to compute POST-PARAMETERS . *rewrite-for-session-urls* Variable Whether HTML pages should possibly be rewritten for cookie-less session-management. *session-gc-frequency* Variable A session GC (see function SESSION-GC) will happen every *SESSION-GC-FREQUENCY* requests (counting only requests which create a new session) if this variable is not NIL. See SESSION-CREATED . *session-max-time* Variable The default time (in seconds) after which a session times out. *session-secret* Variable A random ASCII string that's used to encode the public session data. This variable is initially unbound and will be set (using RESET-SESSION-SECRET ) the first time a session is created, if necessary. You can prevent this from happening if you set the value yourself before starting acceptors. *show-lisp-backtraces-p* Variable Whether Lisp errors shown in HTML output should contain backtrace information. *show-lisp-errors-p* Variable Whether Lisp errors in request handlers should be shown in HTML output. *tmp-directory* Variable Directory for temporary files created by MAKE-TMP-FILE-NAME. *use-remote-addr-for-sessions* Variable Whether the client's remote IP (as returned by REAL-REMOTE-ADDR ) should be encoded into the session string. If this value is true, a session will cease to be accessible if the client's remote IP changes. This might for example be an issue if the client uses a proxy server which doesn't send correct 'X_FORWARDED_FOR' headers. *use-user-agent-for-sessions* Variable Whether the 'User-Agent' header should be encoded into the session string. If this value is true, a session will cease to be accessible if the client sends a different 'User-Agent' header. 11. VARIABLES IN THE CONTEXT OF A REQUEST *acceptor* Variable The current ACCEPTOR object. *reply* Variable The current REPLY object. *request* Variable The current REQUEST object. *session* Variable The current SESSION (can be NIL). 12. CONSTANTS +http-accepted+ Constant: 202 HTTP return code (202) for 'Accepted'. +http-authorization-required+ Constant: 401 HTTP return code (401) for 'Authorization Required'. +http-bad-gateway+ Constant: 502 HTTP return code (502) for 'Bad Gateway'. +http-bad-request+ Constant: 400 HTTP return code (400) for 'Bad Request'. +http-conflict+ Constant: 409 HTTP return code (409) for 'Conflict'. +http-continue+ Constant: 100 HTTP return code (100) for 'Continue'. +http-created+ Constant: 201 HTTP return code (201) for 'Created'. +http-expectation-failed+ Constant: 417 HTTP return code (417) for 'Expectation Failed'. +http-failed-dependency+ Constant: 424 HTTP return code (424) for 'Failed Dependency'. +http-forbidden+ Constant: 403 HTTP return code (403) for 'Forbidden'. +http-gateway-time-out+ Constant: 504 HTTP return code (504) for 'Gateway Time-out'. +http-gone+ Constant: 410 HTTP return code (410) for 'Gone'. +http-internal-server-error+ Constant: 500 HTTP return code (500) for 'Internal Server Error'. +http-length-required+ Constant: 411 HTTP return code (411) for 'Length Required'. +http-method-not-allowed+ Constant: 405 HTTP return code (405) for 'Method Not Allowed'. +http-moved-permanently+ Constant: 301 HTTP return code (301) for 'Moved Permanently'. +http-moved-temporarily+ Constant: 302 HTTP return code (302) for 'Moved Temporarily'. +http-multi-status+ Constant: 207 HTTP return code (207) for 'Multi-Status'. +http-multiple-choices+ Constant: 300 HTTP return code (300) for 'Multiple Choices'. +http-network-authentication-required+ Constant: 511 HTTP return code (511) for 'Network Authentication Required'. +http-no-content+ Constant: 204 HTTP return code (204) for 'No Content'. +http-non-authoritative-information+ Constant: 203 HTTP return code (203) for 'Non-Authoritative Information'. +http-not-acceptable+ Constant: 406 HTTP return code (406) for 'Not Acceptable'. +http-not-found+ Constant: 404 HTTP return code (404) for 'Not Found'. +http-not-implemented+ Constant: 501 HTTP return code (501) for 'Not Implemented'. +http-not-modified+ Constant: 304 HTTP return code (304) for 'Not Modified'. +http-ok+ Constant: 200 HTTP return code (200) for 'OK'. +http-partial-content+ Constant: 206 HTTP return code (206) for 'Partial Content'. +http-payment-required+ Constant: 402 HTTP return code (402) for 'Payment Required'. +http-precondition-failed+ Constant: 412 HTTP return code (412) for 'Precondition Failed'. +http-precondition-required+ Constant: 428 HTTP return code (428) for 'Precondition Required'. +http-proxy-authentication-required+ Constant: 407 HTTP return code (407) for 'Proxy Authentication Required'. +http-request-entity-too-large+ Constant: 413 HTTP return code (413) for 'Request Entity Too Large'. +http-request-header-fields-too-large+ Constant: 431 HTTP return code (431) for 'Request Header Fields Too Large'. +http-request-time-out+ Constant: 408 HTTP return code (408) for 'Request Time-out'. +http-request-uri-too-large+ Constant: 414 HTTP return code (414) for 'Request-URI Too Large'. +http-requested-range-not-satisfiable+ Constant: 416 HTTP return code (416) for 'Requested range not satisfiable'. +http-reset-content+ Constant: 205 HTTP return code (205) for 'Reset Content'. +http-see-other+ Constant: 303 HTTP return code (303) for 'See Other'. +http-service-unavailable+ Constant: 503 HTTP return code (503) for 'Service Unavailable'. +http-switching-protocols+ Constant: 101 HTTP return code (101) for 'Switching Protocols'. +http-temporary-redirect+ Constant: 307 HTTP return code (307) for 'Temporary Redirect'. +http-too-many-requests+ Constant: 429 HTTP return code (429) for 'Too Many Requests'. +http-unsupported-media-type+ Constant: 415 HTTP return code (415) for 'Unsupported Media Type'. +http-use-proxy+ Constant: 305 HTTP return code (305) for 'Use Proxy'. +http-version-not-supported+ Constant: 505 HTTP return code (505) for 'Version not supported'. 13. HUNCHENTOOT-CONDITION Class Superclass for all conditions related to Hunchentoot. 14. HUNCHENTOOT-WARNING Class Superclass for all warnings related to Hunchentoot. 15. TASKMASTER taskmaster Class An instance of this class is responsible for distributing the work of handling requests for its acceptor. This is an \"abstract\" class in the sense that usually only instances of subclasses of TASKMASTER will be used. Direct superclasses: STANDARD-OBJECT Direct subclasses: MULTI-THREADED-TASKMASTER , SINGLE-THREADED-TASKMASTER RELEVANT METHODS shutdown Function: (shutdown taskmaster) Shuts down the taskmaster, i.e. frees all resources that were set up by it. For example, a multi-threaded taskmaster might terminate all threads that are currently associated with it. This function is called by the acceptor's STOP method. execute-acceptor Function: (execute-acceptor taskmaster) This is a callback called by the acceptor once it has performed all initial processing to start listening for incoming connections (see START-LISTENING). It usually calls the ACCEPT-CONNECTIONS method of the acceptor, but depending on the taskmaster instance the method might be called from a new thread. handle-incoming-connection Function: (handle-incoming-connection taskmaster socket) This function is called by the acceptor to start processing of requests on a new incoming connection. SOCKET is the usocket instance that represents the new connection (or a socket handle on LispWorks). The taskmaster starts processing requests on the incoming connection by calling the PROCESS-CONNECTION method of the acceptor instance. The SOCKET argument is passed to PROCESS-CONNECTION as an argument. start-thread Function: (start-thread taskmaster thunk &key name) Start a name thread in which to call the THUNK, in the context of the given TASKMASTER. Keyword arguments provide TASKMASTER-dependent options. Return a thread object. Hunchentoot taskmaster methods will call it with the taskmaster as the context, allowing hunchentoot extensions to define specialized methods that may e.g. wrap the thunk within a proper set of bindings and condition handlers. DIRECT SLOTS acceptor Readers: taskmaster-acceptor Writers: (setf taskmaster-acceptor) A backpointer to the acceptor instance this taskmaster works for. multi-threaded-taskmaster Class An abstract class for taskmasters that use multiple threads. For a concrete class to instantiate, use one-thread-per-connection-taskmaster. Direct superclasses: TASKMASTER Direct subclasses: ONE-THREAD-PER-CONNECTION-TASKMASTER DIRECT SLOTS acceptor-process A process that accepts incoming connections and hands them off to new processes for request handling. one-thread-per-connection-taskmaster Class A taskmaster that starts one thread for listening to incoming requests and one new thread for each incoming connection. If MAX-THREAD-COUNT is null, a new thread will always be created for each request. If MAX-THREAD-COUNT is supplied, the number of request threads is limited to that. Furthermore, if MAX-ACCEPT-COUNT is not supplied, an HTTP 503 will be sent if the thread limit is exceeded. Otherwise, if MAX-ACCEPT-COUNT is supplied, it must be greater than MAX-THREAD-COUNT; in this case, requests are accepted up to MAX-ACCEPT-COUNT, and only then is HTTP 503 sent. It is important to note that MAX-ACCEPT-COUNT and the HTTP 503 behavior described above is racing with the acceptor listen backlog. If we are receiving requests faster than threads can be spawned and 503 sent, the requests will be silently rejected by the kernel. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide MAX-THREAD-COUNT but leave MAX-ACCEPT-COUNT null. This will immediately result in HTTP 503 when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both MAX-THREAD-COUNT and a somewhat larger value for MAX-ACCEPT-COUNT. This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be HTTP 503. This is the default taskmaster implementation for multi-threaded Lisp implementations. Direct superclasses: MULTI-THREADED-TASKMASTER No subclasses. DIRECT SLOTS max-thread-count Type: (OR INTEGER NULL) Initargs: :max-thread-count Readers: taskmaster-max-thread-count Writers: (setf taskmaster-max-thread-count) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit. thread-count Type: INTEGER Initform: 0 Readers: taskmaster-thread-count Writers: (setf taskmaster-thread-count) The number of taskmaster processing threads currently running. thread-count-lock In the absence of 'atomic-incf', we need this to atomically increment and decrement the request count. max-accept-count Type: (OR INTEGER NULL) Initargs: :max-accept-count Readers: taskmaster-max-accept-count Writers: (setf taskmaster-max-accept-count) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT. accept-count Type: INTEGER Initform: 0 The number of connection currently accepted by the taskmaster. These connections are not ensured to be processed, thay may be waiting for an empty processing slot or rejected because the load is too heavy. accept-count-lock In the absence of 'atomic-incf', we need this to atomically increment and decrement the accept count. wait-queue A queue that we use to wait for a free connection. wait-lock The lock for the connection wait queue. worker-thread-name-format Type: (OR STRING NULL) Initargs: :worker-thread-name-format Initform: \"hunchentoot-worker-~A\" single-threaded-taskmaster Class A taskmaster that runs synchronously in the thread where the START function was invoked (or in the case of LispWorks in the thread started by COMM:START-UP-SERVER). This is the simplest possible taskmaster implementation in that its methods do nothing but calling their acceptor \"sister\" methods - EXECUTE-ACCEPTOR calls ACCEPT-CONNECTIONS, HANDLE-INCOMING-CONNECTION calls PROCESS-CONNECTION. Direct superclasses: TASKMASTER ADVANCED TOPICS CUSTOMIZING SESSION BEHAVIOUR For everyday session usage, you will probably just use START-SESSION , SESSION-VALUE , and maybe DELETE-SESSION-VALUE and *SESSION* . However, there are two ways to customize the way Hunchentoot maintains sessions. One way is to mostly leave the session mechanism intact but to tweak it a bit: The publicly visible part of a session is encoded using a secret which you can set yourself. And it is stored using a cookie (or GET parameter) name that you can override. Each session receives a new ID when it is created and you can implement a more robust way to do that. You can arrange to be called whenever a session is created to trigger some action. You might also do this to invent your own session garbage collection . By default, all sessions are stored in a global alist in memory. You can't change the alist part, but you can distribute your sessions over different \"databases\" . By default, every operation which modifies sessions or one of the session databases is guarded by a global lock, but you can arrange to provide different locks for this. The other way to customize Hunchentoot's sessions is to completely replace them. This is actually pretty easy: Create your own class to store state (which doesn't have to and probably shouldn't inherit from SESSION ) and implement methods for SESSION-VERIFY and SESSION-COOKIE-VALUE - that's it. Hunchentoot will continue to use cookies and/or to rewrite URLs to keep track of session state and it will store \"the current session\" (whatever that is in your implementation) in *SESSION* . Everything else (like persisting sessions, GC, getting and setting values) you'll have to take care of yourself and the other session functions (like START-SESSION or SESSION-VALUE ) won't work anymore. (Almost) total freedom, but a lot of responsibility as well... :) reset-session-secret session-cookie-name session-cookie-value session-created next-session-id session-db session-db-lock session-verify CUSTOMIZING ACCEPTOR BEHAVIOUR If you want to modify what acceptors do, you should subclass ACCEPTOR (or SSL-ACCEPTOR ) and specialize the generic functions that constitute their behaviour (see example below). The life of an acceptor looks like this: It is started with the function START which immediately calls START-LISTENING and then applies the function EXECUTE-ACCEPTOR to its taskmaster . This function will eventually call ACCEPT-CONNECTIONS which is responsible for setting things up to wait for clients to connect. For each incoming connection which comes in, HANDLE-INCOMING-CONNECTION is applied to the taskmaster which will either call PROCESS-CONNECTION directly, or will create a thread to call it. PROCESS-CONNECTION calls INITIALIZE-CONNECTION-STREAM before it does anything else, then it selects and calls a function which handles the request , and finally it sends the reply to the client before it calls RESET-CONNECTION-STREAM . If the connection is persistent, this procedure is repeated (except for the intialization step) in a loop until the connection is closed. The acceptor is stopped with STOP . If you just want to use the standard acceptors that come with Hunchentoot, you don't need to know anything about the functions listed in this section. start-listening accept-connections acceptor-log-access acceptor-log-message acceptor-status-message detach-socket initialize-connection-stream process-connection reset-connection-stream An example of how to subclass ACCEPTOR This example shows how to subclass ACCEPTOR in order to provide Hunchentoot with basic virtual host support. It assumes Hunchentoot is sitting behind an Internet-facing reverse-proxy web server that maps the host (or domain) part of incoming HTTP requests to unique localhost ports. (ql:quickload '(\"hunchentoot\" \"drakma\")) ;;; Subclass ACCEPTOR (defclass vhost (hunchentoot:acceptor) ;; slots ((dispatch-table :initform '() :accessor dispatch-table :documentation \"List of dispatch functions\")) ;; options (:default-initargs ; default-initargs must be used :address \"127.0.0.1\")) ; because ACCEPTOR uses it ;;; Specialise ACCEPTOR-DISPATCH-REQUEST for VHOSTs (defmethod hunchentoot:acceptor-dispatch-request ((vhost vhost) request) ;; try REQUEST on each dispatcher in turn (mapc (lambda (dispatcher) (let ((handler (funcall dispatcher request))) (when handler ; Handler found. FUNCALL it and return result (return-from hunchentoot:acceptor-dispatch-request (funcall handler))))) (dispatch-table vhost)) (call-next-method)) ;;; ====================================================================== ;;; Now all we need to do is test it ;;; Instantiate VHOSTs (defvar vhost1 (make-instance 'vhost :port 50001)) (defvar vhost2 (make-instance 'vhost :port 50002)) ;;; Populate each dispatch table (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo1) (dispatch-table vhost1)) (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo2) (dispatch-table vhost2)) ;;; Define handlers (defun foo1 () \"Hello\") (defun foo2 () \"Goodbye\") ;;; Start VHOSTs (hunchentoot:start vhost1) (hunchentoot:start vhost2) ;;; Make some requests (drakma:http-request \"http://127.0.0.1:50001/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:39] \"GET /foo HTTP/1.1\" 200 5 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Hello\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"5\") (:DATE . \"Fri, 08 Jun 2012 14:30:39 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50001/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CA90059}> ;;; T ;;; \"OK\" (drakma:http-request \"http://127.0.0.1:50002/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:47] \"GET /foo HTTP/1.1\" 200 7 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Goodbye\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"7\") (:DATE . \"Fri, 08 Jun 2012 14:30:47 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50002/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CAE8059}> ;;; T ;;; \"OK\" How to make each VHOST write to separate access log streams (or files) is left as an exercise to the reader. TASKMASTERS As a \"normal\" Hunchentoot user, you can completely ignore taskmasters and skip this section. But if you're still reading, here are the dirty details: Each acceptor has a taskmaster associated with it at creation time. It is the taskmaster's job to distribute the work of accepting and handling incoming connections. The acceptor calls the taskmaster if appropriate and the taskmaster calls back into the acceptor. This is done using the generic functions described in this and the previous section. Hunchentoot comes with two standard taskmaster implementations - one (which is the default used on multi-threaded Lisps) which starts a new thread for each incoming connection and one which handles all requests sequentially. It should for example be relatively straightforward to create a taskmaster which allocates threads from a fixed pool instead of creating a new one for each connection. You can control the resources consumed by a threaded taskmaster via two initargs. :max-thread-count lets you set the maximum number of request threads that can be processes simultaneously. If this is nil , the is no thread limit imposed. :max-accept-count lets you set the maximum number of requests that can be outstanding (i.e. being processed or queued for processing). If :max-thread-count is supplied and :max-accept-count is NIL , then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated if there are more than the max-thread-count threads processing requests. If both :max-thread-count and :max-accept-count are supplied, then max-thread-count must be less than max-accept-count; if more than max-thread-count requests are being processed, then requests up to max-accept-count will be queued until a thread becomes available. If more than max-accept-count requests are outstanding, then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide :max-thread-count but leave :max-accept-count null. This will immediately result in +HTTP-SERVICE-UNAVAILABLE+ when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both :max-thread-count and a somewhat larger value for :max-accept-count . This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be +HTTP-SERVICE-UNAVAILABLE+ . The default for these values is 100 and 120, respectively. If you want to implement your own taskmasters, you should subclass TASKMASTER or one of its subclasses, SINGLE-THREADED-TASKMASTER or ONE-THREAD-PER-CONNECTION-TASKMASTER , and specialize the generic functions in this section. execute-acceptor handle-incoming-connection start-thread create-request-handler-thread shutdown Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. SOME MORE TECHNICAL DETAILS Hunchentoot will only work with Lisps where the character codes of all Latin-1 characters coincide with their Unicode code points (which is the case for all current implementations I know). Source code can be downloaded from https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz . The current development version of Hunchentoot can be found at https://github.com/edicl/hunchentoot . If you want to send patches, please fork the github repository and send pull requests. Without cl+ssl You can compile Hunchentoot without SSL support - and thus without the need to have CL+SSL - if you add :HUNCHENTOOT-NO-SSL to *FEATURES* before you compile it. clbuild Hunchentoot and its dependencies can also be installed with clbuild . Gentoo Linux There's also a port for Gentoo Linux thanks to Matthew Kennedy. Running Hunchentoot on port 80 Hunchentoot does not come with code to help with running it on a privileged port (i.e. port 80 or 443) on Unix-like operating systems. Modern Unix-like systems have specific, non-portable ways to allow non-root users to listen to privileged ports, so including such functionality in Hunchentoot was considered unnecessary. Please refer to online resources for help. At the time of this writing, the YAWS documentation has a comprehensive writeup on the topic. Hunchentoot behind a proxy If you're feeling unsecure about exposing Hunchentoot to the wild, wild Internet or if your Lisp web application is part of a larger website, you can hide it behind a proxy server . One approach that I have used several times is to employ Apache's mod_proxy module with a configuration that looks like this: ProxyPass /hunchentoot http://127.0.0.1:3000/hunchentoot ProxyPassReverse /hunchentoot http://127.0.0.1:3000/hunchentoot This will tunnel all requests where the URI path begins with \"/hunchentoot\" to a (Hunchentoot) server listening on port 3000 on the same machine. Of course, there are several other (more lightweight) web proxies that you could use instead of Apache. SUPPORT The development version of Hunchentoot can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"hunchentoot - Web Server"},{"location":"hunchentoot/#hunchentoot-web-server","text":"Version: 1.2.38 Repository: edicl/hunchentoot - Github This page was possible due to the excellent official documentation as well as the page on Web Development on The Common Lisp Cookbook . In case of any inaccuracies, ambiguities or suggestions, please create an issue here . *hunchentoot was formerly known as TBNL.","title":"hunchentoot - Web Server"},{"location":"hunchentoot/#introduction","text":"Hunchentoot is a web server written in Common Lisp and a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. Hunchentoot provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client. It does not include functionality to programmatically generate HTML output. For this task you can use any library you like, e.g. CL-WHO or HTML-TEMPLATE . Hunchentoot should work with most popular lisp implementations including SBCL, CCL, LispWorks and all Lisps which are supported by the compatibility layers usocket and Bordeaux Threads . Hunchentoot talks with its front-end or with the client over TCP/IP sockets and optionally uses multiprocessing to handle several requests at the same time. Therefore, it cannot be implemented completely in portable Common Lisp . Hunchentoot comes with a BSD-style license so you can basically do with it whatever you want. Official documentation for Hunchentoot can be found in the docs directory or at the project website .","title":"INTRODUCTION"},{"location":"hunchentoot/#getting-started","text":"","title":"GETTING STARTED"},{"location":"hunchentoot/#installation-using-quicklisp","text":"See the section on Installation under Defacto Libraries on Home Page .","title":"Installation using quicklisp"},{"location":"hunchentoot/#serving-local-files","text":"To start the server, simply (defvar *acceptor*) (setq *acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4242)) (hunchentoot:start *acceptor*) You should see something - but not very interesting - at \" http://127.0.0.1:4242/ \" in your browser. By default, Hunchentoot serves files from the www/ directory from its source tree. In the distribution, that directory contains a HTML version of the documentation as well as the error templates. If installed via quicklisp, see (ql:where-is-system \"hunchentoot\") . See acceptor slots for a list of various slots (with or without initargs ). And configuration variables for a list of various configuration options for hunchentoot, such as whether to *catch-errors-p or *log-lisp-errors-p* and more. Acceptors provided with hunchentoot: acceptor easy-acceptor ssl-acceptor easy-ssl-acceptor","title":"Serving local files"},{"location":"hunchentoot/#going-dynamic","text":"","title":"Going dynamic"},{"location":"hunchentoot/#create-x-dispatcher","text":"To bind an existing function to a route, we create-prefix-dispatcher that we push onto the *dispatch-table* (just a global list of dispatch functions): (defun hello () (format nil \"Hello, it works!\")) (push (hunchentoot:create-prefix-dispatcher \"/hello.html\" 'hello) hunchentoot:*dispatch-table*) To create a route with a regexp, we use create-regex-dispatcher , where the url-as-regexp can be a string, an s-expression or a cl-ppcre scanner. In all, there exist create-folder-dispatcher-and-handler create-prefix-dispatcher create-regex-dispatcher create-static-file-dispatcher-and-handler","title":"create-X-dispatcher"},{"location":"hunchentoot/#define-easy-handler","text":"define-easy-handler allows to create a function and to bind it to an uri at once. For instance: (hunchentoot:define-easy-handler (say-yo :uri \"/yo\") (name) (setf (hunchentoot:content-type*) \"text/plain\") (format nil \"Hey~@[ ~A~]!\" name)) Visit http://localhost:4242/yo or add parameters to the url: http://localhost:4242/yo?name=Alice . Note that we didn't explicitly ask Hunchentoot to add this route to our first acceptor of the port 4242. This handler also works for another acceptor, say another one opened at port 4444: http://localhost:4444/yo?name=Bob In fact, define-easy-handler accepts an acceptor-names parameter that defines which acceptors it works for.","title":"define-easy-handler"},{"location":"hunchentoot/#accessing-get-and-post-parameters","text":"Query parameters are accessible with (hunchentoot:parameter \"my-param\") while in the context of a request . It acts on the default *request* object which is passed to all handlers. There also are get-paramater and post-parameter . See also the Variables in the context of a request .","title":"Accessing GET and POST parameters"},{"location":"hunchentoot/#more-documentation-tutorials-and-add-ons","text":"Adam Petersen has written a book called \"Lisp for the Web\" which explains how Hunchentoot and some other libraries can be used to build web sites. See also the Web Development - Cookbook . Implementing a blog in Common Lisp - Vetle Roeim Extensions and related softwares: Clack is a web server abstraction layer, defaulting to Hunchentoot. hunchentoot-cgi (by Cyrus Harmo) provides CGI handlers for Hunchentoot. CL-WEBDAV is a WebDAV server based on Hunchentoot. RESTAS is a web framework based on Hunchentoot. Caveman , Radiance , Snooze or again Weblocks are frameworks compatible with it.","title":"More documentation, tutorials and add-ons"},{"location":"hunchentoot/#api-reference","text":"","title":"API REFERENCE"},{"location":"hunchentoot/#1-acceptor","text":"Class To create a Hunchentoot webserver, you make an instance of this class and use the generic function START to start it (and STOP to stop it). Use the :PORT initarg if you don't want to listen on the default http port 80. There are other initargs most of which you probably won't need very often. They are explained in detail in the docstrings of the slot definitions for this class. Unless you are in a Lisp without MP capabilities, you can have several active instances of ACCEPTOR (listening on different ports) at the same time. Direct superclasses: STANDARD-OBJECT Direct subclasses: EASY-ACCEPTOR , SSL-ACCEPTOR","title":"1. ACCEPTOR"},{"location":"hunchentoot/#relevant-methods","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#accept-connections","text":"Function: (accept-connections acceptor) In a loop, accepts a connection and hands it over to the acceptor's taskmaster for processing using HANDLE-INCOMING-CONNECTION. On LispWorks, this function returns immediately, on other Lisps it retusn only once the acceptor has been stopped.","title":"accept-connections"},{"location":"hunchentoot/#acceptor-log-access","text":"Function: (acceptor-log-access acceptor &key return-code) Function to call to log access to the acceptor. The RETURN-CODE, CONTENT and CONTENT-LENGTH keyword arguments contain additional information about the request to log. In addition, it can use the standard request accessor functions that are available to handler functions to find out more information about the request.","title":"acceptor-log-access"},{"location":"hunchentoot/#acceptor-log-message","text":"Function: (acceptor-log-message acceptor log-level format-string &rest format-arguments) Function to call to log messages by the ACCEPTOR. It must accept a severity level for the message, which will be one of :ERROR, :INFO, or :WARNING, a format string and an arbitary number of formatting arguments.","title":"acceptor-log-message"},{"location":"hunchentoot/#acceptor-status-message","text":"Function: (acceptor-status-message acceptor http-status-code &key &allow-other-keys) This function is called after the request's handler has been invoked to convert the HTTP-STATUS-CODE to a HTML message to be displayed to the user. If this function returns a string, that string is sent to the client instead of the content produced by the handler, if any. If an ERROR-TEMPLATE-DIRECTORY is set in the current acceptor and the directory contains a file corresponding to HTTP-STATUS-CODE named \\<code>.html, that file is sent to the client after variable substitution. Variables are referenced by ${ }. Additional keyword arguments may be provided which are made available to the templating logic as substitution variables. These variables can be interpolated into error message templates in, which contains the current URL relative to the server and without GET parameters. In addition to the variables corresponding to keyword arguments, the script-name, lisp-implementation-type, lisp-implementation-version and hunchentoot-version variables are available.","title":"acceptor-status-message"},{"location":"hunchentoot/#detach-socket","text":"Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function.","title":"detach-socket"},{"location":"hunchentoot/#initialize-connection-stream","text":"Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use.","title":"initialize-connection-stream"},{"location":"hunchentoot/#process-connection","text":"Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. Handlers may call to the DETACH-SOCKET generic function to indicate that no further requests should be handled on the connection by Hunchentoot, and that responsibility for the socket is assumed by third-party software. This can be used by specialized handlers that wish to hand over connection polling or processing to functions outside of Hunchentoot, i.e. for connection multiplexing or implementing specialized client protocols. Hunchentoot will finish processing the request and the PROCESS-CONNECTION function will return without closing the connection. At that point, the acceptor may interact with the socket in whatever fashion required.","title":"process-connection"},{"location":"hunchentoot/#reset-connection-stream","text":"Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream.","title":"reset-connection-stream"},{"location":"hunchentoot/#start","text":"Function: (start acceptor) Starts the ACCEPTOR so that it begins accepting connections. Returns the acceptor.","title":"start"},{"location":"hunchentoot/#start-listening","text":"Function: (start-listening acceptor) Sets up a listen socket for the given ACCEPTOR and enables it to listen to incoming connections. This function is called from the thread that starts the acceptor initially and may return errors resulting from the listening operation (like 'address in use' or similar).","title":"start-listening"},{"location":"hunchentoot/#stop","text":"Function: (stop acceptor &key soft) Stops the ACCEPTOR so that it no longer accepts requests. If SOFT is true, and there are any requests in progress, wait until all requests are fully processed, but meanwhile do not accept new requests. Note that SOFT must not be set when calling STOP from within a request handler, as that will deadlock.","title":"stop"},{"location":"hunchentoot/#started-p","text":"Function: (started-p acceptor) Tells if ACCEPTOR has been started. The default implementation simply queries ACCEPTOR for its listening status, so if T is returned to the calling thread, then some thread has called START or some thread's call to STOP hasn't finished. If NIL is returned either some thread has called STOP, or some thread's call to START hasn't finished or START was never called at all for ACCEPTOR.","title":"started-p"},{"location":"hunchentoot/#slots","text":"","title":"SLOTS"},{"location":"hunchentoot/#acceptor-shutdown-p","text":"Initform: T A flag that makes the acceptor shutdown itself when set to something other than NIL.","title":"acceptor-shutdown-p"},{"location":"hunchentoot/#access-log-destination","text":"Initargs: :access-log-destination Readers: hunchentoot:acceptor-access-log-destination Writers: (setf hunchentoot:acceptor-access-log-destination) Destination of the access log which contains one log entry per request handled in a format similar to Apache's access.log. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging.","title":"access-log-destination"},{"location":"hunchentoot/#address","text":"Initargs: :address Readers: hunchentoot:acceptor-address The address the acceptor is listening on. If address is a string denoting an IP address, then the server only receives connections for that address. This must be one of the addresses associated with the machine and allowed values are host names such as \"www.zappa.com\" and address strings such as \"72.3.247.29\". If address is NIL, then the server will receive connections to all IP addresses on the machine. This is the default.","title":"address"},{"location":"hunchentoot/#document-root","text":"Initargs: :document-root Readers: hunchentoot:acceptor-document-root Writers: (setf hunchentoot:acceptor-document-root) Directory pathname that points to files that are served by the acceptor if no more specific acceptor-dispatch-request method handles the request.","title":"document-root"},{"location":"hunchentoot/#error-template-directory","text":"Initargs: :error-template-directory Readers: hunchentoot:acceptor-error-template-directory Writers: (setf hunchentoot:acceptor-error-template-directory) Directory pathname that contains error message template files for server-generated error messages. Files must be named .html with representing the HTTP return code that the file applies to, i.e. 404.html would be used as the content for a HTTP 404 Not found response.","title":"error-template-directory"},{"location":"hunchentoot/#listen-backlog","text":"Initargs: :listen-backlog Readers: hunchentoot:acceptor-listen-backlog Number of pending connections allowed in the listen socket before the kernel rejects further incoming connections.","title":"listen-backlog"},{"location":"hunchentoot/#listen-socket","text":"The socket listening for incoming connections.","title":"listen-socket"},{"location":"hunchentoot/#message-log-destination","text":"Initargs: :message-log-destination Readers: hunchentoot:acceptor-message-log-destination Writers: (setf hunchentoot:acceptor-message-log-destination) Destination of the server error log which is used to log informational, warning and error messages in a free-text format intended for human inspection. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging.","title":"message-log-destination"},{"location":"hunchentoot/#input-chunking-p","text":"Initargs: :input-chunking-p Readers: hunchentoot:acceptor-input-chunking-p Writers: (setf hunchentoot:acceptor-input-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for input, i.e. when accepting request bodies from the client. The default is T and there's usually no reason to change this to NIL.","title":"input-chunking-p"},{"location":"hunchentoot/#name","text":"Initargs: :name Readers: hunchentoot:acceptor-name Writers: (setf hunchentoot:acceptor-name) The optional name of the acceptor, a symbol. This name can be utilized when defining \"easy handlers\" - see DEFINE-EASY-HANDLER. The default name is an uninterned symbol as returned by GENSYM.","title":"name"},{"location":"hunchentoot/#output-chunking-p","text":"Initargs: :output-chunking-p Readers: hunchentoot:acceptor-output-chunking-p Writers: (setf hunchentoot:acceptor-output-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for output, i.e. when sending data to the client. The default is T and there's usually no reason to change this to NIL.","title":"output-chunking-p"},{"location":"hunchentoot/#persistent-connections-p","text":"Initargs: :persistent-connections-p Readers: hunchentoot:acceptor-persistent-connections-p Writers: (setf hunchentoot:acceptor-persistent-connections-p) A generalized boolean denoting whether the acceptor supports persistent connections, which is the default for threaded acceptors. If this property is NIL, Hunchentoot closes each incoming connection after having processed one request. This is the default for non-threaded acceptors.","title":"persistent-connections-p"},{"location":"hunchentoot/#port","text":"Initargs: :port Readers: hunchentoot:acceptor-port The port the acceptor is listening on. The default is 80. Note that depending on your operating system you might need special privileges to listen on port 80. When 0, the port will be chosen by the system the first time the acceptor is started.","title":"port"},{"location":"hunchentoot/#read-timeout","text":"Initargs: :read-timeout Readers: hunchentoot:acceptor-read-timeout The read timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout.","title":"read-timeout"},{"location":"hunchentoot/#reply-class","text":"Initargs: :reply-class Readers: hunchentoot:acceptor-reply-class Writers: (setf hunchentoot:acceptor-reply-class) Determines which class of reply objects is created when a request is served in and should be (a symbol naming) a class which inherits from REPLY. The default is the symbol REPLY.","title":"reply-class"},{"location":"hunchentoot/#request-class","text":"Initargs: :request-class Readers: hunchentoot:acceptor-request-class Writers: (setf hunchentoot:acceptor-request-class) Determines which class of request objects is created when a request comes in and should be (a symbol naming) a class which inherits from REQUEST. The default is the symbol REQUEST.","title":"request-class"},{"location":"hunchentoot/#requests-in-progress","text":"Initform: 0 The number of requests currently in progress.","title":"requests-in-progress"},{"location":"hunchentoot/#shutdown-lock","text":"The lock protecting the shutdown-queue condition variable and the requests-in-progress counter.","title":"shutdown-lock"},{"location":"hunchentoot/#shutdown-queue","text":"A condition variable used with soft shutdown, signaled when all requests have been processed.","title":"shutdown-queue"},{"location":"hunchentoot/#taskmaster","text":"Initargs: :taskmaster The taskmaster (i.e. an instance of a subclass of TASKMASTER) that is responsible for scheduling the work for this acceptor. The default depends on the MP capabilities of the underlying Lisp.","title":"taskmaster"},{"location":"hunchentoot/#write-timeout","text":"Initargs: :write-timeout Readers: hunchentoot:acceptor-write-timeout The write timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout.","title":"write-timeout"},{"location":"hunchentoot/#2-easy-acceptor","text":"Class This is the acceptor of the \"easy\" Hunchentoot framework. Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR","title":"2. EASY-ACCEPTOR"},{"location":"hunchentoot/#3-define-easy-handler","text":"Macro: (define-easy-handler description lambda-list &body body) Defines a handler with the body BODY and optionally registers it with a URI so that it will be found by DISPATCH-EASY-HANDLERS . DESCRIPTION is either a symbol NAME or a list matching the destructuring lambda list (name &key uri acceptor-names default-parameter-type default-request-type) LAMBDA-LIST is a list the elements of which are either a symbol VAR or a list matching the destructuring lambda list (var &key real-name parameter-type init-form request-type) The resulting handler will be a Lisp function with the name NAME and keyword parameters named by the VAR symbols. Each VAR will be bound to the value of the GET or POST parameter called REAL-NAME (a string) before BODY is executed. If REAL-NAME is not provided, it will be computed by downcasing the symbol name of VAR. If URI (which is evaluated) is provided, then it must be a string or a function designator for a function of one argument. In this case, the handler will be returned by DISPATCH-EASY-HANDLERS, if URI is a string and the script name of a request is URI, or if URI designates a function and applying this function to the current request object returns a true value. ACCEPTOR-NAMES (which is evaluated) can be a list of symbols which means that the handler will be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). ACCEPTOR-NAMES can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor. Whether the GET or POST parameter (or both) will be taken into consideration, depends on REQUEST-TYPE which can be :GET, :POST, :BOTH, or NIL. In the last case, the value of DEFAULT-REQUEST-TYPE (the default of which is :BOTH) will be used. The value of VAR will usually be a string (unless it resulted from a file upload in which case it won't be converted at all), but if PARAMETER-TYPE (which is evaluated) is provided, the string will be converted to another Lisp type by the following rules: If the corresponding GET or POST parameter wasn't provided by the client, VAR's value will be NIL. If PARAMETER-TYPE is 'STRING, VAR's value remains as is. If PARAMETER-TYPE is 'INTEGER and the parameter string consists solely of decimal digits, VAR's value will be the corresponding integer, otherwise NIL. If PARAMETER-TYPE is 'KEYWORD, VAR's value will be the keyword obtained by interning the upcased parameter string into the keyword package. If PARAMETER-TYPE is 'CHARACTER and the parameter string is of length one, VAR's value will be the single character of this string, otherwise NIL. If PARAMETER-TYPE is 'BOOLEAN, VAR's value will always be T (unless it is NIL by the first rule above, of course). If PARAMETER-TYPE is any other atom, it is supposed to be a function designator for a unary function which will be called to convert the string to something else. Those were the rules for simple' types, but PARAMETER-TYPE can also be a list starting with one of the symbols LIST, ARRAY, or HASH-TABLE. The second value of the list must always be a simple parameter type as in the last paragraph - we'll call it the inner type' below. In the case of 'LIST, all GET/POST parameters called REAL-NAME will be collected, converted to the inner type, and assembled into a list which will be the value of VAR. In the case of 'ARRAY, all GET/POST parameters which have a name like the result of (format nil \"~A[~A]\" real-name n) where N is a non-negative integer, will be assembled into an array where the Nth element will be set accordingly, after conversion to the inner type. The array, which will become the value of VAR, will be big enough to hold all matching parameters, but not bigger. Array elements not set as described above will be NIL. Note that VAR will always be bound to an array, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. The full form of a 'HASH-TABLE parameter type is (hash-table inner-type key-type test-function), but KEY-TYPE and TEST-FUNCTION can be left out in which case they default to 'STRING and 'EQUAL, respectively. For this parameter type, all GET/POST parameters which have a name like the result of (format nil \"~A{~A}\" real-name key) (where KEY is a string that doesn't contain curly brackets) will become the values (after conversion to INNER-TYPE) of a hash table with test function TEST-FUNCTION where KEY (after conversion to KEY-TYPE) will be the corresponding key. Note that VAR will always be bound to a hash table, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. To make matters even more complicated, the three compound parameter types also have an abbreviated form - just one of the symbols LIST, ARRAY, or HASH-TABLE. In this case, the inner type will default to 'STRING. If PARAMETER-TYPE is not provided or NIL, DEFAULT-PARAMETER-TYPE (the default of which is 'STRING) will be used instead. If the result of the computations above would be that VAR would be bound to NIL, then INIT-FORM (if provided) will be evaluated instead, and VAR will be bound to the result of this evaluation. Handlers built with this macro are constructed in such a way that the resulting Lisp function is useful even outside of Hunchentoot. Specifically, all the parameter computations above will only happen if *REQUEST* is bound, i.e. if we're within a Hunchentoot request. Otherwise, VAR will always be bound to the result of evaluating INIT-FORM unless a corresponding keyword argument is provided.","title":"3. DEFINE-EASY-HANDLER"},{"location":"hunchentoot/#4-ssl-acceptor","text":"Class Create and START an instance of this class (instead of ACCEPTOR) if you want an https server. There are two required initargs, :SSL-CERTIFICATE-FILE and :SSL-PRIVATEKEY-FILE, for pathname designators denoting the certificate file and the key file in PEM format. On LispWorks, you can have both in one file in which case the second initarg is optional. You can also use the :SSL-PRIVATEKEY-PASSWORD initarg to provide a password (as a string) for the key file (or NIL, the default, for no password). The default port for SSL-ACCEPTOR instances is 443 instead of 80 Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR","title":"4. SSL-ACCEPTOR"},{"location":"hunchentoot/#direct-slots","text":"Also see slots for the superclass.","title":"DIRECT SLOTS"},{"location":"hunchentoot/#ssl-certificate-file","text":"Initargs: :ssl-certificate-file Readers: hunchentoot:acceptor-ssl-certificate-file A pathname designator for a certificate file in PEM format.","title":"ssl-certificate-file"},{"location":"hunchentoot/#ssl-privatekey-file","text":"Initargs: :ssl-privatekey-file Readers: hunchentoot:acceptor-ssl-privatekey-file A pathname designator for a private key file in PEM format, or (only on LispWorks) NIL if the certificate file contains the private key.","title":"ssl-privatekey-file"},{"location":"hunchentoot/#ssl-privatekey-password","text":"Initargs: :ssl-privatekey-password Readers: hunchentoot:acceptor-ssl-privatekey-password The password for the private key file or NIL for no password.","title":"ssl-privatekey-password"},{"location":"hunchentoot/#5-easy-ssl-acceptor","text":"Class This is an acceptor that mixes the \"easy\" Hunchentoot with SSL connections. Direct superclasses: EASY-ACCEPTOR , SSL-ACCEPTOR No subclasses.","title":"5. EASY-SSL-ACCEPTOR"},{"location":"hunchentoot/#6-reply","text":"Class Objects of this class hold all the information about an outgoing reply. They are created automatically by Hunchentoot and can be accessed and modified by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REPLY in order to implement your own behaviour. See the REPLY-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses.","title":"6. REPLY"},{"location":"hunchentoot/#relevant-methods_1","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#headers-out","text":"Function: (headers-out* &optional (reply *reply*)) Returns an alist of the outgoing headers associated with the REPLY object REPLY.","title":"headers-out*"},{"location":"hunchentoot/#content-length","text":"Function: (content-length* &optional (reply *reply*)) The outgoing 'Content-Length' http header of REPLY.","title":"content-length*"},{"location":"hunchentoot/#content-type","text":"Function: (content-type* &optional (reply *reply*)) The outgoing 'Content-Type' http header of REPLY.","title":"content-type*"},{"location":"hunchentoot/#cookie-out","text":"Function: (cookie-out name &optional (reply *reply*)) Returns the current value of the outgoing cookie named NAME. Search is case-sensitive.","title":"cookie-out"},{"location":"hunchentoot/#cookies-out","text":"Function: (cookies-out* &optional (reply *reply*)) Returns an alist of the outgoing cookies associated with the REPLY object REPLY.","title":"cookies-out*"},{"location":"hunchentoot/#return-code","text":"Function: (return-code* &optional (reply *reply*)) The http return code of REPLY. The return codes Hunchentoot can handle are defined in specials.lisp.","title":"return-code*"},{"location":"hunchentoot/#send-headers","text":"Function: (send-headers) Sends the initial status line and all headers as determined by the REPLY object *REPLY*. Returns a binary stream to which the body of the reply can be written. Once this function has been called, further changes to *REPLY* don't have any effect. Also, automatic handling of errors (i.e. sending the corresponding status code to the browser, etc.) is turned off for this request. If your handlers return the full body as a string or as an array of octets you should NOT call this function. This function does not return control to the caller during HEAD request processing.","title":"send-headers"},{"location":"hunchentoot/#reply-external-format","text":"Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output.","title":"reply-external-format*"},{"location":"hunchentoot/#slots_1","text":"","title":"SLOTS"},{"location":"hunchentoot/#content-type_1","text":"Readers: hunchentoot:content-type The outgoing 'Content-Type' http header which defaults to the value of *DEFAULT-CONTENT-TYPE*.","title":"content-type"},{"location":"hunchentoot/#content-length_1","text":"Readers: hunchentoot:content-length The outgoing 'Content-Length' http header which defaults NIL. If this is NIL, Hunchentoot will compute the content length.","title":"content-length"},{"location":"hunchentoot/#headers-out_1","text":"Readers: hunchentoot:headers-out An alist of the outgoing http headers not including the 'Set-Cookie', 'Content-Length', and 'Content-Type' headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot.","title":"headers-out"},{"location":"hunchentoot/#return-code_1","text":"Initform: hunchentoot:+http-ok+ Readers: hunchentoot:return-code Writers: (setf hunchentoot:return-code) The http return code of this reply. The return codes Hunchentoot can handle are defined in specials.lisp.","title":"return-code"},{"location":"hunchentoot/#external-format","text":"Initform: hunchentoot:*hunchentoot-default-external-format* Readers: hunchentoot:reply-external-format Writers: (setf hunchentoot:reply-external-format) The external format of the reply - used for character output.","title":"external-format"},{"location":"hunchentoot/#cookies-out_1","text":"Readers: hunchentoot:cookies-out Writers: (setf hunchentoot:cookies-out) The outgoing cookies. This slot's value should only be modified by the functions defined in cookies.lisp.","title":"cookies-out"},{"location":"hunchentoot/#7-request","text":"Class Objects of this class hold all the information about an incoming request. They are created automatically by acceptors and can be accessed by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REQUEST in order to implement your own behaviour. See the REQUEST-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses.","title":"7. REQUEST"},{"location":"hunchentoot/#relevant-methods_2","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#real-remote-addr","text":"Function: (real-remote-addr &optional (request *request*)) Returns the 'X-Forwarded-For' incoming http header as the second value in the form of a list of IP addresses and the first element of this list as the first value if this header exists. Otherwise returns the value of REMOTE-ADDR as the only value.","title":"real-remote-addr"},{"location":"hunchentoot/#parameter","text":"Function: (parameter name &optional (request *request*)) Returns the GET or the POST parameter with name NAME (a string) - or NIL if there is none. If both a GET and a POST parameter with the same name exist the GET parameter is returned. Search is case-sensitive.","title":"parameter"},{"location":"hunchentoot/#get-parameter","text":"Function: (get-parameter name &optional (request *request*)) Returns the GET parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive.","title":"get-parameter"},{"location":"hunchentoot/#get-parameters","text":"Function: (get-parameters* &optional (request *request*)) Returns an alist of the GET parameters associated with the REQUEST object REQUEST.","title":"get-parameters*"},{"location":"hunchentoot/#post-parameter","text":"Function: (post-parameter name &optional (request *request*)) Returns the POST parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive.","title":"post-parameter"},{"location":"hunchentoot/#post-parameters","text":"Function: (post-parameters* &optional (request *request*)) Returns an alist of the POST parameters associated with the REQUEST object REQUEST.","title":"post-parameters*"},{"location":"hunchentoot/#cookie-in","text":"Function: (cookie-in name &optional (request *request*)) Returns the cookie with the name NAME (a string) as sent by the browser - or NIL if there is none.","title":"cookie-in"},{"location":"hunchentoot/#cookies-in","text":"Function: (cookies-in* &optional (request *request*)) Returns an alist of all cookies associated with the REQUEST object REQUEST.","title":"cookies-in*"},{"location":"hunchentoot/#host","text":"Function: (host &optional (request *request*)) Returns the 'Host' incoming http header value.","title":"host"},{"location":"hunchentoot/#query-string","text":"Function: (query-string* &optional (request *request*)) Returns the query string of the REQUEST object REQUEST. That's the part behind the question mark (i.e. the GET parameters).","title":"query-string*"},{"location":"hunchentoot/#referer","text":"Function: (referer &optional (request *request*)) Returns the 'Referer' (sic!) http header.","title":"referer"},{"location":"hunchentoot/#request-method","text":"Function: (request-method* &optional (request *request*)) Returns the request method as a Lisp keyword.","title":"request-method*"},{"location":"hunchentoot/#request-uri","text":"Function: (request-uri* &optional (request *request*)) Returns the request URI.","title":"request-uri*"},{"location":"hunchentoot/#server-protocol","text":"Function: (server-protocol* &optional (request *request*)) Returns the request protocol as a Lisp keyword.","title":"server-protocol*"},{"location":"hunchentoot/#user-agent","text":"Function: (user-agent &optional (request *request*)) Returns the 'User-Agent' http header.","title":"user-agent"},{"location":"hunchentoot/#header-in","text":"Function: (header-in* name &optional (request *request*)) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string.","title":"header-in*"},{"location":"hunchentoot/#headers-in","text":"Function: (headers-in* &optional (request *request*)) Returns an alist of the incoming headers associated with the REQUEST object REQUEST.","title":"headers-in*"},{"location":"hunchentoot/#remote-addr","text":"Function: (remote-addr* &optional (request *request*)) Returns the address the current request originated from.","title":"remote-addr*"},{"location":"hunchentoot/#remote-port","text":"Function: (remote-port* &optional (request *request*)) Returns the port the current request originated from.","title":"remote-port*"},{"location":"hunchentoot/#local-addr","text":"Function: (local-addr* &optional (request *request*)) Returns the address the current request connected to.","title":"local-addr*"},{"location":"hunchentoot/#local-port","text":"Function: (local-port* &optional (request *request*)) Returns the port the current request connected to.","title":"local-port*"},{"location":"hunchentoot/#script-name","text":"Function: (script-name* &optional (request *request*)) Returns the file name of the REQUEST object REQUEST. That's the requested URI without the query string (i.e the GET parameters).","title":"script-name*"},{"location":"hunchentoot/#aux-request-value","text":"Function: (aux-request-value symbol &optional (request *request*)) Returns the value associated with SYMBOL from the request object REQUEST (the default is the current request) if it exists. The second return value is true if such a value was found. Sets the value associated with SYMBOL from the request object REQUEST (default is *REQUEST*). If there is already a value associated with SYMBOL it will be replaced.","title":"aux-request-value"},{"location":"hunchentoot/#delete-aux-request-value","text":"Function: (delete-aux-request-value symbol &optional (request *request*)) Removes the value associated with SYMBOL from the request object REQUEST.","title":"delete-aux-request-value"},{"location":"hunchentoot/#authorization","text":"Function: (authorization &optional (request *request*)) Returns as two values the user and password (if any) as encoded in the 'AUTHORIZATION' header. Returns NIL if there is no such header.","title":"authorization"},{"location":"hunchentoot/#raw-post-data","text":"Function: (raw-post-data &key (request *request*) external-format force-text force-binary want-stream) Returns the content sent by the client if there was any (unless the content type was \"multipart/form-data\"). By default, the result is a string if the type of the Content-Type' media type is \"text\", and a vector of octets otherwise. In the case of a string, the external format to be used to decode the content will be determined from the charset' parameter sent by the client (or otherwise *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used). You can also provide an external format explicitly (through EXTERNAL-FORMAT) in which case the result will unconditionally be a string. Likewise, you can provide a true value for FORCE-TEXT which will force Hunchentoot to act as if the type of the media type had been \"text\". Or you can provide a true value for FORCE-BINARY which means that you want a vector of octets at any rate. If, however, you provide a true value for WANT-STREAM, the other parameters are ignored and you'll get the content (flexi) stream to read from it yourself. It is then your responsibility to read the correct amount of data, because otherwise you won't be able to return a response to the client. If the content type of the request was multipart/form-data' or application/x-www-form-urlencoded', the content has been read by Hunchentoot already and you can't read from the stream anymore. You can call RAW-POST-DATA more than once per request, but you can't mix calls which have different values for WANT-STREAM. Note that this function is slightly misnamed because a client can send content even if the request method is not POST.","title":"raw-post-data"},{"location":"hunchentoot/#recompute-request-parameters","text":"Function: (recompute-request-parameters &key (request *request*) (external-format *hunchentoot-default-external-format*)) Recomputes the GET and POST parameters for the REQUEST object REQUEST. This only makes sense if you're switching external formats during the request.","title":"recompute-request-parameters"},{"location":"hunchentoot/#process-request","text":"Function: (process-request request) This function is called by PROCESS-CONNECTION after the incoming headers have been read. It calls HANDLE-REQUEST to select and call a handler and sends the output of this handler to the client using START-OUTPUT. Note that PROCESS-CONNECTION is called once per connection and loops in case of a persistent connection while PROCESS-REQUEST is called anew for each request. Essentially, you can view process-request as a thin wrapper around HANDLE-REQUEST. The return value of this function is ignored.","title":"process-request"},{"location":"hunchentoot/#handle-request","text":"Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers.","title":"handle-request"},{"location":"hunchentoot/#handle-request_1","text":"Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers.","title":"handle-request"},{"location":"hunchentoot/#acceptor-dispatch-request","text":"Function: (acceptor-dispatch-request acceptor request) This function is called to actually dispatch the request once the standard logging and error handling has been set up. ACCEPTOR subclasses implement methods for this function in order to perform their own request routing. If a method does not want to handle the request, it is supposed to invoke CALL-NEXT-METHOD so that the next ACCEPTOR in the inheritance chain gets a chance to handle the request.","title":"acceptor-dispatch-request"},{"location":"hunchentoot/#slots_2","text":"","title":"SLOTS"},{"location":"hunchentoot/#acceptor","text":"Initargs: :acceptor Readers: hunchentoot:request-acceptor The acceptor which created this request object.","title":"acceptor"},{"location":"hunchentoot/#headers-in_1","text":"Initargs: :headers-in Readers: hunchentoot:headers-in An alist of the incoming headers.","title":"headers-in"},{"location":"hunchentoot/#method","text":"Initargs: :method Readers: hunchentoot:request-method The request method as a keyword.","title":"method"},{"location":"hunchentoot/#uri","text":"Initargs: :uri Readers: hunchentoot:request-uri The request URI as a string.","title":"uri"},{"location":"hunchentoot/#server-protocol_1","text":"Initargs: :server-protocol Readers: hunchentoot:server-protocol The HTTP protocol as a keyword.","title":"server-protocol"},{"location":"hunchentoot/#local-addr_1","text":"Initargs: :local-addr Readers: hunchentoot:local-addr The IP address of the local system that the client connected to.","title":"local-addr"},{"location":"hunchentoot/#local-port_1","text":"Initargs: :local-port Readers: hunchentoot:local-port The TCP port number of the local system that the client connected to.","title":"local-port"},{"location":"hunchentoot/#remote-addr_1","text":"Initargs: :remote-addr Readers: hunchentoot:remote-addr The IP address of the client that initiated this request.","title":"remote-addr"},{"location":"hunchentoot/#remote-port_1","text":"Initargs: :remote-port Readers: hunchentoot:remote-port The TCP port number of the client socket from which this request originated.","title":"remote-port"},{"location":"hunchentoot/#content-stream","text":"Initargs: :content-stream A stream from which the request body can be read if there is one.","title":"content-stream"},{"location":"hunchentoot/#cookies-in_1","text":"Readers: hunchentoot:cookies-in An alist of the cookies sent by the client.","title":"cookies-in"},{"location":"hunchentoot/#get-parameters_1","text":"Readers: hunchentoot:get-parameters An alist of the GET parameters sent by the client.","title":"get-parameters"},{"location":"hunchentoot/#post-parameters_1","text":"Readers: hunchentoot:post-parameters An alist of the POST parameters sent by the client.","title":"post-parameters"},{"location":"hunchentoot/#script-name_1","text":"Readers: hunchentoot:script-name The URI requested by the client without the query string.","title":"script-name"},{"location":"hunchentoot/#query-string_1","text":"Readers: hunchentoot:query-string The query string of this request.","title":"query-string"},{"location":"hunchentoot/#session","text":"Readers: hunchentoot:session Writers: (setf hunchentoot:session) The session object associated with this request.","title":"session"},{"location":"hunchentoot/#aux-data","text":"Used to keep a user-modifiable alist with arbitrary data during the request.","title":"aux-data"},{"location":"hunchentoot/#raw-post-data_1","text":"The raw string sent as the body of a POST request, populated only if not a multipart/form-data request.","title":"raw-post-data"},{"location":"hunchentoot/#8-session","text":"Class SESSION objects are automatically maintained by Hunchentoot. They should not be created explicitly with MAKE-INSTANCE but implicitly with START-SESSION and they should be treated as opaque objects. You can ignore Hunchentoot's SESSION objects altogether and implement your own sessions if you provide corresponding methods for SESSION-COOKIE-VALUE and SESSION-VERIFY. Direct superclasses: STANDARD-OBJECT No subclasses. Hunchentoot supports sessions : Once a request handler has called START-SESSION , Hunchentoot uses either cookies or (if the client doesn't send the cookies back) rewrites URLs to keep track of this client, i.e. to provide a kind of 'state' for the stateless http protocol. Hunchentoot makes some reasonable effort to prevent eavesdroppers from hijacking sessions (see below), but this should not be considered really secure. Don't store sensitive data in sessions and rely solely on the session mechanism as a safeguard against malicious users who want to get at this data! For each request there's one SESSION object which is accessible to the handler via the special variable *SESSION* . This object holds all the information available about the session and can be accessed with the functions described in this chapter. Note that the internal structure of SESSION objects should be considered opaque and may change in future releases of Hunchentoot. Sessions are automatically verified for validity and age when the REQUEST object is instantiated, i.e. if *SESSION* is not NIL then this session is valid (as far as Hunchentoot is concerned) and not too old . Old sessions are automatically removed . Hunchentoot also provides a SESSION-REGENERATE-COOKIE-VALUE function that creates a new cookie value. This helps to prevent against session fixation attacks , and should be used when a user logs in according to the application.","title":"8. SESSION"},{"location":"hunchentoot/#relevant-methods_3","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#start-session","text":"Function: (start-session) Returns the current SESSION object. If there is no current session, creates one and updates the corresponding data structures. In this case the function will also send a session cookie to the browser.","title":"start-session"},{"location":"hunchentoot/#session-value","text":"Function: (session-value symbol &optional (session *session*)) Returns the value associated with SYMBOL from the session object SESSION (the default is the current session) if it exists. Sets the value associated with SYMBOL from the session object SESSION. If there is already a value associated with SYMBOL it will be replaced. Will automatically start a session if none was supplied and there's no session for the current request.","title":"session-value"},{"location":"hunchentoot/#delete-session-value","text":"Function: (delete-session-value symbol &optional (session *session*)) Removes the value associated with SYMBOL from SESSION if there is one.","title":"delete-session-value"},{"location":"hunchentoot/#remove-session","text":"Function: (remove-session session) Completely removes the SESSION object SESSION from Hunchentoot's internal session database.","title":"remove-session"},{"location":"hunchentoot/#slots_3","text":"","title":"SLOTS"},{"location":"hunchentoot/#session-id","text":"Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session.","title":"session-id"},{"location":"hunchentoot/#session-string","text":"The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter.","title":"session-string"},{"location":"hunchentoot/#user-agent_1","text":"Initform: (hunchentoot:user-agent hunchentoot:*request*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created.","title":"user-agent"},{"location":"hunchentoot/#remote-addr_2","text":"Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR.","title":"remote-addr"},{"location":"hunchentoot/#session-start","text":"Initform: (GET-UNIVERSAL-TIME) Readers: hunchentoot:session-start The time this session was started.","title":"session-start"},{"location":"hunchentoot/#last-click","text":"The last time this session was used.","title":"last-click"},{"location":"hunchentoot/#session-data","text":"Initargs: :session-data Data associated with this session - see SESSION-VALUE.","title":"session-data"},{"location":"hunchentoot/#max-time","text":"Type: fixnum Initargs: :max-time Initform: hunchentoot:*session-max-time* Readers: hunchentoot:session-max-time Writers: (setf hunchentoot:session-max-time) The time (in seconds) after which this session expires if it's not used.","title":"max-time"},{"location":"hunchentoot/#session-id_1","text":"Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session.","title":"session-id"},{"location":"hunchentoot/#session-string_1","text":"The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter.","title":"session-string"},{"location":"hunchentoot/#user-agent_2","text":"Initform: (HUNCHENTOOT:USER-AGENT HUNCHENTOOT:*REQUEST*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created.","title":"user-agent"},{"location":"hunchentoot/#remote-addr_3","text":"Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR.","title":"remote-addr"},{"location":"hunchentoot/#session-start_1","text":"Initform: (get-universal-time) Readers: hunchentoot:session-start The time this session was started.","title":"session-start"},{"location":"hunchentoot/#9-miscellaneous-functions","text":"","title":"9. MISCELLANEOUS FUNCTIONS"},{"location":"hunchentoot/#bad-request","text":"Class Direct superclasses: HUNCHENTOOT-ERROR No subclasses.","title":"bad-request"},{"location":"hunchentoot/#client-as-string","text":"Function: (client-as-string socket) A helper function which returns the client's address and port as a string and tries to act robustly in the presence of network problems.","title":"client-as-string"},{"location":"hunchentoot/#create-folder-dispatcher-and-handler","text":"Function: (create-folder-dispatcher-and-handler uri-prefix base-path &optional content-type) Creates and returns a dispatch function which will dispatch to a handler function which emits the file relative to BASE-PATH that is denoted by the URI of the request relative to URI-PREFIX. URI-PREFIX must be a string ending with a slash, BASE-PATH must be a pathname designator for an existing directory. If CONTENT-TYPE is not NIL, it'll be the content type used for all files in the folder.","title":"create-folder-dispatcher-and-handler"},{"location":"hunchentoot/#create-prefix-dispatcher","text":"Function: (create-prefix-dispatcher prefix handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request starts with the string PREFIX.","title":"create-prefix-dispatcher"},{"location":"hunchentoot/#create-regex-dispatcher","text":"Function: (create-regex-dispatcher regex handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request matches the CL-PPCRE regular expression REGEX.","title":"create-regex-dispatcher"},{"location":"hunchentoot/#create-request-handler-thread","text":"Function: (create-request-handler-thread taskmaster socket) Create a new thread in which to process the request. This thread will call PROCESS-CONNECTION to process the request.","title":"create-request-handler-thread"},{"location":"hunchentoot/#create-static-file-dispatcher-and-handler","text":"Function: (create-static-file-dispatcher-and-handler uri path &optional content-type) Creates and returns a request dispatch function which will dispatch to a handler function which emits the file denoted by the pathname designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of the request matches the string URI. If CONTENT-TYPE is NIL, tries to determine the content type via the file's suffix.","title":"create-static-file-dispatcher-and-handler"},{"location":"hunchentoot/#decrement-taskmaster-thread-count","text":"Function: (decrement-taskmaster-thread-count taskmaster) Atomically decrement the number of taskmaster requests","title":"decrement-taskmaster-thread-count"},{"location":"hunchentoot/#default-document-directory","text":"Function: (default-document-directory &optional sub-directory)","title":"default-document-directory"},{"location":"hunchentoot/#detach-socket_1","text":"Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function.","title":"detach-socket"},{"location":"hunchentoot/#dispatch-easy-handlers","text":"Function: (dispatch-easy-handlers request) This is a dispatcher which returns the appropriate handler defined with DEFINE-EASY-HANDLER, if there is one.","title":"dispatch-easy-handlers"},{"location":"hunchentoot/#escape-for-html","text":"Function: (escape-for-html string) Escapes the characters #\\<, #>, #\\', #\\\", and #\\& for HTML output.","title":"escape-for-html"},{"location":"hunchentoot/#handle-if-modified-since","text":"Function: (handle-if-modified-since time &optional (request *request*)) Handles the 'If-Modified-Since' header of REQUEST. The date string is compared to the one generated from the supplied universal time TIME.","title":"handle-if-modified-since"},{"location":"hunchentoot/#handle-static-file","text":"Function: (handle-static-file pathname &optional content-type) A function which acts like a Hunchentoot handler for the file denoted by PATHNAME. Sends a content type header corresponding to CONTENT-TYPE or (if that is NIL) tries to determine the content type via the file's suffix.","title":"handle-static-file"},{"location":"hunchentoot/#http-token-p","text":"Function: (http-token-p token) This function tests whether OBJECT is a non-empty string which is a TOKEN according to RFC 2068 (i.e. whether it may be used for, say, cookie names).","title":"http-token-p"},{"location":"hunchentoot/#hunchentoot-error","text":"Function: (hunchentoot-error format-control &rest format-arguments) Signals an error of type HUNCHENTOOT-SIMPLE-ERROR with the provided format control and arguments. Superclass for all errors related to Hunchentoot.","title":"hunchentoot-error"},{"location":"hunchentoot/#increment-taskmaster-thread-count","text":"Function: (increment-taskmaster-thread-count taskmaster) Atomically increment the number of taskmaster requests.","title":"increment-taskmaster-thread-count"},{"location":"hunchentoot/#initialize-connection-stream_1","text":"Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use.","title":"initialize-connection-stream"},{"location":"hunchentoot/#log-message","text":"Function: (log-message* log-level format-string &rest format-arguments) Convenience function which calls the message logger of the current acceptor (if there is one) with the same arguments it accepts. This is the function which Hunchentoot itself uses to log errors it catches during request processing.","title":"log-message*"},{"location":"hunchentoot/#maybe-invoke-debugger","text":"Function: (maybe-invoke-debugger condition) This generic function is called whenever a condition CONDITION is signaled in Hunchentoot. You might want to specialize it on specific condition classes for debugging purposes.","title":"maybe-invoke-debugger"},{"location":"hunchentoot/#mime-type","text":"Function: (mime-type pathspec) Given a pathname designator PATHSPEC returns the MIME type (as a string) corresponding to the suffix of the file denoted by PATHSPEC (or NIL).","title":"mime-type"},{"location":"hunchentoot/#next-session-id","text":"Function: (next-session-id acceptor) Returns the next sequential session ID, an integer, which should be unique per session. The default method uses a simple global counter and isn't guarded by a lock. For a high-performance production environment you might consider using a more robust implementation.","title":"next-session-id"},{"location":"hunchentoot/#no-cache","text":"Function: (no-cache) Adds appropriate headers to completely prevent caching on most browsers.","title":"no-cache"},{"location":"hunchentoot/#parameter-error","text":"Function: (parameter-error format-control &rest format-arguments) Signals an error of type PARAMETER-ERROR with the provided format control and arguments. Signalled if a function was called with incosistent or illegal parameters.","title":"parameter-error"},{"location":"hunchentoot/#process-connection_1","text":"Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing.","title":"process-connection"},{"location":"hunchentoot/#reason-phrase","text":"Function: (reason-phrase return-code) Returns a reason phrase for the HTTP return code RETURN-CODE (which should be an integer) or NIL for return codes Hunchentoot doesn't know.","title":"reason-phrase"},{"location":"hunchentoot/#redirect","text":"Function: (redirect target &key (host (host *request*) host-provided-p) port (protocol (if (ssl-p) :https :http)) (add-session-id (not (or host-provided-p (starts-with-scheme-p target) (cookie-in (session-cookie-name *acceptor*))))) (code +http-moved-temporarily+)) Redirects the browser to TARGET which should be a string. If TARGET is a full URL starting with a scheme, HOST, PORT and PROTOCOL are ignored. Otherwise, TARGET should denote the path part of a URL, PROTOCOL must be one of the keywords :HTTP or :HTTPS, and the URL to redirect to will be constructed from HOST, PORT, PROTOCOL, and TARGET. Adds a session ID if ADD-SESSION-ID is true. If CODE is a 3xx redirection code, it will be sent as status code.","title":"redirect"},{"location":"hunchentoot/#regenerate-session-cookie-value","text":"Function: (regenerate-session-cookie-value session) Regenerates the cookie value. This should be used when a user logs in according to the application to prevent against session fixation attacks. The cookie value being dependent on ID, USER-AGENT, REMOTE-ADDR, START, and *SESSION-SECRET*, the only value we can change is START to regenerate a new value. Since we're generating a new cookie, it makes sense to have the session being restarted, in time. That said, because of this fact, calling this function twice in the same second will regenerate twice the same value.","title":"regenerate-session-cookie-value"},{"location":"hunchentoot/#reply-external-format_1","text":"Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output.","title":"reply-external-format*"},{"location":"hunchentoot/#request-pathname","text":"Function: (request-pathname &optional (request *request*) drop-prefix) Construct a relative pathname from the request's SCRIPT-NAME. If DROP-PREFIX is given, pathname construction starts at the first path segment after the prefix.","title":"request-pathname"},{"location":"hunchentoot/#require-authorization","text":"Function: (require-authorization &optional (realm hunchentoot)) Sends back appropriate headers to require basic HTTP authentication (see RFC 2617) for the realm REALM.","title":"require-authorization"},{"location":"hunchentoot/#reset-connection-stream_1","text":"Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream.","title":"reset-connection-stream"},{"location":"hunchentoot/#reset-session-secret","text":"Function: (reset-session-secret) Sets *SESSION-SECRET* to a new random value. All old sessions will cease to be valid.","title":"reset-session-secret"},{"location":"hunchentoot/#reset-sessions","text":"Function: (reset-sessions &optional (acceptor *acceptor*)) Removes ALL stored sessions of ACCEPTOR.","title":"reset-sessions"},{"location":"hunchentoot/#rfc-1123-date","text":"Function: (rfc-1123-date &optional (time (get-universal-time))) Generates a time string according to RFC 1123. Default is current time. This can be used to send a 'Last-Modified' header - see HANDLE-IF-MODIFIED-SINCE.","title":"rfc-1123-date"},{"location":"hunchentoot/#script-name_2","text":"Function: (script-name object)","title":"script-name"},{"location":"hunchentoot/#server-protocol_2","text":"Function: (server-protocol object)","title":"server-protocol"},{"location":"hunchentoot/#session-cookie-name","text":"Function: (session-cookie-name acceptor) Returns the name (a string) of the cookie (or the GET parameter) which is used to store a session on the client side. The default is to use the string \"hunchentoot-session\", but you can specialize this function if you want another name.","title":"session-cookie-name"},{"location":"hunchentoot/#session-cookie-value","text":"Function: (session-cookie-value session) Returns a string which can be used to safely restore the session SESSION if as session has already been established. This is used as the value stored in the session cookie or in the corresponding GET parameter and verified by SESSION-VERIFY. A default method is provided and there's no reason to change it unless you want to use your own session objects.","title":"session-cookie-value"},{"location":"hunchentoot/#session-created","text":"Function: (session-created acceptor new-session) This function is called whenever a new session has been created. There's a default method which might trigger a session GC based on the value of *SESSION-GC-FREQUENCY*. The return value is ignored.","title":"session-created"},{"location":"hunchentoot/#session-db","text":"Function: (session-db acceptor) Returns the current session database which is an alist where each car is a session's ID and the cdr is the corresponding SESSION object itself. The default is to use a global list for all acceptors.","title":"session-db"},{"location":"hunchentoot/#session-db-lock","text":"Function: (session-db-lock acceptor &key whole-db-p) A function which returns a lock that will be used to prevent concurrent access to sessions. The first argument will be the acceptor that handles the current request, the second argument is true if the whole (current) session database is modified. If it is NIL, only one existing session in the database is modified. This function can return NIL which means that sessions or session databases will be modified without a lock held (for example for single-threaded environments). The default is to always return a global lock (ignoring the ACCEPTOR argument) for Lisps that support threads and NIL otherwise.","title":"session-db-lock"},{"location":"hunchentoot/#session-gc","text":"Function: (session-gc) Removes sessions from the current session database which are too old - see SESSION-TOO-OLD-P.","title":"session-gc"},{"location":"hunchentoot/#session-too-old-p","text":"Function: (session-too-old-p session) Returns true if the SESSION object SESSION has not been active in the last (SESSION-MAX-TIME SESSION) seconds.","title":"session-too-old-p"},{"location":"hunchentoot/#session-verify","text":"Function: (session-verify request) Tries to get a session identifier from the cookies (or alternatively from the GET parameters) sent by the client (see SESSION-COOKIE-NAME and SESSION-COOKIE-VALUE). This identifier is then checked for validity against the REQUEST object REQUEST. On success the corresponding session object (if not too old) is returned (and updated). Otherwise NIL is returned. A default method is provided and you only need to write your own one if you want to maintain your own sessions.","title":"session-verify"},{"location":"hunchentoot/#set-cookie","text":"Function: (set-cookie name &key (value \"\") expires max-age path domain secure http-only (reply *reply*)) Creates a cookie object from the parameters provided and adds it to the outgoing cookies of the REPLY object REPLY. If a cookie with the name NAME (case-sensitive) already exists, it is replaced.","title":"set-cookie"},{"location":"hunchentoot/#set-cookie_1","text":"Function: (set-cookie* cookie &optional (reply *reply*)) Adds the COOKIE object COOKIE to the outgoing cookies of the REPLY object REPLY. If a cookie with the same name (case-sensitive) already exists, it is replaced.","title":"set-cookie*"},{"location":"hunchentoot/#ssl-p","text":"Function: (ssl-p &optional (acceptor *acceptor*)) Whether the current connection to the client is secure. See ACCEPTOR-SSL-P.","title":"ssl-p"},{"location":"hunchentoot/#taskmaster-max-accept-count","text":"Function: (taskmaster-max-accept-count taskmaster) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT.","title":"taskmaster-max-accept-count"},{"location":"hunchentoot/#taskmaster-max-thread-count","text":"Function: (taskmaster-max-thread-count taskmaster) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit.","title":"taskmaster-max-thread-count"},{"location":"hunchentoot/#taskmaster-thread-count","text":"Function: (taskmaster-thread-count taskmaster) Returns the current number of taskmaster requests.","title":"taskmaster-thread-count"},{"location":"hunchentoot/#too-many-taskmaster-requests","text":"Function: (too-many-taskmaster-requests taskmaster socket) Signal a \"too many requests\" error, just prior to closing the connection.","title":"too-many-taskmaster-requests"},{"location":"hunchentoot/#url-decode","text":"Function: (url-decode string &optional (external-format *hunchentoot-default-external-format*)) Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"url-decode"},{"location":"hunchentoot/#url-encode","text":"Function: (url-encode string &optional (external-format *hunchentoot-default-external-format*)) URL-encodes a string using the external format EXTERNAL-FORMAT. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"url-encode"},{"location":"hunchentoot/#within-request-p","text":"Function: (within-request-p) True if we're in the context of a request, otherwise nil.","title":"within-request-p"},{"location":"hunchentoot/#10-configuration-variables","text":"","title":"10. CONFIGURATION VARIABLES"},{"location":"hunchentoot/#catch-errors-p","text":"Variable Whether Hunchentoot should catch and log errors (or rather invoke the debugger).","title":"*catch-errors-p*"},{"location":"hunchentoot/#content-types-for-url-rewrite","text":"Variable The content types for which url-rewriting is OK. See *REWRITE-FOR-SESSION-URLS* .","title":"*content-types-for-url-rewrite*"},{"location":"hunchentoot/#default-connection-timeout","text":"Variable The default connection timeout used when an acceptor is reading from and writing to a socket stream.","title":"*default-connection-timeout*"},{"location":"hunchentoot/#default-content-type","text":"Variable The default content-type header which is returned to the client. If this is text content type, the character set used for encoding the response will automatically be added to the content type in a ``charset'' attribute.","title":"*default-content-type*"},{"location":"hunchentoot/#dispatch-table","text":"Variable A global list of dispatch functions.","title":"*dispatch-table*"},{"location":"hunchentoot/#file-upload-hook","text":"Variable If this is not NIL, it should be a unary function which will be called with a pathname for each file which is uploaded to Hunchentoot. The pathname denotes the temporary file to which the uploaded file is written. The hook is called directly before the file is created.","title":"*file-upload-hook*"},{"location":"hunchentoot/#handle-http-errors-p","text":"","title":"*handle-http-errors-p*"},{"location":"hunchentoot/#header-stream","text":"Variable If this variable is not NIL, it should be bound to a stream to which incoming and outgoing headers will be written for debugging purposes.","title":"*header-stream*"},{"location":"hunchentoot/#http-error-handler","text":"","title":"*http-error-handler*"},{"location":"hunchentoot/#hunchentoot-default-external-format","text":"Variable The external format used to compute the REQUEST object.","title":"*hunchentoot-default-external-format*"},{"location":"hunchentoot/#hunchentoot-version","text":"","title":"*hunchentoot-version*"},{"location":"hunchentoot/#lisp-errors-log-level","text":"Variable Log level for Lisp errors. Should be one of :ERROR (the default), :WARNING, or :INFO.","title":"*lisp-errors-log-level*"},{"location":"hunchentoot/#lisp-warnings-log-level","text":"Variable Log level for Lisp warnings. Should be one of :ERROR, :WARNING (the default), or :INFO.","title":"*lisp-warnings-log-level*"},{"location":"hunchentoot/#log-lisp-backtraces-p","text":"Variable Whether Lisp backtraces should be logged. Only has an effect if [*LOG-LISP-ERRORS-P*](#log-lisp-errors-p] is true as well.","title":"*log-lisp-backtraces-p*"},{"location":"hunchentoot/#log-lisp-errors-p","text":"Variable Whether Lisp errors in request handlers should be logged.","title":"*log-lisp-errors-p*"},{"location":"hunchentoot/#log-lisp-warnings-p","text":"Variable Whether Lisp warnings in request handlers should be logged.","title":"*log-lisp-warnings-p*"},{"location":"hunchentoot/#methods-for-post-parameters","text":"Variable A list of the request method types (as keywords) for which Hunchentoot will try to compute POST-PARAMETERS .","title":"*methods-for-post-parameters*"},{"location":"hunchentoot/#rewrite-for-session-urls","text":"Variable Whether HTML pages should possibly be rewritten for cookie-less session-management.","title":"*rewrite-for-session-urls*"},{"location":"hunchentoot/#session-gc-frequency","text":"Variable A session GC (see function SESSION-GC) will happen every *SESSION-GC-FREQUENCY* requests (counting only requests which create a new session) if this variable is not NIL. See SESSION-CREATED .","title":"*session-gc-frequency*"},{"location":"hunchentoot/#session-max-time","text":"Variable The default time (in seconds) after which a session times out.","title":"*session-max-time*"},{"location":"hunchentoot/#session-secret","text":"Variable A random ASCII string that's used to encode the public session data. This variable is initially unbound and will be set (using RESET-SESSION-SECRET ) the first time a session is created, if necessary. You can prevent this from happening if you set the value yourself before starting acceptors.","title":"*session-secret*"},{"location":"hunchentoot/#show-lisp-backtraces-p","text":"Variable Whether Lisp errors shown in HTML output should contain backtrace information.","title":"*show-lisp-backtraces-p*"},{"location":"hunchentoot/#show-lisp-errors-p","text":"Variable Whether Lisp errors in request handlers should be shown in HTML output.","title":"*show-lisp-errors-p*"},{"location":"hunchentoot/#tmp-directory","text":"Variable Directory for temporary files created by MAKE-TMP-FILE-NAME.","title":"*tmp-directory*"},{"location":"hunchentoot/#use-remote-addr-for-sessions","text":"Variable Whether the client's remote IP (as returned by REAL-REMOTE-ADDR ) should be encoded into the session string. If this value is true, a session will cease to be accessible if the client's remote IP changes. This might for example be an issue if the client uses a proxy server which doesn't send correct 'X_FORWARDED_FOR' headers.","title":"*use-remote-addr-for-sessions*"},{"location":"hunchentoot/#use-user-agent-for-sessions","text":"Variable Whether the 'User-Agent' header should be encoded into the session string. If this value is true, a session will cease to be accessible if the client sends a different 'User-Agent' header.","title":"*use-user-agent-for-sessions*"},{"location":"hunchentoot/#11-variables-in-the-context-of-a-request","text":"","title":"11. VARIABLES IN THE CONTEXT OF A REQUEST"},{"location":"hunchentoot/#acceptor_1","text":"Variable The current ACCEPTOR object.","title":"*acceptor*"},{"location":"hunchentoot/#reply","text":"Variable The current REPLY object.","title":"*reply*"},{"location":"hunchentoot/#request","text":"Variable The current REQUEST object.","title":"*request*"},{"location":"hunchentoot/#session_1","text":"Variable The current SESSION (can be NIL).","title":"*session*"},{"location":"hunchentoot/#12-constants","text":"","title":"12. CONSTANTS"},{"location":"hunchentoot/#http-accepted","text":"Constant: 202 HTTP return code (202) for 'Accepted'.","title":"+http-accepted+"},{"location":"hunchentoot/#http-authorization-required","text":"Constant: 401 HTTP return code (401) for 'Authorization Required'.","title":"+http-authorization-required+"},{"location":"hunchentoot/#http-bad-gateway","text":"Constant: 502 HTTP return code (502) for 'Bad Gateway'.","title":"+http-bad-gateway+"},{"location":"hunchentoot/#http-bad-request","text":"Constant: 400 HTTP return code (400) for 'Bad Request'.","title":"+http-bad-request+"},{"location":"hunchentoot/#http-conflict","text":"Constant: 409 HTTP return code (409) for 'Conflict'.","title":"+http-conflict+"},{"location":"hunchentoot/#http-continue","text":"Constant: 100 HTTP return code (100) for 'Continue'.","title":"+http-continue+"},{"location":"hunchentoot/#http-created","text":"Constant: 201 HTTP return code (201) for 'Created'.","title":"+http-created+"},{"location":"hunchentoot/#http-expectation-failed","text":"Constant: 417 HTTP return code (417) for 'Expectation Failed'.","title":"+http-expectation-failed+"},{"location":"hunchentoot/#http-failed-dependency","text":"Constant: 424 HTTP return code (424) for 'Failed Dependency'.","title":"+http-failed-dependency+"},{"location":"hunchentoot/#http-forbidden","text":"Constant: 403 HTTP return code (403) for 'Forbidden'.","title":"+http-forbidden+"},{"location":"hunchentoot/#http-gateway-time-out","text":"Constant: 504 HTTP return code (504) for 'Gateway Time-out'.","title":"+http-gateway-time-out+"},{"location":"hunchentoot/#http-gone","text":"Constant: 410 HTTP return code (410) for 'Gone'.","title":"+http-gone+"},{"location":"hunchentoot/#http-internal-server-error","text":"Constant: 500 HTTP return code (500) for 'Internal Server Error'.","title":"+http-internal-server-error+"},{"location":"hunchentoot/#http-length-required","text":"Constant: 411 HTTP return code (411) for 'Length Required'.","title":"+http-length-required+"},{"location":"hunchentoot/#http-method-not-allowed","text":"Constant: 405 HTTP return code (405) for 'Method Not Allowed'.","title":"+http-method-not-allowed+"},{"location":"hunchentoot/#http-moved-permanently","text":"Constant: 301 HTTP return code (301) for 'Moved Permanently'.","title":"+http-moved-permanently+"},{"location":"hunchentoot/#http-moved-temporarily","text":"Constant: 302 HTTP return code (302) for 'Moved Temporarily'.","title":"+http-moved-temporarily+"},{"location":"hunchentoot/#http-multi-status","text":"Constant: 207 HTTP return code (207) for 'Multi-Status'.","title":"+http-multi-status+"},{"location":"hunchentoot/#http-multiple-choices","text":"Constant: 300 HTTP return code (300) for 'Multiple Choices'.","title":"+http-multiple-choices+"},{"location":"hunchentoot/#http-network-authentication-required","text":"Constant: 511 HTTP return code (511) for 'Network Authentication Required'.","title":"+http-network-authentication-required+"},{"location":"hunchentoot/#http-no-content","text":"Constant: 204 HTTP return code (204) for 'No Content'.","title":"+http-no-content+"},{"location":"hunchentoot/#http-non-authoritative-information","text":"Constant: 203 HTTP return code (203) for 'Non-Authoritative Information'.","title":"+http-non-authoritative-information+"},{"location":"hunchentoot/#http-not-acceptable","text":"Constant: 406 HTTP return code (406) for 'Not Acceptable'.","title":"+http-not-acceptable+"},{"location":"hunchentoot/#http-not-found","text":"Constant: 404 HTTP return code (404) for 'Not Found'.","title":"+http-not-found+"},{"location":"hunchentoot/#http-not-implemented","text":"Constant: 501 HTTP return code (501) for 'Not Implemented'.","title":"+http-not-implemented+"},{"location":"hunchentoot/#http-not-modified","text":"Constant: 304 HTTP return code (304) for 'Not Modified'.","title":"+http-not-modified+"},{"location":"hunchentoot/#http-ok","text":"Constant: 200 HTTP return code (200) for 'OK'.","title":"+http-ok+"},{"location":"hunchentoot/#http-partial-content","text":"Constant: 206 HTTP return code (206) for 'Partial Content'.","title":"+http-partial-content+"},{"location":"hunchentoot/#http-payment-required","text":"Constant: 402 HTTP return code (402) for 'Payment Required'.","title":"+http-payment-required+"},{"location":"hunchentoot/#http-precondition-failed","text":"Constant: 412 HTTP return code (412) for 'Precondition Failed'.","title":"+http-precondition-failed+"},{"location":"hunchentoot/#http-precondition-required","text":"Constant: 428 HTTP return code (428) for 'Precondition Required'.","title":"+http-precondition-required+"},{"location":"hunchentoot/#http-proxy-authentication-required","text":"Constant: 407 HTTP return code (407) for 'Proxy Authentication Required'.","title":"+http-proxy-authentication-required+"},{"location":"hunchentoot/#http-request-entity-too-large","text":"Constant: 413 HTTP return code (413) for 'Request Entity Too Large'.","title":"+http-request-entity-too-large+"},{"location":"hunchentoot/#http-request-header-fields-too-large","text":"Constant: 431 HTTP return code (431) for 'Request Header Fields Too Large'.","title":"+http-request-header-fields-too-large+"},{"location":"hunchentoot/#http-request-time-out","text":"Constant: 408 HTTP return code (408) for 'Request Time-out'.","title":"+http-request-time-out+"},{"location":"hunchentoot/#http-request-uri-too-large","text":"Constant: 414 HTTP return code (414) for 'Request-URI Too Large'.","title":"+http-request-uri-too-large+"},{"location":"hunchentoot/#http-requested-range-not-satisfiable","text":"Constant: 416 HTTP return code (416) for 'Requested range not satisfiable'.","title":"+http-requested-range-not-satisfiable+"},{"location":"hunchentoot/#http-reset-content","text":"Constant: 205 HTTP return code (205) for 'Reset Content'.","title":"+http-reset-content+"},{"location":"hunchentoot/#http-see-other","text":"Constant: 303 HTTP return code (303) for 'See Other'.","title":"+http-see-other+"},{"location":"hunchentoot/#http-service-unavailable","text":"Constant: 503 HTTP return code (503) for 'Service Unavailable'.","title":"+http-service-unavailable+"},{"location":"hunchentoot/#http-switching-protocols","text":"Constant: 101 HTTP return code (101) for 'Switching Protocols'.","title":"+http-switching-protocols+"},{"location":"hunchentoot/#http-temporary-redirect","text":"Constant: 307 HTTP return code (307) for 'Temporary Redirect'.","title":"+http-temporary-redirect+"},{"location":"hunchentoot/#http-too-many-requests","text":"Constant: 429 HTTP return code (429) for 'Too Many Requests'.","title":"+http-too-many-requests+"},{"location":"hunchentoot/#http-unsupported-media-type","text":"Constant: 415 HTTP return code (415) for 'Unsupported Media Type'.","title":"+http-unsupported-media-type+"},{"location":"hunchentoot/#http-use-proxy","text":"Constant: 305 HTTP return code (305) for 'Use Proxy'.","title":"+http-use-proxy+"},{"location":"hunchentoot/#http-version-not-supported","text":"Constant: 505 HTTP return code (505) for 'Version not supported'.","title":"+http-version-not-supported+"},{"location":"hunchentoot/#13-hunchentoot-condition","text":"Class Superclass for all conditions related to Hunchentoot.","title":"13. HUNCHENTOOT-CONDITION"},{"location":"hunchentoot/#14-hunchentoot-warning","text":"Class Superclass for all warnings related to Hunchentoot.","title":"14. HUNCHENTOOT-WARNING"},{"location":"hunchentoot/#15-taskmaster","text":"","title":"15. TASKMASTER"},{"location":"hunchentoot/#taskmaster_1","text":"Class An instance of this class is responsible for distributing the work of handling requests for its acceptor. This is an \"abstract\" class in the sense that usually only instances of subclasses of TASKMASTER will be used. Direct superclasses: STANDARD-OBJECT Direct subclasses: MULTI-THREADED-TASKMASTER , SINGLE-THREADED-TASKMASTER","title":"taskmaster"},{"location":"hunchentoot/#relevant-methods_4","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#shutdown","text":"Function: (shutdown taskmaster) Shuts down the taskmaster, i.e. frees all resources that were set up by it. For example, a multi-threaded taskmaster might terminate all threads that are currently associated with it. This function is called by the acceptor's STOP method.","title":"shutdown"},{"location":"hunchentoot/#execute-acceptor","text":"Function: (execute-acceptor taskmaster) This is a callback called by the acceptor once it has performed all initial processing to start listening for incoming connections (see START-LISTENING). It usually calls the ACCEPT-CONNECTIONS method of the acceptor, but depending on the taskmaster instance the method might be called from a new thread.","title":"execute-acceptor"},{"location":"hunchentoot/#handle-incoming-connection","text":"Function: (handle-incoming-connection taskmaster socket) This function is called by the acceptor to start processing of requests on a new incoming connection. SOCKET is the usocket instance that represents the new connection (or a socket handle on LispWorks). The taskmaster starts processing requests on the incoming connection by calling the PROCESS-CONNECTION method of the acceptor instance. The SOCKET argument is passed to PROCESS-CONNECTION as an argument.","title":"handle-incoming-connection"},{"location":"hunchentoot/#start-thread","text":"Function: (start-thread taskmaster thunk &key name) Start a name thread in which to call the THUNK, in the context of the given TASKMASTER. Keyword arguments provide TASKMASTER-dependent options. Return a thread object. Hunchentoot taskmaster methods will call it with the taskmaster as the context, allowing hunchentoot extensions to define specialized methods that may e.g. wrap the thunk within a proper set of bindings and condition handlers.","title":"start-thread"},{"location":"hunchentoot/#direct-slots_1","text":"","title":"DIRECT SLOTS"},{"location":"hunchentoot/#acceptor_2","text":"Readers: taskmaster-acceptor Writers: (setf taskmaster-acceptor) A backpointer to the acceptor instance this taskmaster works for.","title":"acceptor"},{"location":"hunchentoot/#multi-threaded-taskmaster","text":"Class An abstract class for taskmasters that use multiple threads. For a concrete class to instantiate, use one-thread-per-connection-taskmaster. Direct superclasses: TASKMASTER Direct subclasses: ONE-THREAD-PER-CONNECTION-TASKMASTER","title":"multi-threaded-taskmaster"},{"location":"hunchentoot/#direct-slots_2","text":"","title":"DIRECT SLOTS"},{"location":"hunchentoot/#acceptor-process","text":"A process that accepts incoming connections and hands them off to new processes for request handling.","title":"acceptor-process"},{"location":"hunchentoot/#one-thread-per-connection-taskmaster","text":"Class A taskmaster that starts one thread for listening to incoming requests and one new thread for each incoming connection. If MAX-THREAD-COUNT is null, a new thread will always be created for each request. If MAX-THREAD-COUNT is supplied, the number of request threads is limited to that. Furthermore, if MAX-ACCEPT-COUNT is not supplied, an HTTP 503 will be sent if the thread limit is exceeded. Otherwise, if MAX-ACCEPT-COUNT is supplied, it must be greater than MAX-THREAD-COUNT; in this case, requests are accepted up to MAX-ACCEPT-COUNT, and only then is HTTP 503 sent. It is important to note that MAX-ACCEPT-COUNT and the HTTP 503 behavior described above is racing with the acceptor listen backlog. If we are receiving requests faster than threads can be spawned and 503 sent, the requests will be silently rejected by the kernel. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide MAX-THREAD-COUNT but leave MAX-ACCEPT-COUNT null. This will immediately result in HTTP 503 when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both MAX-THREAD-COUNT and a somewhat larger value for MAX-ACCEPT-COUNT. This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be HTTP 503. This is the default taskmaster implementation for multi-threaded Lisp implementations. Direct superclasses: MULTI-THREADED-TASKMASTER No subclasses.","title":"one-thread-per-connection-taskmaster"},{"location":"hunchentoot/#direct-slots_3","text":"","title":"DIRECT SLOTS"},{"location":"hunchentoot/#max-thread-count","text":"Type: (OR INTEGER NULL) Initargs: :max-thread-count Readers: taskmaster-max-thread-count Writers: (setf taskmaster-max-thread-count) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit.","title":"max-thread-count"},{"location":"hunchentoot/#thread-count","text":"Type: INTEGER Initform: 0 Readers: taskmaster-thread-count Writers: (setf taskmaster-thread-count) The number of taskmaster processing threads currently running.","title":"thread-count"},{"location":"hunchentoot/#thread-count-lock","text":"In the absence of 'atomic-incf', we need this to atomically increment and decrement the request count.","title":"thread-count-lock"},{"location":"hunchentoot/#max-accept-count","text":"Type: (OR INTEGER NULL) Initargs: :max-accept-count Readers: taskmaster-max-accept-count Writers: (setf taskmaster-max-accept-count) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT.","title":"max-accept-count"},{"location":"hunchentoot/#accept-count","text":"Type: INTEGER Initform: 0 The number of connection currently accepted by the taskmaster. These connections are not ensured to be processed, thay may be waiting for an empty processing slot or rejected because the load is too heavy.","title":"accept-count"},{"location":"hunchentoot/#accept-count-lock","text":"In the absence of 'atomic-incf', we need this to atomically increment and decrement the accept count.","title":"accept-count-lock"},{"location":"hunchentoot/#wait-queue","text":"A queue that we use to wait for a free connection.","title":"wait-queue"},{"location":"hunchentoot/#wait-lock","text":"The lock for the connection wait queue.","title":"wait-lock"},{"location":"hunchentoot/#worker-thread-name-format","text":"Type: (OR STRING NULL) Initargs: :worker-thread-name-format Initform: \"hunchentoot-worker-~A\"","title":"worker-thread-name-format"},{"location":"hunchentoot/#single-threaded-taskmaster","text":"Class A taskmaster that runs synchronously in the thread where the START function was invoked (or in the case of LispWorks in the thread started by COMM:START-UP-SERVER). This is the simplest possible taskmaster implementation in that its methods do nothing but calling their acceptor \"sister\" methods - EXECUTE-ACCEPTOR calls ACCEPT-CONNECTIONS, HANDLE-INCOMING-CONNECTION calls PROCESS-CONNECTION. Direct superclasses: TASKMASTER","title":"single-threaded-taskmaster"},{"location":"hunchentoot/#advanced-topics","text":"","title":"ADVANCED TOPICS"},{"location":"hunchentoot/#customizing-session-behaviour","text":"For everyday session usage, you will probably just use START-SESSION , SESSION-VALUE , and maybe DELETE-SESSION-VALUE and *SESSION* . However, there are two ways to customize the way Hunchentoot maintains sessions. One way is to mostly leave the session mechanism intact but to tweak it a bit: The publicly visible part of a session is encoded using a secret which you can set yourself. And it is stored using a cookie (or GET parameter) name that you can override. Each session receives a new ID when it is created and you can implement a more robust way to do that. You can arrange to be called whenever a session is created to trigger some action. You might also do this to invent your own session garbage collection . By default, all sessions are stored in a global alist in memory. You can't change the alist part, but you can distribute your sessions over different \"databases\" . By default, every operation which modifies sessions or one of the session databases is guarded by a global lock, but you can arrange to provide different locks for this. The other way to customize Hunchentoot's sessions is to completely replace them. This is actually pretty easy: Create your own class to store state (which doesn't have to and probably shouldn't inherit from SESSION ) and implement methods for SESSION-VERIFY and SESSION-COOKIE-VALUE - that's it. Hunchentoot will continue to use cookies and/or to rewrite URLs to keep track of session state and it will store \"the current session\" (whatever that is in your implementation) in *SESSION* . Everything else (like persisting sessions, GC, getting and setting values) you'll have to take care of yourself and the other session functions (like START-SESSION or SESSION-VALUE ) won't work anymore. (Almost) total freedom, but a lot of responsibility as well... :) reset-session-secret session-cookie-name session-cookie-value session-created next-session-id session-db session-db-lock session-verify","title":"CUSTOMIZING SESSION BEHAVIOUR"},{"location":"hunchentoot/#customizing-acceptor-behaviour","text":"If you want to modify what acceptors do, you should subclass ACCEPTOR (or SSL-ACCEPTOR ) and specialize the generic functions that constitute their behaviour (see example below). The life of an acceptor looks like this: It is started with the function START which immediately calls START-LISTENING and then applies the function EXECUTE-ACCEPTOR to its taskmaster . This function will eventually call ACCEPT-CONNECTIONS which is responsible for setting things up to wait for clients to connect. For each incoming connection which comes in, HANDLE-INCOMING-CONNECTION is applied to the taskmaster which will either call PROCESS-CONNECTION directly, or will create a thread to call it. PROCESS-CONNECTION calls INITIALIZE-CONNECTION-STREAM before it does anything else, then it selects and calls a function which handles the request , and finally it sends the reply to the client before it calls RESET-CONNECTION-STREAM . If the connection is persistent, this procedure is repeated (except for the intialization step) in a loop until the connection is closed. The acceptor is stopped with STOP . If you just want to use the standard acceptors that come with Hunchentoot, you don't need to know anything about the functions listed in this section. start-listening accept-connections acceptor-log-access acceptor-log-message acceptor-status-message detach-socket initialize-connection-stream process-connection reset-connection-stream","title":"CUSTOMIZING ACCEPTOR BEHAVIOUR"},{"location":"hunchentoot/#an-example-of-how-to-subclass-acceptor","text":"This example shows how to subclass ACCEPTOR in order to provide Hunchentoot with basic virtual host support. It assumes Hunchentoot is sitting behind an Internet-facing reverse-proxy web server that maps the host (or domain) part of incoming HTTP requests to unique localhost ports. (ql:quickload '(\"hunchentoot\" \"drakma\")) ;;; Subclass ACCEPTOR (defclass vhost (hunchentoot:acceptor) ;; slots ((dispatch-table :initform '() :accessor dispatch-table :documentation \"List of dispatch functions\")) ;; options (:default-initargs ; default-initargs must be used :address \"127.0.0.1\")) ; because ACCEPTOR uses it ;;; Specialise ACCEPTOR-DISPATCH-REQUEST for VHOSTs (defmethod hunchentoot:acceptor-dispatch-request ((vhost vhost) request) ;; try REQUEST on each dispatcher in turn (mapc (lambda (dispatcher) (let ((handler (funcall dispatcher request))) (when handler ; Handler found. FUNCALL it and return result (return-from hunchentoot:acceptor-dispatch-request (funcall handler))))) (dispatch-table vhost)) (call-next-method)) ;;; ====================================================================== ;;; Now all we need to do is test it ;;; Instantiate VHOSTs (defvar vhost1 (make-instance 'vhost :port 50001)) (defvar vhost2 (make-instance 'vhost :port 50002)) ;;; Populate each dispatch table (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo1) (dispatch-table vhost1)) (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo2) (dispatch-table vhost2)) ;;; Define handlers (defun foo1 () \"Hello\") (defun foo2 () \"Goodbye\") ;;; Start VHOSTs (hunchentoot:start vhost1) (hunchentoot:start vhost2) ;;; Make some requests (drakma:http-request \"http://127.0.0.1:50001/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:39] \"GET /foo HTTP/1.1\" 200 5 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Hello\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"5\") (:DATE . \"Fri, 08 Jun 2012 14:30:39 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50001/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CA90059}> ;;; T ;;; \"OK\" (drakma:http-request \"http://127.0.0.1:50002/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:47] \"GET /foo HTTP/1.1\" 200 7 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Goodbye\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"7\") (:DATE . \"Fri, 08 Jun 2012 14:30:47 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50002/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CAE8059}> ;;; T ;;; \"OK\" How to make each VHOST write to separate access log streams (or files) is left as an exercise to the reader.","title":"An example of how to subclass ACCEPTOR"},{"location":"hunchentoot/#taskmasters","text":"As a \"normal\" Hunchentoot user, you can completely ignore taskmasters and skip this section. But if you're still reading, here are the dirty details: Each acceptor has a taskmaster associated with it at creation time. It is the taskmaster's job to distribute the work of accepting and handling incoming connections. The acceptor calls the taskmaster if appropriate and the taskmaster calls back into the acceptor. This is done using the generic functions described in this and the previous section. Hunchentoot comes with two standard taskmaster implementations - one (which is the default used on multi-threaded Lisps) which starts a new thread for each incoming connection and one which handles all requests sequentially. It should for example be relatively straightforward to create a taskmaster which allocates threads from a fixed pool instead of creating a new one for each connection. You can control the resources consumed by a threaded taskmaster via two initargs. :max-thread-count lets you set the maximum number of request threads that can be processes simultaneously. If this is nil , the is no thread limit imposed. :max-accept-count lets you set the maximum number of requests that can be outstanding (i.e. being processed or queued for processing). If :max-thread-count is supplied and :max-accept-count is NIL , then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated if there are more than the max-thread-count threads processing requests. If both :max-thread-count and :max-accept-count are supplied, then max-thread-count must be less than max-accept-count; if more than max-thread-count requests are being processed, then requests up to max-accept-count will be queued until a thread becomes available. If more than max-accept-count requests are outstanding, then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide :max-thread-count but leave :max-accept-count null. This will immediately result in +HTTP-SERVICE-UNAVAILABLE+ when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both :max-thread-count and a somewhat larger value for :max-accept-count . This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be +HTTP-SERVICE-UNAVAILABLE+ . The default for these values is 100 and 120, respectively. If you want to implement your own taskmasters, you should subclass TASKMASTER or one of its subclasses, SINGLE-THREADED-TASKMASTER or ONE-THREAD-PER-CONNECTION-TASKMASTER , and specialize the generic functions in this section. execute-acceptor handle-incoming-connection start-thread create-request-handler-thread shutdown Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"TASKMASTERS"},{"location":"hunchentoot/#some-more-technical-details","text":"Hunchentoot will only work with Lisps where the character codes of all Latin-1 characters coincide with their Unicode code points (which is the case for all current implementations I know). Source code can be downloaded from https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz . The current development version of Hunchentoot can be found at https://github.com/edicl/hunchentoot . If you want to send patches, please fork the github repository and send pull requests.","title":"SOME MORE TECHNICAL DETAILS"},{"location":"hunchentoot/#without-clssl","text":"You can compile Hunchentoot without SSL support - and thus without the need to have CL+SSL - if you add :HUNCHENTOOT-NO-SSL to *FEATURES* before you compile it.","title":"Without cl+ssl"},{"location":"hunchentoot/#clbuild","text":"Hunchentoot and its dependencies can also be installed with clbuild .","title":"clbuild"},{"location":"hunchentoot/#gentoo-linux","text":"There's also a port for Gentoo Linux thanks to Matthew Kennedy.","title":"Gentoo Linux"},{"location":"hunchentoot/#running-hunchentoot-on-port-80","text":"Hunchentoot does not come with code to help with running it on a privileged port (i.e. port 80 or 443) on Unix-like operating systems. Modern Unix-like systems have specific, non-portable ways to allow non-root users to listen to privileged ports, so including such functionality in Hunchentoot was considered unnecessary. Please refer to online resources for help. At the time of this writing, the YAWS documentation has a comprehensive writeup on the topic.","title":"Running Hunchentoot on port 80"},{"location":"hunchentoot/#hunchentoot-behind-a-proxy","text":"If you're feeling unsecure about exposing Hunchentoot to the wild, wild Internet or if your Lisp web application is part of a larger website, you can hide it behind a proxy server . One approach that I have used several times is to employ Apache's mod_proxy module with a configuration that looks like this: ProxyPass /hunchentoot http://127.0.0.1:3000/hunchentoot ProxyPassReverse /hunchentoot http://127.0.0.1:3000/hunchentoot This will tunnel all requests where the URI path begins with \"/hunchentoot\" to a (Hunchentoot) server listening on port 3000 on the same machine. Of course, there are several other (more lightweight) web proxies that you could use instead of Apache.","title":"Hunchentoot behind a proxy"},{"location":"hunchentoot/#support","text":"The development version of Hunchentoot can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"SUPPORT"},{"location":"iterate/","text":"iterate - Psuedocodic Iteration Version: 1.5 Repository: iterate/iterate - Gitlab In case of any inaccuracies, ambiguities or suggestions, please create an issue here . iterate is a powerful iteration facility for Common Lisp, and a alternative to loop . As opposed to loop , iterate is more lispy, extensible, besides being more powerful. See The Iterate Manual for a more detailed explanation of the various facilities. For a tutorial on looping in Common Lisp, check out Loops, Iterate and Mapping - The Common Lisp Cookbook . HIGHLIGHTS def* : extensibility display-iterate-clauses : quick help for clauses dsetq : for use outside the iter form finally-protected : for protecting against unwindings finding-maximizing : loop equivalent can be quite verbose for : lots of variants! generate in : loop equivalent can be quite verbose there's no support for \"true\" parallel assignment - see with OTHER POINTS iterate does not declare variables unless asked to. See Types and Declarations . into var stores the value into var instead of returning it. There, probably, are some idiosyncrasies involved with running the epilogue code - it is not run \"always\": always , finding , finish , thereis . Notes for myself - indications of incomplete documentation Documentation for finding is incomplete here. Documentation for def* , for has been omitted here. When are the variable values for prologue defined? Will there be future versions of iterate? What is the compatibility relation between terminate and finish for for-next Generalized Drivers ? Installation If quicklisp is set-up, simply (ql:quickload 'iterate) . Otherwise head over here . Accumulation vs Reduction The differences between accumulate and reducing are slight. One difference is that the functions take their arguments in a different order. Another is that in the absence of init-val, accumulate will use nil, whereas reducing will generate different code that avoids any dependence on the initial value. The reason for having both clauses is that one usually thinks of reductions (like sum) and accumulations (like collect) as different beasts. API (CLAUSE) REFERENCE accumulate accumulate expr by func &optional initial-value init-val into var This is a general-purpose accumulation clause. func should be a function of two arguments, the value of expr and the value accumulated so far in the iteration, and it should return the updated value. If no initial value is supplied, nil is used. CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)))) (3 2 1) CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)) initial-value '(init))) (3 2 1 INIT) CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)) initial-value '(init) into var)) NIL See Accumulations , Accumulation vs Reduction and reducing . accumulating An alias for accumulate . adjoining adjoining exptr &optional into var test test at place result-type type Like collect , but only adds the value of exptr if it is not already present. test, which defaults to #'eql, is the test to be used with member. after-each after-each &rest forms Executes forms at the end of the loop body, after each iteration. Forms may contain iterate clauses. CL-USER> (iter (for i below 4) (after-each (print var)) (if (oddp i) (collect i into var) (collect (* 2 i) into var))) ; (0) ; (0 1) ; (0 1 4) ; (0 1 4 3) NIL See Code Placement and Problems with Code Movement . always always expr CL-USER> (iter (for i below 4) (always (evenp i))) NIL If expr ever evaluates to nil, then nil is immediately returned; the epilogue code is not executed. If expr never evaluates to nil, the epilogue code is executed and the last value of expr (or t if expr was never evaluated) is returned (whereas loop would constantly return t). See Aggregated Boolean Tests . appending appending exptr &optional into var at place Like collect , but behaves like the Common Lisp append , and works only on lists. CL-USER> (iter (for i in '((1) (2 3) (4 5 6))) (appending i)) (1 2 3 4 5 6) CL-USER> (iter (for i in '((1) (2 3) (4 5 6))) (appending i into var)) NIL See Accumulations . as An alias for for . collect collect exptr &optional into var test test at place result-type type CL-USER> (iter (for i from 1 to 5) (collect i)) (1 2 3 4 5) CL-USER> (iter (for i from 1 to 5) (collect i at start)) ;; likely to be faster (5 4 3 2 1) place can be either beginning / start or end : default value is end . type should be a subtype of sequence - default is list ; however, the type of sequence being constructed inside the loop is undefined when a non-list type is specified. CL-USER> (iter (for i from 1 to 3) (collect i into vec result-type 'vector) (print vec) (finally (return vec))) ; (1) ; (1 2) ; (1 2 3) #(1 2 3) type or place may be optionally quoted. See Accumulations . collecting Alias for collect . count Alias for counting . This, probably, overrides the CL count when used in top-level inside an iterate loop. CL-USER> (iter (for i in '(1 2 3)) (finally (return (count 1 '(1 2 1))))) 2 counting counting expr &optional into var See Reductions and accumulate . declare-variables (declare (declare-variables)) iterate does not declare variable types unless asked to. Declaration of types of user introduced symbols can be done by either the usual Common Lisp declare , but this declaration should be inside the iter form. Declaration of internal variables or use of the requires one to use declare-variables , or set iterate:::*always-declare-variables* to t`. CL-USER> (macroexpand-1 '(iter (for (the fixnum el) in '(1 2 3)) (declare (DECLARE-VARIABLES)) (count (oddp el)))) ;; note that this produces a type declaration for el. CL-USER> (macroexpand-1 '(iter (for el in '(1 2 3)) (declare (DECLARE-VARIABLES)) (count (oddp el)))) ;; this does not produce a type declaration for el. CL-USER> (macroexpand-1 '(iter (for (the fixnum el) in '(1 2 3)) (count (oddp el)))) ;; this does not produce any declarations. See Types and Declarations . defclause-sequence [Undocumented here.] See Extensibility Aids . defmacro-clause [Undocumented here] See Rolling Your Own . defmacro-driver [Undocumented here.] See Writing Drivers . defsynonym [Undocumented here.] See Extensibility Aids . display-iterate-clauses display-iterate-clauses &optional clause-spec CL-USER> (display-iterate-clauses 'repeat) ; REPEAT Repeat the loop some number of times T CL-USER> (display-iterate-clauses '(for in-vector)) ; FOR IN-VECTOR &OPTIONAL FROM UPFROM DOWNFROM TO DOWNTO ABOVE BELOW BY ; WITH-INDEX Elements of a vector T See On-line help . dsetq dsetq template expr Can be used outside iter. CL-USER> (foo) FIRST SECOND CL-USER> (progn (dsetq (values a b) (foo)) (list a b)) ;; undeclared variables warning (FIRST SECOND) See Destructuring . else else &rest forms Forms are executed if loop is never entered, but is terminated normally. CL-USER> (iter (for i in '(1 2 3)) (while nil) (else (write 'else))) ; ELSE NIL See Code Placement and Problems with Code Movement . finally finally &rest forms Forms are executed after a normal termination of the loop. CL-USER> (iter (for i in '(1 2 3)) (finally (write 'end))) ; END NIL See Code Placement and Problems with Code Movement . finally-protected finally-protected &rest forms Forms are executed \"always\" - regardless of whether the termination was notmal CL-USER> (iter (for i in-vector '(1 2 3)) (finally-protected (write 'error))) ;; warnings ERROR ; Evaluation aborted on #<SIMPLE-TYPE-ERROR expected-type: VECTOR datum: (1 2 3)>. CL-USER> (iter (for i in '(1 2 3)) (finally-protected (write 'no-error))) ; NO-ERROR NIL See Code Placement and Problems with Code Movement . finding finding expr such-that test &optionally into var on-failure failure-value The loop terminates (with epilogue code) whenever test evaluates to non- nil . expr that satifies the test , or failure-value , or nil is returned (unless modified by epilogue). failure-value is always evaluated. CL-USER> (iter (for x in '(1 2 3)) (finding x such-that #'evenp on-failure 'not-found)) 2 CL-USER> (iter (for x in '(1 2 3)) (finding x such-that #'evenp on-failure (error \"not found\"))) ; Evaluation aborted on #<SIMPLE-ERROR \"not found\" {1002F63063}>. CL-USER> (iter (for x in '(1 2 3)) (if (evenp x) (leave x)) (finally (error \"not found\"))) 2 finding expr maximizing m-expr &optionally into var finding expr minimizing m-expr &optionally into var Returns expr corresponding to the maximum value of m-expr . If m-expr is never evaluated (how?), the return value is nil or 0 depending on the type (or its absence) of expr (or var if supplied.) Here, m-expr can also be a list of two symbols. CL-USER> CL-USER> (iter (for list in '((1) (2 3) nil)) (finding list maximizing (length list))) (2 3) CL-USER> (iter (for i in '(1 2 3)) (finding (* 2 i) maximizing (- i) into (twice neg)) (finally (return (values twice neg)))) 2 -1 [Example required for the case when m-expr is not evaluated.] See Finders . finish finish Stop the loop (and run the epilogue code). CL-USER> (iter (for i in '(1 2 3)) (if (evenp i) (finish))) NIL See Control Flow . first-iteration-p first-iteration-p t in the first cycle of the loop, otherwise nil . CL-USER> (iter (for el in '(nil 1 2 nil 3)) (when el (unless (first-iteration-p) (princ \", \")) (princ el))) ; , 1, 2, 3 NIL See Boolean Tests . first-time-p first-iteration-p t only when the expression is evaluated for the first time. CL-USER> (iter (for el in '(nil 1 2 nil 3)) (when el (unless (first-time-p) (princ \", \")) (princ el))) ; 1, 2, 3 NIL See Boolean Tests . for [Undocumented here.] See Numeric Iteration Sequence Iteration Variable Binding and Setting Generalized Drivers Previous Values of Driver Variables generate See Generators and for . CL-USER> (iter (for el in '(a b nil c)) (generate i upfrom 1) (if el (collect (cons el (next i))))) ((A . 1) (B . 2) (C . 3)) for can be replaced by generate to achieve the desired result, except in the case of Variable Binding and Setting . generating Alias for generate if-first-time if-first-time then &optional else CL-USER> (iter (for i in '(1 2 3)) (if-first-time (princ 'first) (print 'not-first))) ; FIRST ; NOT-FIRST ; NOT-FIRST NIL See Control Flow . in in name &rest forms CL-USER> (defvar ar #2A((1 2 3) (4 5 6))) AR CL-USER> (iter outer (for i below (array-dimension ar 0)) (iter (for j below (array-dimension ar 1)) (in outer (collect (aref ar i j))))) (1 2 3 4 5 6) See Named Blocks . initially in &rest forms Place the forms in the prologue of the loop. CL-USER> (iter (initially (princ 'hi)) (for i below 3) (print i)) ; HI ; 0 ; 1 ; 2 NIL CL-USER> (iter (for i below 3) (initially (princ i))) ; -1 ;; this is probably an undefined behaviour. NIL See Code Placement and Problems with Code Movement . leave leave &optional value Returns from the current iterate form with value or nil . CL-USER> (iter (for i below 3) (leave (iter (for j below 2) (if (oddp j) (leave j))))) 1 See Control Flow . maximize maximize expr &optional into var CL-USER> (iter (for list in '((1) (1 2) nil)) (maximize (length list))) 2 See Reductions and finding . maximizing Alias for maximize . minimize minimize expr &optional into var CL-USER> (iter (for list in '((1) (1 2) nil)) (minimize (length list))) 0 See Reductions and finding . minimizing Alias for minimize . multiply multiply expr &optional into var CL-USER> (iter (for i from 1 to 5) (multiply i)) 120 Initial value of * var`* is 1. See Reductions . multiplying Alias for [multiply](# nconcing nconcing exptr &optional into var test test at place result-type type See Accumulations and collect . never never expr Effectively (always (not expr)) , but does not influence the last value returned by a possible other always clause. CL-USER> (iter (repeat 2) (always 2) (never nil)) 2 See Aggregated Boolean Tests next See generate . next-iteration next-iteration CL-USER> (iter (for i below 3) (if (oddp i) (next-iteration) (collect i))) (0 2) nunioning nunioning exptr &optional into var test test at place result-type type See Accumulations and collect . reducing reducing expr by func &optional initial-value init-val into var CL-USER> (iter (for i in '(1 2 3)) (reducing i by (lambda (value-so-far i) (cons i value-so-far)) initial-value ())) (3 2 1) See Reductions , Accumulation vs Reduction and accumulate . repeat repeat n Repeat the loop n times. See Drivers . CL-USER> (iter (repeat 3) (print 'doing)) ; DOING ; DOING ; DOING NIL sum sum expr &optional into var CL-USER> (iter (for i from 1 to 5) (sum i)) 15 summing Alias for sum . terminate `terminate Use to terminate for-next clause. Effectively an alias for finish - but use with for-next to maintain compatibility with future versions of iterate (!). CL-USER> (iter (for i upfrom 0) (if (> i 5) (terminate) (collect i))) (0 1 2 3 4 5) CL-USER> (iter (initially (setq i 0)) (for i next (if (> i 10) (terminate) (incf i)))) NIL See Generalized Drivers . thereis thereis expr If expr is ever non- nil , its value is returned without running the epilogue code. Otherwise epilogue code is run, and nil is returned. Cannot be used with always or never . See Aggregated Boolean Tests . unioning unioning exptr &optional into var test test at place result-type type See Accumulations and collect . until until expr CL-USER> (iter (for i in '(1 2 3 4 5)) (until (> i 5)) (collect i)) (1 2 3 4 5) Equivalent to (if expr (finish)) . See finish and Control Flow . while repeat n until expr Equivalent to (if (not expr) (finish)) . CL-USER> (iter (for i below 10) (while (= 0 (rem i 5))) (collect i)) (0) See finish and Control Flow . with with var &optional = value var is bound to value before the loop is entered. Binding happens sequentially, as while using a let* , and not in parallel as with let . CL-USER> (iter (with i = 0) (while (< i 3)) (collect (incf i))) (1 2 3) CL-USER> (iter (with i = 1) (for i below 3) (collect (incf i))) ; Evaluation aborted on #<SIMPLE-ERROR \"Iterate~@[, in ~a~]:~%Duplicate variable: ~a\" {1004185183}>. See Variable Binding and Setting and Parallel Binding and Stepping . OTHER RESOURCES ON ITERATE The Iterate Manual Comparing LOOP and ITERATE Loop v Iterate - SabraOnTheHill [DLI]: appendix/Don't Loop, Iterate","title":"iterate - Psuedocodic Iteration"},{"location":"iterate/#iterate-psuedocodic-iteration","text":"Version: 1.5 Repository: iterate/iterate - Gitlab In case of any inaccuracies, ambiguities or suggestions, please create an issue here . iterate is a powerful iteration facility for Common Lisp, and a alternative to loop . As opposed to loop , iterate is more lispy, extensible, besides being more powerful. See The Iterate Manual for a more detailed explanation of the various facilities. For a tutorial on looping in Common Lisp, check out Loops, Iterate and Mapping - The Common Lisp Cookbook .","title":"iterate - Psuedocodic Iteration"},{"location":"iterate/#highlights","text":"def* : extensibility display-iterate-clauses : quick help for clauses dsetq : for use outside the iter form finally-protected : for protecting against unwindings finding-maximizing : loop equivalent can be quite verbose for : lots of variants! generate in : loop equivalent can be quite verbose there's no support for \"true\" parallel assignment - see with","title":"HIGHLIGHTS"},{"location":"iterate/#other-points","text":"iterate does not declare variables unless asked to. See Types and Declarations . into var stores the value into var instead of returning it. There, probably, are some idiosyncrasies involved with running the epilogue code - it is not run \"always\": always , finding , finish , thereis .","title":"OTHER POINTS"},{"location":"iterate/#notes-for-myself-indications-of-incomplete-documentation","text":"Documentation for finding is incomplete here. Documentation for def* , for has been omitted here. When are the variable values for prologue defined? Will there be future versions of iterate? What is the compatibility relation between terminate and finish for for-next Generalized Drivers ?","title":"Notes for myself - indications of incomplete documentation"},{"location":"iterate/#installation","text":"If quicklisp is set-up, simply (ql:quickload 'iterate) . Otherwise head over here .","title":"Installation"},{"location":"iterate/#accumulation-vs-reduction","text":"The differences between accumulate and reducing are slight. One difference is that the functions take their arguments in a different order. Another is that in the absence of init-val, accumulate will use nil, whereas reducing will generate different code that avoids any dependence on the initial value. The reason for having both clauses is that one usually thinks of reductions (like sum) and accumulations (like collect) as different beasts.","title":"Accumulation vs Reduction"},{"location":"iterate/#api-clause-reference","text":"","title":"API (CLAUSE) REFERENCE"},{"location":"iterate/#accumulate","text":"accumulate expr by func &optional initial-value init-val into var This is a general-purpose accumulation clause. func should be a function of two arguments, the value of expr and the value accumulated so far in the iteration, and it should return the updated value. If no initial value is supplied, nil is used. CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)))) (3 2 1) CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)) initial-value '(init))) (3 2 1 INIT) CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)) initial-value '(init) into var)) NIL See Accumulations , Accumulation vs Reduction and reducing .","title":"accumulate"},{"location":"iterate/#accumulating","text":"An alias for accumulate .","title":"accumulating"},{"location":"iterate/#adjoining","text":"adjoining exptr &optional into var test test at place result-type type Like collect , but only adds the value of exptr if it is not already present. test, which defaults to #'eql, is the test to be used with member.","title":"adjoining"},{"location":"iterate/#after-each","text":"after-each &rest forms Executes forms at the end of the loop body, after each iteration. Forms may contain iterate clauses. CL-USER> (iter (for i below 4) (after-each (print var)) (if (oddp i) (collect i into var) (collect (* 2 i) into var))) ; (0) ; (0 1) ; (0 1 4) ; (0 1 4 3) NIL See Code Placement and Problems with Code Movement .","title":"after-each"},{"location":"iterate/#always","text":"always expr CL-USER> (iter (for i below 4) (always (evenp i))) NIL If expr ever evaluates to nil, then nil is immediately returned; the epilogue code is not executed. If expr never evaluates to nil, the epilogue code is executed and the last value of expr (or t if expr was never evaluated) is returned (whereas loop would constantly return t). See Aggregated Boolean Tests .","title":"always"},{"location":"iterate/#appending","text":"appending exptr &optional into var at place Like collect , but behaves like the Common Lisp append , and works only on lists. CL-USER> (iter (for i in '((1) (2 3) (4 5 6))) (appending i)) (1 2 3 4 5 6) CL-USER> (iter (for i in '((1) (2 3) (4 5 6))) (appending i into var)) NIL See Accumulations .","title":"appending"},{"location":"iterate/#as","text":"An alias for for .","title":"as"},{"location":"iterate/#collect","text":"collect exptr &optional into var test test at place result-type type CL-USER> (iter (for i from 1 to 5) (collect i)) (1 2 3 4 5) CL-USER> (iter (for i from 1 to 5) (collect i at start)) ;; likely to be faster (5 4 3 2 1) place can be either beginning / start or end : default value is end . type should be a subtype of sequence - default is list ; however, the type of sequence being constructed inside the loop is undefined when a non-list type is specified. CL-USER> (iter (for i from 1 to 3) (collect i into vec result-type 'vector) (print vec) (finally (return vec))) ; (1) ; (1 2) ; (1 2 3) #(1 2 3) type or place may be optionally quoted. See Accumulations .","title":"collect"},{"location":"iterate/#collecting","text":"Alias for collect .","title":"collecting"},{"location":"iterate/#count","text":"Alias for counting . This, probably, overrides the CL count when used in top-level inside an iterate loop. CL-USER> (iter (for i in '(1 2 3)) (finally (return (count 1 '(1 2 1))))) 2","title":"count"},{"location":"iterate/#counting","text":"counting expr &optional into var See Reductions and accumulate .","title":"counting"},{"location":"iterate/#declare-variables","text":"(declare (declare-variables)) iterate does not declare variable types unless asked to. Declaration of types of user introduced symbols can be done by either the usual Common Lisp declare , but this declaration should be inside the iter form. Declaration of internal variables or use of the requires one to use declare-variables , or set iterate:::*always-declare-variables* to t`. CL-USER> (macroexpand-1 '(iter (for (the fixnum el) in '(1 2 3)) (declare (DECLARE-VARIABLES)) (count (oddp el)))) ;; note that this produces a type declaration for el. CL-USER> (macroexpand-1 '(iter (for el in '(1 2 3)) (declare (DECLARE-VARIABLES)) (count (oddp el)))) ;; this does not produce a type declaration for el. CL-USER> (macroexpand-1 '(iter (for (the fixnum el) in '(1 2 3)) (count (oddp el)))) ;; this does not produce any declarations. See Types and Declarations .","title":"declare-variables"},{"location":"iterate/#defclause-sequence","text":"[Undocumented here.] See Extensibility Aids .","title":"defclause-sequence"},{"location":"iterate/#defmacro-clause","text":"[Undocumented here] See Rolling Your Own .","title":"defmacro-clause"},{"location":"iterate/#defmacro-driver","text":"[Undocumented here.] See Writing Drivers .","title":"defmacro-driver"},{"location":"iterate/#defsynonym","text":"[Undocumented here.] See Extensibility Aids .","title":"defsynonym"},{"location":"iterate/#display-iterate-clauses","text":"display-iterate-clauses &optional clause-spec CL-USER> (display-iterate-clauses 'repeat) ; REPEAT Repeat the loop some number of times T CL-USER> (display-iterate-clauses '(for in-vector)) ; FOR IN-VECTOR &OPTIONAL FROM UPFROM DOWNFROM TO DOWNTO ABOVE BELOW BY ; WITH-INDEX Elements of a vector T See On-line help .","title":"display-iterate-clauses"},{"location":"iterate/#dsetq","text":"dsetq template expr Can be used outside iter. CL-USER> (foo) FIRST SECOND CL-USER> (progn (dsetq (values a b) (foo)) (list a b)) ;; undeclared variables warning (FIRST SECOND) See Destructuring .","title":"dsetq"},{"location":"iterate/#else","text":"else &rest forms Forms are executed if loop is never entered, but is terminated normally. CL-USER> (iter (for i in '(1 2 3)) (while nil) (else (write 'else))) ; ELSE NIL See Code Placement and Problems with Code Movement .","title":"else"},{"location":"iterate/#finally","text":"finally &rest forms Forms are executed after a normal termination of the loop. CL-USER> (iter (for i in '(1 2 3)) (finally (write 'end))) ; END NIL See Code Placement and Problems with Code Movement .","title":"finally"},{"location":"iterate/#finally-protected","text":"finally-protected &rest forms Forms are executed \"always\" - regardless of whether the termination was notmal CL-USER> (iter (for i in-vector '(1 2 3)) (finally-protected (write 'error))) ;; warnings ERROR ; Evaluation aborted on #<SIMPLE-TYPE-ERROR expected-type: VECTOR datum: (1 2 3)>. CL-USER> (iter (for i in '(1 2 3)) (finally-protected (write 'no-error))) ; NO-ERROR NIL See Code Placement and Problems with Code Movement .","title":"finally-protected"},{"location":"iterate/#finding","text":"finding expr such-that test &optionally into var on-failure failure-value The loop terminates (with epilogue code) whenever test evaluates to non- nil . expr that satifies the test , or failure-value , or nil is returned (unless modified by epilogue). failure-value is always evaluated. CL-USER> (iter (for x in '(1 2 3)) (finding x such-that #'evenp on-failure 'not-found)) 2 CL-USER> (iter (for x in '(1 2 3)) (finding x such-that #'evenp on-failure (error \"not found\"))) ; Evaluation aborted on #<SIMPLE-ERROR \"not found\" {1002F63063}>. CL-USER> (iter (for x in '(1 2 3)) (if (evenp x) (leave x)) (finally (error \"not found\"))) 2 finding expr maximizing m-expr &optionally into var finding expr minimizing m-expr &optionally into var Returns expr corresponding to the maximum value of m-expr . If m-expr is never evaluated (how?), the return value is nil or 0 depending on the type (or its absence) of expr (or var if supplied.) Here, m-expr can also be a list of two symbols. CL-USER> CL-USER> (iter (for list in '((1) (2 3) nil)) (finding list maximizing (length list))) (2 3) CL-USER> (iter (for i in '(1 2 3)) (finding (* 2 i) maximizing (- i) into (twice neg)) (finally (return (values twice neg)))) 2 -1 [Example required for the case when m-expr is not evaluated.] See Finders .","title":"finding"},{"location":"iterate/#finish","text":"finish Stop the loop (and run the epilogue code). CL-USER> (iter (for i in '(1 2 3)) (if (evenp i) (finish))) NIL See Control Flow .","title":"finish"},{"location":"iterate/#first-iteration-p","text":"first-iteration-p t in the first cycle of the loop, otherwise nil . CL-USER> (iter (for el in '(nil 1 2 nil 3)) (when el (unless (first-iteration-p) (princ \", \")) (princ el))) ; , 1, 2, 3 NIL See Boolean Tests .","title":"first-iteration-p"},{"location":"iterate/#first-time-p","text":"first-iteration-p t only when the expression is evaluated for the first time. CL-USER> (iter (for el in '(nil 1 2 nil 3)) (when el (unless (first-time-p) (princ \", \")) (princ el))) ; 1, 2, 3 NIL See Boolean Tests .","title":"first-time-p"},{"location":"iterate/#for","text":"[Undocumented here.] See Numeric Iteration Sequence Iteration Variable Binding and Setting Generalized Drivers Previous Values of Driver Variables","title":"for"},{"location":"iterate/#generate","text":"See Generators and for . CL-USER> (iter (for el in '(a b nil c)) (generate i upfrom 1) (if el (collect (cons el (next i))))) ((A . 1) (B . 2) (C . 3)) for can be replaced by generate to achieve the desired result, except in the case of Variable Binding and Setting .","title":"generate"},{"location":"iterate/#generating","text":"Alias for generate","title":"generating"},{"location":"iterate/#if-first-time","text":"if-first-time then &optional else CL-USER> (iter (for i in '(1 2 3)) (if-first-time (princ 'first) (print 'not-first))) ; FIRST ; NOT-FIRST ; NOT-FIRST NIL See Control Flow .","title":"if-first-time"},{"location":"iterate/#in","text":"in name &rest forms CL-USER> (defvar ar #2A((1 2 3) (4 5 6))) AR CL-USER> (iter outer (for i below (array-dimension ar 0)) (iter (for j below (array-dimension ar 1)) (in outer (collect (aref ar i j))))) (1 2 3 4 5 6) See Named Blocks .","title":"in"},{"location":"iterate/#initially","text":"in &rest forms Place the forms in the prologue of the loop. CL-USER> (iter (initially (princ 'hi)) (for i below 3) (print i)) ; HI ; 0 ; 1 ; 2 NIL CL-USER> (iter (for i below 3) (initially (princ i))) ; -1 ;; this is probably an undefined behaviour. NIL See Code Placement and Problems with Code Movement .","title":"initially"},{"location":"iterate/#leave","text":"leave &optional value Returns from the current iterate form with value or nil . CL-USER> (iter (for i below 3) (leave (iter (for j below 2) (if (oddp j) (leave j))))) 1 See Control Flow .","title":"leave"},{"location":"iterate/#maximize","text":"maximize expr &optional into var CL-USER> (iter (for list in '((1) (1 2) nil)) (maximize (length list))) 2 See Reductions and finding .","title":"maximize"},{"location":"iterate/#maximizing","text":"Alias for maximize .","title":"maximizing"},{"location":"iterate/#minimize","text":"minimize expr &optional into var CL-USER> (iter (for list in '((1) (1 2) nil)) (minimize (length list))) 0 See Reductions and finding .","title":"minimize"},{"location":"iterate/#minimizing","text":"Alias for minimize .","title":"minimizing"},{"location":"iterate/#multiply","text":"multiply expr &optional into var CL-USER> (iter (for i from 1 to 5) (multiply i)) 120 Initial value of * var`* is 1. See Reductions .","title":"multiply"},{"location":"iterate/#multiplying","text":"Alias for [multiply](#","title":"multiplying"},{"location":"iterate/#nconcing","text":"nconcing exptr &optional into var test test at place result-type type See Accumulations and collect .","title":"nconcing"},{"location":"iterate/#never","text":"never expr Effectively (always (not expr)) , but does not influence the last value returned by a possible other always clause. CL-USER> (iter (repeat 2) (always 2) (never nil)) 2 See Aggregated Boolean Tests","title":"never"},{"location":"iterate/#next","text":"See generate .","title":"next"},{"location":"iterate/#next-iteration","text":"next-iteration CL-USER> (iter (for i below 3) (if (oddp i) (next-iteration) (collect i))) (0 2)","title":"next-iteration"},{"location":"iterate/#nunioning","text":"nunioning exptr &optional into var test test at place result-type type See Accumulations and collect .","title":"nunioning"},{"location":"iterate/#reducing","text":"reducing expr by func &optional initial-value init-val into var CL-USER> (iter (for i in '(1 2 3)) (reducing i by (lambda (value-so-far i) (cons i value-so-far)) initial-value ())) (3 2 1) See Reductions , Accumulation vs Reduction and accumulate .","title":"reducing"},{"location":"iterate/#repeat","text":"repeat n Repeat the loop n times. See Drivers . CL-USER> (iter (repeat 3) (print 'doing)) ; DOING ; DOING ; DOING NIL","title":"repeat"},{"location":"iterate/#sum","text":"sum expr &optional into var CL-USER> (iter (for i from 1 to 5) (sum i)) 15","title":"sum"},{"location":"iterate/#summing","text":"Alias for sum .","title":"summing"},{"location":"iterate/#terminate","text":"`terminate Use to terminate for-next clause. Effectively an alias for finish - but use with for-next to maintain compatibility with future versions of iterate (!). CL-USER> (iter (for i upfrom 0) (if (> i 5) (terminate) (collect i))) (0 1 2 3 4 5) CL-USER> (iter (initially (setq i 0)) (for i next (if (> i 10) (terminate) (incf i)))) NIL See Generalized Drivers .","title":"terminate"},{"location":"iterate/#thereis","text":"thereis expr If expr is ever non- nil , its value is returned without running the epilogue code. Otherwise epilogue code is run, and nil is returned. Cannot be used with always or never . See Aggregated Boolean Tests .","title":"thereis"},{"location":"iterate/#unioning","text":"unioning exptr &optional into var test test at place result-type type See Accumulations and collect .","title":"unioning"},{"location":"iterate/#until","text":"until expr CL-USER> (iter (for i in '(1 2 3 4 5)) (until (> i 5)) (collect i)) (1 2 3 4 5) Equivalent to (if expr (finish)) . See finish and Control Flow .","title":"until"},{"location":"iterate/#while","text":"repeat n until expr Equivalent to (if (not expr) (finish)) . CL-USER> (iter (for i below 10) (while (= 0 (rem i 5))) (collect i)) (0) See finish and Control Flow .","title":"while"},{"location":"iterate/#with","text":"with var &optional = value var is bound to value before the loop is entered. Binding happens sequentially, as while using a let* , and not in parallel as with let . CL-USER> (iter (with i = 0) (while (< i 3)) (collect (incf i))) (1 2 3) CL-USER> (iter (with i = 1) (for i below 3) (collect (incf i))) ; Evaluation aborted on #<SIMPLE-ERROR \"Iterate~@[, in ~a~]:~%Duplicate variable: ~a\" {1004185183}>. See Variable Binding and Setting and Parallel Binding and Stepping .","title":"with"},{"location":"iterate/#other-resources-on-iterate","text":"The Iterate Manual Comparing LOOP and ITERATE Loop v Iterate - SabraOnTheHill [DLI]: appendix/Don't Loop, Iterate","title":"OTHER RESOURCES ON ITERATE"},{"location":"numcl/","text":"numcl - Lispy clone of numpy Version: 0.1 Repository: numcl/numcl - Github This documentation was possible due to the excellent official documentation . In case of any errors here, please create an issue . INTRODUCTION This is a Numpy clone in Common Lisp. At the moment the library is written in pure Common Lisp, focusing more on correctness and usefulness, not speed. Track the progress at https://github.com/numcl/numcl/projects/1 . Goals Closely follow the numpy API, but still make it lispy. Delegate the documentation effort to Numpy community. Replace the Common Lisp array interface. We do not deviate from the traditional symbols/idioms in Common Lisp unless necessary. Therefore we provide symbols that conflicts the Common Lisp symbol. Math functions become aliases to the original CL functions when the inputs are not arrays. See doc/DETAILS.org#packages . Features/Contracts APIs are provided as functions, not macros. It is a design flaw otherwise. This does not mean the API is functional \u2014 we use procedural code. Still, zero overhead. The APIs are simply the wrappers over simple functions and designed to be fully inlined. Optimization will be done on the compiler side, not by macros. Operations are type-correct. They always return arrays of the most specific array-element-type. For example, (zeros 5) returns a bit vector. (asarray '(1 2 3)) returns an (unsigned-byte 2) vector. See doc/DETAILS.org#types . NUMCL Arrays are CL arrays. As this library aims to extend Common Lisp (not to replace part of it) in a compatible way, we do not introduce custom structures/classes for representing an array. See doc/DETAILS.org#representation . Dependencies NUMCL depends on the following libraries that must be installed manually and other libraries that are automatically loaded by quicklisp. https://github.com/numcl/constantfold https://github.com/numcl/gtype https://github.com/numcl/specialized-function . With Roswell, installation can be done by ros install numcl/constantfold numcl/specialized-function numcl/gtype numcl/numcl This library is at least tested on implementation listed below: SBCL 1.4.12 on X86-64 Linux 4.4.0-141-generic (author's environment) SBCL 1.5.1 on X86-64 Linux 4.4.0-141-generic (author's environment) CI tested on CCL, ECL. Dependency graph: GETTING STARTED Array Representation NUMCL arrays are merely the displaced multidimentional arrays and no classes or structures are used. However, in order to guarantee speed and simplify implementation, arrays given to numcl functions must satisfy the following two conditions: Be a specialized array. Things of type (array single-float) , (array (unsigned-byte 16)) etc. Be an array displaced to a simple 1D specialized array. \" Simple array \" means a non-displaced, non-adjustable array without fill pointer. There are a few ways to create the required arrays: (reshape (arange 4.0) '(2 2)) (asarray #2A((0.0 1.0) (2.0 3.0))) (asarray '((0.0 1.0) (2.0 3.0))) (asarray '(#(0.0 1.0) #(2.0 3.0))) (let ((a (zeros '(2 2) :type 'single-float))) (dotimes (i 2) (dotimes (j 2) (setf (aref a i j) ...)))) The names and the parameters of numcl functions mostly (rather strictly) follows the numpy counterpart. There are even numpy names, such as dtype , which are just aliases for array-element-type . See API Reference for the complete list of functions. Optionally, see Array Representation Details if required. Packages NUMCL defines several symbols which have names identical to the corresponding CL symbols. We call them conflicting symbols . To avoid confusion in the code base, we use 3 packages: NUMCL.IMPL : (internal package) for implementing numcl. NUMCL.EXPORTED : (external package), for storing the numcl exported symbols, NUMCL : package, that replaces COMMON-LISP package by shadowing-import symbols from NUMCL.EXPORTED on top of COMMON-LISP package. Types In NUMCL, there is no ratio type: - CL prohibits ratio to have a denominator 1 (e.g. 3/1), and thus the operations on ratios are not closed. - No implementations provide a specialized array for rational . - Ratio computation requires an additional simplification phase (e.g. 2/4 -> 1/2) which does not finish in a constant number of operations and is incompatible to SIMD operations. As a result, ratios are always converted to *numcl-default-float-format* , which is single-float by default. This means that / always returns a float array (except atomic numbers are given). We also force irrational functions to always return floats, by coercion. (Implementations are allowed to return rationals for certain constants, e.g. (sin pi).) (array bignum) does not exist either. However, when the result of numerical computation causes a fixnum overflow, it signals an error instead of overflowing silently. For complex arrays, only (complex *-float) exists (for each float type). Both complex integers and complex ratios are converted into floats. This is because CL does not allow rational complex with imagpart 0 (cf. http://clhs.lisp.se/Body/t_comple.htm ), thus the numerical operation always coerces the result into reals. This prevents us from having (ARRAY (COMPLEX FIXNUM)). This may be contrasted with that in Common Lisp as provided. Examples example.lisp contains a script that you can explore the functionality implemented so far in NUMCL. API REFERENCE As stated on the section on Packages , NUMCL exports all the symbols in package CL, along with the ones with numcl.exported . Therefore, here, we only list the symbols exported by numcl.exported . * Function: (* &rest args) ** *** + Function: (+ &rest args) ++ +++ - Function: (- first &rest args) / Function: (/ first &rest args) // /// /= Function: (/= x y) 1+ Function: (1+ array) 1- Function: (1- array) < Function: (< x y) <= Function: (<= x y) = Function: (= x y) > Function: (> x y) >= Function: (>= x y) abs Function: (abs x) acos Function: (acos x) amax Function: (amax array &rest args &key axes type) amin Function: (amin array &rest args &key axes type) arange Function: (arange &rest args) Arange's argument signature is irregular, following the API of numpy. The interpretation of its arguments depends on the number of arguments. (arange stop &key type) (arange start stop &key type) (arange start stop step &key type) Don't worry, we provide a compiler-macro to avoid the runtime dispatch. aref Function: (aref array &rest subscripts) An extended aref that accepts ranges as lists, similar to numpy's array access. For a 3D array x, range x[1:5,2,3] = (aref x '(1 5) 2 3) x[2,1:5,3] = (aref x 2 '(1 5) 3) x[2,1:2:5,3] = (aref x 2 '(1 2 5) 3) x[2,1:,3] = (aref x 2 '(1 t) 3) x[2,:1,3] = (aref x 2 '(t 1) 3) x[2,:,3] = (aref x 2 '(t t) 3) x[2,:,3] = (aref x 2 t 3) insufficient axis (aref x '(1 5)) == (aref x '(1 5) t t) (aref x 2 '(1 5)) == (aref x 2 '(1 5) t) newaxis (aref x '(1 2 5) nil 2 3) ellipsis (aref x '- 2) = (aref x t t 2) = x[...,2] (aref x 2 '-) = (aref x 2 t t) = x[2,...] (aref x 2 '- 3) = (aref x 2 t 3) = x[2,...,3] (aref x 2 3 '-) = (aref x 2 3 t) = x[2,3,...] argmax argmin argwhere Function: (argwhere array fn) Returns a list of the multidimentional indices of the elements which satisfies the predicate FN. Note that the list elements are the multidimentional indices, even for a single-dimensional array. array-index-from-row-major-index Function: (array-index-from-row-major-index array row-major-index) Takes a multidimentional array and a row-major-index. Returns a list containing the normal index. asarray Function: (asarray contents &key type) Copy CONTENTS to a new array. NOTE: ASARRAY is SLOW as it recurses into the substructures. When CONTENTS is a multidimentional array, its elements are copied to a new array that guarantees the NUMCL assumption. When CONTENTS is a nested sequence, it is traversed up to the depth that guarantees the sane shape for an array. When elements are copied, it is coerced to TYPE. When TYPE is not given, it is replaced with the float-contagion type deduced from the elements of CONTENTS. It may return a 0-dimensional array with CONTENTS being the only element. For example: ;; a vector of two lists. (asarray '((1) (1 2))) -> #((1) (1 2)) ;; a 2D array of 4 lists. (asarray '(((1) (1 2)) ((3) (3 4)))) -> #2A(((1) (1 2)) ((3) (3 4))) (asarray '((1 2) (3 4))) -> #2A((1 2) (3 4)) (asarray #(#(1 2) #(3 4))) -> #2A((1 2) (3 4)) (asarray #((1 2) (3 4))) -> #2A((1 2) (3 4)) However, this behavior may not be ideal because the resulting shape could be affected by the lengths of the strings. (asarray #(#(1 2) #(3 4))) -> #2A((1 2) (3 4)) (asarray #(#(1 2) #(3 4 5))) -> #(#(1 2) #(3 4 5)) (asarray #(\"aa\" \"aa\")) -> #2A((#a #a) (#a #a)) (asarray #(\"aa\" \"aaa\")) -> #(\"aa\" \"aaa\") As a remedy to this problem, we allow TYPE to be a specifier for vector subtypes. Providing such a type specifier will keep the leaf objects (e.g. strings) from split into individual elements. We don't allow it to be a multidimentional array [at the moment.] (asarray #(#(1 2) #(3 4)) :type '(array fixnum (*))) -> #(#(1 2) #(3 4)) (asarray #(#(1 2) #(3 4 5)) :type '(array fixnum (*))) -> #(#(1 2) #(3 4 5)) (asarray #(\"aa\" \"aa\") :type 'string) -> #(\"aa\" \"aa\") (asarray #(\"aa\" \"aaa\") :type 'string) -> #(\"aa\" \"aaa\") (asarray '((1 2) (3 4)) :type '(array fixnum (* *))) -> error asin Function: (asin x) astype Function: (astype array type) atan Function: (atan x) avg Function: (avg array &key axes) bernoulli Function: (bernoulli p &optional shape) Returns a bit array whose elements are 1 with probability P bernoulli-like Function: (bernoulli-like a) beta Function: (beta a b &optional shape (type (union-to-float-type (type-of a) (type-of b)))) binomial Function: (binomial n p &optional shape) broadcast Function: (broadcast function x y &key type (atomic function)) For binary functions ceiling Function: (ceiling number &optional (divisor 1)) chisquare cis Function: (cis x) clip Function: (clip array min max) concatenate Function: (concatenate arrays &key (axis 0) out) conjugate Function: (conjugate x) copy Function: (copy array) cos Function: (cos x) cosh Function: (cosh x) denominator Function: (denominator x) diag Function: (diag a &optional result) Return the diagonal element of a matrix as a vector dirichlet dot dtype Function: (dtype array) einsum Function: (einsum subscripts &rest args) Performs Einstein's summation. The SUBSCRIPT specification is significantly extended from that of Numpy and can be seens as a full-brown DSL for array operations. SUBSCRIPTS is a sequence of the form (<SPEC>+ [-> <TRANSFORM>*] [-> [<SPEC>*]) . The remaining arguments ARGS contain the input arrays and optionally the output arrays. SPEC The first set of SPECs specifies the input subscripts, and the second set of SPECs specifies the output subscripts. Unlike Numpy, there can be multiple output subscripts: It can performs multiple operations in the same loop, then return multiple values. The symbol -> can be a string and can belong to any package because it is compared by STRING=. Each SPEC is an alphabetical string designator, such as a symbol IJK or a string \"IJK\", where each alphabet is considered as an index. It signals a type-error when it contains any non-alpha char. Note that a symbol NIL is interpreted as an empty list rather than N, I and L. Alternatively, each SPEC can be a list that contains a list of symbols. For example, ((i j) (j k) -> (i k)) and (ij jk -> ik) are equivalent. When -> and the output SPECs are omitted, a single output is assumed and its spec is a union of the input specs. For example, (ij jk) is equivalent to (ij jk -> ijk) . Note that (ij jk) and (ij jk ->) have the different meanings: The latter sums up all elements. TRANSFORM TRANSFORM is a list of element-wise operations. The number of TRANSFORM should correspond to the number of outputs. In each TRANSFORM, the elements in the input arrays can be referenced by $N, where N is a 1-indexed number. Similarly the output array can be referred to by @N. For example, (ij ik -> (+ @1 (* $1 $2)) -> ik) is equivalent to (ij ik -> ik) (a GEMM). By default, TRANSFORM is (+ @1 (* $1 ... $N)) for N inputs, which is equivalent to Einstein's summation. ARGS The shape of each input array should unify against the corresponding input spec. For example, with a spec IJI, the input array should be of rank 3 as well as the 1st and the 3rd dimension of the input array should be the same. The shape of each output array is determined by the corresponding output spec. For example, if SUBSCRIPTS is (ij jk -> ik) , the output is an array of rank 2, and the output shape has the same dimension as the first input in the first axis, and the same dimension as the second input in the second axis. If the output arrays are provided, their shapes and types are also checked against the corresponding output spec. The types should match the result of the numerical operations on the elements of the input arrays. The outputs are calculated in the following rule. The output array types are calculated based on the TRANSFORM, and the shapes are calcurated based on the SPEC and the input arrays. The output arrays are allocated and initialized by zeros. Einsum nests one loop for each index in the input specs. For example, (ij jk -> ik) results in a triple loop. In the innermost loop, each array element is bound to $1..$N / @1..@N . For each @i , i -th TRANSFORM is evaluated and assigned to @i . If the same index appears multiple times in a single spec, they share the same value in each iteration. For example, (ii -> i) returns the diagonal elements of the matrix. When TRANSFORMs are missing, it follows naturally from the default TRANSFORM values that When an index used in the input spec is missing in the output spec, the axis is aggregated over the iteration by summation. If the same index appears across the different input specs, the element values from the multiple input arrays are aggregated by multiplication. For example, (ij jk -> ik) will perform (setf (aref a2 i k) (* (aref a0 i j) (aref a1 j k))) when a0, a1 are the input arrays and a2 is the output array. For example, (einsum '(ij jk) a b) is equivalent to: (dotimes (i <max> <output>) (dotimes (j <max>) (dotimes (k <max>) (setf (aref <output> i j k) (* (aref a i j) (aref b j k)))))) Performance If SUBSCRIPTS is a constant, the compiler macro builds an iterator function and make them inlined. Otherwise, a new function is made in each call to einsum, resulting in a large bottleneck. (It could be memoized in the future.) The nesting order of the loops are automatically decided based on the specs. The order affects the memory access pattern and therefore the performance due to the access locality. For example, when writing a GEMM which accesses three matrices by (setf (aref output i j) (* (aref a i k) (aref b k j))) , it is well known that ikj-loop is the fastest among other loops, e.g. ijk-loop. EINSUM reorders the indices so that it maximizes the cache locality. empty Function: (empty shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. empty-like Function: (empty-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. exp Function: (exp x) expand-dims Function: (expand-dims a axes) axes: an int or a list of ints exponential Function: (exponential scale &optional shape (type (union-to-float-type (type-of scale)))) eye Function: (eye n &key (m n) (k 0) (type 'bit)) Returns a matrix whose k-th diagnonal filled with 1. N,M specifies the shape of the return array. K will adjust the sub-diagonal -- positive K moves it upward. f Function: (f dfnum dfden &optional shape (type (union-to-float-type (type-of dfnum) (type-of dfden)))) fceiling Function: (fceiling number &optional (divisor 1)) ffloor Function: (ffloor number &optional (divisor 1)) flatten Function: (flatten a) floor Function: (floor number &optional (divisor 1)) fround Function: (fround number &optional (divisor 1)) ftruncate Function: (ftruncate number &optional (divisor 1)) full Function: (full shape value &key (type (type-of value))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. full-like Function: (full-like array value &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. gamma Function: (gamma k &optional (theta 1.0) shape (type (union-to-float-type (type-of k) (type-of theta)))) geometric gumbel histogram Function: (histogram array &key (low (amin array)) (high (amax array)) (split 1)) Returns a fixnum vector representing a histogram of values. The interval between LOW and HIGH are split by STEP value. All values less than LOW are put in the 0-th bucket; All values greater than equal to HIGH are put in the last bucket. hypergeometric imagpart Function: (imagpart x) inner Function: (inner a b &optional result) Inner product of two vectors. integer-length Function: (integer-length x) invalid-array-index-error NIL NUMCL.EXPORTED:SHAPE Initargs: :shape Readers: numcl.exported:invalid-array-index-error-shape Writers: (setf numcl.exported:invalid-array-index-error-shape) axis Initargs: :axis Readers: numcl.exported:invalid-array-index-error-axis Writers: (setf numcl.exported:invalid-array-index-error-axis) #### subscripts ```lisp Initargs: :subscripts Readers: numcl.exported:invalid-array-index-error-subscripts Writers: (setf numcl.exported:invalid-array-index-error-subscripts)### kron ```lisp Function: (kron a b &optional result) Compute the kronecker product of two vectors. laplace length Function: (length array) linspace Function: (linspace start stop length &key type endpoint) log Function: (log x) logand Function: (logand &rest args) logandc1 Function: (logandc1 &rest args) logandc2 Function: (logandc2 &rest args) logcount Function: (logcount x) logeqv Function: (logeqv &rest args) logior Function: (logior &rest args) logistic lognand Function: (lognand &rest args) lognor Function: (lognor &rest args) lognormal lognot Function: (lognot x) logorc1 Function: (logorc1 &rest args) logorc2 Function: (logorc2 &rest args) logseries logxor Function: (logxor &rest args) map Function: (map result-type function &rest sequences) map-array Function: (map-array function &rest sequences) map-array-into Function: (map-array-into result-sequence function &rest sequences) map-into Function: (map-into result-sequence function &rest sequences) matmul Function: (matmul a b &optional result) Matrix product of two arrays. max Function: (max &rest args) mean Function: (mean array &key axes) min Function: (min &rest args) mod Function: (mod number &optional (divisor 1)) multinomial Function: (multinomial n pvals &optional shape) pvals is a sequence of probabilities summing up to 1. multivariate-normal negative-binomial Function: (negative-binomial n p &optional shape) noncentral-chisquare noncentral-f nonzero Function: (nonzero array) collect multidimentional indices where the element is nonzero normal Function: (normal &optional (mean 0.0) (var 1.0) shape (type (union-to-float-type (type-of mean) (type-of var)))) numcl-array numcl-array-p Function: (numcl-array-p array) Returns true when ARRAY satisfies the NUMCL assumption, that is, an array displaced to a non-displaced 1D array. numerator Function: (numerator x) onehot ones Function: (ones shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. ones-like Function: (ones-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. outer Function: (outer a b &optional result) Compute the outer product of two vectors. pareto phase Function: (phase x) poisson Function: (poisson &optional (lambda 1.0) shape (type (union-to-float-type (type-of lambda)))) power prod Function: (prod array &rest args &key axes type) rank Function: (rank array) rayleigh realpart Function: (realpart x) reduce-array Function: (reduce-array fn array &key axes (type (%reduce-array-result-type array fn)) (initial-element (zero-value type))) rem Function: (rem number &optional (divisor 1)) reshape Function: (reshape a shape) Reshape the array while sharing the backing 1D array. -1 implies that the axis size is deduced from the other axes. At most one axis is allowed to be -1. T implies that the axis size is preserved. It can be used as many times, but only at the right/leftmost axes. Example of reshaping (3 8 5): valid: (6 -1 10) = (6 2 10) (t 2 2 2 t) = (3 2 2 2 5) (3 t t) = (3 8 5) (2 -1 2 2 t) = (2 3 2 2 5) invalid: (2 t 2 2 t) round Function: (round number &optional (divisor 1)) shape Function: (shape array) shuffle Function: (shuffle array-or-sequence &key (start 0) end) This code extends alexandria:shuffle. It additionally accepts arrays and shuffles the elements according to the first axis, viewing the remaining axes as one \"element\". Original documentation: Returns a random permutation of SEQUENCE bounded by START and END. Original sequence may be destructively modified, and (if it contains CONS or lists themselv) share storage with the original one. Signals an error if SEQUENCE is not a proper sequence. signum Function: (signum x) sin Function: (sin x) sinh Function: (sinh x) size Function: (size array) sqrt Function: (sqrt x) square Function: (square x) squeeze Function: (squeeze a) stack Function: (stack arrays &key (axis 0) out) standard-cauchy standard-deviation Function: (standard-deviation array &key axes) standard-exponential standard-gamma standard-normal standard-t stdev Function: (stdev array &key axes) sum Function: (sum array &rest args &key axes type) take Function: (take array indices) Collect the elements using a list of multidimentional indices (in a format returned by WHERE). tan Function: (tan x) tanh Function: (tanh x) to-simple-array Function: (to-simple-array array) Returns a simple array of the equivalent contents. transpose Function: (transpose matrix &optional result) Reverses the axes of an array. tri Function: (tri n &key (m n) (k 0) (type 'bit)) Returns a triangle matrix whose lower diagnonal (including the diagonal) filled with 1. N,M specifies the shape of the return array. K will adjust the sub-diagonal -- positive K fills more 1s. triangular tril Function: (tril matrix &optional (k 0)) Returns the copy of matrix with elements above the k-th diagonal zeroed. Positive K fills less 0s. triu Function: (triu matrix &optional (k 0)) Returns the copy of matrix with elements below the k-th diagonal zeroed. Positive K fills more 0s. truncate Function: (truncate number &optional (divisor 1)) uniform Function: (uniform &optional (low 0.0) (high 1.0) shape type) unstack Function: (unstack array &key (axis 0)) vander Function: (vander v &key (n (length v)) increasing) Returns a matrix where M[i,j] == V[i]^(N-j) when increasing is false (default), and M[i,j] == V[i]^j when increasing is true. var Function: (var array &key axes) variance Function: (variance array &key axes) vdot Function: (vdot a b &optional result) Dot product of two vectors. For complex values, the first value is conjugated. vonmises wald weibull where Function: (where array fn) Returns a list of list of indices of the elements which satisfies the predicate FN. The first list contains the indices for the 1st dimension, the second list contains the indices for the 2nd dimension, and so on. zeros Function: (zeros shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. zeros-like Function: (zeros-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. zipf MORE DISCUSSION Common Lisp Types Common Lisp has the following types for numbers. number = (or complex real) real = (or float rational) rational = (or ratio integer) integer = (or fixnum bignum) float = (or short-float ... long-float) (== irrational). Common Lisp defines several rules for the type of the values returned by the numerical operations. The detail of the rules are explained in CLHS 12.1 Number Concepts . Rational functions behave as rational* -> rational , float* -> float , {rational,float}* -> float . This rule is called float contagion rule. Rational functions do not guarantee integer -> integer , primarily due to / , which returns integer* -> (or ratio integer) . Irrational functions behaves as rational -> (or rational float) , float -> float : For a certain irrational functions, implementations are allowed to return the exact rational number or its float approximation. Examples are (sin pi) -> 1/2 . The behavior depends on the implementation and is called float substitution rule . Array Representation Details NUMCL arrays are not based on custom classes or structures. They are merely the displaced multidimentional arrays. In order to guarantee the speed and to simplify the implementation, the arrays given to numcl functions must satisfy the following two conditions: It is a specialized array. Things of type (array single-float) , (array (unsigned-byte 16)) etc. It is an array displaced to a simple 1D specialized array. \" Simple array \" means a non-displaced, non-adjustable array without fill pointer. The base function for creating a new array is %make-array , but this is not exported in NUMCL. You should use the wrapper functions like ones , zeros , ones-like , arange , linspace , asarray etc. They are always inline-expanded to %make-array , therefore there is no worry about the performance. These functions analyze the input and return the most specialized array for the input, but you can also specify the element type. %make-array instantiates a new flattened array and returns another array displaced to it with the specified shape. The flattened array is returned as the secondary value (as does most other numcl functions). The justification for this scheme is that some implementations (esp. SBCL) require an indirection for accessing the array element (e.g. through array-header in SBCL) even for a simple multi-dimentional array and thus using a displacing array has essentially no performance penalty over using a simple multi-dimentional array. We also ensure that the length of the base arrays are the multiples of 8. This ensures that the program can safely iterate over the extended region with a future support for SIMD operations in mind. AUTHOR, LICENSE, COPYRIGHT Masataro Asai (guicho2.71828@gmail.com) Licensed under LGPL v3. Copyright (c) 2019 IBM Corporation","title":"numcl - Lispy clone of numpy"},{"location":"numcl/#numcl-lispy-clone-of-numpy","text":"Version: 0.1 Repository: numcl/numcl - Github This documentation was possible due to the excellent official documentation . In case of any errors here, please create an issue .","title":"numcl - Lispy clone of numpy"},{"location":"numcl/#introduction","text":"This is a Numpy clone in Common Lisp. At the moment the library is written in pure Common Lisp, focusing more on correctness and usefulness, not speed. Track the progress at https://github.com/numcl/numcl/projects/1 .","title":"INTRODUCTION"},{"location":"numcl/#goals","text":"Closely follow the numpy API, but still make it lispy. Delegate the documentation effort to Numpy community. Replace the Common Lisp array interface. We do not deviate from the traditional symbols/idioms in Common Lisp unless necessary. Therefore we provide symbols that conflicts the Common Lisp symbol. Math functions become aliases to the original CL functions when the inputs are not arrays. See doc/DETAILS.org#packages .","title":"Goals"},{"location":"numcl/#featurescontracts","text":"APIs are provided as functions, not macros. It is a design flaw otherwise. This does not mean the API is functional \u2014 we use procedural code. Still, zero overhead. The APIs are simply the wrappers over simple functions and designed to be fully inlined. Optimization will be done on the compiler side, not by macros. Operations are type-correct. They always return arrays of the most specific array-element-type. For example, (zeros 5) returns a bit vector. (asarray '(1 2 3)) returns an (unsigned-byte 2) vector. See doc/DETAILS.org#types . NUMCL Arrays are CL arrays. As this library aims to extend Common Lisp (not to replace part of it) in a compatible way, we do not introduce custom structures/classes for representing an array. See doc/DETAILS.org#representation .","title":"Features/Contracts"},{"location":"numcl/#dependencies","text":"NUMCL depends on the following libraries that must be installed manually and other libraries that are automatically loaded by quicklisp. https://github.com/numcl/constantfold https://github.com/numcl/gtype https://github.com/numcl/specialized-function . With Roswell, installation can be done by ros install numcl/constantfold numcl/specialized-function numcl/gtype numcl/numcl This library is at least tested on implementation listed below: SBCL 1.4.12 on X86-64 Linux 4.4.0-141-generic (author's environment) SBCL 1.5.1 on X86-64 Linux 4.4.0-141-generic (author's environment) CI tested on CCL, ECL. Dependency graph:","title":"Dependencies"},{"location":"numcl/#getting-started","text":"","title":"GETTING STARTED"},{"location":"numcl/#array-representation","text":"NUMCL arrays are merely the displaced multidimentional arrays and no classes or structures are used. However, in order to guarantee speed and simplify implementation, arrays given to numcl functions must satisfy the following two conditions: Be a specialized array. Things of type (array single-float) , (array (unsigned-byte 16)) etc. Be an array displaced to a simple 1D specialized array. \" Simple array \" means a non-displaced, non-adjustable array without fill pointer. There are a few ways to create the required arrays: (reshape (arange 4.0) '(2 2)) (asarray #2A((0.0 1.0) (2.0 3.0))) (asarray '((0.0 1.0) (2.0 3.0))) (asarray '(#(0.0 1.0) #(2.0 3.0))) (let ((a (zeros '(2 2) :type 'single-float))) (dotimes (i 2) (dotimes (j 2) (setf (aref a i j) ...)))) The names and the parameters of numcl functions mostly (rather strictly) follows the numpy counterpart. There are even numpy names, such as dtype , which are just aliases for array-element-type . See API Reference for the complete list of functions. Optionally, see Array Representation Details if required.","title":"Array Representation"},{"location":"numcl/#packages","text":"NUMCL defines several symbols which have names identical to the corresponding CL symbols. We call them conflicting symbols . To avoid confusion in the code base, we use 3 packages: NUMCL.IMPL : (internal package) for implementing numcl. NUMCL.EXPORTED : (external package), for storing the numcl exported symbols, NUMCL : package, that replaces COMMON-LISP package by shadowing-import symbols from NUMCL.EXPORTED on top of COMMON-LISP package.","title":"Packages"},{"location":"numcl/#types","text":"In NUMCL, there is no ratio type: - CL prohibits ratio to have a denominator 1 (e.g. 3/1), and thus the operations on ratios are not closed. - No implementations provide a specialized array for rational . - Ratio computation requires an additional simplification phase (e.g. 2/4 -> 1/2) which does not finish in a constant number of operations and is incompatible to SIMD operations. As a result, ratios are always converted to *numcl-default-float-format* , which is single-float by default. This means that / always returns a float array (except atomic numbers are given). We also force irrational functions to always return floats, by coercion. (Implementations are allowed to return rationals for certain constants, e.g. (sin pi).) (array bignum) does not exist either. However, when the result of numerical computation causes a fixnum overflow, it signals an error instead of overflowing silently. For complex arrays, only (complex *-float) exists (for each float type). Both complex integers and complex ratios are converted into floats. This is because CL does not allow rational complex with imagpart 0 (cf. http://clhs.lisp.se/Body/t_comple.htm ), thus the numerical operation always coerces the result into reals. This prevents us from having (ARRAY (COMPLEX FIXNUM)). This may be contrasted with that in Common Lisp as provided.","title":"Types"},{"location":"numcl/#examples","text":"example.lisp contains a script that you can explore the functionality implemented so far in NUMCL.","title":"Examples"},{"location":"numcl/#api-reference","text":"As stated on the section on Packages , NUMCL exports all the symbols in package CL, along with the ones with numcl.exported . Therefore, here, we only list the symbols exported by numcl.exported .","title":"API REFERENCE"},{"location":"numcl/#_1","text":"Function: (* &rest args)","title":"*"},{"location":"numcl/#_2","text":"","title":"**"},{"location":"numcl/#_3","text":"","title":"***"},{"location":"numcl/#_4","text":"Function: (+ &rest args)","title":"+"},{"location":"numcl/#_5","text":"","title":"++"},{"location":"numcl/#_6","text":"","title":"+++"},{"location":"numcl/#-","text":"Function: (- first &rest args)","title":"-"},{"location":"numcl/#_7","text":"Function: (/ first &rest args)","title":"/"},{"location":"numcl/#_8","text":"","title":"//"},{"location":"numcl/#_9","text":"","title":"///"},{"location":"numcl/#_10","text":"Function: (/= x y)","title":"/="},{"location":"numcl/#1","text":"Function: (1+ array)","title":"1+"},{"location":"numcl/#1-","text":"Function: (1- array)","title":"1-"},{"location":"numcl/#_11","text":"Function: (< x y)","title":"&lt;"},{"location":"numcl/#_12","text":"Function: (<= x y)","title":"&lt;="},{"location":"numcl/#_13","text":"Function: (= x y)","title":"="},{"location":"numcl/#_14","text":"Function: (> x y)","title":"&gt;"},{"location":"numcl/#_15","text":"Function: (>= x y)","title":"&gt;="},{"location":"numcl/#abs","text":"Function: (abs x)","title":"abs"},{"location":"numcl/#acos","text":"Function: (acos x)","title":"acos"},{"location":"numcl/#amax","text":"Function: (amax array &rest args &key axes type)","title":"amax"},{"location":"numcl/#amin","text":"Function: (amin array &rest args &key axes type)","title":"amin"},{"location":"numcl/#arange","text":"Function: (arange &rest args) Arange's argument signature is irregular, following the API of numpy. The interpretation of its arguments depends on the number of arguments. (arange stop &key type) (arange start stop &key type) (arange start stop step &key type) Don't worry, we provide a compiler-macro to avoid the runtime dispatch.","title":"arange"},{"location":"numcl/#aref","text":"Function: (aref array &rest subscripts) An extended aref that accepts ranges as lists, similar to numpy's array access. For a 3D array x, range x[1:5,2,3] = (aref x '(1 5) 2 3) x[2,1:5,3] = (aref x 2 '(1 5) 3) x[2,1:2:5,3] = (aref x 2 '(1 2 5) 3) x[2,1:,3] = (aref x 2 '(1 t) 3) x[2,:1,3] = (aref x 2 '(t 1) 3) x[2,:,3] = (aref x 2 '(t t) 3) x[2,:,3] = (aref x 2 t 3) insufficient axis (aref x '(1 5)) == (aref x '(1 5) t t) (aref x 2 '(1 5)) == (aref x 2 '(1 5) t) newaxis (aref x '(1 2 5) nil 2 3) ellipsis (aref x '- 2) = (aref x t t 2) = x[...,2] (aref x 2 '-) = (aref x 2 t t) = x[2,...] (aref x 2 '- 3) = (aref x 2 t 3) = x[2,...,3] (aref x 2 3 '-) = (aref x 2 3 t) = x[2,3,...]","title":"aref"},{"location":"numcl/#argmax","text":"","title":"argmax"},{"location":"numcl/#argmin","text":"","title":"argmin"},{"location":"numcl/#argwhere","text":"Function: (argwhere array fn) Returns a list of the multidimentional indices of the elements which satisfies the predicate FN. Note that the list elements are the multidimentional indices, even for a single-dimensional array.","title":"argwhere"},{"location":"numcl/#array-index-from-row-major-index","text":"Function: (array-index-from-row-major-index array row-major-index) Takes a multidimentional array and a row-major-index. Returns a list containing the normal index.","title":"array-index-from-row-major-index"},{"location":"numcl/#asarray","text":"Function: (asarray contents &key type) Copy CONTENTS to a new array. NOTE: ASARRAY is SLOW as it recurses into the substructures. When CONTENTS is a multidimentional array, its elements are copied to a new array that guarantees the NUMCL assumption. When CONTENTS is a nested sequence, it is traversed up to the depth that guarantees the sane shape for an array. When elements are copied, it is coerced to TYPE. When TYPE is not given, it is replaced with the float-contagion type deduced from the elements of CONTENTS. It may return a 0-dimensional array with CONTENTS being the only element. For example: ;; a vector of two lists. (asarray '((1) (1 2))) -> #((1) (1 2)) ;; a 2D array of 4 lists. (asarray '(((1) (1 2)) ((3) (3 4)))) -> #2A(((1) (1 2)) ((3) (3 4))) (asarray '((1 2) (3 4))) -> #2A((1 2) (3 4)) (asarray #(#(1 2) #(3 4))) -> #2A((1 2) (3 4)) (asarray #((1 2) (3 4))) -> #2A((1 2) (3 4)) However, this behavior may not be ideal because the resulting shape could be affected by the lengths of the strings. (asarray #(#(1 2) #(3 4))) -> #2A((1 2) (3 4)) (asarray #(#(1 2) #(3 4 5))) -> #(#(1 2) #(3 4 5)) (asarray #(\"aa\" \"aa\")) -> #2A((#a #a) (#a #a)) (asarray #(\"aa\" \"aaa\")) -> #(\"aa\" \"aaa\") As a remedy to this problem, we allow TYPE to be a specifier for vector subtypes. Providing such a type specifier will keep the leaf objects (e.g. strings) from split into individual elements. We don't allow it to be a multidimentional array [at the moment.] (asarray #(#(1 2) #(3 4)) :type '(array fixnum (*))) -> #(#(1 2) #(3 4)) (asarray #(#(1 2) #(3 4 5)) :type '(array fixnum (*))) -> #(#(1 2) #(3 4 5)) (asarray #(\"aa\" \"aa\") :type 'string) -> #(\"aa\" \"aa\") (asarray #(\"aa\" \"aaa\") :type 'string) -> #(\"aa\" \"aaa\") (asarray '((1 2) (3 4)) :type '(array fixnum (* *))) -> error","title":"asarray"},{"location":"numcl/#asin","text":"Function: (asin x)","title":"asin"},{"location":"numcl/#astype","text":"Function: (astype array type)","title":"astype"},{"location":"numcl/#atan","text":"Function: (atan x)","title":"atan"},{"location":"numcl/#avg","text":"Function: (avg array &key axes)","title":"avg"},{"location":"numcl/#bernoulli","text":"Function: (bernoulli p &optional shape) Returns a bit array whose elements are 1 with probability P","title":"bernoulli"},{"location":"numcl/#bernoulli-like","text":"Function: (bernoulli-like a)","title":"bernoulli-like"},{"location":"numcl/#beta","text":"Function: (beta a b &optional shape (type (union-to-float-type (type-of a) (type-of b))))","title":"beta"},{"location":"numcl/#binomial","text":"Function: (binomial n p &optional shape)","title":"binomial"},{"location":"numcl/#broadcast","text":"Function: (broadcast function x y &key type (atomic function)) For binary functions","title":"broadcast"},{"location":"numcl/#ceiling","text":"Function: (ceiling number &optional (divisor 1))","title":"ceiling"},{"location":"numcl/#chisquare","text":"","title":"chisquare"},{"location":"numcl/#cis","text":"Function: (cis x)","title":"cis"},{"location":"numcl/#clip","text":"Function: (clip array min max)","title":"clip"},{"location":"numcl/#concatenate","text":"Function: (concatenate arrays &key (axis 0) out)","title":"concatenate"},{"location":"numcl/#conjugate","text":"Function: (conjugate x)","title":"conjugate"},{"location":"numcl/#copy","text":"Function: (copy array)","title":"copy"},{"location":"numcl/#cos","text":"Function: (cos x)","title":"cos"},{"location":"numcl/#cosh","text":"Function: (cosh x)","title":"cosh"},{"location":"numcl/#denominator","text":"Function: (denominator x)","title":"denominator"},{"location":"numcl/#diag","text":"Function: (diag a &optional result) Return the diagonal element of a matrix as a vector","title":"diag"},{"location":"numcl/#dirichlet","text":"","title":"dirichlet"},{"location":"numcl/#dot","text":"","title":"dot"},{"location":"numcl/#dtype","text":"Function: (dtype array)","title":"dtype"},{"location":"numcl/#einsum","text":"Function: (einsum subscripts &rest args) Performs Einstein's summation. The SUBSCRIPT specification is significantly extended from that of Numpy and can be seens as a full-brown DSL for array operations. SUBSCRIPTS is a sequence of the form (<SPEC>+ [-> <TRANSFORM>*] [-> [<SPEC>*]) . The remaining arguments ARGS contain the input arrays and optionally the output arrays.","title":"einsum"},{"location":"numcl/#spec","text":"The first set of SPECs specifies the input subscripts, and the second set of SPECs specifies the output subscripts. Unlike Numpy, there can be multiple output subscripts: It can performs multiple operations in the same loop, then return multiple values. The symbol -> can be a string and can belong to any package because it is compared by STRING=. Each SPEC is an alphabetical string designator, such as a symbol IJK or a string \"IJK\", where each alphabet is considered as an index. It signals a type-error when it contains any non-alpha char. Note that a symbol NIL is interpreted as an empty list rather than N, I and L. Alternatively, each SPEC can be a list that contains a list of symbols. For example, ((i j) (j k) -> (i k)) and (ij jk -> ik) are equivalent. When -> and the output SPECs are omitted, a single output is assumed and its spec is a union of the input specs. For example, (ij jk) is equivalent to (ij jk -> ijk) . Note that (ij jk) and (ij jk ->) have the different meanings: The latter sums up all elements.","title":"SPEC"},{"location":"numcl/#transform","text":"TRANSFORM is a list of element-wise operations. The number of TRANSFORM should correspond to the number of outputs. In each TRANSFORM, the elements in the input arrays can be referenced by $N, where N is a 1-indexed number. Similarly the output array can be referred to by @N. For example, (ij ik -> (+ @1 (* $1 $2)) -> ik) is equivalent to (ij ik -> ik) (a GEMM). By default, TRANSFORM is (+ @1 (* $1 ... $N)) for N inputs, which is equivalent to Einstein's summation.","title":"TRANSFORM"},{"location":"numcl/#args","text":"The shape of each input array should unify against the corresponding input spec. For example, with a spec IJI, the input array should be of rank 3 as well as the 1st and the 3rd dimension of the input array should be the same. The shape of each output array is determined by the corresponding output spec. For example, if SUBSCRIPTS is (ij jk -> ik) , the output is an array of rank 2, and the output shape has the same dimension as the first input in the first axis, and the same dimension as the second input in the second axis. If the output arrays are provided, their shapes and types are also checked against the corresponding output spec. The types should match the result of the numerical operations on the elements of the input arrays. The outputs are calculated in the following rule. The output array types are calculated based on the TRANSFORM, and the shapes are calcurated based on the SPEC and the input arrays. The output arrays are allocated and initialized by zeros. Einsum nests one loop for each index in the input specs. For example, (ij jk -> ik) results in a triple loop. In the innermost loop, each array element is bound to $1..$N / @1..@N . For each @i , i -th TRANSFORM is evaluated and assigned to @i . If the same index appears multiple times in a single spec, they share the same value in each iteration. For example, (ii -> i) returns the diagonal elements of the matrix. When TRANSFORMs are missing, it follows naturally from the default TRANSFORM values that When an index used in the input spec is missing in the output spec, the axis is aggregated over the iteration by summation. If the same index appears across the different input specs, the element values from the multiple input arrays are aggregated by multiplication. For example, (ij jk -> ik) will perform (setf (aref a2 i k) (* (aref a0 i j) (aref a1 j k))) when a0, a1 are the input arrays and a2 is the output array. For example, (einsum '(ij jk) a b) is equivalent to: (dotimes (i <max> <output>) (dotimes (j <max>) (dotimes (k <max>) (setf (aref <output> i j k) (* (aref a i j) (aref b j k))))))","title":"ARGS"},{"location":"numcl/#performance","text":"If SUBSCRIPTS is a constant, the compiler macro builds an iterator function and make them inlined. Otherwise, a new function is made in each call to einsum, resulting in a large bottleneck. (It could be memoized in the future.) The nesting order of the loops are automatically decided based on the specs. The order affects the memory access pattern and therefore the performance due to the access locality. For example, when writing a GEMM which accesses three matrices by (setf (aref output i j) (* (aref a i k) (aref b k j))) , it is well known that ikj-loop is the fastest among other loops, e.g. ijk-loop. EINSUM reorders the indices so that it maximizes the cache locality.","title":"Performance"},{"location":"numcl/#empty","text":"Function: (empty shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"empty"},{"location":"numcl/#empty-like","text":"Function: (empty-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"empty-like"},{"location":"numcl/#exp","text":"Function: (exp x)","title":"exp"},{"location":"numcl/#expand-dims","text":"Function: (expand-dims a axes) axes: an int or a list of ints","title":"expand-dims"},{"location":"numcl/#exponential","text":"Function: (exponential scale &optional shape (type (union-to-float-type (type-of scale))))","title":"exponential"},{"location":"numcl/#eye","text":"Function: (eye n &key (m n) (k 0) (type 'bit)) Returns a matrix whose k-th diagnonal filled with 1. N,M specifies the shape of the return array. K will adjust the sub-diagonal -- positive K moves it upward.","title":"eye"},{"location":"numcl/#f","text":"Function: (f dfnum dfden &optional shape (type (union-to-float-type (type-of dfnum) (type-of dfden))))","title":"f"},{"location":"numcl/#fceiling","text":"Function: (fceiling number &optional (divisor 1))","title":"fceiling"},{"location":"numcl/#ffloor","text":"Function: (ffloor number &optional (divisor 1))","title":"ffloor"},{"location":"numcl/#flatten","text":"Function: (flatten a)","title":"flatten"},{"location":"numcl/#floor","text":"Function: (floor number &optional (divisor 1))","title":"floor"},{"location":"numcl/#fround","text":"Function: (fround number &optional (divisor 1))","title":"fround"},{"location":"numcl/#ftruncate","text":"Function: (ftruncate number &optional (divisor 1))","title":"ftruncate"},{"location":"numcl/#full","text":"Function: (full shape value &key (type (type-of value))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"full"},{"location":"numcl/#full-like","text":"Function: (full-like array value &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"full-like"},{"location":"numcl/#gamma","text":"Function: (gamma k &optional (theta 1.0) shape (type (union-to-float-type (type-of k) (type-of theta))))","title":"gamma"},{"location":"numcl/#geometric","text":"","title":"geometric"},{"location":"numcl/#gumbel","text":"","title":"gumbel"},{"location":"numcl/#histogram","text":"Function: (histogram array &key (low (amin array)) (high (amax array)) (split 1)) Returns a fixnum vector representing a histogram of values. The interval between LOW and HIGH are split by STEP value. All values less than LOW are put in the 0-th bucket; All values greater than equal to HIGH are put in the last bucket.","title":"histogram"},{"location":"numcl/#hypergeometric","text":"","title":"hypergeometric"},{"location":"numcl/#imagpart","text":"Function: (imagpart x)","title":"imagpart"},{"location":"numcl/#inner","text":"Function: (inner a b &optional result) Inner product of two vectors.","title":"inner"},{"location":"numcl/#integer-length","text":"Function: (integer-length x)","title":"integer-length"},{"location":"numcl/#invalid-array-index-error","text":"NIL NUMCL.EXPORTED:SHAPE Initargs: :shape Readers: numcl.exported:invalid-array-index-error-shape Writers: (setf numcl.exported:invalid-array-index-error-shape)","title":"invalid-array-index-error"},{"location":"numcl/#axis","text":"Initargs: :axis Readers: numcl.exported:invalid-array-index-error-axis Writers: (setf numcl.exported:invalid-array-index-error-axis) #### subscripts ```lisp Initargs: :subscripts Readers: numcl.exported:invalid-array-index-error-subscripts Writers: (setf numcl.exported:invalid-array-index-error-subscripts)### kron ```lisp Function: (kron a b &optional result) Compute the kronecker product of two vectors.","title":"axis"},{"location":"numcl/#laplace","text":"","title":"laplace"},{"location":"numcl/#length","text":"Function: (length array)","title":"length"},{"location":"numcl/#linspace","text":"Function: (linspace start stop length &key type endpoint)","title":"linspace"},{"location":"numcl/#log","text":"Function: (log x)","title":"log"},{"location":"numcl/#logand","text":"Function: (logand &rest args)","title":"logand"},{"location":"numcl/#logandc1","text":"Function: (logandc1 &rest args)","title":"logandc1"},{"location":"numcl/#logandc2","text":"Function: (logandc2 &rest args)","title":"logandc2"},{"location":"numcl/#logcount","text":"Function: (logcount x)","title":"logcount"},{"location":"numcl/#logeqv","text":"Function: (logeqv &rest args)","title":"logeqv"},{"location":"numcl/#logior","text":"Function: (logior &rest args)","title":"logior"},{"location":"numcl/#logistic","text":"","title":"logistic"},{"location":"numcl/#lognand","text":"Function: (lognand &rest args)","title":"lognand"},{"location":"numcl/#lognor","text":"Function: (lognor &rest args)","title":"lognor"},{"location":"numcl/#lognormal","text":"","title":"lognormal"},{"location":"numcl/#lognot","text":"Function: (lognot x)","title":"lognot"},{"location":"numcl/#logorc1","text":"Function: (logorc1 &rest args)","title":"logorc1"},{"location":"numcl/#logorc2","text":"Function: (logorc2 &rest args)","title":"logorc2"},{"location":"numcl/#logseries","text":"","title":"logseries"},{"location":"numcl/#logxor","text":"Function: (logxor &rest args)","title":"logxor"},{"location":"numcl/#map","text":"Function: (map result-type function &rest sequences)","title":"map"},{"location":"numcl/#map-array","text":"Function: (map-array function &rest sequences)","title":"map-array"},{"location":"numcl/#map-array-into","text":"Function: (map-array-into result-sequence function &rest sequences)","title":"map-array-into"},{"location":"numcl/#map-into","text":"Function: (map-into result-sequence function &rest sequences)","title":"map-into"},{"location":"numcl/#matmul","text":"Function: (matmul a b &optional result) Matrix product of two arrays.","title":"matmul"},{"location":"numcl/#max","text":"Function: (max &rest args)","title":"max"},{"location":"numcl/#mean","text":"Function: (mean array &key axes)","title":"mean"},{"location":"numcl/#min","text":"Function: (min &rest args)","title":"min"},{"location":"numcl/#mod","text":"Function: (mod number &optional (divisor 1))","title":"mod"},{"location":"numcl/#multinomial","text":"Function: (multinomial n pvals &optional shape) pvals is a sequence of probabilities summing up to 1.","title":"multinomial"},{"location":"numcl/#multivariate-normal","text":"","title":"multivariate-normal"},{"location":"numcl/#negative-binomial","text":"Function: (negative-binomial n p &optional shape)","title":"negative-binomial"},{"location":"numcl/#noncentral-chisquare","text":"","title":"noncentral-chisquare"},{"location":"numcl/#noncentral-f","text":"","title":"noncentral-f"},{"location":"numcl/#nonzero","text":"Function: (nonzero array) collect multidimentional indices where the element is nonzero","title":"nonzero"},{"location":"numcl/#normal","text":"Function: (normal &optional (mean 0.0) (var 1.0) shape (type (union-to-float-type (type-of mean) (type-of var))))","title":"normal"},{"location":"numcl/#numcl-array","text":"","title":"numcl-array"},{"location":"numcl/#numcl-array-p","text":"Function: (numcl-array-p array) Returns true when ARRAY satisfies the NUMCL assumption, that is, an array displaced to a non-displaced 1D array.","title":"numcl-array-p"},{"location":"numcl/#numerator","text":"Function: (numerator x)","title":"numerator"},{"location":"numcl/#onehot","text":"","title":"onehot"},{"location":"numcl/#ones","text":"Function: (ones shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"ones"},{"location":"numcl/#ones-like","text":"Function: (ones-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"ones-like"},{"location":"numcl/#outer","text":"Function: (outer a b &optional result) Compute the outer product of two vectors.","title":"outer"},{"location":"numcl/#pareto","text":"","title":"pareto"},{"location":"numcl/#phase","text":"Function: (phase x)","title":"phase"},{"location":"numcl/#poisson","text":"Function: (poisson &optional (lambda 1.0) shape (type (union-to-float-type (type-of lambda))))","title":"poisson"},{"location":"numcl/#power","text":"","title":"power"},{"location":"numcl/#prod","text":"Function: (prod array &rest args &key axes type)","title":"prod"},{"location":"numcl/#rank","text":"Function: (rank array)","title":"rank"},{"location":"numcl/#rayleigh","text":"","title":"rayleigh"},{"location":"numcl/#realpart","text":"Function: (realpart x)","title":"realpart"},{"location":"numcl/#reduce-array","text":"Function: (reduce-array fn array &key axes (type (%reduce-array-result-type array fn)) (initial-element (zero-value type)))","title":"reduce-array"},{"location":"numcl/#rem","text":"Function: (rem number &optional (divisor 1))","title":"rem"},{"location":"numcl/#reshape","text":"Function: (reshape a shape) Reshape the array while sharing the backing 1D array. -1 implies that the axis size is deduced from the other axes. At most one axis is allowed to be -1. T implies that the axis size is preserved. It can be used as many times, but only at the right/leftmost axes. Example of reshaping (3 8 5): valid: (6 -1 10) = (6 2 10) (t 2 2 2 t) = (3 2 2 2 5) (3 t t) = (3 8 5) (2 -1 2 2 t) = (2 3 2 2 5) invalid: (2 t 2 2 t)","title":"reshape"},{"location":"numcl/#round","text":"Function: (round number &optional (divisor 1))","title":"round"},{"location":"numcl/#shape","text":"Function: (shape array)","title":"shape"},{"location":"numcl/#shuffle","text":"Function: (shuffle array-or-sequence &key (start 0) end) This code extends alexandria:shuffle. It additionally accepts arrays and shuffles the elements according to the first axis, viewing the remaining axes as one \"element\". Original documentation: Returns a random permutation of SEQUENCE bounded by START and END. Original sequence may be destructively modified, and (if it contains CONS or lists themselv) share storage with the original one. Signals an error if SEQUENCE is not a proper sequence.","title":"shuffle"},{"location":"numcl/#signum","text":"Function: (signum x)","title":"signum"},{"location":"numcl/#sin","text":"Function: (sin x)","title":"sin"},{"location":"numcl/#sinh","text":"Function: (sinh x)","title":"sinh"},{"location":"numcl/#size","text":"Function: (size array)","title":"size"},{"location":"numcl/#sqrt","text":"Function: (sqrt x)","title":"sqrt"},{"location":"numcl/#square","text":"Function: (square x)","title":"square"},{"location":"numcl/#squeeze","text":"Function: (squeeze a)","title":"squeeze"},{"location":"numcl/#stack","text":"Function: (stack arrays &key (axis 0) out)","title":"stack"},{"location":"numcl/#standard-cauchy","text":"","title":"standard-cauchy"},{"location":"numcl/#standard-deviation","text":"Function: (standard-deviation array &key axes)","title":"standard-deviation"},{"location":"numcl/#standard-exponential","text":"","title":"standard-exponential"},{"location":"numcl/#standard-gamma","text":"","title":"standard-gamma"},{"location":"numcl/#standard-normal","text":"","title":"standard-normal"},{"location":"numcl/#standard-t","text":"","title":"standard-t"},{"location":"numcl/#stdev","text":"Function: (stdev array &key axes)","title":"stdev"},{"location":"numcl/#sum","text":"Function: (sum array &rest args &key axes type)","title":"sum"},{"location":"numcl/#take","text":"Function: (take array indices) Collect the elements using a list of multidimentional indices (in a format returned by WHERE).","title":"take"},{"location":"numcl/#tan","text":"Function: (tan x)","title":"tan"},{"location":"numcl/#tanh","text":"Function: (tanh x)","title":"tanh"},{"location":"numcl/#to-simple-array","text":"Function: (to-simple-array array) Returns a simple array of the equivalent contents.","title":"to-simple-array"},{"location":"numcl/#transpose","text":"Function: (transpose matrix &optional result) Reverses the axes of an array.","title":"transpose"},{"location":"numcl/#tri","text":"Function: (tri n &key (m n) (k 0) (type 'bit)) Returns a triangle matrix whose lower diagnonal (including the diagonal) filled with 1. N,M specifies the shape of the return array. K will adjust the sub-diagonal -- positive K fills more 1s.","title":"tri"},{"location":"numcl/#triangular","text":"","title":"triangular"},{"location":"numcl/#tril","text":"Function: (tril matrix &optional (k 0)) Returns the copy of matrix with elements above the k-th diagonal zeroed. Positive K fills less 0s.","title":"tril"},{"location":"numcl/#triu","text":"Function: (triu matrix &optional (k 0)) Returns the copy of matrix with elements below the k-th diagonal zeroed. Positive K fills more 0s.","title":"triu"},{"location":"numcl/#truncate","text":"Function: (truncate number &optional (divisor 1))","title":"truncate"},{"location":"numcl/#uniform","text":"Function: (uniform &optional (low 0.0) (high 1.0) shape type)","title":"uniform"},{"location":"numcl/#unstack","text":"Function: (unstack array &key (axis 0))","title":"unstack"},{"location":"numcl/#vander","text":"Function: (vander v &key (n (length v)) increasing) Returns a matrix where M[i,j] == V[i]^(N-j) when increasing is false (default), and M[i,j] == V[i]^j when increasing is true.","title":"vander"},{"location":"numcl/#var","text":"Function: (var array &key axes)","title":"var"},{"location":"numcl/#variance","text":"Function: (variance array &key axes)","title":"variance"},{"location":"numcl/#vdot","text":"Function: (vdot a b &optional result) Dot product of two vectors. For complex values, the first value is conjugated.","title":"vdot"},{"location":"numcl/#vonmises","text":"","title":"vonmises"},{"location":"numcl/#wald","text":"","title":"wald"},{"location":"numcl/#weibull","text":"","title":"weibull"},{"location":"numcl/#where","text":"Function: (where array fn) Returns a list of list of indices of the elements which satisfies the predicate FN. The first list contains the indices for the 1st dimension, the second list contains the indices for the 2nd dimension, and so on.","title":"where"},{"location":"numcl/#zeros","text":"Function: (zeros shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"zeros"},{"location":"numcl/#zeros-like","text":"Function: (zeros-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"zeros-like"},{"location":"numcl/#zipf","text":"","title":"zipf"},{"location":"numcl/#more-discussion","text":"","title":"MORE DISCUSSION"},{"location":"numcl/#common-lisp-types","text":"Common Lisp has the following types for numbers. number = (or complex real) real = (or float rational) rational = (or ratio integer) integer = (or fixnum bignum) float = (or short-float ... long-float) (== irrational). Common Lisp defines several rules for the type of the values returned by the numerical operations. The detail of the rules are explained in CLHS 12.1 Number Concepts . Rational functions behave as rational* -> rational , float* -> float , {rational,float}* -> float . This rule is called float contagion rule. Rational functions do not guarantee integer -> integer , primarily due to / , which returns integer* -> (or ratio integer) . Irrational functions behaves as rational -> (or rational float) , float -> float : For a certain irrational functions, implementations are allowed to return the exact rational number or its float approximation. Examples are (sin pi) -> 1/2 . The behavior depends on the implementation and is called float substitution rule .","title":"Common Lisp Types"},{"location":"numcl/#array-representation-details","text":"NUMCL arrays are not based on custom classes or structures. They are merely the displaced multidimentional arrays. In order to guarantee the speed and to simplify the implementation, the arrays given to numcl functions must satisfy the following two conditions: It is a specialized array. Things of type (array single-float) , (array (unsigned-byte 16)) etc. It is an array displaced to a simple 1D specialized array. \" Simple array \" means a non-displaced, non-adjustable array without fill pointer. The base function for creating a new array is %make-array , but this is not exported in NUMCL. You should use the wrapper functions like ones , zeros , ones-like , arange , linspace , asarray etc. They are always inline-expanded to %make-array , therefore there is no worry about the performance. These functions analyze the input and return the most specialized array for the input, but you can also specify the element type. %make-array instantiates a new flattened array and returns another array displaced to it with the specified shape. The flattened array is returned as the secondary value (as does most other numcl functions). The justification for this scheme is that some implementations (esp. SBCL) require an indirection for accessing the array element (e.g. through array-header in SBCL) even for a simple multi-dimentional array and thus using a displacing array has essentially no performance penalty over using a simple multi-dimentional array. We also ensure that the length of the base arrays are the multiples of 8. This ensures that the program can safely iterate over the extended region with a future support for SIMD operations in mind.","title":"Array Representation Details"},{"location":"numcl/#author-license-copyright","text":"Masataro Asai (guicho2.71828@gmail.com) Licensed under LGPL v3. Copyright (c) 2019 IBM Corporation","title":"AUTHOR, LICENSE, COPYRIGHT"},{"location":"postmodern/","text":"postmodern - PostgreSQL programming interace Version: 1.30 Nickname: pomo Repository: marijnh/Postmodern - Github This page was possible due to the excellent official documentation as well as the page on Web Development on The Common Lisp Cookbook . In case of any inaccuracies, ambiguities or suggestions, please create an issue here . Postmodern is a Common Lisp library for interacting with PostgreSQL databases . The focus has been on: Efficient communication with the database server without need for foreign libraries. Support for UTF-8 on Unicode-aware Lisp implementations A syntax for mixing SQL and Lisp code Convenient support for prepared statements and stored procedures A metaclass for simple database-access objects The biggest differences between this library and clsql or cl-dbi are that Postmodern has no intention of being portable across different SQL implementations (it embraces non-standard PostgreSQL features), and approaches extensions like lispy SQL and database access objects in a quite different way. GETTING STARTED Starting the Postgres server [TODO] Someone more familiar with postgres or databases should review this section. Follow the installation instructions to install Postgres. Once done, you should have access to the postgres , pg_ctl , and optionally the psql commands on your command line / terminal. Once done, this page elaborates the process of starting the database server and any issues that may arise. (You can select the postgresql version from top of the page.) Initialize the directory: pg_ctl init -D postmodern # see \\ pg_ctl --help \\ from the options . Optionally, change port and unix_socket_directories from postmodern/postgresql.conf . pg_ctl start -D postmodern to start the server. You should get a server started message; if not, the link above should help in debugging. Proceed to the next section once you successfully start the server. This page elaborates on the configuration settings. In addition, you can list the databases by using psql -p PORT -h unix_socket_directories -l , replacing the italicized arguments appropriately. Connecting to the Postgres server We firstly connect to the default existing database. Create a new database for our purposes, and then disconnect and reconnect to this database. We also assume the server is started at 8080 and username is \"username\" . CL-USER> (connect-toplevel \"postgres\" \"username\" \"\" \"localhost\" :port 8080) ; No value CL-USER> (execute \"create database testdb\") 0 CL-USER> (disconnect-toplevel) NIL CL-USER> (connect-toplevel \"testdb\" \"username\" \"\" \"localhost\" :port 8080) ; No value [TODO] Distinguish why \"exactly\" connect and connect-toplevel are different? What goes on under the hood? Also, what role does :pooled-p play? Other things you may want to take a look at with regards to connection include: database-connection connect *default-use-ssl* disconnect connected-p reconnect *database* with-connection call-with-connection connect-toplevel disconnect-toplevel clear-connection-pool *max-pool-size* list-connections Executing arbitrary database commands Query is the basic way to send queries to the database: CL-USER> (query \"select 22, 'Folie et d\u00e9raison', 4.5\") ((22 \"Folie et d\u00e9raison\" 9/2)) CL-USER> (query (:select 22 \"Folie et d\u00e9raison\" 4.5)) ((22 \"Folie et d\u00e9raison\" 9/2)) In many contexts, query strings and lists starting with keywords can be used interchangeably. The lists will be compiled to SQL. The S-SQL manual describes the syntax used by these expressions. Lisp values occurring in them are automatically escaped. In the above query, only constant values are used, but it is possible to transparently use run-time values as well: CL-USER> (defun database-powered-addition (a b) (query (:select (:+ a b)) :single)) DATABASE-POWERED-ADDITION CL-USER> (database-powered-addition 1030 204) 1234 1 That last argument, :single , indicates that we want the result not as a list of lists (for the result rows), but as a single value, since we know that we are only selecting one value. See the documentation of query for the other options. You do not have to pull in the whole result of a query at once, you can also iterate over it with the doquery macro. The following things should be useful about querying: query execute doquery prepare defprepared defprepared-with-names with-transaction commit-transaction abort-transaction with-savepoint release-savepoint rollback-savepoint commit-hooks abort-hooks with-logical-transaction abort-logical-transaction commit-logical-transaction *current-logical-transaction* ensure-transaction with-schema sequence-next coalesce Database Access Class You can work directly with the database or you can use a simple database-access-class (aka dao-class ) which would cover all the fields in a row. This is what a database-access class looks like: (defclass points () ((x :col-type integer :initarg :x :reader point-x) (y :col-type integer :initarg :y :reader point-y) (value :col-type integer :initarg :value :accessor value)) (:metaclass dao-class) (:keys x y)) Once the class is defined, we create the table in the database: CL-USER> (dao-table-definition 'points) \"CREATE TABLE points (x INTEGER NOT NULL, y INTEGER NOT NULL, value INTEGER NOT NULL, PRIMARY KEY (x, y))\" CL-USER> (execute (dao-table-definition 'points)) 0 In more complicated cases, you might want to :create-table directly. You can use sql to view the result of parsing the form . CL-USER> (sql (:create-table so-items ((item-id :type integer) (so-id :type (or integer db-null) :references ((so-headers id))) (product-id :type (or integer db-null)) (qty :type (or integer db-null)) (net-price :type (or numeric db-null))) (:primary-key item-id so-id))) \"CREATE TABLE so_items (item_id INTEGER NOT NULL, so_id INTEGER REFERENCES so_headers(id) MATCH SIMPLE ON DELETE RESTRICT ON UPDATE RESTRICT, product_id INTEGER, qty INTEGER, net_price NUMERIC, PRIMARY KEY (item_id, so_id))\" (Note that you'd need to execute this form using query or execute . Also see this for details and examples on using S-SQL for creating tables.) You can use insert-dao for inserting DAO-objects into the database. (Of course, you can use query to do all this using the usual SQL syntax.) CL-USER> (insert-dao (make-instance 'points :x 0 :y 1 :value 10)) #<POINTS {10145AC1D3}> CL-USER> (insert-dao (make-instance 'points :x 1 :y 0 :value 15)) #<POINTS {10145B5EA3}> CL-USER> (select-dao 'country) (#<COUNTRY {101C5F3103}> #<COUNTRY {101C5F3883}>) 2 CL-USER> (select-dao 'points) (#<POINTS {1017B9BB93}> #<POINTS {1017B9BC23}>) 2 CL-USER> (query (:select '* :from 'points)) ((0 1 10) (1 0 15)) 2 Finally, you can use update-dao to, well, update the database entry: CL-USER> (let ((1-0 (get-dao 'points 1 0))) (setf (value 1-0) 20) (update-dao 1-0)) #<POINTS {101F1628E3}> CL-USER> (query (:select '* :from 'points)) ((0 1 10) (1 0 20)) 2 Here are the other useful constructs related to database access objects: dao-class dao-keys dao-exists-p make-dao define-dao-finalization get-dao select-dao do-select-dao query-dao do-query-dao *ignore-unknown-columns* insert-dao update-dao save-dao save-dao/transaction upsert-dao delete-dao dao-table-name dao-table-definition with-column-writers S-SQL Finally, here is some more demonstration of S-SQL syntax: (sql (:select 'relname :from 'pg-catalog.pg-class :inner-join 'pg-catalog.pg-namespace :on (:= 'relnamespace 'pg-namespace.oid) :where (:and (:= 'relkind \"r\") (:not-in 'nspname (:set \"pg_catalog\" \"pg_toast\")) (:pg-catalog.pg-table-is-visible 'pg-class.oid)))) ;; => \"(SELECT relname FROM pg_catalog.pg_class ;; INNER JOIN pg_catalog.pg_namespace ON (relnamespace = pg_namespace.oid) ;; WHERE ((relkind = 'r') and (nspname NOT IN ('pg_catalog', 'pg_toast')) ;; and pg_catalog.pg_table_is_visible(pg_class.oid)))\" Lists starting with keywords are used to express SQL commands and operators while lists starting with something else will be evaluated and then inserted into the query. Quoted symbols name columns or tables (keywords can also be used but might introduce ambiguities). The syntax supports subqueries, multiple joins, stored procedures, etc. See the S-SQL reference manual for a complete treatment. [TODO] Add more S-SQL examples. Compare them with SxQL as well. Prepared statements *allow-overwriting-prepared-statements* prepared-statement-exists-p list-prepared-statements drop-prepared-statement list-postmodern-prepared-statements find-postgresql-prepared-statement find-postmodern-prepared-statement reset-prepared-statement get-pid get-pid-from-postmodern cancel-backend terminate-backend Example Usage: CL-USER> (funcall (prepare (:select '* :from 'points :where (:= 'x '$1))) 0) ((0 1 10)) 1 prepare defprepared defprepared-with-names Migration [TODO] Groaking migrations needed for ELI5-cation. Other useful constructs Inspecting the database list-tables list-tables-in-schema table-exists-p table-description list-sequences sequence-exists-p list-views view-exists-p list-schemata schema-exist-p schema-exists-p database-version num-records-in-database current-database database-exists-p database-size list-databases list-schemas list-tablespaces list-available-types list-table-sizes table-size more-table-info list-columns list-columns-with-types column-exists-p describe-views list-database-functions list-indices list-table-indices index-exists-p list-indexed-column-and-attributes list-index-definitions find-primary-key-info list-foreign-keys list-unique-or-primary-constraints list-all-constraints describe-constraint describe-foreign-key-constraints list-triggers list-detailed-triggers list-database-users list-roles list-available-extensions list-installed-extensions change-toplevel-database Table definition and creation deftable !dao-def !index !unique-index !foreign !unique create-table create-all-tables create-package-tables *table-name* *table-symbol* Schemata create-schema drop-schema get-search-path set-search-path split-fully-qualified-table-name Database Health Measurements cache-hit-ratio bloat-measurement unused-indexes check-query-performance Miscellaneous Utility Functions execute-file CONFIGURATION VARIABLES *allow-overwriting-prepared-statements* Variable When set to t, ensured-prepared will overwrite prepared statements having the same name if the query statement itself in the postmodern meta connection is different than the query statement provided to ensure-prepared. *current-logical-transaction* Variable This is bound to the current transaction-handle or savepoint-handle instance representing the innermost open logical transaction. *database* Variable Special variable holding the current database. Most functions and macros operating on a database assume this binds to a connected database. *default-use-ssl* Variable The default for connect's use-ssl argument. This starts at :no. If you set it to anything else, be sure to also load the CL+SSL library. *escape-sql-names-p* Variable Setting this to T will make S-SQL add double quotes around identifiers in queries. Setting it :auto will turn on this behaviour only for reserved words. Setting it to :literal will cause to-sql-name to escape reserved words,but will not make other changes such as changing forward slash to underscore. *ignore-unknown-columns* Variable Normally, when get-dao, select-dao, or query-dao finds a column in the database that's not in the DAO class, it will raise an error. Setting this variable to a non-NIL will cause it to simply ignore the unknown column. *isolation-level* *max-pool-size* Variable Set the maximum amount of connections kept in a single connection pool, where a pool consists of all the stored connections with the exact same connect arguments. Defaults to NIL, which means there is no maximum. *table-name*, Variable These variables are bound to the relevant name and symbol while the forms of a table definition are evaluated. Can be used to define shorthands like the ones below. *table-symbol* Variable Used inside deftable to find the symbol naming the table being defined. FUNCTIONS AND MACROS !dao-def Function: (!dao-def) Should only be used inside deftable's body. Adds the result of calling dao-table-definition on table-symbol to the definition. !foreign Function: (!foreign target fields &rest target-fields/on-delete/on-update/deferrable/initially-deferred) Add a foreign key to the table being defined. target-table is the referenced table. columns is a list of column names or single name in this table, and, if the columns have different names in the referenced table, target-columns must be another list of column names or single column name of the target-table, or :primary-key to denote the column(s) of the target-table's primary key as referenced column(s). The on-delete and on-update arguments can be used to specify ON DELETE and ON UPDATE actions, as per the keywords allowed in create-table. In addition, the deferrable and initially-deferred arguments can be used to indicate whether constraint checking can be deferred until the current transaction completed, and whether this should be done by default. Note that none of these are really &key arguments, but rather are picked out of a &rest arg at runtime, so that they can be specified even when target-columns is not given. !index Function: (!index &rest fields) Define an index on the table being defined. The columns can be given as symbols or strings. !unique Function: (!unique target-fields &key deferrable initially-deferred) Constrains one or more columns to only contain unique (combinations of) values, with deferrable and initially-deferred defined as in !foreign !unique-index Function: (!unique-index &rest fields) Used inside a deftable form. Define a unique index on the defined table. abort-hooks Generic Function: (abort-hooks object) Generic Function: (setf (abort-hooks object) ...) An accessor for the transaction or savepoint's list of commit hooks, each of which should be a function with no required arguments. These functions will be executed when a transaction is committed or a savepoint released. abort-logical-transaction Generic Function: (abort-logical-transaction savepoint) Roll back the given logical transaction, regardless of whether it is an actual transaction or a savepoint. abort-transaction Function: (abort-transaction transaction) Roll back the given transaction. bloat-measurement Function: (bloat-measurement) \u2192 list Bloat measurement of unvacuumed dead tuples. Borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ who borrowed it from https://github.com/heroku/heroku-pg-extras/tree/master/commands . cache-hit-ratio Function: (cache-hit-ratio) \u2192 list The cache hit ratio shows data on serving the data from memory compared to how often you have to go to disk. This function returns a list of heapblocks read from disk, heapblocks hit from memory and the ratio of heapblocks hit from memory / total heapblocks hit. Borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ call-with-connection Function: (call-with-connection spec thunk) The functional backend to with-connection. Binds *database* to a new connection as specified by spec, which should be a list that connect can be applied to, and runs the zero-argument function given as second argument in the new environment. When the function returns or throws, the new connection is disconnected. cancel-backend Function: (cancel-backend pid &optional (database *database*)) Polite way of terminating a query at the database (as opposed to calling close-database). Slower than (terminate-backend pid) and does not always work. change-toplevel-database Function: (change-toplevel-database new-database user password host) \u2192 string Just changes the database assuming you are using a toplevel connection. Recommended only for development work. Returns the name of the newly connected database as a string. check-query-performance Function: (check-query-performance &optional (ob nil) (num-calls 100) (limit 20)) \u2192 list This function requires that postgresql extension pg_stat_statements must be loaded via shared_preload_libraries. It is borrowed from https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ . Optional parameters OB allow order-by to be 'calls', 'total-time', 'rows-per' or 'time-per', defaulting to time-per. num-calls to require that the number of calls exceeds a certain threshold, and limit to limit the number of rows returned. It returns a list of lists, each row containing the query, number of calls, total_time, total_time/calls, stddev_time, rows, rows/calls and the cache hit percentage. clear-connection-pool Function: (clear-connection-pool) Disconnect and remove all connections from the connection pools. coalesce Function: (coalesce &rest args) \u2192 value Returns the first non-NIL, non-NULL (as in :null) argument, or NIL if none are present. Useful for providing a fall-back value for the result of a query, or, when given only one argument, for transforming :nulls to NIL. column-exists-p Function: (column-exists-p table-name column-name) \u2192 boolean Determine if a particular column exists. Table name and column-name can be either strings or symbols. commit-hooks Generic Function: (commit-hooks object) An accessor for the transaction or savepoint's list of commit hooks, each of which should be a function with no required arguments. These functions will be executed when a transaction is committed or a savepoint released. commit-logical-transaction Generic Function: (commit-logical-transaction savepoint) [TODO] This symbol is not exported. Commit the given logical transaction, regardless of whether it is an actual transaction or a savepoint. commit-transaction Function: (commit-transaction transaction) Commit the given transaction. connect Function: (connect database-name user password host &key (port 5432) pooled-p (use-ssl *default-use-ssl*) (service postgres)) \u2192 database-connection Create a new database connection for the given user and the database. Port will default to 5432, which is where most PostgreSQL servers are running. If pooled-p is T, a connection will be taken from a pool of connections of this type, if one is available there, and when the connection is disconnected it will be put back into this pool instead. use-ssl can be :no, :yes, or :try, as in open-database, and defaults to the value of *default-use-ssl*. connect-toplevel Function: (connect-toplevel database-name user password host &key (port 5432) (use-ssl *default-use-ssl*)) Bind the *database* to a new connection. Use this if you only need one connection, or if you want a connection for debugging from the REPL. connected-p Function: (connected-p database) \u2192 boolean Returns a boolean indicating whether the given connection is still connected to the server. create-all-tables Function: (create-all-tables) Creates all defined tables. create-package-tables Function: (create-package-tables package) Creates all tables identified by symbols interned in the given package. create-schema Function: (create-schema schema) Creates a new schema. Raises an error if the schema is already exists. create-table Function: (create-table name) Creates the table identified by symbol by executing all forms in its definition. current-database Function: (current-database) \u2192 string Returns the string name of the current database. dao-class : (dao-class) Postmodern contains a simple system for defining CLOS classes that represent rows in the database. This is not intended as a full-fledged object-relational magic system \u2015 while serious ORM systems have their place, they are notoriously hard to get right, and are outside of the scope of a humble SQL library like this. At the heart of Postmodern's DAO system is the dao-class metaclass. It allows you to define classes for your database-access objects as regular CLOS classes. Some of the slots in these classes will refer to columns in the database. To specify that a slot refers to a column, give it a :col-type option containing an S-SQL type expression (useful if you want to be able to derive a table definition from the class definition), or simply a :column option with value T. Such slots can also take a :col-default option, used to provide a database-side default value as an S-SQL expression. You can use the :col-name initarg (whose unevaluated value will be passed to to-sql-name) to specify the slot's column's name. DAO class definitions support two extra class options: :table-name to give the name of the table that the class refers to (defaults to the class name), and :keys to provide a set of primary keys for the table. When no primary keys are defined, operations such as update-dao and get-dao will not work. IMPORTANT: Class finalization for a dao class instance are wrapped with a thread lock. However, any time you are using threads and a class that inherits from other classes, you should ensure that classes are finalized before you start generating threads that create new instances of that class. Simple example: (defclass user () ((name :col-type string :initarg :name :accessor user-name) (creditcard :col-type (or db-null integer) :initarg :card :col-default :null) (score :col-type bigint :col-default 0 :accessor user-score)) (:metaclass dao-class) (:keys name)) The (or db-null integer) form is used to indicate a column can have NULL values. When inheriting from DAO classes, a subclass' set of columns also contains all the columns of its superclasses. The primary key for such a class is the union of its own keys and all the keys from its superclasses. Classes inheriting from DAO classes should probably always use the dao-class metaclass themselves. When a DAO is created with make-instance, the :fetch-defaults keyword argument can be passed, which, when T, will cause a query to fetch the default values for all slots that refers to columns with defaults and were not bound through initargs. In some cases, such as serial columns, which have an implicit default, this will not work. You can work around this by creating your own sequence, e.g. \"my_sequence\", and defining a (:nextval \"my_sequence\") default. Finally, DAO class slots can have an option :ghost t to specify them as ghost slots. These are selected when retrieving instances, but not written when updating or inserting, or even included in the table definition. The only known use for this to date is for creating the table with (oids=true), and specify a slot like this: (oid :col-type integer :ghost t :accessor get-oid) dao-exists-p Generic Function: (dao-exists-p dao) \u2192 boolean Test whether a row with the same primary key as the given dao exists in the database. Will also return NIL when any of the key slots in the object are unbound. dao-keys Generic Function: (dao-keys class) \u2192 list Returns list of slot names that are the primary key of DAO class. This is likely interesting if you have primary keys which are composed of more than one slot. Pay careful attention to situations where the primary key not only has more than one column, but they are actually in a different order than they are in the database table itself. You can check this with the find-primary-key-info function. (pomo:find-primary-key-info \"country1\") ((\"name\" \"text\") (\"id\" \"integer\")) \u2192 list Returns list of values that are the primary key of dao. dao-table-definition Function: (dao-table-definition table) \u2192 string Given a DAO class, or the name of one, this will produce an SQL query string with a definition of the table. This is just the bare simple definition, so if you need any extra indices or or constraints, you'll have to write your own queries to add them, in which case look to s-sql's create-table function. dao-table-name Function: (dao-table-name class) \u2192 string Get the name of the table associated with the given DAO class (or symbol naming such a class). database-connection : (database-connection) Objects of this type represent database connections. database-error Condition This is the condition type that will be used to signal virtually all database-related errors (though in some cases socket errors may be raised when a connection fails on the IP level). Direct Slots cl-postgres::error-code Initargs: :CODE cl-postgres::message Initargs: :MESSAGE Readers: CL-POSTGRES:DATABASE-ERROR-MESSAGE cl-postgres::detail Initargs: :DETAIL cl-postgres::hint Initargs: :HINT cl-postgres::context Initargs: :CONTEXT cl-postgres::query position Initargs: :POSITION cl-postgres::cause Initargs: :CAUSE database-error-cause Generic Function: (database-error-cause condition) database-error-code Generic Function: (database-error-code condition) database-error-constraint-name Function: (database-error-constraint-name err) Given a database-error for an integrity violation, will attempt to extract the constraint name. database-error-detail Generic Function: (database-error-detail condition) database-error-extract-name Function: (database-error-extract-name err) Given a database-error, will extract the critical name from the error message. database-error-message Generic Function: (database-error-message condition) database-error-query Generic Function: (database-error-query condition) database-exists-p Function: (database-exists-p database-name) \u2192 boolean Checks to see if a particular database exists. database-size Function: (database-size &optional (name nil)) \u2192 list Given the name of a database, will return the name, a pretty-print string of the size of the database and the size in bytes. If a database name is not provided, it will return the result for the currently connected database. database-version Function: (database-version) \u2192 string Returns the version of the current postgresql database. define-dao-finalization Macro: (define-dao-finalization ((dao-name class) &rest keyword-args) &body body) Create an :around-method for make-dao. The body is executed in a lexical environment where dao-name is bound to a freshly created and inserted DAO. The representation of the DAO in the database is then updated to reflect changes that body might have introduced. Useful for processing values of slots with the type serial, which are unknown before insert-dao. defprepared Macro: (defprepared name query &optional (format rows)) \u2192 function This is the macro-style variant of prepare. It is like prepare, but gives the function a name which now becomes a top-level function for the prepared statement. The name should not be quoted or a string. defprepared-with-names Macro: (defprepared-with-names name (&rest args) (query &rest query-args) &optional (format rows)) Like defprepared, but allows to specify names of the function arguments as well as arguments supplied to the query. (defprepared-with-names user-messages (user &key (limit 10)) (\"select * from messages where user_id = $1 order by date desc limit $2\" (user-id user) limit) :plists) deftable Macro: (deftable name &body definitions) Define a table. name can be either a symbol or a (symbol string) list. In the first case, the table name is derived from the symbol's name by S-SQL's rules. In the second case, the name is given explicitly. The body of definitions can contain anything that evaluates to a string, as well as S-SQL expressions. The variables *table-name* and *table-symbol* are bound to the relevant values in the body. Note that the evaluation of the definition is ordered, so you'll generally want to create your table first and then define indices on it. delete-dao Generic Function: (delete-dao dao) Delete the given dao from the database. describe-constraint Function: (describe-constraint table-name constraint-name) \u2192 list Return a list of alists of the descriptions a particular constraint given the table-name and the constraint name using the information_schema table. describe-foreign-key-constraints Function: (describe-foreign-key-constraints) \u2192 list Generates a list of lists of information on the foreign key constraints describe-views Function: (describe-views &optional (schema public)) \u2192 list Describe the current views in the specified schema. Defaults to public schema. disconnect Generic Function: (disconnect database) Disconnects a normal database connection, or moves a pooled connection into the pool. disconnect-toplevel Function: (disconnect-toplevel) Disconnect the *database*. do-query-dao Macro: (do-query-dao ((type type-var) query) &body body) \u2192 list Like query-dao, but iterates over the results rather than returning them. For each matching DAO, body is evaluated with type-var bound to the instance. (do-query-dao (('user user) (:order-by (:select '* :from 'user :where (:> 'score 10000)) 'name)) (pushnew user high-scorers)) do-select-dao Macro: (do-select-dao ((type type-var) &optional (test) &rest ordering) &body body) Like select-dao, but iterates over the results rather than returning them. For each matching DAO, body is evaluated with type-var bound to the DAO instance. (do-select-dao (('user user) (:> 'score 10000) 'name) (pushnew user high-scorers)) doquery Macro: (doquery query (&rest names) &body body) Execute the given query (a string or a list starting with a keyword), iterating over the rows in the result. The body will be executed with the values in the row bound to the symbols given in names. To iterate over a parameterised query, one can specify a list whose car is the query, and whose cdr contains the arguments. For example: (doquery (:select 'name 'score :from 'scores) (n s) (incf (gethash n *scores*) s)) (doquery ((:select 'name :from 'scores :where (:> 'score '$1)) 100) (name) (print name)) double-precision drop-index Function: (drop-index name &key concurrently if-exists cascade) Drop an index. Available keys are :concurrently, :if-exists, and :cascade. drop-prepared-statement Function: (drop-prepared-statement name &key (location both) (database *database*) (remove-function t)) Prepared statements are stored both in the meta slot in the postmodern connection and in postgresql session information. If you know the prepared statement name, you can delete the prepared statement from both locations (the default behavior), just from postmodern (passing :postmodern to the location key parameter) or just from postgresql (passing :postgresql to the location key parameter). If you pass the name 'All' as the statement name, it will delete all prepared statements. The statement name can be a string or quoted symbol. drop-schema Function: (drop-schema schema &key (if-exists nil) (cascade nil)) Removes a schema. Accepts :if-exists and/or :cascade arguments like :drop-table. drop-sequence Function: (drop-sequence name &key if-exists cascade) Drop a sequence. Name should be quoted. Available key parameters are :if-exists and :cascade drop-table Function: (drop-table name &key if-exists cascade) Drop a table. Available additional key parameters are :if-exists and :cascade. ensure-transaction Macro: (ensure-transaction &body body) Ensures that body is executed within a transaction, but does not begin a new transaction if one is already in progress. ensure-transaction-with-isolation-level Macro: (ensure-transaction-with-isolation-level isolation-level &body body) Executes body within a with-transaction form if and only if no transaction is already in progress. This adds the ability to specify an isolatin level other than the current default execute Macro: (execute query &rest args) Like query called with format :none. Returns the amount of affected rows as its first returned value. (Also returns this amount as the second returned value, but use of this is deprecated.) execute-file Function: (execute-file pathname &optional (print nil)) This function will execute sql queries stored in a file. Each sql statement in the file will be run independently, but if one statement fails, subsequent query statements will not be run, but any statement prior to the failing statement will have been commited. If you want the standard transction treatment such that all statements succeed or no statement succeeds, then ensure that the file starts with a \"begin transaction\" statement and finishes with an \"end transaction\" statement. See the test file test-execute-file-broken-transaction.sql as an example. For debugging purposes, if the optional print parameter is set to t, format will print the count of the query and the query to the REPL. IMPORTANT NOTE: This utility function assumes that the file containing the sql queries can be trusted and bypasses the normal postmodern parameterization of queries. find-postgresql-prepared-statement Function: (find-postgresql-prepared-statement name) \u2192 string Returns the specified named prepared statement (if any) that postgresql has for this session. find-postmodern-prepared-statement Function: (find-postmodern-prepared-statement name) \u2192 string Returns the specified named prepared statement (if any) that postmodern has put in the meta slot in the connection. Note that this is the statement itself, not the name. find-primary-key-info Function: (find-primary-key-info table &optional (just-key nil)) \u2192 list Returns a list of two strings. First the column name of the primary key of the table and second the string name for the datatype. Optionally, just-key can be set to t and it will return just the column name of the primary key as a string. get-dao Generic Function: (get-dao type &rest args) \u2192 dao Select the DAO object from the row that has the given primary key values, or NIL if no such row exists. Objects created by this function will have initialize-instance called on them (after loading in the values from the database) without any arguments \u2015 even :default-initargs are skipped. The same goes for select-dao and query-dao. get-pid Function: (get-pid) \u2192 integer Get the process id used by postgresql for this connection. get-pid-from-postmodern Function: (get-pid-from-postmodern) \u2192 integer Get the process id used by postgresql for this connection, but get it from the postmodern connection parameters. get-search-path Function: (get-search-path) Retrieve the current search path. index-exists-p Function: (index-exists-p index-name) \u2192 boolean Tests whether an index with the given name exists. The name can be either a string or a symbol. insert-dao Generic Function: (insert-dao dao) \u2192 dao Insert the given dao into the database. Column slots of the object which are unbound implies the database defaults. Hence, if these columns has no defaults defined in the database, the the insertion of the dao will be failed. (This feature only works on PostgreSQL 8.2 and up.) list-all-constraints Function: (list-all-constraints table-name &optional (strings-p)) \u2192 list Users information_schema to list all the constraints in a table. Table-name can be either a string or quoted. list-available-extensions Function: (list-available-extensions) \u2192 list List the postgresql extensions which are available in the system to the currently connected database. The extensions may or may not be installed. \u2192 list Lists extensions that are available to be installed in the database. Returns a list of lists where each sublist has the name of the extension, the default version, the installed version (if any) and a comment string. list-available-types Function: (list-available-types) \u2192 list List the available types in this postgresql version. list-columns Function: (list-columns table-name) \u2192 list Returns a list of strings of just the column names in a table. Pulls info from the postmodern table-description function rather than directly. list-columns-with-types Function: (list-columns-with-types table-name) \u2192 list Return a list of (name type) lists for the fields of a table. Goes directly to the pg-catalog tables. list-connections Function: (list-connections) \u2192 list List the current postgresql connections to the currently connected database. list-database-functions Function: (list-database-functions) \u2192 list Returns a list of the functions in the database from the information_schema. list-database-users Function: (list-database-users) \u2192 list List database users. list-databases Function: (list-databases &key (order-by-size nil) (size t)) \u2192 list Returns a list of lists where each sub-list contains the name of the database, a pretty-print string of the size of that database and the size in bytes. The default order is by database name. Pass t as a parameter to :order-by-size for order by size. Setting size to nil will return just the database names in a single list ordered by name. This function excludes the template databases list-detailed-triggers Function: (list-detailed-triggers) \u2192 list List detailed information on the triggers from the information_schema table. list-foreign-keys Function: (list-foreign-keys table schema) \u2192 list Returns a list of sublists of foreign key info in the form of '((constraint-name local-table local-table-column foreign-table-name foreign-column-name)) list-index-definitions Function: (list-index-definitions table-name) \u2192 list Returns a list of the definitions used to create the current indexes for the table list-indexed-column-and-attributes Function: (list-indexed-column-and-attributes table-name) \u2192 list List the indexed columns and their attributes in a table. Includes primary key. list-indices Function: (list-indices &optional strings-p) \u2192 list Return a list of the indexs in a database. Turn them into keywords if strings-p is not true. list-installed-extensions Function: (list-installed-extensions) \u2192 list List the postgresql extensions which are installed in the currently connected database. \u2192 list Return a list of the installed extension list-postmodern-prepared-statements Function: (list-postmodern-prepared-statements &optional (names-only nil)) \u2192 list List the prepared statements that postmodern has put in the meta slot in the connection. It will return a list of alists of form: ((:NAME . SNY24) (:STATEMENT . (SELECT name, salary FROM employee WHERE (city = \\$1))) (:PREPARE-TIME . #<TIMESTAMP 25-11-2018T15:36:43,385>) (:PARAMETER-TYPES . text) (:FROM-SQL) If the names-only parameter is set to t, it will only return a list of the names of the prepared statements. list-prepared-statements : (list-prepared-statements (&optional names-only)) \u2192 list This is syntactic sugar. It runs a query that lists the prepared statements in the session in which the function is run. If the names-only parameter is set to t, it will only return a list of the names of the prepared statements. list-roles Function: (list-roles &optional (lt nil)) \u2192 list Returns a list of alists of rolenames, role attributes and membership in roles. See https://www.postgresql.org/docs/current/role-membership.html for an explanation. Optionally passing :alists or :plists can be used to set the return list types to :alists or :plists. This is the same as the psql function \\du. list-schemas Function: (list-schemas) \u2192 list List schemas in the current database, excluding the pg_* system schemas. list-schemata Function: (list-schemata) \u2192 list Returns list of the user defined schemata (as strings) and the quantity of existing schemata. list-sequences Function: (list-sequences &optional strings-p) \u2192 list Returns a list of the sequences in the current database. When strings-p is T, the names will be given as strings, otherwise as keywords. list-table-indices Function: (list-table-indices table-name &optional strings-p) \u2192 list List the index names and the related columns in a table. Returns a list of alists. list-table-sizes Function: (list-table-sizes &key (schema public) (order-by-size nil) (size t)) \u2192 list Returns a list of lists (table-name, size in 8k pages) of tables in the current database. Providing a name to the schema parameter will return just the information for tables in that schema. It defaults to just the tables in the public schema. Setting schema to nil will return all tables, indexes etc in the database in descending order of size. This would include system tables, so there are a lot more than you would expect. If :size is set to nil, it returns only a flat list of table names. Setting order-by-size to t will return the result in order of size instead of by table name. list-tables Function: (list-tables &optional strings-p) \u2192 list Returns a list of the tables in the current database and schema. When strings-p is T, the names will be given as strings, otherwise as keywords. list-tables-in-schema Function: (list-tables-in-schema &optional (schema-name public) lisp-strings-p) \u2192 list Returns a list of the tables in the current database and the specified schema. When strings-p is T,the names will be given as strings, otherwise as keywords. list-tablespaces Function: (list-tablespaces) \u2192 list Lists the tablespaces in the currently connected database. list-triggers Function: (list-triggers &optional table-name) \u2192 list List distinct trigger names from the information_schema table. Table-name can be either quoted or string. list-unique-or-primary-constraints Function: (list-unique-or-primary-constraints table-name &optional (strings-p)) \u2192 list List constraints on a table. list-views Function: (list-views &optional strings-p) \u2192 list Returns list of the user defined views in the current database. When strings-p is T, the names will be returned as strings, otherwise as keywords. make-dao Generic Function: (make-dao type &rest args &key &allow-other-keys) \u2192 dao Combines make-instance with insert-dao. Return the created dao. more-table-info Function: (more-table-info table-name) \u2192 list Returns more table info than table-description. Table can be either a string or quoted. num-records-in-database Function: (num-records-in-database) \u2192 list Returns a list of lists with schema, table name and approximate number of records in the currently connected database. numeric parse-queries Function: (parse-queries file-content) read SQL queries in given string and split them, returns a list prepare Macro: (prepare query &optional (format rows)) \u2192 function Wraps a query into a function that can be used as the interface to a prepared statement. The given query (either a string or an S-SQL form) may contain placeholders, which look like \\$1, \\$2, etc. The resulting function takes one argument for every placeholder in the query, executes the prepared query, and returns the result in the format specified. (Allowed formats are the same as for query.) For queries that have to be run very often, especially when they are complex, it may help performance since the server only has to plan them once. See the PostgreSQL manual for details. In some cases, the server will complain about not being able to deduce the type of the arguments in a statement. In that case you should add type declarations (either with the PostgreSQL's CAST SQL-conforming syntax or historical :: syntax, or with S-SQL's :type construct) to help it out. Note that it will attempt to automatically reconnect if database-connection-error, or admin-shutdown. It will reset prepared statements triggering an invalid-sql-statement-name error. It will overwrite old prepared statements triggering a duplicate-prepared-statement error. prepared-statement-exists-p Function: (prepared-statement-exists-p name) \u2192 boolean This returns t if the prepared statement exists in the current postgresql session, otherwise nil. query Macro: (query query &rest args/format) \u2192 result Execute the given query, which can be either a string or an S-SQL form (list starting with a keyword). If the query contains placeholders (\\$1, \\$2, etc) their values can be given as extra arguments. If one of these arguments is a keyword occurring in the table below, it will not be used as a query argument, but will determine the format in which the results are returned instead. Any of the following formats can be used, with the default being :rows: :none | Ignore the result values. | :lists, :rows | Return a list of lists, each list containing the values for a row. | :list, :row | Return a single row as a list. | :alists | Return a list of alists which map column names to values, with the names represented as keywords. | :alist | Return a single row as an alist. | :array-hash | Return an array of hashtables which map column names to hash table keys | :str-alists | Like :alists, but use the original column names. | :str-alist | Return a single row as an alist, with strings for names. | :plists | Return a list of plists which map column names to values,with the names represented as keywords. | :plist | Return a single row as a plist. | :column | Return a single column as a list. | :single | Return a single value. | :single! | Like :single, but raise an error when the number of selected rows is not equal to 1. | (:dao type) | Return a list of DAOs of the given type. The names of the fields returned by the query must match slots in the DAO class the same way as with query-dao. | (:dao type :single) | Return a single DAO of the given type. | If the database returns information about the amount rows that were affected, such as with updating or deleting queries, this is returned as a second value. query-dao Macro: (query-dao type query &rest args) \u2192 list Execute the given query (which can be either a string or an S-SQL expression) and return the result as DAOs of the given type. If the query contains placeholders (\\$1, \\$2, etc) their values can be given as extra arguments. The names of the fields returned by the query must either match slots in the DAO class, or be bound through with-column-writers. read-queries Function: (read-queries filename) read SQL queries in given file and split them, returns a list real NIL reconnect Generic Function: (reconnect database) Reconnect a disconnected database connection. This is not allowed for pooled connections \u2015 after they are disconnected they might be in use by some other process, and should no longer be used. register-sql-operators Macro: (register-sql-operators arity &rest names) Define simple operators. Arity is one of :unary (like 'not'), :unary-postfix (the operator comes after the operand), :n-ary (like '+': the operator falls away when there is only one operand), :2+-ary (like '=', which is meaningless for one operand), or :n-or-unary (like '-', where the operator is kept in the unary case). After the arity follow any number of operators, either just a keyword, in which case the downcased symbol name is used as the operator, or a two-element list containing a keyword and a name string. release-savepoint Function: (release-savepoint savepoint) Release the given savepoint. reset-prepared-statement Function: (reset-prepared-statement condition) \u2192 restart If you have received an invalid-prepared-statement error but the prepared statement is still in the meta slot in the postmodern connection, this will try to regenerate the prepared statement at the database connection level and restart the connection. rollback-savepoint Function: (rollback-savepoint savepoint) Roll back the given savepoint. save-dao Function: (save-dao dao) \u2192 boolean Tries to insert the given dao using insert-dao. If this raises a unique key violation error, it tries to update it by using update-dao instead. Be aware that there is a possible race condition here \u2015 if some other process deletes the row at just the right moment, the update fails as well. Returns a boolean telling you whether a new row was inserted. This function is unsafe to use inside of a transaction \u2015 when a row with the given keys already exists, the transaction will be aborted. Use save-dao/transaction instead in such a situation. See also: upsert-dao. save-dao/transaction Function: (save-dao/transaction dao) \u2192 boolean Acts exactly like save-dao, except that it protects its attempt to insert the object with a rollback point, so that a failure will not abort the transaction. See also: upsert-dao. schema-exists-p Function: (schema-exists-p name) \u2192 boolean Tests the existence of a given schema. Returns T if the schema exists or NIL otherwise. select-dao Macro: (select-dao type &optional (test t) &rest ordering) \u2192 list Select DAO objects for the rows in the associated table for which the given test (either an S-SQL expression or a string) holds. When sorting arguments are given, which can also be S-SQL forms or strings, these are used to sort the result. (Note that, if you want to sort, you have to pass the test argument.) (select-dao 'user (:> 'score 10000) 'name) sequence-exists-p Function: (sequence-exists-p sequence) \u2192 boolean Tests whether a sequence with the given name exists. The name can be either a string or a symbol. sequence-next Function: (sequence-next sequence) \u2192 integer Get the next value from a sequence. The sequence identifier can be either a string or a symbol, in the latter case it will be converted to a string according to S-SQL rules. set-search-path Function: (set-search-path path) Sets the search path to the path. This function is used by with-schema. split-fully-qualified-table-name : (split-fully-qualified-table-name) \u2192 list Takes a name of the form database.schema.table or schema.table or just table and returns a list in the form '(table schema database) sql Macro: (sql form) Compile form to a sql expression as far as possible. sql-compile Function: (sql-compile form) sql-error Function: (sql-error control &rest args) Condition sql-escape Generic Function: (sql-escape arg) Get the representation of a Lisp value so that it can be used in a query. sql-escape-string Function: (sql-escape-string string &optional prefix) Escape string data so it can be used in a query. table-description Function: (table-description table-name &optional schema-name) \u2192 list Returns a list of the fields in the named table. Each field is represented by a list of three elements: the field name, the type, and a boolean indicating whether the field may be NULL. Optionally, schema-name can be specified to restrict the result to fields from the named schema. Without it, all fields in the table are returned, regardless of their schema. table-exists-p Function: (table-exists-p table-name &optional (schema-name nil)) \u2192 boolean Tests whether a table with the given name exists. The name can be either a string or a symbol. It can also be qualified in the form of 'schema.table or 'database.schema.table table-size Function: (table-size table-name) \u2192 list Return the size of a postgresql table in k or m. Table-name can be either a string or quoted. terminate-backend Function: (terminate-backend pid &optional (database *database*)) Less polite way of terminating at the database (as opposed to calling close-database). Faster than (cancel-backend pid) and more reliable. unused-indexes Function: (unused-indexes) \u2192 list Returns a list of lists showing schema.table, indexname, index_size and number of scans. The code was borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ update-dao Generic Function: (update-dao dao) \u2192 dao Update the representation of the given dao in the database to the values in the object. This is not defined for tables that do not have any non-primary-key columns. Raises an error when no row matching the dao exists. upsert-dao Generic Function: (upsert-dao dao) \u2192 dao Like save-dao or save-dao/transaction but using a different method that doesn't involve a database exception. This is safe to use both in and outside a transaction, though it's advisable to always do it in a transaction to prevent a race condition. The way it works is: If the object contains unbound slots, we call insert-dao directly, thus the behavior is like save-dao. Otherwise we try to update a record with the same primary key. If the PostgreSQL returns a non-zero number of rows updated it treated as the record is already exists in the database, and we stop here. If the PostgreSQL returns a zero number of rows updated, it treated as the record does not exist and we call insert-dao. The race condition might occur at step 3 if there's no transaction: if UPDATE returns zero number of rows updated and another thread inserts the record at that moment, the insertion implied by step 3 will fail. Note, that triggers and rules may affect the number of inserted or updated rows returned by PostgreSQL, so zero or non-zero number of affected rows may not actually indicate the existence of record in the database. This method returns two values: the DAO object and a boolean (T if the object was inserted, NIL if it was updated). varchar view-exists-p Function: (view-exists-p view) \u2192 boolean Tests whether a view with the given name exists. The name can be either a string or a symbol. with-column-writers Macro: (with-column-writers (&rest defs) &body body) Provides control over the way get-dao, select-dao, and query-dao read values from the database. This is not commonly needed, but can be used to reduce the amount of queries a system makes. writers should be a list of alternating column names (strings or symbols) and writers, where writers are either symbols referring to a slot in the objects, or functions taking two arguments \u2015 an instance and a value \u2015 which can be used to somehow store the value in the new instance. When any DAO-fetching function is called in the body, and columns matching the given names are encountered in the result, the writers are used instead of the default behaviour (try and store the value in the slot that matches the column name). An example of using this is to add some non-column slots to a DAO class, and use query-dao within a with-column-writers form to pull in extra information about the objects, and immediately store it in the new instances. with-connection Macro: (with-connection spec &body body) Evaluates the body with *database* bound to a connection as specified by spec, which should be list that connect can be applied to. with-logical-transaction Macro: (with-logical-transaction (&optional (name) (isolation-level)) &body body) Executes body within a with-transaction form if no transaction is currently in progress, otherwise simulates a nested transaction by executing it within a with-savepoint form. The transaction or savepoint is bound to name if one is supplied. The isolation-level will set the isolation-level used by the transaction. You can specify the following isolation levels in postmodern transactions: :read-committed-rw (read committed with read and write) :read-committed-ro (read committed with read only) :repeatable-read-rw (repeatable read with read and write) :repeatable-read-ro (repeatable read with read only) :serializable (serializable with reand and write) Sample usage where \"george\" is just the name given to the transaction (not quoted or a string) and ... simply indicates other statements would be expected here: (with-logical-transaction () (execute (:insert-into 'test-data :set 'value 77)) ...) (with-logical-transaction (george) (execute (:insert-into 'test-data :set 'value 22)) ...) (with-logical-transaction (george :read-committed-rw) (execute (:insert-into 'test-data :set 'value 33)) ...) (with-logical-transaction (:serializable) (execute (:insert-into 'test-data :set 'value 44)) ...) with-savepoint Macro: (with-savepoint name &body body) Can only be used within a transaction. Establishes a savepoint with the given name at the start of body, and binds the same name to a handle for that savepoint. At the end of body, the savepoint is released, unless a condition is thrown, in which case it is rolled back. with-schema Macro: (with-schema (schema &key (strict) (if-not-exist) (drop-after)) &body form) Sets the current schema to namespace and executes the body. Before executing body the PostgreSQL's session variable search_path is set to the given namespace. After executing body the search_path variable is restored to the original value. If the keyword :strict is set to T then the namespace is only the scheme on the search path upon the body execution. Otherwise the namespace is just first schema on the search path upon the the body execution. If :if-not-exist is NIL, an error is signaled. If :drop-after is T the namespace is dropped from the database after the body execution. with-transaction Macro: (with-transaction (&optional name isolation-level) &body body) Execute the given body within a database transaction, committing it when the body exits normally, and aborting otherwise. An optional name and/or isolation-level can be given to the transaction. The name can be used to force a commit or abort before the body unwinds. The isolation-level will set the isolation-level used by the transaction. You can specify the following isolation levels in postmodern transactions: :read-committed-rw (read committed with read and write) :read-committed-ro (read committed with read only) :repeatable-read-rw (repeatable read with read and write) :repeatable-read-ro (repeatable read with read only) :serializable (serializable with reand and write) Sample usage where \"george\" is just the name given to the transaction (not quoted or a string) and ... simply indicates other statements would be expected here: (with-transaction () (execute (:insert-into 'test-data :set 'value 77)) ...) (with-transaction (george) (execute (:insert-into 'test-data :set 'value 22)) ...) (with-transaction (george :read-committed-rw) (execute (:insert-into 'test-data :set 'value 33)) (query (:select '* :from 'test-data)) ...) (with-transaction (:serializable) (execute (:insert-into 'test-data :set 'value 44)) ...) Further discussion of transactions and isolation levels can found here .","title":"postmodern - PostgreSQL programming interace"},{"location":"postmodern/#postmodern-postgresql-programming-interace","text":"Version: 1.30 Nickname: pomo Repository: marijnh/Postmodern - Github This page was possible due to the excellent official documentation as well as the page on Web Development on The Common Lisp Cookbook . In case of any inaccuracies, ambiguities or suggestions, please create an issue here . Postmodern is a Common Lisp library for interacting with PostgreSQL databases . The focus has been on: Efficient communication with the database server without need for foreign libraries. Support for UTF-8 on Unicode-aware Lisp implementations A syntax for mixing SQL and Lisp code Convenient support for prepared statements and stored procedures A metaclass for simple database-access objects The biggest differences between this library and clsql or cl-dbi are that Postmodern has no intention of being portable across different SQL implementations (it embraces non-standard PostgreSQL features), and approaches extensions like lispy SQL and database access objects in a quite different way.","title":"postmodern - PostgreSQL programming interace"},{"location":"postmodern/#getting-started","text":"","title":"GETTING STARTED"},{"location":"postmodern/#starting-the-postgres-server","text":"[TODO] Someone more familiar with postgres or databases should review this section. Follow the installation instructions to install Postgres. Once done, you should have access to the postgres , pg_ctl , and optionally the psql commands on your command line / terminal. Once done, this page elaborates the process of starting the database server and any issues that may arise. (You can select the postgresql version from top of the page.) Initialize the directory: pg_ctl init -D postmodern # see \\ pg_ctl --help \\ from the options . Optionally, change port and unix_socket_directories from postmodern/postgresql.conf . pg_ctl start -D postmodern to start the server. You should get a server started message; if not, the link above should help in debugging. Proceed to the next section once you successfully start the server. This page elaborates on the configuration settings. In addition, you can list the databases by using psql -p PORT -h unix_socket_directories -l , replacing the italicized arguments appropriately.","title":"Starting the Postgres server"},{"location":"postmodern/#connecting-to-the-postgres-server","text":"We firstly connect to the default existing database. Create a new database for our purposes, and then disconnect and reconnect to this database. We also assume the server is started at 8080 and username is \"username\" . CL-USER> (connect-toplevel \"postgres\" \"username\" \"\" \"localhost\" :port 8080) ; No value CL-USER> (execute \"create database testdb\") 0 CL-USER> (disconnect-toplevel) NIL CL-USER> (connect-toplevel \"testdb\" \"username\" \"\" \"localhost\" :port 8080) ; No value [TODO] Distinguish why \"exactly\" connect and connect-toplevel are different? What goes on under the hood? Also, what role does :pooled-p play? Other things you may want to take a look at with regards to connection include: database-connection connect *default-use-ssl* disconnect connected-p reconnect *database* with-connection call-with-connection connect-toplevel disconnect-toplevel clear-connection-pool *max-pool-size* list-connections","title":"Connecting to the Postgres server"},{"location":"postmodern/#executing-arbitrary-database-commands","text":"Query is the basic way to send queries to the database: CL-USER> (query \"select 22, 'Folie et d\u00e9raison', 4.5\") ((22 \"Folie et d\u00e9raison\" 9/2)) CL-USER> (query (:select 22 \"Folie et d\u00e9raison\" 4.5)) ((22 \"Folie et d\u00e9raison\" 9/2)) In many contexts, query strings and lists starting with keywords can be used interchangeably. The lists will be compiled to SQL. The S-SQL manual describes the syntax used by these expressions. Lisp values occurring in them are automatically escaped. In the above query, only constant values are used, but it is possible to transparently use run-time values as well: CL-USER> (defun database-powered-addition (a b) (query (:select (:+ a b)) :single)) DATABASE-POWERED-ADDITION CL-USER> (database-powered-addition 1030 204) 1234 1 That last argument, :single , indicates that we want the result not as a list of lists (for the result rows), but as a single value, since we know that we are only selecting one value. See the documentation of query for the other options. You do not have to pull in the whole result of a query at once, you can also iterate over it with the doquery macro. The following things should be useful about querying: query execute doquery prepare defprepared defprepared-with-names with-transaction commit-transaction abort-transaction with-savepoint release-savepoint rollback-savepoint commit-hooks abort-hooks with-logical-transaction abort-logical-transaction commit-logical-transaction *current-logical-transaction* ensure-transaction with-schema sequence-next coalesce","title":"Executing arbitrary database commands"},{"location":"postmodern/#database-access-class","text":"You can work directly with the database or you can use a simple database-access-class (aka dao-class ) which would cover all the fields in a row. This is what a database-access class looks like: (defclass points () ((x :col-type integer :initarg :x :reader point-x) (y :col-type integer :initarg :y :reader point-y) (value :col-type integer :initarg :value :accessor value)) (:metaclass dao-class) (:keys x y)) Once the class is defined, we create the table in the database: CL-USER> (dao-table-definition 'points) \"CREATE TABLE points (x INTEGER NOT NULL, y INTEGER NOT NULL, value INTEGER NOT NULL, PRIMARY KEY (x, y))\" CL-USER> (execute (dao-table-definition 'points)) 0 In more complicated cases, you might want to :create-table directly. You can use sql to view the result of parsing the form . CL-USER> (sql (:create-table so-items ((item-id :type integer) (so-id :type (or integer db-null) :references ((so-headers id))) (product-id :type (or integer db-null)) (qty :type (or integer db-null)) (net-price :type (or numeric db-null))) (:primary-key item-id so-id))) \"CREATE TABLE so_items (item_id INTEGER NOT NULL, so_id INTEGER REFERENCES so_headers(id) MATCH SIMPLE ON DELETE RESTRICT ON UPDATE RESTRICT, product_id INTEGER, qty INTEGER, net_price NUMERIC, PRIMARY KEY (item_id, so_id))\" (Note that you'd need to execute this form using query or execute . Also see this for details and examples on using S-SQL for creating tables.) You can use insert-dao for inserting DAO-objects into the database. (Of course, you can use query to do all this using the usual SQL syntax.) CL-USER> (insert-dao (make-instance 'points :x 0 :y 1 :value 10)) #<POINTS {10145AC1D3}> CL-USER> (insert-dao (make-instance 'points :x 1 :y 0 :value 15)) #<POINTS {10145B5EA3}> CL-USER> (select-dao 'country) (#<COUNTRY {101C5F3103}> #<COUNTRY {101C5F3883}>) 2 CL-USER> (select-dao 'points) (#<POINTS {1017B9BB93}> #<POINTS {1017B9BC23}>) 2 CL-USER> (query (:select '* :from 'points)) ((0 1 10) (1 0 15)) 2 Finally, you can use update-dao to, well, update the database entry: CL-USER> (let ((1-0 (get-dao 'points 1 0))) (setf (value 1-0) 20) (update-dao 1-0)) #<POINTS {101F1628E3}> CL-USER> (query (:select '* :from 'points)) ((0 1 10) (1 0 20)) 2 Here are the other useful constructs related to database access objects: dao-class dao-keys dao-exists-p make-dao define-dao-finalization get-dao select-dao do-select-dao query-dao do-query-dao *ignore-unknown-columns* insert-dao update-dao save-dao save-dao/transaction upsert-dao delete-dao dao-table-name dao-table-definition with-column-writers","title":"Database Access Class"},{"location":"postmodern/#s-sql","text":"Finally, here is some more demonstration of S-SQL syntax: (sql (:select 'relname :from 'pg-catalog.pg-class :inner-join 'pg-catalog.pg-namespace :on (:= 'relnamespace 'pg-namespace.oid) :where (:and (:= 'relkind \"r\") (:not-in 'nspname (:set \"pg_catalog\" \"pg_toast\")) (:pg-catalog.pg-table-is-visible 'pg-class.oid)))) ;; => \"(SELECT relname FROM pg_catalog.pg_class ;; INNER JOIN pg_catalog.pg_namespace ON (relnamespace = pg_namespace.oid) ;; WHERE ((relkind = 'r') and (nspname NOT IN ('pg_catalog', 'pg_toast')) ;; and pg_catalog.pg_table_is_visible(pg_class.oid)))\" Lists starting with keywords are used to express SQL commands and operators while lists starting with something else will be evaluated and then inserted into the query. Quoted symbols name columns or tables (keywords can also be used but might introduce ambiguities). The syntax supports subqueries, multiple joins, stored procedures, etc. See the S-SQL reference manual for a complete treatment. [TODO] Add more S-SQL examples. Compare them with SxQL as well.","title":"S-SQL"},{"location":"postmodern/#prepared-statements","text":"*allow-overwriting-prepared-statements* prepared-statement-exists-p list-prepared-statements drop-prepared-statement list-postmodern-prepared-statements find-postgresql-prepared-statement find-postmodern-prepared-statement reset-prepared-statement get-pid get-pid-from-postmodern cancel-backend terminate-backend Example Usage: CL-USER> (funcall (prepare (:select '* :from 'points :where (:= 'x '$1))) 0) ((0 1 10)) 1 prepare defprepared defprepared-with-names","title":"Prepared statements"},{"location":"postmodern/#migration","text":"[TODO] Groaking migrations needed for ELI5-cation.","title":"Migration"},{"location":"postmodern/#other-useful-constructs","text":"Inspecting the database list-tables list-tables-in-schema table-exists-p table-description list-sequences sequence-exists-p list-views view-exists-p list-schemata schema-exist-p schema-exists-p database-version num-records-in-database current-database database-exists-p database-size list-databases list-schemas list-tablespaces list-available-types list-table-sizes table-size more-table-info list-columns list-columns-with-types column-exists-p describe-views list-database-functions list-indices list-table-indices index-exists-p list-indexed-column-and-attributes list-index-definitions find-primary-key-info list-foreign-keys list-unique-or-primary-constraints list-all-constraints describe-constraint describe-foreign-key-constraints list-triggers list-detailed-triggers list-database-users list-roles list-available-extensions list-installed-extensions change-toplevel-database Table definition and creation deftable !dao-def !index !unique-index !foreign !unique create-table create-all-tables create-package-tables *table-name* *table-symbol* Schemata create-schema drop-schema get-search-path set-search-path split-fully-qualified-table-name Database Health Measurements cache-hit-ratio bloat-measurement unused-indexes check-query-performance Miscellaneous Utility Functions execute-file","title":"Other useful constructs"},{"location":"postmodern/#configuration-variables","text":"","title":"CONFIGURATION VARIABLES"},{"location":"postmodern/#allow-overwriting-prepared-statements","text":"Variable When set to t, ensured-prepared will overwrite prepared statements having the same name if the query statement itself in the postmodern meta connection is different than the query statement provided to ensure-prepared.","title":"*allow-overwriting-prepared-statements*"},{"location":"postmodern/#current-logical-transaction","text":"Variable This is bound to the current transaction-handle or savepoint-handle instance representing the innermost open logical transaction.","title":"*current-logical-transaction*"},{"location":"postmodern/#database","text":"Variable Special variable holding the current database. Most functions and macros operating on a database assume this binds to a connected database.","title":"*database*"},{"location":"postmodern/#default-use-ssl","text":"Variable The default for connect's use-ssl argument. This starts at :no. If you set it to anything else, be sure to also load the CL+SSL library.","title":"*default-use-ssl*"},{"location":"postmodern/#escape-sql-names-p","text":"Variable Setting this to T will make S-SQL add double quotes around identifiers in queries. Setting it :auto will turn on this behaviour only for reserved words. Setting it to :literal will cause to-sql-name to escape reserved words,but will not make other changes such as changing forward slash to underscore.","title":"*escape-sql-names-p*"},{"location":"postmodern/#ignore-unknown-columns","text":"Variable Normally, when get-dao, select-dao, or query-dao finds a column in the database that's not in the DAO class, it will raise an error. Setting this variable to a non-NIL will cause it to simply ignore the unknown column.","title":"*ignore-unknown-columns*"},{"location":"postmodern/#isolation-level","text":"","title":"*isolation-level*"},{"location":"postmodern/#max-pool-size","text":"Variable Set the maximum amount of connections kept in a single connection pool, where a pool consists of all the stored connections with the exact same connect arguments. Defaults to NIL, which means there is no maximum.","title":"*max-pool-size*"},{"location":"postmodern/#table-name","text":"Variable These variables are bound to the relevant name and symbol while the forms of a table definition are evaluated. Can be used to define shorthands like the ones below.","title":"*table-name*,"},{"location":"postmodern/#table-symbol","text":"Variable Used inside deftable to find the symbol naming the table being defined.","title":"*table-symbol*"},{"location":"postmodern/#functions-and-macros","text":"","title":"FUNCTIONS AND MACROS"},{"location":"postmodern/#dao-def","text":"Function: (!dao-def) Should only be used inside deftable's body. Adds the result of calling dao-table-definition on table-symbol to the definition.","title":"!dao-def"},{"location":"postmodern/#foreign","text":"Function: (!foreign target fields &rest target-fields/on-delete/on-update/deferrable/initially-deferred) Add a foreign key to the table being defined. target-table is the referenced table. columns is a list of column names or single name in this table, and, if the columns have different names in the referenced table, target-columns must be another list of column names or single column name of the target-table, or :primary-key to denote the column(s) of the target-table's primary key as referenced column(s). The on-delete and on-update arguments can be used to specify ON DELETE and ON UPDATE actions, as per the keywords allowed in create-table. In addition, the deferrable and initially-deferred arguments can be used to indicate whether constraint checking can be deferred until the current transaction completed, and whether this should be done by default. Note that none of these are really &key arguments, but rather are picked out of a &rest arg at runtime, so that they can be specified even when target-columns is not given.","title":"!foreign"},{"location":"postmodern/#index","text":"Function: (!index &rest fields) Define an index on the table being defined. The columns can be given as symbols or strings.","title":"!index"},{"location":"postmodern/#unique","text":"Function: (!unique target-fields &key deferrable initially-deferred) Constrains one or more columns to only contain unique (combinations of) values, with deferrable and initially-deferred defined as in !foreign","title":"!unique"},{"location":"postmodern/#unique-index","text":"Function: (!unique-index &rest fields) Used inside a deftable form. Define a unique index on the defined table.","title":"!unique-index"},{"location":"postmodern/#abort-hooks","text":"Generic Function: (abort-hooks object) Generic Function: (setf (abort-hooks object) ...) An accessor for the transaction or savepoint's list of commit hooks, each of which should be a function with no required arguments. These functions will be executed when a transaction is committed or a savepoint released.","title":"abort-hooks"},{"location":"postmodern/#abort-logical-transaction","text":"Generic Function: (abort-logical-transaction savepoint) Roll back the given logical transaction, regardless of whether it is an actual transaction or a savepoint.","title":"abort-logical-transaction"},{"location":"postmodern/#abort-transaction","text":"Function: (abort-transaction transaction) Roll back the given transaction.","title":"abort-transaction"},{"location":"postmodern/#bloat-measurement","text":"Function: (bloat-measurement) \u2192 list Bloat measurement of unvacuumed dead tuples. Borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ who borrowed it from https://github.com/heroku/heroku-pg-extras/tree/master/commands .","title":"bloat-measurement"},{"location":"postmodern/#cache-hit-ratio","text":"Function: (cache-hit-ratio) \u2192 list The cache hit ratio shows data on serving the data from memory compared to how often you have to go to disk. This function returns a list of heapblocks read from disk, heapblocks hit from memory and the ratio of heapblocks hit from memory / total heapblocks hit. Borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/","title":"cache-hit-ratio"},{"location":"postmodern/#call-with-connection","text":"Function: (call-with-connection spec thunk) The functional backend to with-connection. Binds *database* to a new connection as specified by spec, which should be a list that connect can be applied to, and runs the zero-argument function given as second argument in the new environment. When the function returns or throws, the new connection is disconnected.","title":"call-with-connection"},{"location":"postmodern/#cancel-backend","text":"Function: (cancel-backend pid &optional (database *database*)) Polite way of terminating a query at the database (as opposed to calling close-database). Slower than (terminate-backend pid) and does not always work.","title":"cancel-backend"},{"location":"postmodern/#change-toplevel-database","text":"Function: (change-toplevel-database new-database user password host) \u2192 string Just changes the database assuming you are using a toplevel connection. Recommended only for development work. Returns the name of the newly connected database as a string.","title":"change-toplevel-database"},{"location":"postmodern/#check-query-performance","text":"Function: (check-query-performance &optional (ob nil) (num-calls 100) (limit 20)) \u2192 list This function requires that postgresql extension pg_stat_statements must be loaded via shared_preload_libraries. It is borrowed from https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ . Optional parameters OB allow order-by to be 'calls', 'total-time', 'rows-per' or 'time-per', defaulting to time-per. num-calls to require that the number of calls exceeds a certain threshold, and limit to limit the number of rows returned. It returns a list of lists, each row containing the query, number of calls, total_time, total_time/calls, stddev_time, rows, rows/calls and the cache hit percentage.","title":"check-query-performance"},{"location":"postmodern/#clear-connection-pool","text":"Function: (clear-connection-pool) Disconnect and remove all connections from the connection pools.","title":"clear-connection-pool"},{"location":"postmodern/#coalesce","text":"Function: (coalesce &rest args) \u2192 value Returns the first non-NIL, non-NULL (as in :null) argument, or NIL if none are present. Useful for providing a fall-back value for the result of a query, or, when given only one argument, for transforming :nulls to NIL.","title":"coalesce"},{"location":"postmodern/#column-exists-p","text":"Function: (column-exists-p table-name column-name) \u2192 boolean Determine if a particular column exists. Table name and column-name can be either strings or symbols.","title":"column-exists-p"},{"location":"postmodern/#commit-hooks","text":"Generic Function: (commit-hooks object) An accessor for the transaction or savepoint's list of commit hooks, each of which should be a function with no required arguments. These functions will be executed when a transaction is committed or a savepoint released.","title":"commit-hooks"},{"location":"postmodern/#commit-logical-transaction","text":"Generic Function: (commit-logical-transaction savepoint) [TODO] This symbol is not exported. Commit the given logical transaction, regardless of whether it is an actual transaction or a savepoint.","title":"commit-logical-transaction"},{"location":"postmodern/#commit-transaction","text":"Function: (commit-transaction transaction) Commit the given transaction.","title":"commit-transaction"},{"location":"postmodern/#connect","text":"Function: (connect database-name user password host &key (port 5432) pooled-p (use-ssl *default-use-ssl*) (service postgres)) \u2192 database-connection Create a new database connection for the given user and the database. Port will default to 5432, which is where most PostgreSQL servers are running. If pooled-p is T, a connection will be taken from a pool of connections of this type, if one is available there, and when the connection is disconnected it will be put back into this pool instead. use-ssl can be :no, :yes, or :try, as in open-database, and defaults to the value of *default-use-ssl*.","title":"connect"},{"location":"postmodern/#connect-toplevel","text":"Function: (connect-toplevel database-name user password host &key (port 5432) (use-ssl *default-use-ssl*)) Bind the *database* to a new connection. Use this if you only need one connection, or if you want a connection for debugging from the REPL.","title":"connect-toplevel"},{"location":"postmodern/#connected-p","text":"Function: (connected-p database) \u2192 boolean Returns a boolean indicating whether the given connection is still connected to the server.","title":"connected-p"},{"location":"postmodern/#create-all-tables","text":"Function: (create-all-tables) Creates all defined tables.","title":"create-all-tables"},{"location":"postmodern/#create-package-tables","text":"Function: (create-package-tables package) Creates all tables identified by symbols interned in the given package.","title":"create-package-tables"},{"location":"postmodern/#create-schema","text":"Function: (create-schema schema) Creates a new schema. Raises an error if the schema is already exists.","title":"create-schema"},{"location":"postmodern/#create-table","text":"Function: (create-table name) Creates the table identified by symbol by executing all forms in its definition.","title":"create-table"},{"location":"postmodern/#current-database","text":"Function: (current-database) \u2192 string Returns the string name of the current database.","title":"current-database"},{"location":"postmodern/#dao-class","text":": (dao-class) Postmodern contains a simple system for defining CLOS classes that represent rows in the database. This is not intended as a full-fledged object-relational magic system \u2015 while serious ORM systems have their place, they are notoriously hard to get right, and are outside of the scope of a humble SQL library like this. At the heart of Postmodern's DAO system is the dao-class metaclass. It allows you to define classes for your database-access objects as regular CLOS classes. Some of the slots in these classes will refer to columns in the database. To specify that a slot refers to a column, give it a :col-type option containing an S-SQL type expression (useful if you want to be able to derive a table definition from the class definition), or simply a :column option with value T. Such slots can also take a :col-default option, used to provide a database-side default value as an S-SQL expression. You can use the :col-name initarg (whose unevaluated value will be passed to to-sql-name) to specify the slot's column's name. DAO class definitions support two extra class options: :table-name to give the name of the table that the class refers to (defaults to the class name), and :keys to provide a set of primary keys for the table. When no primary keys are defined, operations such as update-dao and get-dao will not work. IMPORTANT: Class finalization for a dao class instance are wrapped with a thread lock. However, any time you are using threads and a class that inherits from other classes, you should ensure that classes are finalized before you start generating threads that create new instances of that class. Simple example: (defclass user () ((name :col-type string :initarg :name :accessor user-name) (creditcard :col-type (or db-null integer) :initarg :card :col-default :null) (score :col-type bigint :col-default 0 :accessor user-score)) (:metaclass dao-class) (:keys name)) The (or db-null integer) form is used to indicate a column can have NULL values. When inheriting from DAO classes, a subclass' set of columns also contains all the columns of its superclasses. The primary key for such a class is the union of its own keys and all the keys from its superclasses. Classes inheriting from DAO classes should probably always use the dao-class metaclass themselves. When a DAO is created with make-instance, the :fetch-defaults keyword argument can be passed, which, when T, will cause a query to fetch the default values for all slots that refers to columns with defaults and were not bound through initargs. In some cases, such as serial columns, which have an implicit default, this will not work. You can work around this by creating your own sequence, e.g. \"my_sequence\", and defining a (:nextval \"my_sequence\") default. Finally, DAO class slots can have an option :ghost t to specify them as ghost slots. These are selected when retrieving instances, but not written when updating or inserting, or even included in the table definition. The only known use for this to date is for creating the table with (oids=true), and specify a slot like this: (oid :col-type integer :ghost t :accessor get-oid)","title":"dao-class"},{"location":"postmodern/#dao-exists-p","text":"Generic Function: (dao-exists-p dao) \u2192 boolean Test whether a row with the same primary key as the given dao exists in the database. Will also return NIL when any of the key slots in the object are unbound.","title":"dao-exists-p"},{"location":"postmodern/#dao-keys","text":"Generic Function: (dao-keys class) \u2192 list Returns list of slot names that are the primary key of DAO class. This is likely interesting if you have primary keys which are composed of more than one slot. Pay careful attention to situations where the primary key not only has more than one column, but they are actually in a different order than they are in the database table itself. You can check this with the find-primary-key-info function. (pomo:find-primary-key-info \"country1\") ((\"name\" \"text\") (\"id\" \"integer\")) \u2192 list Returns list of values that are the primary key of dao.","title":"dao-keys"},{"location":"postmodern/#dao-table-definition","text":"Function: (dao-table-definition table) \u2192 string Given a DAO class, or the name of one, this will produce an SQL query string with a definition of the table. This is just the bare simple definition, so if you need any extra indices or or constraints, you'll have to write your own queries to add them, in which case look to s-sql's create-table function.","title":"dao-table-definition"},{"location":"postmodern/#dao-table-name","text":"Function: (dao-table-name class) \u2192 string Get the name of the table associated with the given DAO class (or symbol naming such a class).","title":"dao-table-name"},{"location":"postmodern/#database-connection","text":": (database-connection) Objects of this type represent database connections.","title":"database-connection"},{"location":"postmodern/#database-error","text":"Condition This is the condition type that will be used to signal virtually all database-related errors (though in some cases socket errors may be raised when a connection fails on the IP level). Direct Slots cl-postgres::error-code Initargs: :CODE cl-postgres::message Initargs: :MESSAGE Readers: CL-POSTGRES:DATABASE-ERROR-MESSAGE cl-postgres::detail Initargs: :DETAIL cl-postgres::hint Initargs: :HINT cl-postgres::context Initargs: :CONTEXT cl-postgres::query position Initargs: :POSITION cl-postgres::cause Initargs: :CAUSE","title":"database-error"},{"location":"postmodern/#database-error-cause","text":"Generic Function: (database-error-cause condition)","title":"database-error-cause"},{"location":"postmodern/#database-error-code","text":"Generic Function: (database-error-code condition)","title":"database-error-code"},{"location":"postmodern/#database-error-constraint-name","text":"Function: (database-error-constraint-name err) Given a database-error for an integrity violation, will attempt to extract the constraint name.","title":"database-error-constraint-name"},{"location":"postmodern/#database-error-detail","text":"Generic Function: (database-error-detail condition)","title":"database-error-detail"},{"location":"postmodern/#database-error-extract-name","text":"Function: (database-error-extract-name err) Given a database-error, will extract the critical name from the error message.","title":"database-error-extract-name"},{"location":"postmodern/#database-error-message","text":"Generic Function: (database-error-message condition)","title":"database-error-message"},{"location":"postmodern/#database-error-query","text":"Generic Function: (database-error-query condition)","title":"database-error-query"},{"location":"postmodern/#database-exists-p","text":"Function: (database-exists-p database-name) \u2192 boolean Checks to see if a particular database exists.","title":"database-exists-p"},{"location":"postmodern/#database-size","text":"Function: (database-size &optional (name nil)) \u2192 list Given the name of a database, will return the name, a pretty-print string of the size of the database and the size in bytes. If a database name is not provided, it will return the result for the currently connected database.","title":"database-size"},{"location":"postmodern/#database-version","text":"Function: (database-version) \u2192 string Returns the version of the current postgresql database.","title":"database-version"},{"location":"postmodern/#define-dao-finalization","text":"Macro: (define-dao-finalization ((dao-name class) &rest keyword-args) &body body) Create an :around-method for make-dao. The body is executed in a lexical environment where dao-name is bound to a freshly created and inserted DAO. The representation of the DAO in the database is then updated to reflect changes that body might have introduced. Useful for processing values of slots with the type serial, which are unknown before insert-dao.","title":"define-dao-finalization"},{"location":"postmodern/#defprepared","text":"Macro: (defprepared name query &optional (format rows)) \u2192 function This is the macro-style variant of prepare. It is like prepare, but gives the function a name which now becomes a top-level function for the prepared statement. The name should not be quoted or a string.","title":"defprepared"},{"location":"postmodern/#defprepared-with-names","text":"Macro: (defprepared-with-names name (&rest args) (query &rest query-args) &optional (format rows)) Like defprepared, but allows to specify names of the function arguments as well as arguments supplied to the query. (defprepared-with-names user-messages (user &key (limit 10)) (\"select * from messages where user_id = $1 order by date desc limit $2\" (user-id user) limit) :plists)","title":"defprepared-with-names"},{"location":"postmodern/#deftable","text":"Macro: (deftable name &body definitions) Define a table. name can be either a symbol or a (symbol string) list. In the first case, the table name is derived from the symbol's name by S-SQL's rules. In the second case, the name is given explicitly. The body of definitions can contain anything that evaluates to a string, as well as S-SQL expressions. The variables *table-name* and *table-symbol* are bound to the relevant values in the body. Note that the evaluation of the definition is ordered, so you'll generally want to create your table first and then define indices on it.","title":"deftable"},{"location":"postmodern/#delete-dao","text":"Generic Function: (delete-dao dao) Delete the given dao from the database.","title":"delete-dao"},{"location":"postmodern/#describe-constraint","text":"Function: (describe-constraint table-name constraint-name) \u2192 list Return a list of alists of the descriptions a particular constraint given the table-name and the constraint name using the information_schema table.","title":"describe-constraint"},{"location":"postmodern/#describe-foreign-key-constraints","text":"Function: (describe-foreign-key-constraints) \u2192 list Generates a list of lists of information on the foreign key constraints","title":"describe-foreign-key-constraints"},{"location":"postmodern/#describe-views","text":"Function: (describe-views &optional (schema public)) \u2192 list Describe the current views in the specified schema. Defaults to public schema.","title":"describe-views"},{"location":"postmodern/#disconnect","text":"Generic Function: (disconnect database) Disconnects a normal database connection, or moves a pooled connection into the pool.","title":"disconnect"},{"location":"postmodern/#disconnect-toplevel","text":"Function: (disconnect-toplevel) Disconnect the *database*.","title":"disconnect-toplevel"},{"location":"postmodern/#do-query-dao","text":"Macro: (do-query-dao ((type type-var) query) &body body) \u2192 list Like query-dao, but iterates over the results rather than returning them. For each matching DAO, body is evaluated with type-var bound to the instance. (do-query-dao (('user user) (:order-by (:select '* :from 'user :where (:> 'score 10000)) 'name)) (pushnew user high-scorers))","title":"do-query-dao"},{"location":"postmodern/#do-select-dao","text":"Macro: (do-select-dao ((type type-var) &optional (test) &rest ordering) &body body) Like select-dao, but iterates over the results rather than returning them. For each matching DAO, body is evaluated with type-var bound to the DAO instance. (do-select-dao (('user user) (:> 'score 10000) 'name) (pushnew user high-scorers))","title":"do-select-dao"},{"location":"postmodern/#doquery","text":"Macro: (doquery query (&rest names) &body body) Execute the given query (a string or a list starting with a keyword), iterating over the rows in the result. The body will be executed with the values in the row bound to the symbols given in names. To iterate over a parameterised query, one can specify a list whose car is the query, and whose cdr contains the arguments. For example: (doquery (:select 'name 'score :from 'scores) (n s) (incf (gethash n *scores*) s)) (doquery ((:select 'name :from 'scores :where (:> 'score '$1)) 100) (name) (print name))","title":"doquery"},{"location":"postmodern/#double-precision","text":"","title":"double-precision"},{"location":"postmodern/#drop-index","text":"Function: (drop-index name &key concurrently if-exists cascade) Drop an index. Available keys are :concurrently, :if-exists, and :cascade.","title":"drop-index"},{"location":"postmodern/#drop-prepared-statement","text":"Function: (drop-prepared-statement name &key (location both) (database *database*) (remove-function t)) Prepared statements are stored both in the meta slot in the postmodern connection and in postgresql session information. If you know the prepared statement name, you can delete the prepared statement from both locations (the default behavior), just from postmodern (passing :postmodern to the location key parameter) or just from postgresql (passing :postgresql to the location key parameter). If you pass the name 'All' as the statement name, it will delete all prepared statements. The statement name can be a string or quoted symbol.","title":"drop-prepared-statement"},{"location":"postmodern/#drop-schema","text":"Function: (drop-schema schema &key (if-exists nil) (cascade nil)) Removes a schema. Accepts :if-exists and/or :cascade arguments like :drop-table.","title":"drop-schema"},{"location":"postmodern/#drop-sequence","text":"Function: (drop-sequence name &key if-exists cascade) Drop a sequence. Name should be quoted. Available key parameters are :if-exists and :cascade","title":"drop-sequence"},{"location":"postmodern/#drop-table","text":"Function: (drop-table name &key if-exists cascade) Drop a table. Available additional key parameters are :if-exists and :cascade.","title":"drop-table"},{"location":"postmodern/#ensure-transaction","text":"Macro: (ensure-transaction &body body) Ensures that body is executed within a transaction, but does not begin a new transaction if one is already in progress.","title":"ensure-transaction"},{"location":"postmodern/#ensure-transaction-with-isolation-level","text":"Macro: (ensure-transaction-with-isolation-level isolation-level &body body) Executes body within a with-transaction form if and only if no transaction is already in progress. This adds the ability to specify an isolatin level other than the current default","title":"ensure-transaction-with-isolation-level"},{"location":"postmodern/#execute","text":"Macro: (execute query &rest args) Like query called with format :none. Returns the amount of affected rows as its first returned value. (Also returns this amount as the second returned value, but use of this is deprecated.)","title":"execute"},{"location":"postmodern/#execute-file","text":"Function: (execute-file pathname &optional (print nil)) This function will execute sql queries stored in a file. Each sql statement in the file will be run independently, but if one statement fails, subsequent query statements will not be run, but any statement prior to the failing statement will have been commited. If you want the standard transction treatment such that all statements succeed or no statement succeeds, then ensure that the file starts with a \"begin transaction\" statement and finishes with an \"end transaction\" statement. See the test file test-execute-file-broken-transaction.sql as an example. For debugging purposes, if the optional print parameter is set to t, format will print the count of the query and the query to the REPL. IMPORTANT NOTE: This utility function assumes that the file containing the sql queries can be trusted and bypasses the normal postmodern parameterization of queries.","title":"execute-file"},{"location":"postmodern/#find-postgresql-prepared-statement","text":"Function: (find-postgresql-prepared-statement name) \u2192 string Returns the specified named prepared statement (if any) that postgresql has for this session.","title":"find-postgresql-prepared-statement"},{"location":"postmodern/#find-postmodern-prepared-statement","text":"Function: (find-postmodern-prepared-statement name) \u2192 string Returns the specified named prepared statement (if any) that postmodern has put in the meta slot in the connection. Note that this is the statement itself, not the name.","title":"find-postmodern-prepared-statement"},{"location":"postmodern/#find-primary-key-info","text":"Function: (find-primary-key-info table &optional (just-key nil)) \u2192 list Returns a list of two strings. First the column name of the primary key of the table and second the string name for the datatype. Optionally, just-key can be set to t and it will return just the column name of the primary key as a string.","title":"find-primary-key-info"},{"location":"postmodern/#get-dao","text":"Generic Function: (get-dao type &rest args) \u2192 dao Select the DAO object from the row that has the given primary key values, or NIL if no such row exists. Objects created by this function will have initialize-instance called on them (after loading in the values from the database) without any arguments \u2015 even :default-initargs are skipped. The same goes for select-dao and query-dao.","title":"get-dao"},{"location":"postmodern/#get-pid","text":"Function: (get-pid) \u2192 integer Get the process id used by postgresql for this connection.","title":"get-pid"},{"location":"postmodern/#get-pid-from-postmodern","text":"Function: (get-pid-from-postmodern) \u2192 integer Get the process id used by postgresql for this connection, but get it from the postmodern connection parameters.","title":"get-pid-from-postmodern"},{"location":"postmodern/#get-search-path","text":"Function: (get-search-path) Retrieve the current search path.","title":"get-search-path"},{"location":"postmodern/#index-exists-p","text":"Function: (index-exists-p index-name) \u2192 boolean Tests whether an index with the given name exists. The name can be either a string or a symbol.","title":"index-exists-p"},{"location":"postmodern/#insert-dao","text":"Generic Function: (insert-dao dao) \u2192 dao Insert the given dao into the database. Column slots of the object which are unbound implies the database defaults. Hence, if these columns has no defaults defined in the database, the the insertion of the dao will be failed. (This feature only works on PostgreSQL 8.2 and up.)","title":"insert-dao"},{"location":"postmodern/#list-all-constraints","text":"Function: (list-all-constraints table-name &optional (strings-p)) \u2192 list Users information_schema to list all the constraints in a table. Table-name can be either a string or quoted.","title":"list-all-constraints"},{"location":"postmodern/#list-available-extensions","text":"Function: (list-available-extensions) \u2192 list List the postgresql extensions which are available in the system to the currently connected database. The extensions may or may not be installed. \u2192 list Lists extensions that are available to be installed in the database. Returns a list of lists where each sublist has the name of the extension, the default version, the installed version (if any) and a comment string.","title":"list-available-extensions"},{"location":"postmodern/#list-available-types","text":"Function: (list-available-types) \u2192 list List the available types in this postgresql version.","title":"list-available-types"},{"location":"postmodern/#list-columns","text":"Function: (list-columns table-name) \u2192 list Returns a list of strings of just the column names in a table. Pulls info from the postmodern table-description function rather than directly.","title":"list-columns"},{"location":"postmodern/#list-columns-with-types","text":"Function: (list-columns-with-types table-name) \u2192 list Return a list of (name type) lists for the fields of a table. Goes directly to the pg-catalog tables.","title":"list-columns-with-types"},{"location":"postmodern/#list-connections","text":"Function: (list-connections) \u2192 list List the current postgresql connections to the currently connected database.","title":"list-connections"},{"location":"postmodern/#list-database-functions","text":"Function: (list-database-functions) \u2192 list Returns a list of the functions in the database from the information_schema.","title":"list-database-functions"},{"location":"postmodern/#list-database-users","text":"Function: (list-database-users) \u2192 list List database users.","title":"list-database-users"},{"location":"postmodern/#list-databases","text":"Function: (list-databases &key (order-by-size nil) (size t)) \u2192 list Returns a list of lists where each sub-list contains the name of the database, a pretty-print string of the size of that database and the size in bytes. The default order is by database name. Pass t as a parameter to :order-by-size for order by size. Setting size to nil will return just the database names in a single list ordered by name. This function excludes the template databases","title":"list-databases"},{"location":"postmodern/#list-detailed-triggers","text":"Function: (list-detailed-triggers) \u2192 list List detailed information on the triggers from the information_schema table.","title":"list-detailed-triggers"},{"location":"postmodern/#list-foreign-keys","text":"Function: (list-foreign-keys table schema) \u2192 list Returns a list of sublists of foreign key info in the form of '((constraint-name local-table local-table-column foreign-table-name foreign-column-name))","title":"list-foreign-keys"},{"location":"postmodern/#list-index-definitions","text":"Function: (list-index-definitions table-name) \u2192 list Returns a list of the definitions used to create the current indexes for the table","title":"list-index-definitions"},{"location":"postmodern/#list-indexed-column-and-attributes","text":"Function: (list-indexed-column-and-attributes table-name) \u2192 list List the indexed columns and their attributes in a table. Includes primary key.","title":"list-indexed-column-and-attributes"},{"location":"postmodern/#list-indices","text":"Function: (list-indices &optional strings-p) \u2192 list Return a list of the indexs in a database. Turn them into keywords if strings-p is not true.","title":"list-indices"},{"location":"postmodern/#list-installed-extensions","text":"Function: (list-installed-extensions) \u2192 list List the postgresql extensions which are installed in the currently connected database. \u2192 list Return a list of the installed extension","title":"list-installed-extensions"},{"location":"postmodern/#list-postmodern-prepared-statements","text":"Function: (list-postmodern-prepared-statements &optional (names-only nil)) \u2192 list List the prepared statements that postmodern has put in the meta slot in the connection. It will return a list of alists of form: ((:NAME . SNY24) (:STATEMENT . (SELECT name, salary FROM employee WHERE (city = \\$1))) (:PREPARE-TIME . #<TIMESTAMP 25-11-2018T15:36:43,385>) (:PARAMETER-TYPES . text) (:FROM-SQL) If the names-only parameter is set to t, it will only return a list of the names of the prepared statements.","title":"list-postmodern-prepared-statements"},{"location":"postmodern/#list-prepared-statements","text":": (list-prepared-statements (&optional names-only)) \u2192 list This is syntactic sugar. It runs a query that lists the prepared statements in the session in which the function is run. If the names-only parameter is set to t, it will only return a list of the names of the prepared statements.","title":"list-prepared-statements"},{"location":"postmodern/#list-roles","text":"Function: (list-roles &optional (lt nil)) \u2192 list Returns a list of alists of rolenames, role attributes and membership in roles. See https://www.postgresql.org/docs/current/role-membership.html for an explanation. Optionally passing :alists or :plists can be used to set the return list types to :alists or :plists. This is the same as the psql function \\du.","title":"list-roles"},{"location":"postmodern/#list-schemas","text":"Function: (list-schemas) \u2192 list List schemas in the current database, excluding the pg_* system schemas.","title":"list-schemas"},{"location":"postmodern/#list-schemata","text":"Function: (list-schemata) \u2192 list Returns list of the user defined schemata (as strings) and the quantity of existing schemata.","title":"list-schemata"},{"location":"postmodern/#list-sequences","text":"Function: (list-sequences &optional strings-p) \u2192 list Returns a list of the sequences in the current database. When strings-p is T, the names will be given as strings, otherwise as keywords.","title":"list-sequences"},{"location":"postmodern/#list-table-indices","text":"Function: (list-table-indices table-name &optional strings-p) \u2192 list List the index names and the related columns in a table. Returns a list of alists.","title":"list-table-indices"},{"location":"postmodern/#list-table-sizes","text":"Function: (list-table-sizes &key (schema public) (order-by-size nil) (size t)) \u2192 list Returns a list of lists (table-name, size in 8k pages) of tables in the current database. Providing a name to the schema parameter will return just the information for tables in that schema. It defaults to just the tables in the public schema. Setting schema to nil will return all tables, indexes etc in the database in descending order of size. This would include system tables, so there are a lot more than you would expect. If :size is set to nil, it returns only a flat list of table names. Setting order-by-size to t will return the result in order of size instead of by table name.","title":"list-table-sizes"},{"location":"postmodern/#list-tables","text":"Function: (list-tables &optional strings-p) \u2192 list Returns a list of the tables in the current database and schema. When strings-p is T, the names will be given as strings, otherwise as keywords.","title":"list-tables"},{"location":"postmodern/#list-tables-in-schema","text":"Function: (list-tables-in-schema &optional (schema-name public) lisp-strings-p) \u2192 list Returns a list of the tables in the current database and the specified schema. When strings-p is T,the names will be given as strings, otherwise as keywords.","title":"list-tables-in-schema"},{"location":"postmodern/#list-tablespaces","text":"Function: (list-tablespaces) \u2192 list Lists the tablespaces in the currently connected database.","title":"list-tablespaces"},{"location":"postmodern/#list-triggers","text":"Function: (list-triggers &optional table-name) \u2192 list List distinct trigger names from the information_schema table. Table-name can be either quoted or string.","title":"list-triggers"},{"location":"postmodern/#list-unique-or-primary-constraints","text":"Function: (list-unique-or-primary-constraints table-name &optional (strings-p)) \u2192 list List constraints on a table.","title":"list-unique-or-primary-constraints"},{"location":"postmodern/#list-views","text":"Function: (list-views &optional strings-p) \u2192 list Returns list of the user defined views in the current database. When strings-p is T, the names will be returned as strings, otherwise as keywords.","title":"list-views"},{"location":"postmodern/#make-dao","text":"Generic Function: (make-dao type &rest args &key &allow-other-keys) \u2192 dao Combines make-instance with insert-dao. Return the created dao.","title":"make-dao"},{"location":"postmodern/#more-table-info","text":"Function: (more-table-info table-name) \u2192 list Returns more table info than table-description. Table can be either a string or quoted.","title":"more-table-info"},{"location":"postmodern/#num-records-in-database","text":"Function: (num-records-in-database) \u2192 list Returns a list of lists with schema, table name and approximate number of records in the currently connected database.","title":"num-records-in-database"},{"location":"postmodern/#numeric","text":"","title":"numeric"},{"location":"postmodern/#parse-queries","text":"Function: (parse-queries file-content) read SQL queries in given string and split them, returns a list","title":"parse-queries"},{"location":"postmodern/#prepare","text":"Macro: (prepare query &optional (format rows)) \u2192 function Wraps a query into a function that can be used as the interface to a prepared statement. The given query (either a string or an S-SQL form) may contain placeholders, which look like \\$1, \\$2, etc. The resulting function takes one argument for every placeholder in the query, executes the prepared query, and returns the result in the format specified. (Allowed formats are the same as for query.) For queries that have to be run very often, especially when they are complex, it may help performance since the server only has to plan them once. See the PostgreSQL manual for details. In some cases, the server will complain about not being able to deduce the type of the arguments in a statement. In that case you should add type declarations (either with the PostgreSQL's CAST SQL-conforming syntax or historical :: syntax, or with S-SQL's :type construct) to help it out. Note that it will attempt to automatically reconnect if database-connection-error, or admin-shutdown. It will reset prepared statements triggering an invalid-sql-statement-name error. It will overwrite old prepared statements triggering a duplicate-prepared-statement error.","title":"prepare"},{"location":"postmodern/#prepared-statement-exists-p","text":"Function: (prepared-statement-exists-p name) \u2192 boolean This returns t if the prepared statement exists in the current postgresql session, otherwise nil.","title":"prepared-statement-exists-p"},{"location":"postmodern/#query","text":"Macro: (query query &rest args/format) \u2192 result Execute the given query, which can be either a string or an S-SQL form (list starting with a keyword). If the query contains placeholders (\\$1, \\$2, etc) their values can be given as extra arguments. If one of these arguments is a keyword occurring in the table below, it will not be used as a query argument, but will determine the format in which the results are returned instead. Any of the following formats can be used, with the default being :rows: :none | Ignore the result values. | :lists, :rows | Return a list of lists, each list containing the values for a row. | :list, :row | Return a single row as a list. | :alists | Return a list of alists which map column names to values, with the names represented as keywords. | :alist | Return a single row as an alist. | :array-hash | Return an array of hashtables which map column names to hash table keys | :str-alists | Like :alists, but use the original column names. | :str-alist | Return a single row as an alist, with strings for names. | :plists | Return a list of plists which map column names to values,with the names represented as keywords. | :plist | Return a single row as a plist. | :column | Return a single column as a list. | :single | Return a single value. | :single! | Like :single, but raise an error when the number of selected rows is not equal to 1. | (:dao type) | Return a list of DAOs of the given type. The names of the fields returned by the query must match slots in the DAO class the same way as with query-dao. | (:dao type :single) | Return a single DAO of the given type. | If the database returns information about the amount rows that were affected, such as with updating or deleting queries, this is returned as a second value.","title":"query"},{"location":"postmodern/#query-dao","text":"Macro: (query-dao type query &rest args) \u2192 list Execute the given query (which can be either a string or an S-SQL expression) and return the result as DAOs of the given type. If the query contains placeholders (\\$1, \\$2, etc) their values can be given as extra arguments. The names of the fields returned by the query must either match slots in the DAO class, or be bound through with-column-writers.","title":"query-dao"},{"location":"postmodern/#read-queries","text":"Function: (read-queries filename) read SQL queries in given file and split them, returns a list","title":"read-queries"},{"location":"postmodern/#real","text":"NIL","title":"real"},{"location":"postmodern/#reconnect","text":"Generic Function: (reconnect database) Reconnect a disconnected database connection. This is not allowed for pooled connections \u2015 after they are disconnected they might be in use by some other process, and should no longer be used.","title":"reconnect"},{"location":"postmodern/#register-sql-operators","text":"Macro: (register-sql-operators arity &rest names) Define simple operators. Arity is one of :unary (like 'not'), :unary-postfix (the operator comes after the operand), :n-ary (like '+': the operator falls away when there is only one operand), :2+-ary (like '=', which is meaningless for one operand), or :n-or-unary (like '-', where the operator is kept in the unary case). After the arity follow any number of operators, either just a keyword, in which case the downcased symbol name is used as the operator, or a two-element list containing a keyword and a name string.","title":"register-sql-operators"},{"location":"postmodern/#release-savepoint","text":"Function: (release-savepoint savepoint) Release the given savepoint.","title":"release-savepoint"},{"location":"postmodern/#reset-prepared-statement","text":"Function: (reset-prepared-statement condition) \u2192 restart If you have received an invalid-prepared-statement error but the prepared statement is still in the meta slot in the postmodern connection, this will try to regenerate the prepared statement at the database connection level and restart the connection.","title":"reset-prepared-statement"},{"location":"postmodern/#rollback-savepoint","text":"Function: (rollback-savepoint savepoint) Roll back the given savepoint.","title":"rollback-savepoint"},{"location":"postmodern/#save-dao","text":"Function: (save-dao dao) \u2192 boolean Tries to insert the given dao using insert-dao. If this raises a unique key violation error, it tries to update it by using update-dao instead. Be aware that there is a possible race condition here \u2015 if some other process deletes the row at just the right moment, the update fails as well. Returns a boolean telling you whether a new row was inserted. This function is unsafe to use inside of a transaction \u2015 when a row with the given keys already exists, the transaction will be aborted. Use save-dao/transaction instead in such a situation. See also: upsert-dao.","title":"save-dao"},{"location":"postmodern/#save-daotransaction","text":"Function: (save-dao/transaction dao) \u2192 boolean Acts exactly like save-dao, except that it protects its attempt to insert the object with a rollback point, so that a failure will not abort the transaction. See also: upsert-dao.","title":"save-dao/transaction"},{"location":"postmodern/#schema-exists-p","text":"Function: (schema-exists-p name) \u2192 boolean Tests the existence of a given schema. Returns T if the schema exists or NIL otherwise.","title":"schema-exists-p"},{"location":"postmodern/#select-dao","text":"Macro: (select-dao type &optional (test t) &rest ordering) \u2192 list Select DAO objects for the rows in the associated table for which the given test (either an S-SQL expression or a string) holds. When sorting arguments are given, which can also be S-SQL forms or strings, these are used to sort the result. (Note that, if you want to sort, you have to pass the test argument.) (select-dao 'user (:> 'score 10000) 'name)","title":"select-dao"},{"location":"postmodern/#sequence-exists-p","text":"Function: (sequence-exists-p sequence) \u2192 boolean Tests whether a sequence with the given name exists. The name can be either a string or a symbol.","title":"sequence-exists-p"},{"location":"postmodern/#sequence-next","text":"Function: (sequence-next sequence) \u2192 integer Get the next value from a sequence. The sequence identifier can be either a string or a symbol, in the latter case it will be converted to a string according to S-SQL rules.","title":"sequence-next"},{"location":"postmodern/#set-search-path","text":"Function: (set-search-path path) Sets the search path to the path. This function is used by with-schema.","title":"set-search-path"},{"location":"postmodern/#split-fully-qualified-table-name","text":": (split-fully-qualified-table-name) \u2192 list Takes a name of the form database.schema.table or schema.table or just table and returns a list in the form '(table schema database)","title":"split-fully-qualified-table-name"},{"location":"postmodern/#sql","text":"Macro: (sql form) Compile form to a sql expression as far as possible.","title":"sql"},{"location":"postmodern/#sql-compile","text":"Function: (sql-compile form)","title":"sql-compile"},{"location":"postmodern/#sql-error","text":"Function: (sql-error control &rest args) Condition","title":"sql-error"},{"location":"postmodern/#sql-escape","text":"Generic Function: (sql-escape arg) Get the representation of a Lisp value so that it can be used in a query.","title":"sql-escape"},{"location":"postmodern/#sql-escape-string","text":"Function: (sql-escape-string string &optional prefix) Escape string data so it can be used in a query.","title":"sql-escape-string"},{"location":"postmodern/#table-description","text":"Function: (table-description table-name &optional schema-name) \u2192 list Returns a list of the fields in the named table. Each field is represented by a list of three elements: the field name, the type, and a boolean indicating whether the field may be NULL. Optionally, schema-name can be specified to restrict the result to fields from the named schema. Without it, all fields in the table are returned, regardless of their schema.","title":"table-description"},{"location":"postmodern/#table-exists-p","text":"Function: (table-exists-p table-name &optional (schema-name nil)) \u2192 boolean Tests whether a table with the given name exists. The name can be either a string or a symbol. It can also be qualified in the form of 'schema.table or 'database.schema.table","title":"table-exists-p"},{"location":"postmodern/#table-size","text":"Function: (table-size table-name) \u2192 list Return the size of a postgresql table in k or m. Table-name can be either a string or quoted.","title":"table-size"},{"location":"postmodern/#terminate-backend","text":"Function: (terminate-backend pid &optional (database *database*)) Less polite way of terminating at the database (as opposed to calling close-database). Faster than (cancel-backend pid) and more reliable.","title":"terminate-backend"},{"location":"postmodern/#unused-indexes","text":"Function: (unused-indexes) \u2192 list Returns a list of lists showing schema.table, indexname, index_size and number of scans. The code was borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/","title":"unused-indexes"},{"location":"postmodern/#update-dao","text":"Generic Function: (update-dao dao) \u2192 dao Update the representation of the given dao in the database to the values in the object. This is not defined for tables that do not have any non-primary-key columns. Raises an error when no row matching the dao exists.","title":"update-dao"},{"location":"postmodern/#upsert-dao","text":"Generic Function: (upsert-dao dao) \u2192 dao Like save-dao or save-dao/transaction but using a different method that doesn't involve a database exception. This is safe to use both in and outside a transaction, though it's advisable to always do it in a transaction to prevent a race condition. The way it works is: If the object contains unbound slots, we call insert-dao directly, thus the behavior is like save-dao. Otherwise we try to update a record with the same primary key. If the PostgreSQL returns a non-zero number of rows updated it treated as the record is already exists in the database, and we stop here. If the PostgreSQL returns a zero number of rows updated, it treated as the record does not exist and we call insert-dao. The race condition might occur at step 3 if there's no transaction: if UPDATE returns zero number of rows updated and another thread inserts the record at that moment, the insertion implied by step 3 will fail. Note, that triggers and rules may affect the number of inserted or updated rows returned by PostgreSQL, so zero or non-zero number of affected rows may not actually indicate the existence of record in the database. This method returns two values: the DAO object and a boolean (T if the object was inserted, NIL if it was updated).","title":"upsert-dao"},{"location":"postmodern/#varchar","text":"","title":"varchar"},{"location":"postmodern/#view-exists-p","text":"Function: (view-exists-p view) \u2192 boolean Tests whether a view with the given name exists. The name can be either a string or a symbol.","title":"view-exists-p"},{"location":"postmodern/#with-column-writers","text":"Macro: (with-column-writers (&rest defs) &body body) Provides control over the way get-dao, select-dao, and query-dao read values from the database. This is not commonly needed, but can be used to reduce the amount of queries a system makes. writers should be a list of alternating column names (strings or symbols) and writers, where writers are either symbols referring to a slot in the objects, or functions taking two arguments \u2015 an instance and a value \u2015 which can be used to somehow store the value in the new instance. When any DAO-fetching function is called in the body, and columns matching the given names are encountered in the result, the writers are used instead of the default behaviour (try and store the value in the slot that matches the column name). An example of using this is to add some non-column slots to a DAO class, and use query-dao within a with-column-writers form to pull in extra information about the objects, and immediately store it in the new instances.","title":"with-column-writers"},{"location":"postmodern/#with-connection","text":"Macro: (with-connection spec &body body) Evaluates the body with *database* bound to a connection as specified by spec, which should be list that connect can be applied to.","title":"with-connection"},{"location":"postmodern/#with-logical-transaction","text":"Macro: (with-logical-transaction (&optional (name) (isolation-level)) &body body) Executes body within a with-transaction form if no transaction is currently in progress, otherwise simulates a nested transaction by executing it within a with-savepoint form. The transaction or savepoint is bound to name if one is supplied. The isolation-level will set the isolation-level used by the transaction. You can specify the following isolation levels in postmodern transactions: :read-committed-rw (read committed with read and write) :read-committed-ro (read committed with read only) :repeatable-read-rw (repeatable read with read and write) :repeatable-read-ro (repeatable read with read only) :serializable (serializable with reand and write) Sample usage where \"george\" is just the name given to the transaction (not quoted or a string) and ... simply indicates other statements would be expected here: (with-logical-transaction () (execute (:insert-into 'test-data :set 'value 77)) ...) (with-logical-transaction (george) (execute (:insert-into 'test-data :set 'value 22)) ...) (with-logical-transaction (george :read-committed-rw) (execute (:insert-into 'test-data :set 'value 33)) ...) (with-logical-transaction (:serializable) (execute (:insert-into 'test-data :set 'value 44)) ...)","title":"with-logical-transaction"},{"location":"postmodern/#with-savepoint","text":"Macro: (with-savepoint name &body body) Can only be used within a transaction. Establishes a savepoint with the given name at the start of body, and binds the same name to a handle for that savepoint. At the end of body, the savepoint is released, unless a condition is thrown, in which case it is rolled back.","title":"with-savepoint"},{"location":"postmodern/#with-schema","text":"Macro: (with-schema (schema &key (strict) (if-not-exist) (drop-after)) &body form) Sets the current schema to namespace and executes the body. Before executing body the PostgreSQL's session variable search_path is set to the given namespace. After executing body the search_path variable is restored to the original value. If the keyword :strict is set to T then the namespace is only the scheme on the search path upon the body execution. Otherwise the namespace is just first schema on the search path upon the the body execution. If :if-not-exist is NIL, an error is signaled. If :drop-after is T the namespace is dropped from the database after the body execution.","title":"with-schema"},{"location":"postmodern/#with-transaction","text":"Macro: (with-transaction (&optional name isolation-level) &body body) Execute the given body within a database transaction, committing it when the body exits normally, and aborting otherwise. An optional name and/or isolation-level can be given to the transaction. The name can be used to force a commit or abort before the body unwinds. The isolation-level will set the isolation-level used by the transaction. You can specify the following isolation levels in postmodern transactions: :read-committed-rw (read committed with read and write) :read-committed-ro (read committed with read only) :repeatable-read-rw (repeatable read with read and write) :repeatable-read-ro (repeatable read with read only) :serializable (serializable with reand and write) Sample usage where \"george\" is just the name given to the transaction (not quoted or a string) and ... simply indicates other statements would be expected here: (with-transaction () (execute (:insert-into 'test-data :set 'value 77)) ...) (with-transaction (george) (execute (:insert-into 'test-data :set 'value 22)) ...) (with-transaction (george :read-committed-rw) (execute (:insert-into 'test-data :set 'value 33)) (query (:select '* :from 'test-data)) ...) (with-transaction (:serializable) (execute (:insert-into 'test-data :set 'value 44)) ...) Further discussion of transactions and isolation levels can found here .","title":"with-transaction"},{"location":"unix-opts/","text":"unix-opts - cmd line argument parser Version: 0.1.7 Nickname: opts This documentation was possible due to the excellent official documentation and example . In case of any inaccuracies, ambiguities or suggestions, please create an issue here . GETTING STARTED Consider the following command line options defined using define-opts : (opts:define-opts (:name :help :description \"print this help text\" :short #\\h :long \"help\") (:name :verbose :description \"verbose output\" :short #\\v :long \"verbose\") (:name :level :description \"the program will run on LEVEL level\" :short #\\l :long \"level\" :required t :arg-parser #'parse-integer ; <- takes an argument, which we want to parse into integer :meta-var \"LEVEL\") (:name :output :description \"redirect output to file FILE\" :short #\\o :long \"output\" :arg-parser #'identity ; <- takes an argument, but we keep it as the string :meta-var \"FILE\")) describe gets us the required \"help text\" (see the documentation for other options): CL-USER> (opts:describe :prefix \"Demonstrating REPL\") Demonstrating REPL Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL Command line arguments can be processed with a call to get-opts . For demonstration purposes, we use the REPL. See this example directory to see how this might be done in a script. CL-USER> (opts:get-opts '()) ; Evaluation aborted on #<UNIX-OPTS:MISSING-REQUIRED-OPTION {10084173F3}>. CL-USER> (opts:get-opts '(\"--level\" \"2\")) (:LEVEL 2) NIL CL-USER> (opts:get-opts '(\"--level\" \"2\" \"--help\")) (:LEVEL 2 :HELP T) NIL get-opts can throw several conditions: unknown-option missing-arg arg-parser-failed missing-required-option Each of these has several restarts: use-value skip-option reparse-arg (See the documentation for get-opts for the details about each of these restarts. The Cookbook chapter on Error and Exception Handling should be helpful if you want to learn about them.) Thus, a typical way to use get-opts would be simply wrap the error in handler-case : CL-USER> (handler-case (opts:get-opts '()) (error (condition) (format t \"~A\" condition) (opts:describe))) missing required options: \"--level\" Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL You could use getf or destructuring-bind to obtain the arguments you need: CL-USER> (defun process-options (&rest options) (handler-case (opts:get-opts options) (error (condition) ; or you could case down on the various conditions above! (format t \"~A\" condition) (opts:describe)))) PROCESS-OPTIONS CL-USER> (destructuring-bind (&key level help) (process-options \"--level\" \"2\" \"--help\") (if help (opts:describe) (format t \"I see you've supplied level option, you want ~a level!~%\" level))) Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL CL-USER> (destructuring-bind (&key level help) (process-options \"--level\" \"2\") (if help (opts:describe) (format t \"I see you've supplied level option, you want ~a level!~%\" level))) I see you've supplied level option, you want 2 level! NIL You could also iterate:dsetq to bring the options to global space. CL-USER> (destructuring-bind (&key verbose level help) (process-options \"--level\" \"2\" \"--verbose\") (if help (opts:describe) ; assume we have defined *level* and *verbose* previously (dsetq (*verbose* *level*) (list verbose level)))) (T 2) CL-USER> *verbose* T CL-USER> *level* 2 API REFERENCE arg-parser-failed Condition This condition is thrown when some option OPTION wants an argument, it's given but cannot be parsed by argument parser. Direct Slots raw-arg Initargs: :RAW-ARG Readers: RAW-ARG argv Function: (argv) Return a list of program's arguments, including command used to execute the program as first elements of the list. Portable across implementations. define-opts Macro: (define-opts &body descriptions) Define command line options. Arguments of this macro must be plists containing various parameters. Here we enumerate all allowed parameters: :name - keyword that will be included in list returned by get-opts function if actual option is supplied by user. :description - description of the option (it will be used in describe function). This argument is optional, but it's recommended to supply it. :short - single character, short variant of the option. You may omit this argument if you supply :long variant of option. :long - string, long variant of option. You may omit this argument if you supply :short variant of option. :arg-parser - if actual option must take an argument, supply this argument, it must be a function that takes a string and parses it. :meta-var - if actual option requires an argument, this is how it will be printed in option description. describe Function: (describe &key prefix suffix usage-of args (stream *standard-output*)) Return string describing options of the program that were defined with define-opts macro previously. You can supply prefix and suffix arguments that will be printed before and after options respectively. If usage-of is supplied, it should be a string, name of the program for \"Usage: \" section. This section is only printed if this name is given. If your program takes arguments (apart from options), you can specify how to print them in \"Usage: \" section with args option (should be a string designator). Output goes to stream . exit Function: (exit &optional (status 0)) Exit the program returning status . get-opts Function: (get-opts &optional options) Parse command line options. If options is given, it should be a list to parse. If it's not given, the function will use argv function to get list of command line arguments. Return two values: a list that contains keywords associated with command line options with define-opts macro, and a list of free arguments. If some option requires an argument, you can use getf to test presence of the option and get its argument if the option is present. The parser may signal various conditions. Let's list them all specifying which restarts are available for every condition, and what kind of information the programmer can extract from the conditions. unknown-option is thrown when parser encounters unknown (not previously defined with define-opts ) option. Use the option reader to get name of the option (string). Available restarts: use-value : substitute the option and try again, skip-option : ignore the option. missing-arg is thrown when some option wants an argument, but there is no such argument given. Use the option reader to get name of the option (string). Available restarts: use-value : supplied value will be used, skip-option : ignore the option. arg-parser-failed is thrown when some option wants an argument, it's given but cannot be parsed by argument parser. Use the option reader to get name of the option (string) and raw-arg to get raw string representing the argument before parsing. Available restarts: use-value : supplied value will be used, skip-option : ignore the option, reparse-arg : supplied string will be parsed instead. missing-required-option is thrown when some option was required but was not given. Use the missing-options reader to get the list of options that are missing. Available restarts: use-value : supplied list of values will be used, skip-option : ignore all these options, effectively binding them to nil missing-arg Condition This condition is thrown when some option OPTION wants an argument, but there is no such argument given. missing-options Generic Function: (missing-options condition) missing-required-option Condition This condition is thrown when required options are missing. Direct Slots missing-options Initargs: :MISSING-OPTIONS Readers: MISSING-OPTIONS option Generic Function: (option condition) Class representation of an option raw-arg Generic Function: (raw-arg condition) reparse-arg skip-option unknown-option Condition This condition is thrown when parser encounters unknown (not previously defined with define-opts ) option. use-value Function: (use-value value &optional condition) Transfer control and value to a restart named USE-VALUE, or return NIL if none exists.","title":"unix-opts - cmd line argument parser"},{"location":"unix-opts/#unix-opts-cmd-line-argument-parser","text":"Version: 0.1.7 Nickname: opts This documentation was possible due to the excellent official documentation and example . In case of any inaccuracies, ambiguities or suggestions, please create an issue here .","title":"unix-opts - cmd line argument parser"},{"location":"unix-opts/#getting-started","text":"Consider the following command line options defined using define-opts : (opts:define-opts (:name :help :description \"print this help text\" :short #\\h :long \"help\") (:name :verbose :description \"verbose output\" :short #\\v :long \"verbose\") (:name :level :description \"the program will run on LEVEL level\" :short #\\l :long \"level\" :required t :arg-parser #'parse-integer ; <- takes an argument, which we want to parse into integer :meta-var \"LEVEL\") (:name :output :description \"redirect output to file FILE\" :short #\\o :long \"output\" :arg-parser #'identity ; <- takes an argument, but we keep it as the string :meta-var \"FILE\")) describe gets us the required \"help text\" (see the documentation for other options): CL-USER> (opts:describe :prefix \"Demonstrating REPL\") Demonstrating REPL Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL Command line arguments can be processed with a call to get-opts . For demonstration purposes, we use the REPL. See this example directory to see how this might be done in a script. CL-USER> (opts:get-opts '()) ; Evaluation aborted on #<UNIX-OPTS:MISSING-REQUIRED-OPTION {10084173F3}>. CL-USER> (opts:get-opts '(\"--level\" \"2\")) (:LEVEL 2) NIL CL-USER> (opts:get-opts '(\"--level\" \"2\" \"--help\")) (:LEVEL 2 :HELP T) NIL get-opts can throw several conditions: unknown-option missing-arg arg-parser-failed missing-required-option Each of these has several restarts: use-value skip-option reparse-arg (See the documentation for get-opts for the details about each of these restarts. The Cookbook chapter on Error and Exception Handling should be helpful if you want to learn about them.) Thus, a typical way to use get-opts would be simply wrap the error in handler-case : CL-USER> (handler-case (opts:get-opts '()) (error (condition) (format t \"~A\" condition) (opts:describe))) missing required options: \"--level\" Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL You could use getf or destructuring-bind to obtain the arguments you need: CL-USER> (defun process-options (&rest options) (handler-case (opts:get-opts options) (error (condition) ; or you could case down on the various conditions above! (format t \"~A\" condition) (opts:describe)))) PROCESS-OPTIONS CL-USER> (destructuring-bind (&key level help) (process-options \"--level\" \"2\" \"--help\") (if help (opts:describe) (format t \"I see you've supplied level option, you want ~a level!~%\" level))) Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL CL-USER> (destructuring-bind (&key level help) (process-options \"--level\" \"2\") (if help (opts:describe) (format t \"I see you've supplied level option, you want ~a level!~%\" level))) I see you've supplied level option, you want 2 level! NIL You could also iterate:dsetq to bring the options to global space. CL-USER> (destructuring-bind (&key verbose level help) (process-options \"--level\" \"2\" \"--verbose\") (if help (opts:describe) ; assume we have defined *level* and *verbose* previously (dsetq (*verbose* *level*) (list verbose level)))) (T 2) CL-USER> *verbose* T CL-USER> *level* 2","title":"GETTING STARTED"},{"location":"unix-opts/#api-reference","text":"","title":"API REFERENCE"},{"location":"unix-opts/#arg-parser-failed","text":"Condition This condition is thrown when some option OPTION wants an argument, it's given but cannot be parsed by argument parser. Direct Slots raw-arg Initargs: :RAW-ARG Readers: RAW-ARG","title":"arg-parser-failed"},{"location":"unix-opts/#argv","text":"Function: (argv) Return a list of program's arguments, including command used to execute the program as first elements of the list. Portable across implementations.","title":"argv"},{"location":"unix-opts/#define-opts","text":"Macro: (define-opts &body descriptions) Define command line options. Arguments of this macro must be plists containing various parameters. Here we enumerate all allowed parameters: :name - keyword that will be included in list returned by get-opts function if actual option is supplied by user. :description - description of the option (it will be used in describe function). This argument is optional, but it's recommended to supply it. :short - single character, short variant of the option. You may omit this argument if you supply :long variant of option. :long - string, long variant of option. You may omit this argument if you supply :short variant of option. :arg-parser - if actual option must take an argument, supply this argument, it must be a function that takes a string and parses it. :meta-var - if actual option requires an argument, this is how it will be printed in option description.","title":"define-opts"},{"location":"unix-opts/#describe","text":"Function: (describe &key prefix suffix usage-of args (stream *standard-output*)) Return string describing options of the program that were defined with define-opts macro previously. You can supply prefix and suffix arguments that will be printed before and after options respectively. If usage-of is supplied, it should be a string, name of the program for \"Usage: \" section. This section is only printed if this name is given. If your program takes arguments (apart from options), you can specify how to print them in \"Usage: \" section with args option (should be a string designator). Output goes to stream .","title":"describe"},{"location":"unix-opts/#exit","text":"Function: (exit &optional (status 0)) Exit the program returning status .","title":"exit"},{"location":"unix-opts/#get-opts","text":"Function: (get-opts &optional options) Parse command line options. If options is given, it should be a list to parse. If it's not given, the function will use argv function to get list of command line arguments. Return two values: a list that contains keywords associated with command line options with define-opts macro, and a list of free arguments. If some option requires an argument, you can use getf to test presence of the option and get its argument if the option is present. The parser may signal various conditions. Let's list them all specifying which restarts are available for every condition, and what kind of information the programmer can extract from the conditions. unknown-option is thrown when parser encounters unknown (not previously defined with define-opts ) option. Use the option reader to get name of the option (string). Available restarts: use-value : substitute the option and try again, skip-option : ignore the option. missing-arg is thrown when some option wants an argument, but there is no such argument given. Use the option reader to get name of the option (string). Available restarts: use-value : supplied value will be used, skip-option : ignore the option. arg-parser-failed is thrown when some option wants an argument, it's given but cannot be parsed by argument parser. Use the option reader to get name of the option (string) and raw-arg to get raw string representing the argument before parsing. Available restarts: use-value : supplied value will be used, skip-option : ignore the option, reparse-arg : supplied string will be parsed instead. missing-required-option is thrown when some option was required but was not given. Use the missing-options reader to get the list of options that are missing. Available restarts: use-value : supplied list of values will be used, skip-option : ignore all these options, effectively binding them to nil","title":"get-opts"},{"location":"unix-opts/#missing-arg","text":"Condition This condition is thrown when some option OPTION wants an argument, but there is no such argument given.","title":"missing-arg"},{"location":"unix-opts/#missing-options","text":"Generic Function: (missing-options condition)","title":"missing-options"},{"location":"unix-opts/#missing-required-option","text":"Condition This condition is thrown when required options are missing. Direct Slots missing-options Initargs: :MISSING-OPTIONS Readers: MISSING-OPTIONS","title":"missing-required-option"},{"location":"unix-opts/#option","text":"Generic Function: (option condition) Class representation of an option","title":"option"},{"location":"unix-opts/#raw-arg","text":"Generic Function: (raw-arg condition)","title":"raw-arg"},{"location":"unix-opts/#reparse-arg","text":"","title":"reparse-arg"},{"location":"unix-opts/#skip-option","text":"","title":"skip-option"},{"location":"unix-opts/#unknown-option","text":"Condition This condition is thrown when parser encounters unknown (not previously defined with define-opts ) option.","title":"unknown-option"},{"location":"unix-opts/#use-value","text":"Function: (use-value value &optional condition) Transfer control and value to a restart named USE-VALUE, or return NIL if none exists.","title":"use-value"}]}