<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>postmodern - PostgreSQL programming interace - common-lisp.readthedocs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../extra.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "postmodern - PostgreSQL programming interace";
    var mkdocs_page_input_path = "postmodern.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/lisp.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> common-lisp.readthedocs</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">index</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Defacto libraries</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../alexandria/">alexandria - Commonly Used Utilities</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../bordeaux-threads/">bordeaux-threads - Threading</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cl-ppcre/">cl-ppcre - Regular Expressions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cl-who/">cl-who - DSL for Markup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../fiveam/">fiveam - Regression Testing Framework</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../hunchentoot/">hunchentoot - Web Server</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../iterate/">iterate - Psuedocodic Iteration</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">postmodern - PostgreSQL programming interace</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#getting-started">GETTING STARTED</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#starting-the-postgres-server">Starting the Postgres server</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#connecting-to-the-postgres-server">Connecting to the Postgres server</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#executing-arbitrary-database-commands">Executing arbitrary database commands</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-access-class">Database Access Class</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#s-sql">S-SQL</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#prepared-statements">Prepared statements</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#migration">Migration</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#other-useful-constructs">Other useful constructs</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#configuration-variables">CONFIGURATION VARIABLES</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#allow-overwriting-prepared-statements">*allow-overwriting-prepared-statements*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#current-logical-transaction">*current-logical-transaction*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database">*database*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#default-use-ssl">*default-use-ssl*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#escape-sql-names-p">*escape-sql-names-p*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ignore-unknown-columns">*ignore-unknown-columns*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#isolation-level">*isolation-level*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#max-pool-size">*max-pool-size*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#table-name">*table-name*,</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#table-symbol">*table-symbol*</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#functions-and-macros">FUNCTIONS AND MACROS</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#dao-def">!dao-def</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#foreign">!foreign</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#index">!index</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#unique">!unique</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#unique-index">!unique-index</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#abort-hooks">abort-hooks</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#abort-logical-transaction">abort-logical-transaction</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#abort-transaction">abort-transaction</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bloat-measurement">bloat-measurement</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cache-hit-ratio">cache-hit-ratio</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#call-with-connection">call-with-connection</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cancel-backend">cancel-backend</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#change-toplevel-database">change-toplevel-database</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#check-query-performance">check-query-performance</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#clear-connection-pool">clear-connection-pool</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#coalesce">coalesce</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#column-exists-p">column-exists-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#commit-hooks">commit-hooks</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#commit-logical-transaction">commit-logical-transaction</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#commit-transaction">commit-transaction</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#connect">connect</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#connect-toplevel">connect-toplevel</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#connected-p">connected-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#create-all-tables">create-all-tables</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#create-package-tables">create-package-tables</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#create-schema">create-schema</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#create-table">create-table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#current-database">current-database</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dao-class">dao-class</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dao-exists-p">dao-exists-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dao-keys">dao-keys</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dao-table-definition">dao-table-definition</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dao-table-name">dao-table-name</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-connection">database-connection</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-error">database-error</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-error-cause">database-error-cause</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-error-code">database-error-code</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-error-constraint-name">database-error-constraint-name</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-error-detail">database-error-detail</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-error-extract-name">database-error-extract-name</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-error-message">database-error-message</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-error-query">database-error-query</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-exists-p">database-exists-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-size">database-size</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#database-version">database-version</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#define-dao-finalization">define-dao-finalization</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defprepared">defprepared</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defprepared-with-names">defprepared-with-names</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#deftable">deftable</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#delete-dao">delete-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#describe-constraint">describe-constraint</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#describe-foreign-key-constraints">describe-foreign-key-constraints</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#describe-views">describe-views</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#disconnect">disconnect</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#disconnect-toplevel">disconnect-toplevel</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#do-query-dao">do-query-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#do-select-dao">do-select-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#doquery">doquery</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#double-precision">double-precision</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#drop-index">drop-index</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#drop-prepared-statement">drop-prepared-statement</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#drop-schema">drop-schema</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#drop-sequence">drop-sequence</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#drop-table">drop-table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ensure-transaction">ensure-transaction</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ensure-transaction-with-isolation-level">ensure-transaction-with-isolation-level</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#execute">execute</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#execute-file">execute-file</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#find-postgresql-prepared-statement">find-postgresql-prepared-statement</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#find-postmodern-prepared-statement">find-postmodern-prepared-statement</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#find-primary-key-info">find-primary-key-info</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#get-dao">get-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#get-pid">get-pid</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#get-pid-from-postmodern">get-pid-from-postmodern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#get-search-path">get-search-path</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#index-exists-p">index-exists-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#insert-dao">insert-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-all-constraints">list-all-constraints</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-available-extensions">list-available-extensions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-available-types">list-available-types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-columns">list-columns</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-columns-with-types">list-columns-with-types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-connections">list-connections</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-database-functions">list-database-functions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-database-users">list-database-users</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-databases">list-databases</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-detailed-triggers">list-detailed-triggers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-foreign-keys">list-foreign-keys</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-index-definitions">list-index-definitions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-indexed-column-and-attributes">list-indexed-column-and-attributes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-indices">list-indices</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-installed-extensions">list-installed-extensions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-postmodern-prepared-statements">list-postmodern-prepared-statements</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-prepared-statements">list-prepared-statements</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-roles">list-roles</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-schemas">list-schemas</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-schemata">list-schemata</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-sequences">list-sequences</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-table-indices">list-table-indices</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-table-sizes">list-table-sizes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-tables">list-tables</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-tables-in-schema">list-tables-in-schema</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-tablespaces">list-tablespaces</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-triggers">list-triggers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-unique-or-primary-constraints">list-unique-or-primary-constraints</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#list-views">list-views</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#make-dao">make-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#more-table-info">more-table-info</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#num-records-in-database">num-records-in-database</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#numeric">numeric</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#parse-queries">parse-queries</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#prepare">prepare</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#prepared-statement-exists-p">prepared-statement-exists-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#query">query</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#query-dao">query-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#read-queries">read-queries</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#real">real</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reconnect">reconnect</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#register-sql-operators">register-sql-operators</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#release-savepoint">release-savepoint</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reset-prepared-statement">reset-prepared-statement</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rollback-savepoint">rollback-savepoint</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#save-dao">save-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#save-daotransaction">save-dao/transaction</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#schema-exists-p">schema-exists-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#select-dao">select-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sequence-exists-p">sequence-exists-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sequence-next">sequence-next</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#set-search-path">set-search-path</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#split-fully-qualified-table-name">split-fully-qualified-table-name</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sql">sql</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sql-compile">sql-compile</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sql-error">sql-error</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sql-escape">sql-escape</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sql-escape-string">sql-escape-string</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#table-description">table-description</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#table-exists-p">table-exists-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#table-size">table-size</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#terminate-backend">terminate-backend</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#unused-indexes">unused-indexes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#update-dao">update-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#upsert-dao">upsert-dao</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#varchar">varchar</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#view-exists-p">view-exists-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#with-column-writers">with-column-writers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#with-connection">with-connection</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#with-logical-transaction">with-logical-transaction</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#with-savepoint">with-savepoint</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#with-schema">with-schema</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#with-transaction">with-transaction</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Not yet defacto</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../numcl/">numcl - Lispy clone of numpy</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../unix-opts/">unix-opts - cmd line argument parser</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../utilities/">utilities - A collection of some more utility libraries</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">common-lisp.readthedocs</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Defacto libraries &raquo;</li>
        
      
    
    <li>postmodern - PostgreSQL programming interace</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="postmodern-postgresql-programming-interace">postmodern - PostgreSQL programming interace</h1>
<p>Version: 1.30
<br/>
Nickname: pomo
<br/>
Repository: <a href="https://github.com/marijnh/Postmodern">marijnh/Postmodern - Github</a></p>
<p><em>This page was possible due to the excellent <a href="https://edicl.github.io/hunchentoot/">official documentation</a> as well as the page on <a href="https://marijnhaverbeke.nl/postmodern/postmodern.html">Web Development on The Common Lisp Cookbook</a>.</em></p>
<p><em>In case of any inaccuracies, ambiguities or suggestions, please <a href="https://github.com/digikar99/common-lisp.readthedocs/issues">create an issue here</a>.</em></p>
<hr />
<p>Postmodern is a Common Lisp library for interacting with <a href="https://postgresql.org">PostgreSQL
databases</a>. The focus has been on:</p>
<ul>
<li>Efficient communication with the database server without need for
    foreign libraries.</li>
<li>Support for UTF-8 on Unicode-aware Lisp implementations</li>
<li>A syntax for mixing SQL and Lisp code</li>
<li>Convenient support for prepared statements and stored procedures</li>
<li>A metaclass for simple database-access objects</li>
</ul>
<p>The biggest differences between this library and
<a href="http://quickdocs.org/clsql/">clsql</a> or
<a href="https://github.com/fukamachi/cl-dbi">cl-dbi</a> are that Postmodern has no
intention of being portable across different SQL implementations (it
embraces non-standard PostgreSQL features), and approaches extensions
like lispy SQL and database access objects in a quite different way.</p>
<h2 id="getting-started">GETTING STARTED</h2>
<h3 id="starting-the-postgres-server">Starting the Postgres server</h3>
<p>[TODO] Someone more familiar with postgres or databases should review this section.</p>
<p>Follow the <a href="https://www.postgresql.org/download/">installation instructions</a> to install Postgres.
Once done, you should have access to the <code>postgres</code>, <code>pg_ctl</code>, and optionally the <code>psql</code> commands on your command line / terminal.</p>
<p>Once done, <a href="https://www.postgresql.org/docs/10/server-start.html">this page</a> elaborates
the process of starting the database server and any issues that may arise. (You can select the postgresql version from top of the page.)</p>
<ul>
<li>Initialize the directory: <code>pg_ctl init -D postmodern # see \</code>pg_ctl --help<code>\ from the options</code>.</li>
<li>Optionally, change <code>port</code> and <code>unix_socket_directories</code> from <code>postmodern/postgresql.conf</code>.</li>
<li><code>pg_ctl start -D postmodern</code> to start the server.</li>
</ul>
<p>You should get a <code>server started</code> message; if not, the link above should help in debugging.
Proceed to the next section once you successfully start the server.</p>
<p><a href="https://www.postgresql.org/docs/10/runtime-config-connection.html">This page</a> elaborates on the configuration settings.</p>
<p>In addition, you can list the databases by using
<code>psql -p</code><em><code>PORT</code></em><code>-h</code><em><code>unix_socket_directories</code></em><code>-l</code>,
replacing the italicized arguments appropriately. </p>
<h3 id="connecting-to-the-postgres-server">Connecting to the Postgres server</h3>
<p>We firstly connect to the default existing database. Create a new database for our
purposes, and then disconnect and reconnect to this database.</p>
<p>We also assume the server is started at 8080 and username is <code>"username"</code>.</p>
<pre><code class="lisp">CL-USER&gt; (connect-toplevel &quot;postgres&quot; &quot;username&quot; &quot;&quot; &quot;localhost&quot; :port 8080)
; No value
CL-USER&gt; (execute &quot;create database testdb&quot;)
0
CL-USER&gt; (disconnect-toplevel)
NIL
CL-USER&gt; (connect-toplevel &quot;testdb&quot; &quot;username&quot; &quot;&quot; &quot;localhost&quot; :port 8080)
; No value
</code></pre>

<p>[TODO] Distinguish why "exactly" connect and connect-toplevel are different? What goes on under the hood? Also, what role does <code>:pooled-p</code> play?</p>
<p>Other things you may want to take a look at with regards to connection include:</p>
<ul>
<li><a href="#database-connection">database-connection</a></li>
<li><a href="#connect">connect</a></li>
<li><a href="#default-use-ssl">*default-use-ssl*</a></li>
<li><a href="#disconnect">disconnect</a> </li>
<li><a href="#connected-p">connected-p</a> </li>
<li><a href="#reconnect">reconnect</a> </li>
<li><a href="#database">*database*</a></li>
<li><a href="#with-connection">with-connection</a> </li>
<li><a href="#call-with-connection">call-with-connection</a> </li>
<li><a href="#connect-toplevel">connect-toplevel</a>        </li>
<li><a href="#disconnect-toplevel">disconnect-toplevel</a> </li>
<li><a href="#clear-connection-pool">clear-connection-pool</a> </li>
<li><a href="#max-pool-size">*max-pool-size*</a></li>
<li><a href="#list-connections">list-connections</a> </li>
</ul>
<h3 id="executing-arbitrary-database-commands">Executing arbitrary database commands</h3>
<p><a href="#query">Query</a> is the basic way to send queries to the database:</p>
<pre><code class="lisp">CL-USER&gt; (query &quot;select 22, 'Folie et déraison', 4.5&quot;)
((22 &quot;Folie et déraison&quot; 9/2))
CL-USER&gt; (query (:select 22 &quot;Folie et déraison&quot; 4.5))
((22 &quot;Folie et déraison&quot; 9/2))

</code></pre>

<p>In many contexts, query strings and lists starting with keywords can be used interchangeably. The lists will be compiled to SQL. The <a href="https://marijnhaverbeke.nl/postmodern/s-sql.html">S-SQL manual</a> describes the syntax used by these expressions. Lisp values occurring in them are automatically escaped. In the above query, only constant values are used, but it is possible to transparently use run-time values as well:</p>
<pre><code class="lisp">CL-USER&gt; (defun database-powered-addition (a b)
           (query (:select (:+ a b)) :single))
DATABASE-POWERED-ADDITION
CL-USER&gt; (database-powered-addition 1030 204)
1234
1
</code></pre>

<p>That last argument, <code>:single</code>, indicates that we want the result not as a list of lists (for the result rows), but as a single value, since we know that we are only selecting one value. See the documentation of <a href="#query">query</a> for the other options.</p>
<p>You do not have to pull in the whole result of a query at once, you can also iterate over it with the <a href="#doquery">doquery</a> macro.</p>
<p>The following things should be useful about querying:</p>
<ul>
<li><a href="#query">query</a> </li>
<li><a href="#execute">execute</a></li>
<li><a href="#doquery">doquery</a> </li>
<li><a href="#prepare">prepare</a> </li>
<li><a href="#defprepared">defprepared</a></li>
<li><a href="#defprepared-with-names">defprepared-with-names</a></li>
<li><a href="#with-transaction">with-transaction</a></li>
<li><a href="#commit-transaction">commit-transaction</a> </li>
<li><a href="#abort-transaction">abort-transaction</a> </li>
<li><a href="#with-savepoint">with-savepoint</a> </li>
<li><a href="#release-savepoint">release-savepoint</a> </li>
<li><a href="#rollback-savepoint">rollback-savepoint</a> </li>
<li><a href="#commit-hooks">commit-hooks</a>        </li>
<li><a href="#abort-hooks">abort-hooks</a>        </li>
<li><a href="#with-logical-transaction">with-logical-transaction</a></li>
<li><a href="#abort-logical-transaction">abort-logical-transaction</a></li>
<li><a href="#commit-logical-transaction">commit-logical-transaction</a>        </li>
<li><a href="#current-logical-transaction">*current-logical-transaction*</a></li>
<li><a href="#ensure-transaction">ensure-transaction</a> </li>
<li><a href="#with-schema">with-schema</a></li>
<li><a href="#sequence-next">sequence-next</a> </li>
<li><a href="#coalesce">coalesce</a> </li>
</ul>
<h3 id="database-access-class">Database Access Class</h3>
<p>You can work directly with the database or you can use a simple
database-access-class (aka <a href="#dao-class">dao-class</a>) which would cover all the fields in a
row. This is what a database-access class looks like:</p>
<pre><code class="commonlisp">(defclass points ()
  ((x :col-type integer :initarg :x
      :reader point-x)
   (y :col-type integer :initarg :y
      :reader point-y)
   (value :col-type integer :initarg :value
          :accessor value))
  (:metaclass dao-class)
  (:keys x y))
</code></pre>

<p>Once the class is defined, we create the table in the database:</p>
<pre><code class="lisp">CL-USER&gt; (dao-table-definition 'points)
&quot;CREATE TABLE points (x INTEGER NOT NULL, y INTEGER NOT NULL, value INTEGER NOT NULL, PRIMARY KEY (x, y))&quot;
CL-USER&gt; (execute (dao-table-definition 'points))
0
</code></pre>

<p>In more complicated cases, you might want to <code>:create-table</code> directly. You can use <a href="#sql">sql</a> to view the result of parsing the <code>form</code>.</p>
<pre><code class="lisp">CL-USER&gt; (sql (:create-table so-items
                             ((item-id :type integer)
                              (so-id :type (or integer db-null) :references ((so-headers id)))
                              (product-id :type (or integer db-null))
                              (qty :type (or integer db-null))
                              (net-price :type (or numeric db-null)))
                             (:primary-key item-id so-id)))
&quot;CREATE TABLE so_items (item_id INTEGER NOT NULL, so_id INTEGER REFERENCES so_headers(id) MATCH SIMPLE ON DELETE RESTRICT ON UPDATE RESTRICT, product_id INTEGER, qty INTEGER, net_price NUMERIC, PRIMARY KEY (item_id, so_id))&quot;
</code></pre>

<p>(Note that you'd need to execute this form using <a href="#query">query</a> or <a href="#execute">execute</a>. Also see <a href="https://marijnhaverbeke.nl/postmodern/create-tables.html">this</a> for details and examples on using S-SQL for creating tables.)</p>
<p>You can use <a href="#insert-dao">insert-dao</a> for inserting DAO-objects into the database. (Of course, you can use <code>query</code> to do all this using the usual SQL syntax.)</p>
<pre><code class="lisp">CL-USER&gt; (insert-dao (make-instance 'points :x 0 :y 1 :value 10))
#&lt;POINTS {10145AC1D3}&gt;
CL-USER&gt; (insert-dao (make-instance 'points :x 1 :y 0 :value 15))
#&lt;POINTS {10145B5EA3}&gt;
CL-USER&gt; (select-dao 'country)
(#&lt;COUNTRY {101C5F3103}&gt; #&lt;COUNTRY {101C5F3883}&gt;)
2
CL-USER&gt; (select-dao 'points)
(#&lt;POINTS {1017B9BB93}&gt; #&lt;POINTS {1017B9BC23}&gt;)
2
CL-USER&gt; (query (:select '* :from 'points))
((0 1 10) (1 0 15))
2
</code></pre>

<p>Finally, you can use <a href="#update-dao">update-dao</a> to, well, update the database entry:</p>
<pre><code class="lisp">CL-USER&gt; (let ((1-0 (get-dao 'points 1 0)))
           (setf (value 1-0) 20)
           (update-dao 1-0))
#&lt;POINTS {101F1628E3}&gt;
CL-USER&gt; (query (:select '* :from 'points))
((0 1 10) (1 0 20))
2
</code></pre>

<p>Here are the other useful constructs related to database access objects:</p>
<ul>
<li><a href="#dao-class">dao-class</a></li>
<li><a href="#dao-keys">dao-keys</a> </li>
<li><a href="#dao-exists-p">dao-exists-p</a> </li>
<li><a href="#make-dao">make-dao</a></li>
<li><a href="#define-dao-finalization">define-dao-finalization</a></li>
<li><a href="#get-dao">get-dao</a> </li>
<li><a href="#select-dao">select-dao</a></li>
<li><a href="#do-select-dao">do-select-dao</a></li>
<li><a href="#query-dao">query-dao</a> </li>
<li><a href="#do-query-dao">do-query-dao</a></li>
<li><a href="#ignore-unknown-columns">*ignore-unknown-columns*</a></li>
<li><a href="#insert-dao">insert-dao</a> </li>
<li><a href="#update-dao">update-dao</a> </li>
<li><a href="#save-dao">save-dao</a> </li>
<li><a href="#save-dao/transaction">save-dao/transaction</a> </li>
<li><a href="#upsert-dao">upsert-dao</a> </li>
<li><a href="#delete-dao">delete-dao</a> </li>
<li><a href="#dao-table-name">dao-table-name</a> </li>
<li><a href="#dao-table-definition">dao-table-definition</a> </li>
<li><a href="#with-column-writers">with-column-writers</a></li>
</ul>
<h3 id="s-sql">S-SQL</h3>
<p>Finally, here is some more demonstration of S-SQL syntax:</p>
<pre><code class="commonlisp">(sql (:select 'relname :from 'pg-catalog.pg-class
      :inner-join 'pg-catalog.pg-namespace :on (:= 'relnamespace 'pg-namespace.oid)
      :where (:and (:= 'relkind &quot;r&quot;)
                   (:not-in 'nspname (:set &quot;pg_catalog&quot; &quot;pg_toast&quot;))
                   (:pg-catalog.pg-table-is-visible 'pg-class.oid))))
;; =&gt; &quot;(SELECT relname FROM pg_catalog.pg_class
;;      INNER JOIN pg_catalog.pg_namespace ON (relnamespace = pg_namespace.oid)
;;      WHERE ((relkind = 'r') and (nspname NOT IN ('pg_catalog', 'pg_toast'))
;;             and pg_catalog.pg_table_is_visible(pg_class.oid)))&quot;
</code></pre>

<p>Lists starting with keywords are used to express SQL
commands and operators while lists starting with something else will be
evaluated and then inserted into the query. Quoted symbols name columns
or tables (keywords can also be used but might introduce ambiguities).
The syntax supports subqueries, multiple joins, stored procedures, etc.
See the <a href="https://marijnhaverbeke.nl/postmodern/s-sql.html">S-SQL reference manual</a> for a complete treatment.</p>
<p>[TODO] Add more S-SQL examples. Compare them with SxQL as well.</p>
<h3 id="prepared-statements">Prepared statements</h3>
<ul>
<li><a href="#allow-overwriting-prepared-statements">*allow-overwriting-prepared-statements*</a></li>
<li><a href="#prepared-statement-exists-p">prepared-statement-exists-p</a> </li>
<li><a href="#list-prepared-statements">list-prepared-statements</a></li>
<li><a href="#drop-prepared-statement">drop-prepared-statement</a></li>
<li><a href="#list-postmodern-prepared-statements">list-postmodern-prepared-statements</a>        </li>
<li><a href="#find-postgresql-prepared-statement">find-postgresql-prepared-statement</a>        </li>
<li><a href="#find-postmodern-prepared-statement">find-postmodern-prepared-statement</a>        </li>
<li><a href="#reset-prepared-statement">reset-prepared-statement</a> </li>
<li><a href="#get-pid">get-pid</a> </li>
<li><a href="#get-pid-from-postmodern">get-pid-from-postmodern</a> </li>
<li><a href="#cancel-backend">cancel-backend</a> </li>
<li><a href="#terminate-backend">terminate-backend</a> </li>
</ul>
<p>Example Usage:</p>
<pre><code class="lisp">CL-USER&gt; (funcall (prepare (:select '* :from 'points
                                    :where (:= 'x '$1)))
                  0)
((0 1 10))
1
</code></pre>

<ul>
<li><a href="#prepare">prepare</a> </li>
<li><a href="#defprepared">defprepared</a></li>
<li><a href="#defprepared-with-names">defprepared-with-names</a></li>
</ul>
<h3 id="migration">Migration</h3>
<p>[TODO] Groaking migrations needed for ELI5-cation. </p>
<h3 id="other-useful-constructs">Other useful constructs</h3>
<ul>
<li><strong>Inspecting the database</strong><ul>
<li><a href="#list-tables">list-tables</a> </li>
<li><a href="#list-tables-in-schema">list-tables-in-schema</a></li>
<li><a href="#table-exists-p">table-exists-p</a> </li>
<li><a href="#table-description">table-description</a></li>
<li><a href="#list-sequences">list-sequences</a> </li>
<li><a href="#sequence-exists-p">sequence-exists-p</a> </li>
<li><a href="#list-views">list-views</a> </li>
<li><a href="#view-exists-p">view-exists-p</a> </li>
<li><a href="#list-schemata">list-schemata</a> </li>
<li><a href="#schema-exist-p">schema-exist-p</a></li>
<li><a href="#schema-exists-p">schema-exists-p</a> </li>
<li><a href="#database-version">database-version</a> </li>
<li><a href="#num-records-in-database">num-records-in-database</a> </li>
<li><a href="#current-database">current-database</a> </li>
<li><a href="#database-exists-p">database-exists-p</a> </li>
<li><a href="#database-size">database-size</a> </li>
<li><a href="#list-databases">list-databases</a></li>
<li><a href="#list-schemas">list-schemas</a></li>
<li><a href="#list-tablespaces">list-tablespaces</a> </li>
<li><a href="#list-available-types">list-available-types</a> </li>
<li><a href="#list-table-sizes">list-table-sizes</a></li>
<li><a href="#table-size">table-size</a> </li>
<li><a href="#more-table-info">more-table-info</a> </li>
<li><a href="#list-columns">list-columns</a> </li>
<li><a href="#list-columns-with-types">list-columns-with-types</a> </li>
<li><a href="#column-exists-p">column-exists-p</a> </li>
<li><a href="#describe-views">describe-views</a></li>
<li><a href="#list-database-functions">list-database-functions</a> </li>
<li><a href="#list-indices">list-indices</a> </li>
<li><a href="#list-table-indices">list-table-indices</a></li>
<li><a href="#index-exists-p">index-exists-p</a> </li>
<li><a href="#list-indexed-column-and-attributes">list-indexed-column-and-attributes</a>        </li>
<li><a href="#list-index-definitions">list-index-definitions</a> </li>
<li><a href="#find-primary-key-info">find-primary-key-info</a></li>
<li><a href="#list-foreign-keys">list-foreign-keys</a> </li>
<li><a href="#list-unique-or-primary-constraints">list-unique-or-primary-constraints</a>        </li>
<li><a href="#list-all-constraints">list-all-constraints</a> </li>
<li><a href="#describe-constraint">describe-constraint</a></li>
<li><a href="#describe-foreign-key-constraints">describe-foreign-key-constraints</a> </li>
<li><a href="#list-triggers">list-triggers</a> </li>
<li><a href="#list-detailed-triggers">list-detailed-triggers</a> </li>
<li><a href="#list-database-users">list-database-users</a> </li>
<li><a href="#list-roles">list-roles</a> </li>
<li><a href="#list-available-extensions">list-available-extensions</a> </li>
<li><a href="#list-installed-extensions">list-installed-extensions</a> </li>
<li><a href="#change-toplevel-database">change-toplevel-database</a></li>
</ul>
</li>
<li><strong>Table definition and creation</strong><ul>
<li><a href="#deftable">deftable</a> </li>
<li><a href="#dao-def">!dao-def</a> </li>
<li><a href="#index">!index</a></li>
<li><a href="#unique-index">!unique-index</a></li>
<li><a href="#foreign">!foreign</a></li>
<li><a href="#unique">!unique</a></li>
<li><a href="#create-table">create-table</a> </li>
<li><a href="#create-all-tables">create-all-tables</a> </li>
<li><a href="#create-package-tables">create-package-tables</a> </li>
<li><a href="#table-name">*table-name*</a></li>
<li><a href="#table-symbol">*table-symbol*</a></li>
</ul>
</li>
<li><strong>Schemata</strong><ul>
<li><a href="#create-schema">create-schema</a> </li>
<li><a href="#drop-schema">drop-schema</a></li>
<li><a href="#get-search-path">get-search-path</a> </li>
<li><a href="#set-search-path">set-search-path</a> </li>
<li><a href="#split-fully-qualified-table-name">split-fully-qualified-table-name</a> </li>
</ul>
</li>
<li><strong>Database Health Measurements</strong><ul>
<li><a href="#cache-hit-ratio">cache-hit-ratio</a> </li>
<li><a href="#bloat-measurement">bloat-measurement</a> </li>
<li><a href="#unused-indexes">unused-indexes</a> </li>
<li><a href="#check-query-performance">check-query-performance</a> </li>
</ul>
</li>
<li><strong>Miscellaneous Utility Functions</strong><ul>
<li><a href="#execute-file">execute-file</a></li>
</ul>
</li>
</ul>
<h2 id="configuration-variables">CONFIGURATION VARIABLES</h2>
<h3 id="allow-overwriting-prepared-statements">*allow-overwriting-prepared-statements*</h3>
<pre><code class="lisp">Variable
</code></pre>

<p>When set to t, ensured-prepared will overwrite prepared statements
having the same name if the query statement itself in the postmodern
meta connection is different than the query statement provided to
ensure-prepared.</p>
<h3 id="current-logical-transaction">*current-logical-transaction*</h3>
<pre><code class="lisp">Variable
</code></pre>

<p>This is bound to the current transaction-handle or savepoint-handle
instance representing the innermost open logical transaction.</p>
<h3 id="database">*database*</h3>
<pre><code class="lisp">Variable
</code></pre>

<p>Special variable holding the current database. Most functions and macros
operating on a database assume this binds to a connected database.</p>
<h3 id="default-use-ssl">*default-use-ssl*</h3>
<pre><code class="lisp">Variable
</code></pre>

<p>The default for connect's use-ssl argument. This starts at :no. If you
set it to anything else, be sure to also load the CL+SSL library.</p>
<h3 id="escape-sql-names-p">*escape-sql-names-p*</h3>
<pre><code class="lisp">Variable
</code></pre>

<p>Setting this to T will make S-SQL add double quotes around
identifiers in queries. Setting it :auto will turn on this behaviour
only for reserved words. Setting it to :literal will cause to-sql-name to
escape reserved words,but will not make other changes such as changing
forward slash to underscore.</p>
<h3 id="ignore-unknown-columns">*ignore-unknown-columns*</h3>
<pre><code class="lisp">Variable
</code></pre>

<p>Normally, when get-dao, select-dao, or query-dao finds a column in the
database that's not in the DAO class, it will raise an error. Setting
this variable to a non-NIL will cause it to simply ignore the unknown
column.</p>
<h3 id="isolation-level">*isolation-level*</h3>
<h3 id="max-pool-size">*max-pool-size*</h3>
<pre><code class="lisp">Variable
</code></pre>

<p>Set the maximum amount of connections kept in a single connection pool,
where a pool consists of all the stored connections with the exact same
connect arguments. Defaults to NIL, which means there is no maximum.</p>
<h3 id="table-name">*table-name*,</h3>
<pre><code class="lisp">Variable
</code></pre>

<p>These variables are bound to the relevant name and symbol while the
forms of a table definition are evaluated. Can be used to define
shorthands like the ones below.</p>
<h3 id="table-symbol">*table-symbol*</h3>
<pre><code class="lisp">Variable
</code></pre>

<p>Used inside <a href="#deftable">deftable</a> to find the symbol naming the table being defined.</p>
<h2 id="functions-and-macros">FUNCTIONS AND MACROS</h2>
<h3 id="dao-def">!dao-def</h3>
<pre><code class="lisp">Function: (!dao-def)
</code></pre>

<p>Should only be used inside deftable's body. Adds the result of calling
dao-table-definition on <strong>table-symbol</strong> to the definition.</p>
<h3 id="foreign">!foreign</h3>
<pre><code class="lisp">Function: (!foreign target fields &amp;rest
 target-fields/on-delete/on-update/deferrable/initially-deferred)
</code></pre>

<p>Add a foreign key to the table being defined. target-table is the
referenced table. columns is a list of column names or single name in
this table, and, if the columns have different names in the referenced
table, target-columns must be another list of column names or single
column name of the target-table, or :primary-key to denote the column(s)
of the target-table's primary key as referenced column(s).</p>
<p>The on-delete and on-update arguments can be used to specify ON DELETE
and ON UPDATE actions, as per the keywords allowed in create-table. In
addition, the deferrable and initially-deferred arguments can be used to
indicate whether constraint checking can be deferred until the current
transaction completed, and whether this should be done by default. Note
that none of these are really &amp;key arguments, but rather are picked out
of a &amp;rest arg at runtime, so that they can be specified even when
target-columns is not given.</p>
<h3 id="index">!index</h3>
<pre><code class="lisp">Function: (!index &amp;rest fields)
</code></pre>

<p>Define an index on the table being defined. The columns can be given as
symbols or strings.</p>
<h3 id="unique">!unique</h3>
<pre><code class="lisp">Function: (!unique target-fields &amp;key deferrable initially-deferred)
</code></pre>

<p>Constrains one or more columns to only contain unique (combinations of)
values, with deferrable and initially-deferred defined as in !foreign</p>
<h3 id="unique-index">!unique-index</h3>
<pre><code class="lisp">Function: (!unique-index &amp;rest fields)
</code></pre>

<p>Used inside a <a href="#deftable">deftable</a> form. Define a unique index on the defined table.</p>
<h3 id="abort-hooks">abort-hooks</h3>
<pre><code class="lisp">Generic Function: (abort-hooks object)
Generic Function: (setf (abort-hooks object) ...)
</code></pre>

<p>An accessor for the transaction or savepoint's list of commit hooks,
each of which should be a function with no required arguments. These
functions will be executed when a transaction is committed or a
savepoint released.</p>
<h3 id="abort-logical-transaction">abort-logical-transaction</h3>
<pre><code class="lisp">Generic Function: (abort-logical-transaction savepoint)
</code></pre>

<p>Roll back the given logical transaction, regardless of whether it is an
actual transaction or a savepoint.</p>
<h3 id="abort-transaction">abort-transaction</h3>
<pre><code class="lisp">Function: (abort-transaction transaction)
</code></pre>

<p>Roll back the given transaction.</p>
<h3 id="bloat-measurement">bloat-measurement</h3>
<pre><code class="lisp">Function: (bloat-measurement)
</code></pre>

<p>→ list</p>
<p>Bloat measurement of unvacuumed dead tuples. Borrowed from:
<a href="https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/">https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/</a>
who borrowed it from
<a href="https://github.com/heroku/heroku-pg-extras/tree/master/commands">https://github.com/heroku/heroku-pg-extras/tree/master/commands</a>.</p>
<h3 id="cache-hit-ratio">cache-hit-ratio</h3>
<pre><code class="lisp">Function: (cache-hit-ratio)
</code></pre>

<p>→ list</p>
<p>The cache hit ratio shows data on serving the data from memory compared
to how often you have to go to disk. This function returns a list of
heapblocks read from disk, heapblocks hit from memory and the ratio of
heapblocks hit from memory / total heapblocks hit. Borrowed from:
<a href="https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/">https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/</a></p>
<h3 id="call-with-connection">call-with-connection</h3>
<pre><code class="lisp">Function: (call-with-connection spec thunk)
</code></pre>

<p>The functional backend to with-connection. Binds *database* to a new
connection as specified by spec, which should be a list that connect can
be applied to, and runs the zero-argument function given as second
argument in the new environment. When the function returns or throws,
the new connection is disconnected.</p>
<h3 id="cancel-backend">cancel-backend</h3>
<pre><code class="lisp">Function: (cancel-backend pid &amp;optional (database *database*))
</code></pre>

<p>Polite way of terminating a query at the database (as opposed to calling
close-database). Slower than (terminate-backend pid) and does not always
work.</p>
<h3 id="change-toplevel-database">change-toplevel-database</h3>
<pre><code class="lisp">Function: (change-toplevel-database new-database user password host)
</code></pre>

<p>→ string</p>
<p>Just changes the database assuming you are using a toplevel connection.
Recommended only for development work. Returns the name of the newly
connected database as a string.</p>
<h3 id="check-query-performance">check-query-performance</h3>
<pre><code class="lisp">Function: (check-query-performance &amp;optional (ob nil) (num-calls 100) (limit 20))
</code></pre>

<p>→ list</p>
<p>This function requires that postgresql extension pg_stat_statements
must be loaded via shared_preload_libraries. It is borrowed from
<a href="https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/">https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/</a>.
Optional parameters OB allow order-by to be 'calls', 'total-time',
'rows-per' or 'time-per', defaulting to time-per. num-calls to require
that the number of calls exceeds a certain threshold, and limit to limit
the number of rows returned. It returns a list of lists, each row
containing the query, number of calls, total_time, total_time/calls,
stddev_time, rows, rows/calls and the cache hit percentage.</p>
<h3 id="clear-connection-pool">clear-connection-pool</h3>
<pre><code class="lisp">Function: (clear-connection-pool)
</code></pre>

<p>Disconnect and remove all connections from the connection pools.</p>
<h3 id="coalesce">coalesce</h3>
<pre><code class="lisp">Function: (coalesce &amp;rest args)
</code></pre>

<p>→ value</p>
<p>Returns the first non-NIL, non-NULL (as in :null) argument, or NIL if
none are present. Useful for providing a fall-back value for the result
of a query, or, when given only one argument, for transforming :nulls to
NIL.</p>
<h3 id="column-exists-p">column-exists-p</h3>
<pre><code class="lisp">Function: (column-exists-p table-name column-name)
</code></pre>

<p>→ boolean</p>
<p>Determine if a particular column exists. Table name and column-name can
be either strings or symbols.</p>
<h3 id="commit-hooks">commit-hooks</h3>
<pre><code class="lisp">Generic Function: (commit-hooks object)
</code></pre>

<p>An accessor for the transaction or savepoint's list of commit hooks,
each of which should be a function with no required arguments. These
functions will be executed when a transaction is committed or a
savepoint released.</p>
<h3 id="commit-logical-transaction">commit-logical-transaction</h3>
<pre><code class="lisp">Generic Function: (commit-logical-transaction savepoint)
</code></pre>

<p>[TODO] This symbol is not exported.</p>
<p>Commit the given logical transaction, regardless of whether it is an
actual transaction or a savepoint.</p>
<h3 id="commit-transaction">commit-transaction</h3>
<pre><code class="lisp">Function: (commit-transaction transaction)
</code></pre>

<p>Commit the given transaction.</p>
<h3 id="connect">connect</h3>
<pre><code class="lisp">Function: (connect database-name user password host &amp;key (port 5432) pooled-p
 (use-ssl *default-use-ssl*) (service postgres))
</code></pre>

<p>→ database-connection</p>
<p>Create a new database connection for the given user and the database.
Port will default to 5432, which is where most PostgreSQL servers are
running. If pooled-p is T, a connection will be taken from a pool of
connections of this type, if one is available there, and when the
connection is disconnected it will be put back into this pool instead.
use-ssl can be :no, :yes, or :try, as in open-database, and defaults to
the value of *default-use-ssl*.</p>
<h3 id="connect-toplevel">connect-toplevel</h3>
<pre><code class="lisp">Function: (connect-toplevel database-name user password host &amp;key (port 5432)
 (use-ssl *default-use-ssl*))
</code></pre>

<p>Bind the *database* to a new connection. Use this if you only need one
connection, or if you want a connection for debugging from the REPL.</p>
<h3 id="connected-p">connected-p</h3>
<pre><code class="lisp">Function: (connected-p database)
</code></pre>

<p>→ boolean</p>
<p>Returns a boolean indicating whether the given connection is still
connected to the server.</p>
<h3 id="create-all-tables">create-all-tables</h3>
<pre><code class="lisp">Function: (create-all-tables)
</code></pre>

<p>Creates all defined tables.</p>
<h3 id="create-package-tables">create-package-tables</h3>
<pre><code class="lisp">Function: (create-package-tables package)
</code></pre>

<p>Creates all tables identified by symbols interned in the given package.</p>
<h3 id="create-schema">create-schema</h3>
<pre><code class="lisp">Function: (create-schema schema)
</code></pre>

<p>Creates a new schema. Raises an error if the schema is already exists.</p>
<h3 id="create-table">create-table</h3>
<pre><code class="lisp">Function: (create-table name)
</code></pre>

<p>Creates the table identified by symbol by executing all forms in its
definition.</p>
<h3 id="current-database">current-database</h3>
<pre><code class="lisp">Function: (current-database)
</code></pre>

<p>→ string</p>
<p>Returns the string name of the current database.</p>
<h3 id="dao-class">dao-class</h3>
<pre><code class="lisp">: (dao-class)
</code></pre>

<p>Postmodern contains a simple system for defining CLOS classes that
represent rows in the database. This is not intended as a full-fledged
object-relational magic system ― while serious ORM systems have their
place, they are notoriously hard to get right, and are outside of the
scope of a humble SQL library like this.</p>
<p>At the heart of Postmodern's DAO system is the dao-class metaclass. It
allows you to define classes for your database-access objects as regular
CLOS classes. Some of the slots in these classes will refer to columns
in the database. To specify that a slot refers to a column, give it a
:col-type option containing an S-SQL type expression (useful if you want
to be able to derive a table definition from the class definition), or
simply a :column option with value T. Such slots can also take a
:col-default option, used to provide a database-side default value as an
S-SQL expression. You can use the :col-name initarg (whose unevaluated
value will be passed to to-sql-name) to specify the slot's column's
name.</p>
<p>DAO class definitions support two extra class options: :table-name to
give the name of the table that the class refers to (defaults to the
class name), and :keys to provide a set of primary keys for the table.
When no primary keys are defined, operations such as update-dao and
get-dao will not work.</p>
<p>IMPORTANT: Class finalization for a dao class instance are wrapped with
a thread lock. However, any time you are using threads and a class that
inherits from other classes, you should ensure that classes are
finalized before you start generating threads that create new instances
of that class.</p>
<p>Simple example:</p>
<pre><code class="commonlisp">(defclass user ()
  ((name :col-type string :initarg :name :accessor user-name)
   (creditcard :col-type (or db-null integer) :initarg :card :col-default :null)
   (score :col-type bigint :col-default 0 :accessor user-score))
  (:metaclass dao-class)
  (:keys name))
</code></pre>

<p>The (or db-null integer) form is used to indicate a column can have NULL
values.</p>
<p>When inheriting from DAO classes, a subclass' set of columns also
contains all the columns of its superclasses. The primary key for such a
class is the union of its own keys and all the keys from its
superclasses. Classes inheriting from DAO classes should probably always
use the dao-class metaclass themselves.</p>
<p>When a DAO is created with make-instance, the :fetch-defaults keyword
argument can be passed, which, when T, will cause a query to fetch the
default values for all slots that refers to columns with defaults and
were not bound through initargs. In some cases, such as serial columns,
which have an implicit default, this will not work. You can work around
this by creating your own sequence, e.g. "my_sequence", and defining a
(:nextval "my_sequence") default.</p>
<p>Finally, DAO class slots can have an option :ghost t to specify them as
ghost slots. These are selected when retrieving instances, but not
written when updating or inserting, or even included in the table
definition. The only known use for this to date is for creating the
table with (oids=true), and specify a slot like this:</p>
<pre><code class="commonlisp">(oid :col-type integer :ghost t :accessor get-oid)
</code></pre>

<h3 id="dao-exists-p">dao-exists-p</h3>
<pre><code class="lisp">Generic Function: (dao-exists-p dao)
</code></pre>

<p>→ boolean</p>
<p>Test whether a row with the same primary key as the given dao exists in
the database. Will also return NIL when any of the key slots in the
object are unbound.</p>
<h3 id="dao-keys">dao-keys</h3>
<pre><code class="lisp">Generic Function: (dao-keys class)
</code></pre>

<p>→ list</p>
<p>Returns list of slot names that are the primary key of DAO class. This
is likely interesting if you have primary keys which are composed of
more than one slot. Pay careful attention to situations where the
primary key not only has more than one column, but they are actually in
a different order than they are in the database table itself. You can
check this with the find-primary-key-info function.</p>
<pre><code class="commonlisp">(pomo:find-primary-key-info &quot;country1&quot;)

((&quot;name&quot; &quot;text&quot;) (&quot;id&quot; &quot;integer&quot;))
</code></pre>

<p>→ list</p>
<p>Returns list of values that are the primary key of dao.</p>
<h3 id="dao-table-definition">dao-table-definition</h3>
<pre><code class="lisp">Function: (dao-table-definition table)
</code></pre>

<p>→ string</p>
<p>Given a DAO class, or the name of one, this will produce an SQL query
string with a definition of the table. This is just the bare simple
definition, so if you need any extra indices or or constraints, you'll
have to write your own queries to add them, in which case look to
s-sql's create-table function.</p>
<h3 id="dao-table-name">dao-table-name</h3>
<pre><code class="lisp">Function: (dao-table-name class)
</code></pre>

<p>→ string</p>
<p>Get the name of the table associated with the given DAO class (or symbol
naming such a class).</p>
<h3 id="database-connection">database-connection</h3>
<pre><code class="lisp">: (database-connection)
</code></pre>

<p>Objects of this type represent database connections.</p>
<h3 id="database-error">database-error</h3>
<pre><code class="lisp">Condition
</code></pre>

<p>This is the condition type that will be used to
signal virtually all database-related errors (though in some cases
socket errors may be raised when a connection fails on the IP
level).</p>
<p><u><strong>Direct Slots</strong></u></p>
<p><strong>cl-postgres::error-code</strong></p>
<pre><code class="lisp">Initargs: :CODE
</code></pre>

<p><strong>cl-postgres::message</strong></p>
<pre><code class="lisp">Initargs: :MESSAGE
Readers: CL-POSTGRES:DATABASE-ERROR-MESSAGE
</code></pre>

<p><strong>cl-postgres::detail</strong></p>
<pre><code class="lisp">Initargs: :DETAIL
</code></pre>

<p><strong>cl-postgres::hint</strong></p>
<pre><code class="lisp">Initargs: :HINT
</code></pre>

<p><strong>cl-postgres::context</strong></p>
<pre><code class="lisp">Initargs: :CONTEXT
</code></pre>

<p><strong>cl-postgres::query</strong></p>
<pre><code class="lisp"></code></pre>

<p><strong>position</strong></p>
<pre><code class="lisp">Initargs: :POSITION
</code></pre>

<p><strong>cl-postgres::cause</strong></p>
<pre><code class="lisp">Initargs: :CAUSE
</code></pre>

<h3 id="database-error-cause">database-error-cause</h3>
<pre><code class="lisp">Generic Function: (database-error-cause condition)
</code></pre>

<h3 id="database-error-code">database-error-code</h3>
<pre><code class="lisp">Generic Function: (database-error-code condition)
</code></pre>

<h3 id="database-error-constraint-name">database-error-constraint-name</h3>
<pre><code class="lisp">Function: (database-error-constraint-name err)
</code></pre>

<p>Given a database-error for an integrity violation, will attempt to
extract the constraint name.</p>
<h3 id="database-error-detail">database-error-detail</h3>
<pre><code class="lisp">Generic Function: (database-error-detail condition)
</code></pre>

<h3 id="database-error-extract-name">database-error-extract-name</h3>
<pre><code class="lisp">Function: (database-error-extract-name err)
</code></pre>

<p>Given a database-error, will extract the critical name from the error message.</p>
<h3 id="database-error-message">database-error-message</h3>
<pre><code class="lisp">Generic Function: (database-error-message condition)
</code></pre>

<h3 id="database-error-query">database-error-query</h3>
<pre><code class="lisp">Generic Function: (database-error-query condition)
</code></pre>

<h3 id="database-exists-p">database-exists-p</h3>
<pre><code class="lisp">Function: (database-exists-p database-name)
</code></pre>

<p>→ boolean</p>
<p>Checks to see if a particular database exists.</p>
<h3 id="database-size">database-size</h3>
<pre><code class="lisp">Function: (database-size &amp;optional (name nil))
</code></pre>

<p>→ list</p>
<p>Given the name of a database, will return the name, a pretty-print
string of the size of the database and the size in bytes. If a database
name is not provided, it will return the result for the currently
connected database.</p>
<h3 id="database-version">database-version</h3>
<pre><code class="lisp">Function: (database-version)
</code></pre>

<p>→ string</p>
<p>Returns the version of the current postgresql database.</p>
<h3 id="define-dao-finalization">define-dao-finalization</h3>
<pre><code class="lisp">Macro: (define-dao-finalization ((dao-name class) &amp;rest keyword-args) &amp;body body)
</code></pre>

<p>Create an :around-method for make-dao. The body is executed in a lexical
environment where dao-name is bound to a freshly created and inserted
DAO. The representation of the DAO in the database is then updated to
reflect changes that body might have introduced. Useful for processing
values of slots with the type serial, which are unknown before
insert-dao.</p>
<h3 id="defprepared">defprepared</h3>
<pre><code class="lisp">Macro: (defprepared name query &amp;optional (format rows))
</code></pre>

<p>→ function</p>
<p>This is the macro-style variant of prepare. It is like prepare, but
gives the function a name which now becomes a top-level function for the
prepared statement. The name should not be quoted or a string.</p>
<h3 id="defprepared-with-names">defprepared-with-names</h3>
<pre><code class="lisp">Macro: (defprepared-with-names name (&amp;rest args) (query &amp;rest query-args) &amp;optional
 (format rows))
</code></pre>

<p>Like defprepared, but allows to specify names of the function arguments
as well as arguments supplied to the query.</p>
<pre><code class="commonlisp">(defprepared-with-names user-messages (user &amp;key (limit 10))
  (&quot;select * from messages
    where user_id = $1
    order by date desc
    limit $2&quot; (user-id user) limit)
  :plists)
</code></pre>

<h3 id="deftable">deftable</h3>
<pre><code class="lisp">Macro: (deftable name &amp;body definitions)
</code></pre>

<p>Define a table. name can be either a symbol or a (symbol string) list.
In the first case, the table name is derived from the symbol's name by
S-SQL's rules. In the second case, the name is given explicitly. The
body of definitions can contain anything that evaluates to a string, as
well as S-SQL expressions. The variables *table-name* and
*table-symbol* are bound to the relevant values in the body. Note that
the evaluation of the definition is ordered, so you'll generally want to
create your table first and then define indices on it.</p>
<h3 id="delete-dao">delete-dao</h3>
<pre><code class="lisp">Generic Function: (delete-dao dao)
</code></pre>

<p>Delete the given dao from the database.</p>
<h3 id="describe-constraint">describe-constraint</h3>
<pre><code class="lisp">Function: (describe-constraint table-name constraint-name)
</code></pre>

<p>→ list</p>
<p>Return a list of alists of the descriptions a particular constraint
given the table-name and the constraint name using the
information_schema table.</p>
<h3 id="describe-foreign-key-constraints">describe-foreign-key-constraints</h3>
<pre><code class="lisp">Function: (describe-foreign-key-constraints)
</code></pre>

<p>→ list</p>
<p>Generates a list of lists of information on the foreign key constraints</p>
<h3 id="describe-views">describe-views</h3>
<pre><code class="lisp">Function: (describe-views &amp;optional (schema public))
</code></pre>

<p>→ list</p>
<p>Describe the current views in the specified schema. Defaults to public
schema.</p>
<h3 id="disconnect">disconnect</h3>
<pre><code class="lisp">Generic Function: (disconnect database)
</code></pre>

<p>Disconnects a normal database connection, or moves a pooled connection
into the pool.</p>
<h3 id="disconnect-toplevel">disconnect-toplevel</h3>
<pre><code class="lisp">Function: (disconnect-toplevel)
</code></pre>

<p>Disconnect the *database*.</p>
<h3 id="do-query-dao">do-query-dao</h3>
<pre><code class="lisp">Macro: (do-query-dao ((type type-var) query) &amp;body body)
</code></pre>

<p>→ list</p>
<p>Like query-dao, but iterates over the results rather than returning
them. For each matching DAO, body is evaluated with type-var bound to
the instance.</p>
<pre><code class="commonlisp">(do-query-dao (('user user) (:order-by (:select '* :from 'user :where (:&gt; 'score 10000)) 'name))
  (pushnew user high-scorers))
</code></pre>

<h3 id="do-select-dao">do-select-dao</h3>
<pre><code class="lisp">Macro: (do-select-dao ((type type-var) &amp;optional (test) &amp;rest ordering) &amp;body body)
</code></pre>

<p>Like select-dao, but iterates over the results rather than returning
them. For each matching DAO, body is evaluated with type-var bound to
the DAO instance.</p>
<pre><code class="commonlisp">(do-select-dao (('user user) (:&gt; 'score 10000) 'name)
  (pushnew user high-scorers))
</code></pre>

<h3 id="doquery">doquery</h3>
<pre><code class="lisp">Macro: (doquery query (&amp;rest names) &amp;body body)
</code></pre>

<p>Execute the given query (a string or a list starting with a keyword),
iterating over the rows in the result. The body will be executed with
the values in the row bound to the symbols given in names. To iterate
over a parameterised query, one can specify a list whose car is the
query, and whose cdr contains the arguments. For example:</p>
<pre><code class="commonlisp">(doquery (:select 'name 'score :from 'scores) (n s)
  (incf (gethash n *scores*) s))

(doquery ((:select 'name :from 'scores :where (:&gt; 'score '$1)) 100) (name)
  (print name))
</code></pre>

<h3 id="double-precision">double-precision</h3>
<h3 id="drop-index">drop-index</h3>
<pre><code class="lisp">Function: (drop-index name &amp;key concurrently if-exists cascade)
</code></pre>

<p>Drop an index. Available keys are :concurrently, :if-exists, and :cascade.</p>
<h3 id="drop-prepared-statement">drop-prepared-statement</h3>
<pre><code class="lisp">Function: (drop-prepared-statement name &amp;key (location both) (database *database*)
 (remove-function t))
</code></pre>

<p>Prepared statements are stored both in the meta slot in the postmodern
connection and in postgresql session information. If you know the
prepared statement name, you can delete the prepared statement from both
locations (the default behavior), just from postmodern (passing
:postmodern to the location key parameter) or just from postgresql
(passing :postgresql to the location key parameter). If you pass the
name 'All' as the statement name, it will delete all prepared
statements. The statement name can be a string or quoted symbol.</p>
<h3 id="drop-schema">drop-schema</h3>
<pre><code class="lisp">Function: (drop-schema schema &amp;key (if-exists nil) (cascade nil))
</code></pre>

<p>Removes a schema. Accepts :if-exists and/or :cascade arguments like
:drop-table.</p>
<h3 id="drop-sequence">drop-sequence</h3>
<pre><code class="lisp">Function: (drop-sequence name &amp;key if-exists cascade)
</code></pre>

<p>Drop a sequence. Name should be quoted. Available key parameters are :if-exists and :cascade</p>
<h3 id="drop-table">drop-table</h3>
<pre><code class="lisp">Function: (drop-table name &amp;key if-exists cascade)
</code></pre>

<p>Drop a table. Available additional key parameters are :if-exists and :cascade.</p>
<h3 id="ensure-transaction">ensure-transaction</h3>
<pre><code class="lisp">Macro: (ensure-transaction &amp;body body)
</code></pre>

<p>Ensures that body is executed within a transaction, but does not begin a
new transaction if one is already in progress.</p>
<h3 id="ensure-transaction-with-isolation-level">ensure-transaction-with-isolation-level</h3>
<pre><code class="lisp">Macro: (ensure-transaction-with-isolation-level isolation-level &amp;body body)
</code></pre>

<p>Executes body within a with-transaction form if and only if no
transaction is already in progress. This adds the ability to specify an isolatin
level other than the current default</p>
<h3 id="execute">execute</h3>
<pre><code class="lisp">Macro: (execute query &amp;rest args)
</code></pre>

<p>Like query called with format :none. Returns the amount of affected rows
as its first returned value. (Also returns this amount as the second
returned value, but use of this is deprecated.)</p>
<h3 id="execute-file">execute-file</h3>
<pre><code class="lisp">Function: (execute-file pathname &amp;optional (print nil))
</code></pre>

<p>This function will execute sql queries stored in a file. Each sql
statement in the file will be run independently, but if one statement
fails, subsequent query statements will not be run, but any statement
prior to the failing statement will have been commited.</p>
<p>If you want the standard transction treatment such that all statements
succeed or no statement succeeds, then ensure that the file starts with
a "begin transaction" statement and finishes with an "end transaction"
statement. See the test file test-execute-file-broken-transaction.sql as
an example.</p>
<p>For debugging purposes, if the optional print parameter is set to t,
format will print the count of the query and the query to the REPL.</p>
<p>IMPORTANT NOTE: This utility function assumes that the file containing
the sql queries can be trusted and bypasses the normal postmodern
parameterization of queries.</p>
<h3 id="find-postgresql-prepared-statement">find-postgresql-prepared-statement</h3>
<pre><code class="lisp">Function: (find-postgresql-prepared-statement name)
</code></pre>

<p>→ string</p>
<p>Returns the specified named prepared statement (if any) that postgresql
has for this session.</p>
<h3 id="find-postmodern-prepared-statement">find-postmodern-prepared-statement</h3>
<pre><code class="lisp">Function: (find-postmodern-prepared-statement name)
</code></pre>

<p>→ string</p>
<p>Returns the specified named prepared statement (if any) that postmodern
has put in the meta slot in the connection. Note that this is the
statement itself, not the name.</p>
<h3 id="find-primary-key-info">find-primary-key-info</h3>
<pre><code class="lisp">Function: (find-primary-key-info table &amp;optional (just-key nil))
</code></pre>

<p>→ list</p>
<p>Returns a list of two strings. First the column name of the primary key
of the table and second the string name for the datatype. Optionally,
just-key can be set to t and it will return just the column name of the
primary key as a string.</p>
<h3 id="get-dao">get-dao</h3>
<pre><code class="lisp">Generic Function: (get-dao type &amp;rest args)
</code></pre>

<p>→ dao</p>
<p>Select the DAO object from the row that has the given primary key
values, or NIL if no such row exists. Objects created by this function
will have initialize-instance called on them (after loading in the
values from the database) without any arguments ― even :default-initargs
are skipped. The same goes for select-dao and query-dao.</p>
<h3 id="get-pid">get-pid</h3>
<pre><code class="lisp">Function: (get-pid)
</code></pre>

<p>→ integer</p>
<p>Get the process id used by postgresql for this connection.</p>
<h3 id="get-pid-from-postmodern">get-pid-from-postmodern</h3>
<pre><code class="lisp">Function: (get-pid-from-postmodern)
</code></pre>

<p>→ integer</p>
<p>Get the process id used by postgresql for this connection, but get it
from the postmodern connection parameters.</p>
<h3 id="get-search-path">get-search-path</h3>
<pre><code class="lisp">Function: (get-search-path)
</code></pre>

<p>Retrieve the current search path.</p>
<h3 id="index-exists-p">index-exists-p</h3>
<pre><code class="lisp">Function: (index-exists-p index-name)
</code></pre>

<p>→ boolean</p>
<p>Tests whether an index with the given name exists. The name can be
either a string or a symbol.</p>
<h3 id="insert-dao">insert-dao</h3>
<pre><code class="lisp">Generic Function: (insert-dao dao)
</code></pre>

<p>→ dao</p>
<p>Insert the given dao into the database. Column slots of the object which
are unbound implies the database defaults. Hence, if these columns has
no defaults defined in the database, the the insertion of the dao will
be failed. (This feature only works on PostgreSQL 8.2 and up.)</p>
<h3 id="list-all-constraints">list-all-constraints</h3>
<pre><code class="lisp">Function: (list-all-constraints table-name &amp;optional (strings-p))
</code></pre>

<p>→ list</p>
<p>Users information_schema to list all the constraints in a table.
Table-name can be either a string or quoted.</p>
<h3 id="list-available-extensions">list-available-extensions</h3>
<pre><code class="lisp">Function: (list-available-extensions)
</code></pre>

<p>→ list</p>
<p>List the postgresql extensions which are available in the system to the
currently connected database. The extensions may or may not be
installed.
→ list</p>
<p>Lists extensions that are available to be installed in the database.
Returns a list of lists where each sublist has the name of the
extension, the default version, the installed version (if any) and a
comment string.</p>
<h3 id="list-available-types">list-available-types</h3>
<pre><code class="lisp">Function: (list-available-types)
</code></pre>

<p>→ list</p>
<p>List the available types in this postgresql version.</p>
<h3 id="list-columns">list-columns</h3>
<pre><code class="lisp">Function: (list-columns table-name)
</code></pre>

<p>→ list</p>
<p>Returns a list of strings of just the column names in a table. Pulls
info from the postmodern table-description function rather than
directly.</p>
<h3 id="list-columns-with-types">list-columns-with-types</h3>
<pre><code class="lisp">Function: (list-columns-with-types table-name)
</code></pre>

<p>→ list</p>
<p>Return a list of (name type) lists for the fields of a table. Goes
directly to the pg-catalog tables.</p>
<h3 id="list-connections">list-connections</h3>
<pre><code class="lisp">Function: (list-connections)
</code></pre>

<p>→ list</p>
<p>List the current postgresql connections to the currently connected
database.</p>
<h3 id="list-database-functions">list-database-functions</h3>
<pre><code class="lisp">Function: (list-database-functions)
</code></pre>

<p>→ list</p>
<p>Returns a list of the functions in the database from the
information_schema.</p>
<h3 id="list-database-users">list-database-users</h3>
<pre><code class="lisp">Function: (list-database-users)
</code></pre>

<p>→ list</p>
<p>List database users.</p>
<h3 id="list-databases">list-databases</h3>
<pre><code class="lisp">Function: (list-databases &amp;key (order-by-size nil) (size t))
</code></pre>

<p>→ list</p>
<p>Returns a list of lists where each sub-list contains the name of the
database, a pretty-print string of the size of that database and the
size in bytes. The default order is by database name. Pass t as a
parameter to :order-by-size for order by size. Setting size to nil will
return just the database names in a single list ordered by name. This
function excludes the template databases</p>
<h3 id="list-detailed-triggers">list-detailed-triggers</h3>
<pre><code class="lisp">Function: (list-detailed-triggers)
</code></pre>

<p>→ list</p>
<p>List detailed information on the triggers from the information_schema
table.</p>
<h3 id="list-foreign-keys">list-foreign-keys</h3>
<pre><code class="lisp">Function: (list-foreign-keys table schema)
</code></pre>

<p>→ list</p>
<p>Returns a list of sublists of foreign key info in the form of
'((constraint-name local-table local-table-column foreign-table-name
foreign-column-name))</p>
<h3 id="list-index-definitions">list-index-definitions</h3>
<pre><code class="lisp">Function: (list-index-definitions table-name)
</code></pre>

<p>→ list</p>
<p>Returns a list of the definitions used to create the current indexes for
the table</p>
<h3 id="list-indexed-column-and-attributes">list-indexed-column-and-attributes</h3>
<pre><code class="lisp">Function: (list-indexed-column-and-attributes table-name)
</code></pre>

<p>→ list</p>
<p>List the indexed columns and their attributes in a table. Includes
primary key.</p>
<h3 id="list-indices">list-indices</h3>
<pre><code class="lisp">Function: (list-indices &amp;optional strings-p)
</code></pre>

<p>→ list</p>
<p>Return a list of the indexs in a database. Turn them into keywords if
strings-p is not true.</p>
<h3 id="list-installed-extensions">list-installed-extensions</h3>
<pre><code class="lisp">Function: (list-installed-extensions)
</code></pre>

<p>→ list</p>
<p>List the postgresql extensions which are installed in the currently
connected database.
→ list</p>
<p>Return a list of the installed extension</p>
<h3 id="list-postmodern-prepared-statements">list-postmodern-prepared-statements</h3>
<pre><code class="lisp">Function: (list-postmodern-prepared-statements &amp;optional (names-only nil))
</code></pre>

<p>→ list</p>
<p>List the prepared statements that postmodern has put in the meta slot in
the connection. It will return a list of alists of form: ((:NAME .
SNY24) (:STATEMENT . (SELECT name, salary FROM employee WHERE (city =
\$1))) (:PREPARE-TIME . #&lt;TIMESTAMP 25-11-2018T15:36:43,385&gt;)
(:PARAMETER-TYPES . text) (:FROM-SQL)</p>
<p>If the names-only parameter is set to t, it will only return a list of
the names of the prepared statements.</p>
<h3 id="list-prepared-statements">list-prepared-statements</h3>
<pre><code class="lisp">: (list-prepared-statements (&amp;optional names-only))
</code></pre>

<p>→ list</p>
<p>This is syntactic sugar. It runs a query that lists the prepared
statements in the session in which the function is run. If the
names-only parameter is set to t, it will only return a list of the
names of the prepared statements.</p>
<h3 id="list-roles">list-roles</h3>
<pre><code class="lisp">Function: (list-roles &amp;optional (lt nil))
</code></pre>

<p>→ list</p>
<p>Returns a list of alists of rolenames, role attributes and membership in
roles. See
<a href="https://www.postgresql.org/docs/current/role-membership.html">https://www.postgresql.org/docs/current/role-membership.html</a> for an
explanation. Optionally passing :alists or :plists can be used to set
the return list types to :alists or :plists. This is the same as the
psql function \du.</p>
<h3 id="list-schemas">list-schemas</h3>
<pre><code class="lisp">Function: (list-schemas)
</code></pre>

<p>→ list</p>
<p>List schemas in the current database, excluding the pg_* system
schemas.</p>
<h3 id="list-schemata">list-schemata</h3>
<pre><code class="lisp">Function: (list-schemata)
</code></pre>

<p>→ list</p>
<p>Returns list of the user defined schemata (as strings) and the quantity
of existing schemata.</p>
<h3 id="list-sequences">list-sequences</h3>
<pre><code class="lisp">Function: (list-sequences &amp;optional strings-p)
</code></pre>

<p>→ list</p>
<p>Returns a list of the sequences in the current database. When strings-p
is T, the names will be given as strings, otherwise as keywords.</p>
<h3 id="list-table-indices">list-table-indices</h3>
<pre><code class="lisp">Function: (list-table-indices table-name &amp;optional strings-p)
</code></pre>

<p>→ list</p>
<p>List the index names and the related columns in a table. Returns a list
of alists.</p>
<h3 id="list-table-sizes">list-table-sizes</h3>
<pre><code class="lisp">Function: (list-table-sizes &amp;key (schema public) (order-by-size nil) (size t))
</code></pre>

<p>→ list</p>
<p>Returns a list of lists (table-name, size in 8k pages) of tables in the
current database. Providing a name to the schema parameter will return
just the information for tables in that schema. It defaults to just the
tables in the public schema. Setting schema to nil will return all
tables, indexes etc in the database in descending order of size. This
would include system tables, so there are a lot more than you would
expect. If :size is set to nil, it returns only a flat list of table
names. Setting order-by-size to t will return the result in order of
size instead of by table name.</p>
<h3 id="list-tables">list-tables</h3>
<pre><code class="lisp">Function: (list-tables &amp;optional strings-p)
</code></pre>

<p>→ list</p>
<p>Returns a list of the tables in the current database and schema. When
strings-p is T, the names will be given as strings, otherwise as
keywords.</p>
<h3 id="list-tables-in-schema">list-tables-in-schema</h3>
<pre><code class="lisp">Function: (list-tables-in-schema &amp;optional (schema-name public) lisp-strings-p)
</code></pre>

<p>→ list</p>
<p>Returns a list of the tables in the current database and the specified
schema. When strings-p is T,the names will be given as strings,
otherwise as keywords.</p>
<h3 id="list-tablespaces">list-tablespaces</h3>
<pre><code class="lisp">Function: (list-tablespaces)
</code></pre>

<p>→ list</p>
<p>Lists the tablespaces in the currently connected database.</p>
<h3 id="list-triggers">list-triggers</h3>
<pre><code class="lisp">Function: (list-triggers &amp;optional table-name)
</code></pre>

<p>→ list</p>
<p>List distinct trigger names from the information_schema table.
Table-name can be either quoted or string.</p>
<h3 id="list-unique-or-primary-constraints">list-unique-or-primary-constraints</h3>
<pre><code class="lisp">Function: (list-unique-or-primary-constraints table-name &amp;optional (strings-p))
</code></pre>

<p>→ list</p>
<p>List constraints on a table.</p>
<h3 id="list-views">list-views</h3>
<pre><code class="lisp">Function: (list-views &amp;optional strings-p)
</code></pre>

<p>→ list</p>
<p>Returns list of the user defined views in the current database. When
strings-p is T, the names will be returned as strings, otherwise as
keywords.</p>
<h3 id="make-dao">make-dao</h3>
<pre><code class="lisp">Generic Function: (make-dao type &amp;rest args &amp;key &amp;allow-other-keys)
</code></pre>

<p>→ dao</p>
<p>Combines make-instance with insert-dao. Return the created dao.</p>
<h3 id="more-table-info">more-table-info</h3>
<pre><code class="lisp">Function: (more-table-info table-name)
</code></pre>

<p>→ list</p>
<p>Returns more table info than table-description. Table can be either a
string or quoted.</p>
<h3 id="num-records-in-database">num-records-in-database</h3>
<pre><code class="lisp">Function: (num-records-in-database)
</code></pre>

<p>→ list</p>
<p>Returns a list of lists with schema, table name and approximate number
of records in the currently connected database.</p>
<h3 id="numeric">numeric</h3>
<h3 id="parse-queries">parse-queries</h3>
<pre><code class="lisp">Function: (parse-queries file-content)
</code></pre>

<p>read SQL queries in given string and split them, returns a list</p>
<h3 id="prepare">prepare</h3>
<pre><code class="lisp">Macro: (prepare query &amp;optional (format rows))
</code></pre>

<p>→ function</p>
<p>Wraps a query into a function that can be used as the interface to a
prepared statement. The given query (either a string or an S-SQL form)
may contain placeholders, which look like \$1, \$2, etc. The resulting
function takes one argument for every placeholder in the query, executes
the prepared query, and returns the result in the format specified.
(Allowed formats are the same as for query.)</p>
<p>For queries that have to be run very often, especially when they are
complex, it may help performance since the server only has to plan them
once. See the <a href="http://www.postgresql.org/docs/current/static/sql-prepare.html">PostgreSQL
manual</a>
for details.</p>
<p>In some cases, the server will complain about not being able to deduce
the type of the arguments in a statement. In that case you should add
type declarations (either with the PostgreSQL's CAST SQL-conforming
syntax or historical :: syntax, or with S-SQL's :type construct) to help
it out.</p>
<p>Note that it will attempt to automatically reconnect if
database-connection-error, or admin-shutdown. It will reset prepared
statements triggering an invalid-sql-statement-name error. It will
overwrite old prepared statements triggering a
duplicate-prepared-statement error.</p>
<h3 id="prepared-statement-exists-p">prepared-statement-exists-p</h3>
<pre><code class="lisp">Function: (prepared-statement-exists-p name)
</code></pre>

<p>→ boolean This returns t if the prepared statement exists in the current
postgresql session, otherwise nil.</p>
<h3 id="query">query</h3>
<pre><code class="lisp">Macro: (query query &amp;rest args/format)
</code></pre>

<p>→ result</p>
<p>Execute the given query, which can be either a string or an S-SQL form
(list starting with a keyword). If the query contains placeholders (\$1,
\$2, etc) their values can be given as extra arguments. If one of these
arguments is a keyword occurring in the table below, it will not be used
as a query argument, but will determine the format in which the results
are returned instead. Any of the following formats can be used, with the
default being :rows:</p>
<pre><code>:none               | Ignore the result values.                                                                                                                                |
:lists, :rows       | Return a list of lists, each list containing the values for a row.                                                                                     |
:list, :row         | Return a single row as a list.                                                                                                                         |
:alists             | Return a list of alists which map column names to values, with the names represented as keywords.                                                        |
:alist              | Return a single row as an alist.                                                                                                                         |
:array-hash         | Return an array of hashtables which map column names to hash table keys                                                                                  |
:str-alists         | Like :alists, but use the original column names.                                                                                                       |
:str-alist          | Return a single row as an alist, with strings for names.                                                                                                 |
:plists             | Return a list of plists which map column names to values,with the names represented as keywords.                                                         |
:plist              | Return a single row as a plist.                                                                                                                          |
:column             | Return a single column as a list.                                                                                                                        |
:single             | Return a single value.                                                                                                                                   |
:single!            | Like :single, but raise an error when the number of selected rows is not equal to 1.                                                                     |
(:dao type)         | Return a list of DAOs of the given type. The names of the fields returned by the query must match slots in the DAO class the same way as with query-dao. |
(:dao type :single) | Return a single DAO of the given type.                                                                                                                 |
</code></pre>

<p>If the database returns information about the amount rows that were
affected, such as with updating or deleting queries, this is returned as
a second value.</p>
<h3 id="query-dao">query-dao</h3>
<pre><code class="lisp">Macro: (query-dao type query &amp;rest args)
</code></pre>

<p>→ list</p>
<p>Execute the given query (which can be either a string or an S-SQL
expression) and return the result as DAOs of the given type. If the
query contains placeholders (\$1, \$2, etc) their values can be given as
extra arguments. The names of the fields returned by the query must
either match slots in the DAO class, or be bound through
with-column-writers.</p>
<h3 id="read-queries">read-queries</h3>
<pre><code class="lisp">Function: (read-queries filename)
</code></pre>

<p>read SQL queries in given file and split them, returns a list</p>
<h3 id="real">real</h3>
<pre><code class="lisp">NIL
</code></pre>

<h3 id="reconnect">reconnect</h3>
<pre><code class="lisp">Generic Function: (reconnect database)
</code></pre>

<p>Reconnect a disconnected database connection. This is not allowed for
pooled connections ― after they are disconnected they might be in use by
some other process, and should no longer be used.</p>
<h3 id="register-sql-operators">register-sql-operators</h3>
<pre><code class="lisp">Macro: (register-sql-operators arity &amp;rest names)
</code></pre>

<p>Define simple operators. Arity is one of :unary (like
'not'), :unary-postfix (the operator comes after the operand),
:n-ary (like '+': the operator falls away when there is only one
operand), :2+-ary (like '=', which is meaningless for one operand),
or :n-or-unary (like '-', where the operator is kept in the unary
case). After the arity follow any number of operators, either just a
keyword, in which case the downcased symbol name is used as the
operator, or a two-element list containing a keyword and a name
string.</p>
<h3 id="release-savepoint">release-savepoint</h3>
<pre><code class="lisp">Function: (release-savepoint savepoint)
</code></pre>

<p>Release the given savepoint.</p>
<h3 id="reset-prepared-statement">reset-prepared-statement</h3>
<pre><code class="lisp">Function: (reset-prepared-statement condition)
</code></pre>

<p>→ restart</p>
<p>If you have received an invalid-prepared-statement error but the
prepared statement is still in the meta slot in the postmodern
connection, this will try to regenerate the prepared statement at the
database connection level and restart the connection.</p>
<h3 id="rollback-savepoint">rollback-savepoint</h3>
<pre><code class="lisp">Function: (rollback-savepoint savepoint)
</code></pre>

<p>Roll back the given savepoint.</p>
<h3 id="save-dao">save-dao</h3>
<pre><code class="lisp">Function: (save-dao dao)
</code></pre>

<p>→ boolean</p>
<p>Tries to insert the given dao using insert-dao. If this raises a unique
key violation error, it tries to update it by using update-dao instead.
Be aware that there is a possible race condition here ― if some other
process deletes the row at just the right moment, the update fails as
well. Returns a boolean telling you whether a new row was inserted.</p>
<p>This function is unsafe to use inside of a transaction ― when a row with
the given keys already exists, the transaction will be aborted. Use
save-dao/transaction instead in such a situation.</p>
<p>See also: upsert-dao.</p>
<h3 id="save-daotransaction">save-dao/transaction</h3>
<pre><code class="lisp">Function: (save-dao/transaction dao)
</code></pre>

<p>→ boolean</p>
<p>Acts exactly like save-dao, except that it protects its attempt to
insert the object with a rollback point, so that a failure will not
abort the transaction.</p>
<p>See also: upsert-dao.</p>
<h3 id="schema-exists-p">schema-exists-p</h3>
<pre><code class="lisp">Function: (schema-exists-p name)
</code></pre>

<p>→ boolean</p>
<p>Tests the existence of a given schema. Returns T if the schema exists or
NIL otherwise.</p>
<h3 id="select-dao">select-dao</h3>
<pre><code class="lisp">Macro: (select-dao type &amp;optional (test t) &amp;rest ordering)
</code></pre>

<p>→ list</p>
<p>Select DAO objects for the rows in the associated table for which the
given test (either an S-SQL expression or a string) holds. When sorting
arguments are given, which can also be S-SQL forms or strings, these are
used to sort the result.</p>
<p>(Note that, if you want to sort, you have to pass the test argument.)</p>
<pre><code class="commonlisp">(select-dao 'user (:&gt; 'score 10000) 'name)
</code></pre>

<h3 id="sequence-exists-p">sequence-exists-p</h3>
<pre><code class="lisp">Function: (sequence-exists-p sequence)
</code></pre>

<p>→ boolean</p>
<p>Tests whether a sequence with the given name exists. The name can be
either a string or a symbol.</p>
<h3 id="sequence-next">sequence-next</h3>
<pre><code class="lisp">Function: (sequence-next sequence)
</code></pre>

<p>→ integer</p>
<p>Get the next value from a sequence. The sequence identifier can be
either a string or a symbol, in the latter case it will be converted to
a string according to S-SQL rules.</p>
<h3 id="set-search-path">set-search-path</h3>
<pre><code class="lisp">Function: (set-search-path path)
</code></pre>

<p>Sets the search path to the path. This function is used by with-schema.</p>
<h3 id="split-fully-qualified-table-name">split-fully-qualified-table-name</h3>
<pre><code class="lisp">: (split-fully-qualified-table-name)
</code></pre>

<p>→ list Takes a name of the form database.schema.table or schema.table or
just table and returns a list in the form '(table schema database)</p>
<h3 id="sql">sql</h3>
<pre><code class="lisp">Macro: (sql form)
</code></pre>

<p>Compile form to a sql expression as far as possible.</p>
<h3 id="sql-compile">sql-compile</h3>
<pre><code class="lisp">Function: (sql-compile form)
</code></pre>

<h3 id="sql-error">sql-error</h3>
<pre><code class="lisp">Function: (sql-error control &amp;rest args)
</code></pre>

<pre><code class="lisp">Condition
</code></pre>

<h3 id="sql-escape">sql-escape</h3>
<pre><code class="lisp">Generic Function: (sql-escape arg)
</code></pre>

<p>Get the representation of a Lisp value so that it
can be used in a query.</p>
<h3 id="sql-escape-string">sql-escape-string</h3>
<pre><code class="lisp">Function: (sql-escape-string string &amp;optional prefix)
</code></pre>

<p>Escape string data so it can be used in a query.</p>
<h3 id="table-description">table-description</h3>
<pre><code class="lisp">Function: (table-description table-name &amp;optional schema-name)
</code></pre>

<p>→ list</p>
<p>Returns a list of the fields in the named table. Each field is
represented by a list of three elements: the field name, the type, and a
boolean indicating whether the field may be NULL. Optionally,
schema-name can be specified to restrict the result to fields from the
named schema. Without it, all fields in the table are returned,
regardless of their schema.</p>
<h3 id="table-exists-p">table-exists-p</h3>
<pre><code class="lisp">Function: (table-exists-p table-name &amp;optional (schema-name nil))
</code></pre>

<p>→ boolean</p>
<p>Tests whether a table with the given name exists. The name can be either
a string or a symbol. It can also be qualified in the form of
'schema.table or 'database.schema.table</p>
<h3 id="table-size">table-size</h3>
<pre><code class="lisp">Function: (table-size table-name)
</code></pre>

<p>→ list</p>
<p>Return the size of a postgresql table in k or m. Table-name can be
either a string or quoted.</p>
<h3 id="terminate-backend">terminate-backend</h3>
<pre><code class="lisp">Function: (terminate-backend pid &amp;optional (database *database*))
</code></pre>

<p>Less polite way of terminating at the database (as opposed to calling
close-database). Faster than (cancel-backend pid) and more reliable.</p>
<h3 id="unused-indexes">unused-indexes</h3>
<pre><code class="lisp">Function: (unused-indexes)
</code></pre>

<p>→ list</p>
<p>Returns a list of lists showing schema.table, indexname, index_size and
number of scans. The code was borrowed from:
<a href="https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/">https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/</a></p>
<h3 id="update-dao">update-dao</h3>
<pre><code class="lisp">Generic Function: (update-dao dao)
</code></pre>

<p>→ dao</p>
<p>Update the representation of the given dao in the database to the values
in the object. This is not defined for tables that do not have any
non-primary-key columns. Raises an error when no row matching the dao
exists.</p>
<h3 id="upsert-dao">upsert-dao</h3>
<pre><code class="lisp">Generic Function: (upsert-dao dao)
</code></pre>

<p>→ dao</p>
<p>Like save-dao or save-dao/transaction but using a different method that
doesn't involve a database exception. This is safe to use both in and
outside a transaction, though it's advisable to always do it in a
transaction to prevent a race condition. The way it works is:</p>
<p>If the object contains unbound slots, we call insert-dao directly, thus
the behavior is like save-dao.</p>
<p>Otherwise we try to update a record with the same primary key. If the
PostgreSQL returns a non-zero number of rows updated it treated as the
record is already exists in the database, and we stop here.</p>
<p>If the PostgreSQL returns a zero number of rows updated, it treated as
the record does not exist and we call insert-dao.</p>
<p>The race condition might occur at step 3 if there's no transaction: if
UPDATE returns zero number of rows updated and another thread inserts
the record at that moment, the insertion implied by step 3 will fail.</p>
<p>Note, that triggers and rules may affect the number of inserted or
updated rows returned by PostgreSQL, so zero or non-zero number of
affected rows may not actually indicate the existence of record in the
database.</p>
<p>This method returns two values: the DAO object and a boolean (T if the
object was inserted, NIL if it was updated).</p>
<h3 id="varchar">varchar</h3>
<h3 id="view-exists-p">view-exists-p</h3>
<pre><code class="lisp">Function: (view-exists-p view)
</code></pre>

<p>→ boolean</p>
<p>Tests whether a view with the given name exists. The name can be either
a string or a symbol.</p>
<h3 id="with-column-writers">with-column-writers</h3>
<pre><code class="lisp">Macro: (with-column-writers (&amp;rest defs) &amp;body body)
</code></pre>

<p>Provides control over the way get-dao, select-dao, and query-dao read
values from the database. This is not commonly needed, but can be used
to reduce the amount of queries a system makes. writers should be a list
of alternating column names (strings or symbols) and writers, where
writers are either symbols referring to a slot in the objects, or
functions taking two arguments ― an instance and a value ― which can be
used to somehow store the value in the new instance. When any
DAO-fetching function is called in the body, and columns matching the
given names are encountered in the result, the writers are used instead
of the default behaviour (try and store the value in the slot that
matches the column name).</p>
<p>An example of using this is to add some non-column slots to a DAO class,
and use query-dao within a with-column-writers form to pull in extra
information about the objects, and immediately store it in the new
instances.</p>
<h3 id="with-connection">with-connection</h3>
<pre><code class="lisp">Macro: (with-connection spec &amp;body body)
</code></pre>

<p>Evaluates the body with *database* bound to a connection as specified
by spec, which should be list that connect can be applied to.</p>
<h3 id="with-logical-transaction">with-logical-transaction</h3>
<pre><code class="lisp">Macro: (with-logical-transaction (&amp;optional (name) (isolation-level)) &amp;body body)
</code></pre>

<p>Executes body within a with-transaction form if no transaction is
currently in progress, otherwise simulates a nested transaction by
executing it within a with-savepoint form. The transaction or savepoint
is bound to name if one is supplied. The isolation-level will set the
isolation-level used by the transaction.</p>
<p>You can specify the following isolation levels in postmodern
transactions:</p>
<ul>
<li>:read-committed-rw (read committed with read and write)</li>
<li>:read-committed-ro (read committed with read only)</li>
<li>:repeatable-read-rw (repeatable read with read and write)</li>
<li>:repeatable-read-ro (repeatable read with read only)</li>
<li>:serializable (serializable with reand and write)</li>
</ul>
<p>Sample usage where "george" is just the name given to the transaction
(not quoted or a string) and ... simply indicates other statements would
be expected here:</p>
<pre><code class="commonlisp">(with-logical-transaction ()
  (execute (:insert-into 'test-data :set 'value 77))
  ...)

(with-logical-transaction (george)
  (execute (:insert-into 'test-data :set 'value 22))
  ...)

(with-logical-transaction (george :read-committed-rw)
  (execute (:insert-into 'test-data :set 'value 33))
  ...)

(with-logical-transaction (:serializable)
  (execute (:insert-into 'test-data :set 'value 44))
  ...)
</code></pre>

<h3 id="with-savepoint">with-savepoint</h3>
<pre><code class="lisp">Macro: (with-savepoint name &amp;body body)
</code></pre>

<p>Can only be used within a transaction. Establishes a savepoint with the
given name at the start of body, and binds the same name to a handle for
that savepoint. At the end of body, the savepoint is released, unless a
condition is thrown, in which case it is rolled back.</p>
<h3 id="with-schema">with-schema</h3>
<pre><code class="lisp">Macro: (with-schema (schema &amp;key (strict) (if-not-exist) (drop-after)) &amp;body form)
</code></pre>

<p>Sets the current schema to namespace and executes the body. Before
executing body the PostgreSQL's session variable search_path is set to
the given namespace. After executing body the search_path variable is
restored to the original value. If the keyword :strict is set to T then
the namespace is only the scheme on the search path upon the body
execution. Otherwise the namespace is just first schema on the search
path upon the the body execution. If :if-not-exist is NIL, an error is
signaled. If :drop-after is T the namespace is dropped from the database
after the body execution.</p>
<h3 id="with-transaction">with-transaction</h3>
<pre><code class="lisp">Macro: (with-transaction (&amp;optional name isolation-level) &amp;body body)
</code></pre>

<p>Execute the given body within a database transaction, committing it when
the body exits normally, and aborting otherwise. An optional name and/or
isolation-level can be given to the transaction. The name can be used to
force a commit or abort before the body unwinds. The isolation-level
will set the isolation-level used by the transaction.</p>
<p>You can specify the following isolation levels in postmodern
transactions:</p>
<ul>
<li>:read-committed-rw (read committed with read and write)</li>
<li>:read-committed-ro (read committed with read only)</li>
<li>:repeatable-read-rw (repeatable read with read and write)</li>
<li>:repeatable-read-ro (repeatable read with read only)</li>
<li>:serializable (serializable with reand and write)</li>
</ul>
<p>Sample usage where "george" is just the name given to the transaction
(not quoted or a string) and ... simply indicates other statements would
be expected here:</p>
<pre><code class="commonlisp">(with-transaction ()
  (execute (:insert-into 'test-data :set 'value 77))
  ...)

(with-transaction (george)
  (execute (:insert-into 'test-data :set 'value 22))
  ...)

(with-transaction (george :read-committed-rw)
  (execute (:insert-into 'test-data :set 'value 33))
  (query (:select '* :from 'test-data))
  ...)

(with-transaction (:serializable)
  (execute (:insert-into 'test-data :set 'value 44))
  ...)
</code></pre>

<p>Further discussion of transactions and isolation levels can found
<a href="isolation-notes.html">here</a>.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../numcl/" class="btn btn-neutral float-right" title="numcl - Lispy clone of numpy">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../iterate/" class="btn btn-neutral" title="iterate - Psuedocodic Iteration"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../iterate/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../numcl/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
