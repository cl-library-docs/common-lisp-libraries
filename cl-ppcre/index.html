<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>cl-ppcre - Regular Expressions - common-lisp-libraries</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../extra.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "cl-ppcre - Regular Expressions";
    var mkdocs_page_input_path = "cl-ppcre.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/lisp.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> common-lisp-libraries</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">index</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Defacto libraries</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../alexandria/">alexandria - Commonly Used Utilities</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../bordeaux-threads/">bordeaux-threads - Threading</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">cl-ppcre - Regular Expressions</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#getting-started">GETTING STARTED</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#using-perl-regex">Using perl regex</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#using-s-expressions">Using s-expressions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#performance-aspects">Performance Aspects</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#functions-and-macros">FUNCTIONS AND MACROS</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#all-matches">all-matches</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#all-matches-as-strings">all-matches-as-strings</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#create-optimized-test-function">create-optimized-test-function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#create-scanner">create-scanner</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#define-parse-tree-synonym">define-parse-tree-synonym</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#do-matches">do-matches</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#do-matches-as-strings">do-matches-as-strings</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#do-register-groups">do-register-groups</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#do-scans">do-scans</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#parse-string">parse-string</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#parse-tree-synonym">parse-tree-synonym</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ppcre-error">ppcre-error</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ppcre-invocation-error">ppcre-invocation-error</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ppcre-syntax-error">ppcre-syntax-error</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ppcre-syntax-error-pos">ppcre-syntax-error-pos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ppcre-syntax-error-string">ppcre-syntax-error-string</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#quote-meta-chars">quote-meta-chars</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#regex-apropos">regex-apropos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#regex-apropos-list">regex-apropos-list</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#regex-replace">regex-replace</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#regex-replace-all">regex-replace-all</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#register-groups-bind">register-groups-bind</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#scan">scan</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#scan-to-strings">scan-to-strings</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#split">split</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#configuration-variables">CONFIGURATION VARIABLES</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#allow-named-registers">*allow-named-registers*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#allow-quoting">*allow-quoting*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#look-ahead-for-suffix">*look-ahead-for-suffix*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#optimize-char-classes">*optimize-char-classes*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#property-resolver">*property-resolver*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#regex-char-code-limit">*regex-char-code-limit*</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#use-bmh-matchers">*use-bmh-matchers*</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#support">SUPPORT</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cl-who/">cl-who - DSL for Markup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../fiveam/">fiveam - Regression Testing Framework</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../hunchentoot/">hunchentoot - Web Server</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../iterate/">iterate - Psuedocodic Iteration</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../postmodern/">postmodern - PostgreSQL programming interace</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../quicklisp/">quicklisp - Library Manager</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Not yet defacto</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../numcl/">numcl - Lispy clone of numpy</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../unix-opts/">unix-opts - cmd line argument parser</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../utilities/">utilities - A collection of some more utility libraries</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">common-lisp-libraries</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Defacto libraries &raquo;</li>
        
      
    
    <li>cl-ppcre - Regular Expressions</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="cl-ppcre-regular-expressions">cl-ppcre - Regular Expressions</h1>
<p>Version: 2.1.1
<br/>
Nickname: ppcre
<br/>
Repository: <a href="https://github.com/edicl/cl-ppcre">edicl/cl-ppcre - Github</a></p>
<p><em>This documentation is possible the <a href="https://edicl.github.io/cl-ppcre">excellent official documentation</a> as of 4th May 2020.</em></p>
<p><em>In case of any inaccuracies, ambiguities or suggestions, please <a href="https://github.com/cl-library-docs/common-lisp-libraries/issues">create an issue here</a>.</em></p>
<hr />
<p>CL-PPCRE is a Portable Perl-Compatible Regular Expressions library for Common Lisp.
This is also thread-safe, and allows specifying <a href="#using-s-expressions">regular expressions using
S-expressions</a>.</p>
<h2 id="getting-started">GETTING STARTED</h2>
<h3 id="using-perl-regex">Using perl regex</h3>
<p>Per the name, <code>cl-ppcre</code> is more or less compatible with perl 5.8 including
extended features like non-greedy repetitions, positive and negative
look-ahead and look-behind assertions, "standalone" subexpressions,
and conditional subpatterns. The following Perl features are
(currently) <strong>not</strong> supported:</p>
<ul>
<li><code>(?{ code })</code> and <code>(??{ code })</code> because they obviously don't make
    sense in Lisp.</li>
<li><code>\N{name}</code> (named characters), <code>\x{263a}</code> (wide hex characters),
    <code>\l</code>, <code>\u</code>, <code>\L</code>, and <code>\U</code> because they're actually not part of
    Perl's <em>regex</em> syntax - but see
    <a href="https://github.com/edicl/cl-interpol/">CL-INTERPOL</a>.</li>
<li><code>\X</code> (extended Unicode), and <code>\C</code> (single character). But you can
    of course use all characters supported by your CL implementation.</li>
<li>Posix character classes like <code>[[:alpha]]</code>. Load <code>(asdf:load-system :cl-ppcre-unicode)</code>
    to install <a href="#unicode-property-resolver">unicode-preperty-resolver</a> as your
    <a href="#property-resolver">property-resolver</a>. See <a href="https://edicl.github.io/cl-unicode/">cl-unicode</a>
    for the supported unicode properties and their naming conventions.</li>
<li><code>\G</code> for Perl's <code>pos()</code> because we don't have it.</li>
</ul>
<p>Note, however, that <code>\t</code>, <code>\n</code>, <code>\r</code>, <code>\f</code>, <code>\a</code>, <code>\e</code>, <code>\033</code> (octal
character codes), <code>\x1B</code> (hexadecimal character codes), <code>\c[</code> (control
characters), <code>\w</code>, <code>\W</code>, <code>\s</code>, <code>\S</code>, <code>\d</code>, <code>\D</code>, <code>\b</code>, <code>\B</code>, <code>\A</code>,
<code>\Z</code>, and <code>\z</code> <strong>are</strong> supported.</p>
<p>Users can straightaway start with:</p>
<ul>
<li><a href="#scan">scan</a></li>
<li><a href="#scan-to-strings">scan-to-strings</a></li>
<li><a href="#split">split</a></li>
<li><a href="#quote-meta-chars">quote-meta-chars</a></li>
<li><a href="#register-groups-bind">register-groups-bind</a></li>
<li><a href="#regex-replace">regex-replace</a></li>
</ul>
<p>Register groups simply refer to the captured groups. For instance:</p>
<pre><code class="lisp">CL-USER&gt; (register-groups-bind (a b) (&quot;([^ ]+) ([^ ]+)&quot; &quot;hello world&quot;)
           (list a b))
(&quot;hello&quot; &quot;world&quot;)
</code></pre>

<p>See the <a href="#do-matches">other macros</a> for iterative versions of these.</p>
<p>Those wanting to get into perl regular expressions, might find <a href="https://perldoc.perl.org/perlre.html">their official
documentation</a> useful.</p>
<p>Users comfortable with regular expressions might also want to try
<a href="https://github.com/edicl/cl-interpol/">cl-interpol</a> - which provides string
interpolation facilities to the lisp reader. (Yes, it's defacto!)</p>
<h3 id="using-s-expressions">Using s-expressions</h3>
<p>The basics:</p>
<pre><code>+------- Common Lisp Equivalent -------+----------- Perl Equivalent -----------+
| String / Character                   | Literal treatment                     |
| :void                                | Empty string                          |
| :everything                          | Dot                                   |
| :(non-)word-boundary                 | \b, \B (non)                          |
| :(non-)digit-class                   | \d, \D (non)                          |
| :(non-)word-char-class               | \w, \W (non)                          |
| :(non-)whitespace-char-class         | \s, \S (non)                          |
| :start/end-anchor                    | ^ [start], $ [end                     |
| :modeless-start/end-anchor           | \A [start], \Z [end]                  |
| :modeless-end-anchor-no-newline      | \z                                    |
| :case-(in)sensitive-p                | (?i), (?-i) [insensitive]             |
| :(not)-multi-line-mode-p             | (?m), (?-m) [not]                     |
| :(not)-single-line-mode-p            | (?s), (?-s) [not]                     |
| (anything else)                      | Syntax Error                          |
+--------------------------------------+---------------------------------------+
</code></pre>

<p>Simple combinations include <code>:sequence</code>, <code>:group</code>, <code>:flags</code>, <code>:register</code>,
<code>:greedy-repetition</code>, <code>:non-greedy-repetition</code>. You could play around with
<a href="#parse-string">parse-string</a> to learn more about the equivalence.</p>
<p>For instance:</p>
<pre><code class="lisp">* (parse-string &quot;(ab)*&quot;)
(:GREEDY-REPETITION 0 `NIL` (:REGISTER &quot;ab&quot;))

* (parse-string &quot;(a(b))&quot;)
(:REGISTER (:SEQUENCE #\a (:REGISTER #\b)))

* (parse-string &quot;(?:abc){3,5}&quot;)
(:GREEDY-REPETITION 3 5 (:GROUP &quot;abc&quot;))
;; (:GREEDY-REPETITION 3 5 &quot;abc&quot;) would also be OK

* (parse-string &quot;a(?i)b(?-i)c&quot;)
(:SEQUENCE #\a
 (:SEQUENCE (:FLAGS :CASE-INSENSITIVE-P)
  (:SEQUENCE #\b (:SEQUENCE (:FLAGS :CASE-SENSITIVE-P) #\c))))
;; same as (:SEQUENCE #\a :CASE-INSENSITIVE-P #\b :CASE-SENSITIVE-P #\c)

* (parse-string &quot;(?=a)b&quot;)
(:SEQUENCE (:POSITIVE-LOOKAHEAD #\a) #\b)

* (parse-string &quot;aa|aaa&quot;)
(:ALTERNATION &quot;aa&quot; &quot;aaa&quot;)
</code></pre>

<p>See the <a href="https://edicl.github.io/cl-ppcre/#create-scanner2">manual</a> for the
more detailed equivalence.</p>
<p>Thus, you could equivalently use parse-trees for the functions and macros that
expect regex.</p>
<pre><code class="lisp">* (all-matches-as-strings '(:greedy-repetition 1 nil #\a) &quot;aaaa&quot;)
(&quot;aaaa&quot;)
</code></pre>

<h3 id="performance-aspects">Performance Aspects</h3>
<p><code>cl-ppcre</code> was intended to be fast. Indeed, <a href="http://web.archive.org/web/20080624164217/http://weitz.de/cl-ppcre/#bench">when it first appeared,
it was perhaps the fastest</a>.</p>
<p>However, in 2020, it can be five times as slow as Perl:</p>
<pre><code class="sh">time perl -e '&quot;@{['x' x 50000000]}&quot; =~ /([xy])*/'

real    0m0.245s
user    0m0.161s
sys     0m0.084s
</code></pre>

<pre><code class="lisp">CL-USER&gt; (time (progn
                 (scan &quot;([xy])*&quot;
                       (make-string 50000000 :element-type 'base-char
                                    :initial-element #\x))
                 nil))
Evaluation took:
  1.116 seconds of real time
  1.115901 seconds of total run time (1.111972 user, 0.003929 system)
  100.00% CPU
  2,463,959,814 processor cycles
  50,000,032 bytes consed
</code></pre>

<p>But still (more than) 5 times faster than python:</p>
<pre><code class="sh">time python3 -c 'import re; x = re.search(&quot;([xy])*&quot;, &quot;x&quot;*50000000)'

real    0m7.458s
user    0m4.563s
sys     0m2.892s
</code></pre>

<p>Or slower as well:</p>
<pre><code class="sh">$ ~ time python3 -c 'import re; x = re.search(&quot;x*&quot;, &quot;x&quot;*50000000)'

real    0m0.146s
user    0m0.109s
sys     0m0.036s
</code></pre>

<p>Honestly, though, it should be possible to use implementation specific means to speed things up
- or copying the developments in the perl and/or python world.</p>
<p>Perhaps, see the <a href="https://edicl.github.io/cl-ppcre/#blabla">manual</a> for hints on speeding things
up.</p>
<h2 id="functions-and-macros">FUNCTIONS AND MACROS</h2>
<h3 id="all-matches">all-matches</h3>
<pre><code class="lisp">Function: (all-matches regex target-string
            &amp;key (start 0) (end (length target-string)))
</code></pre>

<p>Returns a list containing the start and end positions of all
matches of <code>regex</code> against <code>target-string</code>, i.e. if there are N matches
the list contains (* 2 N) elements.  If <code>regex</code> matches an empty string
the scan is continued one position behind this match.</p>
<h3 id="all-matches-as-strings">all-matches-as-strings</h3>
<pre><code class="lisp">Function: (all-matches-as-strings regex target-string
            &amp;key (start 0) (end (length target-string)) sharedp)
</code></pre>

<p>Returns a list containing all substrings of <code>target-string</code> which
match <code>regex</code>. If <code>regex</code> matches an empty string the scan is continued
one position behind this match. If <code>sharedp</code> is true, the substrings may
share structure with <code>target-string</code>.</p>
<h3 id="create-optimized-test-function">create-optimized-test-function</h3>
<pre><code class="lisp">Function: (create-optimized-test-function test-function
            &amp;key (start 0) (end *regex-char-code-limit*)
              (kind *optimize-char-classes*))
</code></pre>

<p>Given a unary test function which is applicable to characters
returns a function which yields the same boolean results for all
characters with character codes from <code>start</code> to (excluding) <code>end</code>.  If
<code>kind</code> is <code>nil</code>, <code>test-function</code> will simply be returned.  Otherwise, <code>kind</code>
should be one of:</p>
<ul>
<li>
<p><code>:hash-table</code> - builds a hash table representing all characters which
                satisfy the test and returns a closure which checks if
                a character is in that hash table</p>
</li>
<li>
<p><code>:charset</code> - instead of a hash table uses a "charset" which is a
             data structure using non-linear hashing and optimized to
             represent (sparse) sets of characters in a fast and
             space-efficient way (contributed by Nikodemus Siivola)</p>
</li>
<li>
<p><code>:charmap</code> - instead of a hash table uses a bit vector to represent
             the set of characters</p>
</li>
</ul>
<p>You can also use <code>:hash-table*</code> or <code>:charset*</code> which are like <code>:hash-table</code>
and <code>:charset</code> but use the complement of the set if the set contains
more than half of all characters between <code>start</code> and <code>end</code>.  This saves
space but needs an additional pass across all characters to create the
data structure.  There is no corresponding <code>:charmap*</code> kind as the bit
vectors are already created to cover the smallest possible interval
which contains either the set or its complement.</p>
<h3 id="create-scanner">create-scanner</h3>
<pre><code class="lisp">Function: (create-scanner regex
            &amp;key case-insensitive-mode multi-line-mode 
              single-line-mode extended-mode destructive)
</code></pre>

<p>Accepts a regular expression - either as a
parse-tree or as a string - and returns a scan closure which will scan
strings for this regular expression and a list mapping registers to
their names (<code>nil</code> stands for unnamed ones).  The "mode" keyword
arguments are equivalent to the imsx modifiers in Perl.  If
<code>destructive</code> is not <code>nil</code>, the function is allowed to destructively
modify its first argument (but only if it's a parse tree).</p>
<p>(More in the manual!)</p>
<h3 id="define-parse-tree-synonym">define-parse-tree-synonym</h3>
<pre><code class="lisp">Macro: (define-parse-tree-synonym name parse-tree)
</code></pre>

<p>Defines the symbol <code>name</code> to be a synonym for the parse tree
<code>parse-tree</code>.  Both arguments are quoted.</p>
<h3 id="do-matches">do-matches</h3>
<pre><code class="lisp">Macro: (do-matches (match-start match-end regex target-string
                     &amp;optional result-form &amp;key start end)
         &amp;body body)
</code></pre>

<p>Iterates over <code>target-string</code> and tries to match <code>regex</code> as often as
possible evaluating <code>body</code> with <code>match-start</code> and <code>match-end</code> bound to the
start/end positions of each match in turn.  After the last match,
returns <code>result-form</code> if provided or <code>nil</code> otherwise.  An implicit block
named <code>nil</code> surrounds <code>do-matches</code>; <code>return</code> may be used to terminate the
loop immediately.  If <code>regex</code> matches an empty string the scan is
continued one position behind this match. <code>body</code> may start with
declarations.</p>
<h3 id="do-matches-as-strings">do-matches-as-strings</h3>
<pre><code class="lisp">Macro: (do-matches-as-strings
           (match-var regex target-string 
             &amp;optional result-form &amp;key start end sharedp)
         &amp;body body)
</code></pre>

<p>Iterates over <code>target-string</code> and tries to match <code>regex</code> as often as
possible evaluating <code>body</code> with <code>match-var</code> bound to the substring of
<code>target-string</code> corresponding to each match in turn.  After the last
match, returns <code>result-form</code> if provided or <code>nil</code> otherwise.  An implicit
block named <code>nil</code> surrounds <code>do-matches-as-strings</code>; <code>return</code> may be used to
terminate the loop immediately.  If <code>regex</code> matches an empty string the
scan is continued one position behind this match.  If <code>sharedp</code> is true,
the substrings may share structure with <code>target-string</code>.  <code>body</code> may start
with declarations.</p>
<h3 id="do-register-groups">do-register-groups</h3>
<pre><code class="lisp">Macro: (do-register-groups
            var-list
            (regex target-string 
               &amp;optional result-form &amp;key start end sharedp)
          &amp;body body)
</code></pre>

<p>Iterates over <code>target-string</code> and tries to match <code>regex</code> as often as
possible evaluating <code>body</code> with the variables in <code>var-list</code> bound to the
corresponding register groups for each match in turn, i.e. each
variable is either bound to a string or to <code>nil</code>.  For each element of
<code>var-list</code> which is <code>nil</code> there's no binding to the corresponding register
group. The number of variables in <code>var-list</code> must not be greater than
the number of register groups.  After the last match, returns
<code>result-form</code> if provided or <code>nil</code> otherwise.  An implicit block named <code>nil</code>
surrounds <code>do-register-groups</code>; <code>return</code> may be used to terminate the loop
immediately. If <code>regex</code> matches an empty string the scan is continued
one position behind this match.  If <code>sharedp</code> is true, the substrings
may share structure with <code>target-string</code>.  <code>body</code> may start with
declarations.</p>
<h3 id="do-scans">do-scans</h3>
<pre><code class="lisp">Macro: (do-scans (match-start match-end reg-starts reg-ends regex target-string
                    &amp;optional result-form &amp;key start end) 
          &amp;body body)
</code></pre>

<p>Iterates over <code>target-string</code> and tries to match <code>regex</code> as often as
possible evaluating BODY with <code>match-start</code>, <code>match-end</code>, <code>reg-starts</code>, and
<code>reg-ends</code> bound to the four return values of each match in turn.  After
the last match, returns <code>result-form</code> if provided or <code>nil</code> otherwise. An
implicit block named <code>nil</code> surrounds <code>do-scans</code>; <code>return</code> may be used to
terminate the loop immediately.  If <code>regex</code> matches an empty string the
scan is continued one position behind this match. <code>body</code> may start with
declarations.</p>
<h3 id="parse-string">parse-string</h3>
<pre><code class="lisp">Function: (parse-string string)
</code></pre>

<p>Translate the regex string <code>string</code> into a parse tree.</p>
<h3 id="parse-tree-synonym">parse-tree-synonym</h3>
<pre><code class="lisp">Function: (parse-tree-synonym symbol)
</code></pre>

<p>Returns the parse tree the <code>symbol</code> symbol is a synonym for.  Returns
<code>nil</code> is <code>symbol</code> wasn't yet defined to be a synonym.</p>
<h3 id="ppcre-error">ppcre-error</h3>
<p>Every error signaled by CL-PPCRE is of type <code>ppcre-error</code>. This is a direct subtype of
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/e_smp_er.htm">simple-error</a>
without any additional slots or options.</p>
<h3 id="ppcre-invocation-error">ppcre-invocation-error</h3>
<p>Errors of type <code>ppcre-invocation-error</code> are signaled if one of the exported functions of CL-PPCRE is called with wrong or inconsistent arguments. This is a direct subtype of <code>ppcre-error</code> without any additional slots or options.</p>
<h3 id="ppcre-syntax-error">ppcre-syntax-error</h3>
<p>An error of type <code>ppcre-syntax-error</code> is signaled if CL-PPCRE's parser encounters an error when trying to parse a regex string or to convert a parse tree into its internal representation. This is a direct subtype of <code>ppcre-error</code> with two additional slots. These denote the regex string which HTML-PPCRE was parsing and the position within the string where the error occurred. If the error happens while CL-PPCRE is converting a parse tree, both of these slots contain NIL. (See the next two entries on how to access these slots.)</p>
<h3 id="ppcre-syntax-error-pos">ppcre-syntax-error-pos</h3>
<pre><code class="lisp">Function: (ppcre-syntax-error-pos condition)
</code></pre>

<p>Returns the position within the string where the error occurred
(or <code>nil</code> if the error happened while trying to convert a parse tree</p>
<h3 id="ppcre-syntax-error-string">ppcre-syntax-error-string</h3>
<pre><code class="lisp">Function: (ppcre-syntax-error-string condition)
</code></pre>

<p>Returns the string the parser was parsing when the error was
encountered (or <code>nil</code> if the error happened while trying to convert a
parse tree).</p>
<h3 id="quote-meta-chars">quote-meta-chars</h3>
<pre><code class="lisp">Function: (quote-meta-chars string &amp;key (start 0) (end (length string)))
</code></pre>

<p>Quote, i.e. prefix all non-word characters in <code>string</code> with <code>#\\</code>.</p>
<h3 id="regex-apropos">regex-apropos</h3>
<pre><code class="lisp">Function: (regex-apropos regex &amp;optional packages &amp;key (case-insensitive t))
</code></pre>

<p>Similar to the standard function <code>apropos</code> but returns a list of all
symbols which match the regular expression REGEX.  If <code>case-insensitive</code>
is true and <code>regex</code> isn't already a scanner, a case-insensitive scanner
is used.</p>
<h3 id="regex-apropos-list">regex-apropos-list</h3>
<pre><code class="lisp">Function: (regex-apropos-list regex &amp;optional packages &amp;key (case-insensitive t))
</code></pre>

<p>Similar to the standard function <code>apropos-list</code> but returns a list of
all symbols which match the regular expression <code>regex</code>.  If
<code>case-insensitive</code> is true and <code>regex</code> isn't already a scanner, a
case-insensitive scanner is used.</p>
<h3 id="regex-replace">regex-replace</h3>
<pre><code class="lisp">Function: (regex-replace regex target-string replacement
             &amp;key (start 0) (end (length target-string))
               preserve-case simple-calls
               (element-type 'character))
</code></pre>

<p>Try to match <code>target-string</code> between <code>start</code> and <code>end</code> against <code>regex</code> and
replace the first match with <code>replacement</code>.  Two values are returned;
the modified string, and <code>t</code> if <code>regex</code> matched or <code>nil</code> otherwise.</p>
<p><code>replacement</code> can be a string which may contain the special substrings
"\&amp;" for the whole match, "`" for the part of <code>target-string</code>
before the match, "\'" for the part of <code>target-string</code> after the
match, "\N" or "{N}" for the Nth register where N is a positive
integer.</p>
<p><code>replacement</code> can also be a function designator in which case the
match will be replaced with the result of calling the function
designated by <code>replacement</code> with the arguments <code>target-string</code>, <code>start</code>,
<code>end</code>, <code>match-start</code>, <code>match-end</code>, <code>reg-starts</code>, and <code>reg-ends</code>. (<code>reg-starts</code> and
<code>reg-ends</code> are arrays holding the start and end positions of matched
registers or <code>nil</code> - the meaning of the other arguments should be
obvious.)</p>
<p>Finally, <code>replacement</code> can be a list where each element is a string,
one of the symbols <code>:match</code>, <code>:before-match</code>, or <code>:after-match</code> -
corresponding to "\&amp;", "`", and "\'" above -, an integer N -
representing register (1+ N) -, or a function designator.</p>
<p>If <code>preserve-case</code> is true, the replacement will try to preserve the
case (all upper case, all lower case, or capitalized) of the
match. The result will always be a fresh string, even if <code>regex</code> doesn't
match.</p>
<p><code>element-type</code> is the element type of the resulting string.</p>
<h3 id="regex-replace-all">regex-replace-all</h3>
<pre><code class="lisp">Function: (regex-replace-all regex target-string replacement
             &amp;key (start 0) (end (length target-string))
             preserve-case simple-calls 
             (element-type 'character))
</code></pre>

<p>Try to match <code>target-string</code> between <code>start</code> and <code>end</code> against <code>regex</code> and
replace all matches with <code>replacement</code>.  Two values are returned; the
modified string, and T if <code>regex</code> matched or <code>nil</code> otherwise.</p>
<p><code>replacement</code> can be a string which may contain the special substrings
"\&amp;" for the whole match, "`" for the part of <code>target-string</code>
before the match, "\'" for the part of <code>target-string</code> after the
match, "\N" or "{N}" for the Nth register where N is a positive
integer.</p>
<p><code>replacement</code> can also be a function designator in which case the
match will be replaced with the result of calling the function
designated by <code>replacement</code> with the arguments <code>target-string</code>, <code>start</code>,
<code>end</code>, <code>match-start</code>, <code>match-end</code>, <code>reg-starts</code>, and <code>reg-ends</code>. (<code>reg-starts</code> and
<code>reg-ends</code> are arrays holding the start and end positions of matched
registers or <code>nil</code> - the meaning of the other arguments should be
obvious.)</p>
<p>Finally, <code>replacement</code> can be a list where each element is a string,
one of the symbols <code>:match</code>, <code>:before-match</code>, or <code>:after-match</code> -
corresponding to "\&amp;", "`", and "\'" above -, an integer N -
representing register (1+ N) -, or a function designator.</p>
<p>If <code>preserve-case</code> is true, the replacement will try to preserve the
case (all upper case, all lower case, or capitalized) of the
match. The result will always be a fresh string, even if <code>regex</code> doesn't
match.</p>
<p><code>element-type</code> is the element type of the resulting string.</p>
<h3 id="register-groups-bind">register-groups-bind</h3>
<pre><code class="lisp">Macro: (register-groups-bind var-list
            (regex target-string &amp;key start end sharedp) 
          &amp;body body)
</code></pre>

<p>Executes <code>body</code> with the variables in <code>var-list</code> bound to the
corresponding register groups after <code>target-string</code> has been matched
against <code>regex</code>, i.e. each variable is either bound to a string or to
<code>nil</code>.  If there is no match, <code>body</code> is <em>not</em> executed. For each element
of <code>var-list</code> which is <code>nil</code> there's no binding to the corresponding
register group.  The number of variables in <code>var-list</code> must not be
greater than the number of register groups.  If <code>sharedp</code> is true, the
substrings may share structure with <code>target-string</code>.</p>
<h3 id="scan">scan</h3>
<pre><code class="lisp">Function: (scan regex target-string &amp;key start end real-start-pos)
</code></pre>

<p>Searches <code>target-string</code> from <code>start</code> to <code>end</code> and tries
to match <code>regex</code>.  On success returns four values - the start of the
match, the end of the match, and two arrays denoting the beginnings
and ends of register matches.  On failure returns <code>nil</code>.  <code>regex</code> can be a
string which will be parsed according to Perl syntax, a parse tree, or
a pre-compiled scanner created by <a href="#create-scanner">create-scanner</a>.  <code>target-string</code> will
be coerced to a simple string if it isn't one already.  The
<code>real-start-pos</code> parameter should be ignored - it exists only for
internal purposes.</p>
<h3 id="scan-to-strings">scan-to-strings</h3>
<pre><code class="lisp">Function: (scan-to-strings regex target-string
             &amp;key (start 0) (end (length target-string)) sharedp)
</code></pre>

<p>Like <code>scan</code> but returns substrings of <code>target-string</code> instead of
positions, i.e. this function returns two values on success: the whole
match as a string plus an array of substrings (or <code>nil</code>s) corresponding
to the matched registers.  If <code>sharedp</code> is true, the substrings may
share structure with <code>target-string</code>.</p>
<h3 id="split">split</h3>
<pre><code class="lisp">Function: (split regex target-string
             &amp;key (start 0) (end (length target-string))
               limit with-registers-p omit-unmatched-p sharedp)
</code></pre>

<p>Matches <code>regex</code> against <code>target-string</code> as often as possible and
returns a list of the substrings between the matches.  If
<code>with-registers-p</code> is true, substrings corresponding to matched
registers are inserted into the list as well.  If <code>omit-unmatched-p</code> is
true, unmatched registers will simply be left out, otherwise they will
show up as <code>nil</code>.  <code>limit</code> limits the number of elements returned -
registers aren't counted.  If <code>limit</code> is <code>nil</code> (or 0 which is
equivalent), trailing empty strings are removed from the result list.
If <code>regex</code> matches an empty string the scan is continued one position
behind this match.  If <code>sharedp</code> is true, the substrings may share
structure with <code>target-string</code>.</p>
<h2 id="configuration-variables">CONFIGURATION VARIABLES</h2>
<h3 id="allow-named-registers">*allow-named-registers*</h3>
<p>Whether the parser should support AllegroCL's named registers
<code>(?&lt;name&gt;"&lt;regex&gt;")</code> and back-reference \k<name> syntax.</p>
<h3 id="allow-quoting">*allow-quoting*</h3>
<p>Whether the parser should support Perl's \Q and \E.</p>
<h3 id="look-ahead-for-suffix">*look-ahead-for-suffix*</h3>
<p>Controls whether scanners will optimistically look ahead for a
  constant suffix of a regular expression, if there is one.</p>
<h3 id="optimize-char-classes">*optimize-char-classes*</h3>
<p>Whether character classes should be compiled into look-ups into
O(1) data structures.  This is usually fast but will be costly in
terms of scanner creation time and might be costly in terms of size if
<code>*regex-char-code-limit*</code> is high.  This value will be used as the <code>:kind</code>
keyword argument to <code>create-optimized-test-function</code> - see there for the
possible non-<code>NIL</code> values.</p>
<h3 id="property-resolver">*property-resolver*</h3>
<p>Should be <code>NIL</code> or a designator for a function which accepts strings
and returns unary character test functions or <code>NIL</code>.  This 'resolver' is
intended to handle character properties' like \p{IsAlpha}.  If
<code>*property-resolver*</code> is <code>NIL</code>, then the parser will simply treat \p and
\P as #\p and #\P as in older versions of CL-PPCRE.</p>
<h3 id="regex-char-code-limit">*regex-char-code-limit*</h3>
<p>The upper exclusive bound on the char-codes of characters which can
occur in character classes.  Change this value BEFORE creating
scanners if you don't need the (full) Unicode support of
implementations like AllegroCL, CLISP, LispWorks, or SBCL.</p>
<h3 id="use-bmh-matchers">*use-bmh-matchers*</h3>
<p>Whether the scanners created by <a href="#create-scanner">create-scanner</a> should use the (fast
but large) Boyer-Moore-Horspool matchers.</p>
<h2 id="support">SUPPORT</h2>
<p>The development version of cl-ppcre can be found <a href="https://github.com/edicl/cl-ppcre">on
github</a>. Please use the github issue
tracking system to submit bug reports. Patches are welcome, please use
<a href="https://github.com/edicl/cl-ppcre/pulls">GitHub pull requests</a>. If you
want to make a change, please <a href="http://weitz.de/patches.html">read this
first</a>.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../cl-who/" class="btn btn-neutral float-right" title="cl-who - DSL for Markup">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../bordeaux-threads/" class="btn btn-neutral" title="bordeaux-threads - Threading"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../bordeaux-threads/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../cl-who/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
