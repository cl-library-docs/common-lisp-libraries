<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>iterate - Psuedocodic Iteration - common-lisp-libraries</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../extra.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "iterate - Psuedocodic Iteration";
    var mkdocs_page_input_path = "iterate.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/lisp.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> common-lisp-libraries</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">index</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Defacto libraries</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../asdf/">asdf - Build System</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../alexandria/">alexandria - Commonly Used Utilities</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../bordeaux-threads/">bordeaux-threads - Threading</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cl-ppcre/">cl-ppcre - Regular Expressions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cl-who/">cl-who - DSL for Markup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../fiveam/">fiveam - Regression Testing Framework</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../hunchentoot/">hunchentoot - Web Server</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">iterate - Psuedocodic Iteration</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#highlights">HIGHLIGHTS</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#other-points">OTHER POINTS</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#notes-for-myself-indications-of-incomplete-documentation">Notes for myself - indications of incomplete documentation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#installation">Installation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#accumulation-vs-reduction">Accumulation vs Reduction</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#api-clause-reference">API (CLAUSE) REFERENCE</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#accumulate">accumulate</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#accumulating">accumulating</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#adjoining">adjoining</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#after-each">after-each</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#always">always</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#appending">appending</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#as">as</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#collect">collect</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#collecting">collecting</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#count">count</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#counting">counting</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#declare-variables">declare-variables</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defclause-sequence">defclause-sequence</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defmacro-clause">defmacro-clause</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defmacro-driver">defmacro-driver</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defsynonym">defsynonym</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#display-iterate-clauses">display-iterate-clauses</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dsetq">dsetq</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#else">else</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#finally">finally</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#finally-protected">finally-protected</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#finding">finding</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#finish">finish</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#first-iteration-p">first-iteration-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#first-time-p">first-time-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#for">for</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#generate">generate</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#generating">generating</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#if-first-time">if-first-time</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#in">in</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#initially">initially</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#leave">leave</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#maximize">maximize</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#maximizing">maximizing</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#minimize">minimize</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#minimizing">minimizing</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#multiply">multiply</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#multiplying">multiplying</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#nconcing">nconcing</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#never">never</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#next">next</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#next-iteration">next-iteration</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#nunioning">nunioning</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reducing">reducing</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#repeat">repeat</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sum">sum</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#summing">summing</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#terminate">terminate</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#thereis">thereis</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#unioning">unioning</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#until">until</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#while">while</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#with">with</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#other-resources-on-iterate">OTHER RESOURCES ON ITERATE</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../postmodern/">postmodern - PostgreSQL programming interace</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../quicklisp/">quicklisp - Library Manager</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../utilities/">utilities - A collection of utility libraries</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Not yet defacto</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../numcl/">numcl - Lispy clone of numpy</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../unix-opts/">unix-opts - cmd line argument parser</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">common-lisp-libraries</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Defacto libraries &raquo;</li>
        
      
    
    <li>iterate - Psuedocodic Iteration</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="iterate-psuedocodic-iteration">iterate - Psuedocodic Iteration</h1>
<p>Version: 1.5
<br/>
Repository: <a href="https://gitlab.common-lisp.net/iterate/iterate">iterate/iterate - Gitlab</a></p>
<p><em>In case of any inaccuracies, ambiguities or suggestions, please <a href="https://github.com/digikar99/common-lisp.readthedocs/issues">create an issue here</a>.</em></p>
<hr />
<p><code>iterate</code> is a powerful iteration facility for Common Lisp, and a alternative to <code>loop</code>. As opposed to <code>loop</code>, <code>iterate</code> is more lispy, extensible, besides being more powerful.</p>
<p>See <a href="https://common-lisp.net/project/iterate/index.html">The Iterate Manual</a> for a more detailed explanation of the various facilities.</p>
<p>For a tutorial on looping in Common Lisp, check out <a href="http://lispcookbook.github.io/cl-cookbook/iteration.html">Loops, Iterate and Mapping - The Common Lisp Cookbook</a>.</p>
<h2 id="highlights">HIGHLIGHTS</h2>
<ul>
<li><a href="#defclause-sequence">def*</a>: extensibility</li>
<li><a href="#display-iterate-clauses">display-iterate-clauses</a>: quick help for clauses</li>
<li><a href="#dsetq">dsetq</a>: for use outside the <code>iter</code> form</li>
<li><a href="#finally-protected">finally-protected</a>: for protecting against unwindings</li>
<li><a href="#finding">finding-maximizing</a>: <code>loop</code> equivalent can be quite verbose</li>
<li><a href="#for">for</a>: lots of variants!</li>
<li><a href="#generate">generate</a></li>
<li><a href="#in">in</a>: <code>loop</code> equivalent can be quite verbose</li>
<li>there's no support for "true" parallel assignment - see <a href="#with">with</a></li>
</ul>
<h2 id="other-points">OTHER POINTS</h2>
<ul>
<li><code>iterate</code> does not declare variables unless asked to. See <a href="https://common-lisp.net/project/iterate/doc/Types-and-Declarations.html">Types and Declarations</a>.</li>
<li><code>into</code><em><code>var</code></em> stores the value into <em><code>var</code></em> instead of returning it.</li>
<li>There, probably, are some idiosyncrasies involved with running the epilogue code - it is not run "always": <code>always</code>, <code>finding</code>, <code>finish</code>, <code>thereis</code>.</li>
</ul>
<h3 id="notes-for-myself-indications-of-incomplete-documentation">Notes for myself - indications of incomplete documentation</h3>
<ul>
<li>Documentation for <code>finding</code> is incomplete here.</li>
<li>Documentation for <code>def*</code>, <code>for</code> has been omitted here.</li>
<li>When are the variable values for prologue defined?</li>
<li>Will there be future versions of iterate? What is the compatibility relation between <code>terminate</code> and <code>finish</code> for <code>for-next</code> <a href="https://common-lisp.net/project/iterate/doc/Generalized-Drivers.html">Generalized Drivers</a>?</li>
</ul>
<h3 id="installation">Installation</h3>
<p>If <code>quicklisp</code> is set-up, simply <code>(ql:quickload 'iterate)</code>. </p>
<p>Otherwise <a href="https://common-lisp.net/project/iterate/index.html">head over here</a>.</p>
<h3 id="accumulation-vs-reduction">Accumulation vs Reduction</h3>
<p>The differences between accumulate and reducing are slight. One difference is that the functions take their arguments in a different order. Another is that in the absence of init-val, accumulate will use nil, whereas reducing will generate different code that avoids any dependence on the initial value. The reason for having both clauses is that one usually thinks of reductions (like sum) and accumulations (like collect) as different beasts.</p>
<h2 id="api-clause-reference">API (CLAUSE) REFERENCE</h2>
<h3 id="accumulate">accumulate</h3>
<p><code>accumulate</code><em><code>expr</code></em><code>by</code><em><code>func</code></em><code>&amp;optional initial-value</code><em><code>init-val</code></em><code>into</code><em><code>var</code></em></p>
<p>This is a general-purpose accumulation clause. func should be a function of two arguments, the value of expr and the value accumulated so far in the iteration, and it should return the updated value. If no initial value is supplied, nil is used.</p>
<pre><code class="lisp">CL-USER&gt; (iter (for i in '(1 2 3))
               (accumulate i by 
                           (lambda (i values-so-far)
                             (cons i values-so-far))))
(3 2 1)
CL-USER&gt; (iter (for i in '(1 2 3))
               (accumulate i by 
                           (lambda (i values-so-far)
                             (cons i values-so-far))
                           initial-value '(init)))
(3 2 1 INIT)
CL-USER&gt; (iter (for i in '(1 2 3))
               (accumulate i by 
                          (lambda (i values-so-far)
                            (cons i values-so-far))
                          initial-value '(init) into var))
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Accumulations.html">Accumulations</a>, <a href="#accumulation-vs-reduction">Accumulation vs Reduction</a> and <a href="#reducing">reducing</a>. </p>
<h3 id="accumulating">accumulating</h3>
<p>An alias for <a href="#accumulate">accumulate</a>.</p>
<h3 id="adjoining">adjoining</h3>
<p><code>adjoining</code><em><code>exptr</code></em><code>&amp;optional into</code><em><code>var</code></em><code>test</code><em><code>test</code></em><code>at</code><em><code>place</code></em><code>result-type</code><em><code>type</code></em></p>
<p>Like <a href="#collect">collect</a>, but only adds the value of exptr if it is not already present. test, which defaults to #'eql, is the test to be used with member.</p>
<h3 id="after-each">after-each</h3>
<p><code>after-each &amp;rest</code><em><code>forms</code></em></p>
<p>Executes forms at the end of the loop body, after each iteration. Forms may contain iterate clauses.</p>
<pre><code class="lisp">CL-USER&gt; (iter (for i below 4) 
               (after-each (print var))
               (if (oddp i)
                   (collect i into var)
                   (collect (* 2 i) into var)))

; (0) 
; (0 1) 
; (0 1 4) 
; (0 1 4 3) 
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Code-Placement.html#index-after_002deach-103">Code Placement</a> and <a href="https://common-lisp.net/project/iterate/doc/Problems-with-Code-Movement.html#Problems-with-Code-Movement">Problems with Code Movement</a>.</p>
<h3 id="always">always</h3>
<p><code>always</code><em><code>expr</code></em></p>
<pre><code class="lisp">CL-USER&gt; (iter (for i below 4) (always (evenp i)))
NIL
</code></pre>

<ul>
<li>If expr ever evaluates to nil, then nil is immediately returned; the epilogue code is not executed. </li>
<li>If expr never evaluates to nil, the epilogue code is executed and the last value of expr (or t if expr was never evaluated) is returned (whereas loop would constantly return t).</li>
</ul>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Aggregated-Boolean-Tests.html">Aggregated Boolean Tests</a>.</p>
<h3 id="appending">appending</h3>
<p><code>appending</code><em><code>exptr</code></em><code>&amp;optional into</code><em><code>var</code></em><code>at</code><em><code>place</code></em>
Like <a href="#collect">collect</a>, but behaves like the Common Lisp <code>append</code>, and works only on lists.</p>
<pre><code class="lisp">CL-USER&gt; (iter (for i in '((1) (2 3) (4 5 6)))
               (appending i))
(1 2 3 4 5 6)
CL-USER&gt; (iter (for i in '((1) (2 3) (4 5 6)))
               (appending i into var))
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Accumulations.html">Accumulations</a>.</p>
<h3 id="as">as</h3>
<p>An alias for <a href="#for">for</a>.</p>
<h3 id="collect">collect</h3>
<p><code>collect</code><em><code>exptr</code></em><code>&amp;optional into</code><em><code>var</code></em><code>test</code><em><code>test</code></em><code>at</code><em><code>place</code></em><code>result-type</code><em><code>type</code></em></p>
<pre><code class="lisp">CL-USER&gt; (iter (for i from 1 to 5)
               (collect i))
(1 2 3 4 5)
CL-USER&gt; (iter (for i from 1 to 5)
               (collect i at start)) ;; likely to be faster
(5 4 3 2 1)
</code></pre>

<ul>
<li><code>place</code> can be either <code>beginning</code>/<code>start</code> or <code>end</code>: default value is <code>end</code>.</li>
<li><code>type</code> should be a subtype of <code>sequence</code> - default is <code>list</code>; however, the type of sequence being constructed inside the loop is undefined when a non-list type is specified.</li>
</ul>
<pre><code class="lisp">CL-USER&gt; (iter (for i from 1 to 3)
               (collect i into vec result-type 'vector)
               (print vec)
               (finally (return vec)))

; (1)
; (1 2) 
; (1 2 3) 
#(1 2 3)
</code></pre>

<ul>
<li><code>type</code> or <code>place</code> may be optionally quoted.</li>
</ul>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Accumulations.html">Accumulations</a>.</p>
<h3 id="collecting">collecting</h3>
<p>Alias for <a href="#collect">collect</a>.</p>
<h3 id="count">count</h3>
<p>Alias for <a href="#counting">counting</a>.</p>
<p>This, probably, overrides the CL <code>count</code> when used in top-level inside an iterate loop.</p>
<pre><code class="lisp">CL-USER&gt; (iter (for i in '(1 2 3))
               (finally (return (count 1 '(1 2 1)))))
2
</code></pre>

<h3 id="counting">counting</h3>
<p><code>counting</code><em><code>expr</code></em><code>&amp;optional into</code><em><code>var</code></em></p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Reductions.html">Reductions</a> and <a href="#accumulate">accumulate</a>.</p>
<h3 id="declare-variables">declare-variables</h3>
<p><code>(declare (declare-variables))</code></p>
<ul>
<li>iterate does not declare variable types unless asked to. </li>
<li>Declaration of types of user introduced symbols can be done by either the usual Common Lisp <code>declare</code>, but this declaration should be inside the iter form.</li>
<li>Declaration of internal variables or use of <code>the</code> requires one to use <code>declare-variables</code>, or set <code>iterate:::*always-declare-variables* to</code>t`.</li>
</ul>
<pre><code class="lisp">CL-USER&gt; (macroexpand-1 '(iter (for (the fixnum el) in '(1 2 3))
                               (declare (DECLARE-VARIABLES))
                               (count (oddp el))))
;; note that this produces a type declaration for el.
CL-USER&gt; (macroexpand-1 '(iter (for el in '(1 2 3))
                               (declare (DECLARE-VARIABLES))
                               (count (oddp el))))
;; this does not produce a type declaration for el.
CL-USER&gt; (macroexpand-1 '(iter (for (the fixnum el) in '(1 2 3))
                               (count (oddp el))))
;; this does not produce any declarations.
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Types-and-Declarations.html">Types and Declarations</a>.</p>
<h3 id="defclause-sequence">defclause-sequence</h3>
<p>[Undocumented here.]</p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Extensibility-Aids.html">Extensibility Aids</a>.</p>
<h3 id="defmacro-clause">defmacro-clause</h3>
<p>[Undocumented here]</p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Rolling-Your-Own.html">Rolling Your Own</a>.</p>
<h3 id="defmacro-driver">defmacro-driver</h3>
<p>[Undocumented here.]</p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Writing-Drivers.html">Writing Drivers</a>.</p>
<h3 id="defsynonym">defsynonym</h3>
<p>[Undocumented here.]</p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Extensibility-Aids.html">Extensibility Aids</a>.</p>
<h3 id="display-iterate-clauses">display-iterate-clauses</h3>
<p><code>display-iterate-clauses &amp;optional</code><em><code>clause-spec</code></em></p>
<pre><code class="lisp">CL-USER&gt; (display-iterate-clauses 'repeat)
; REPEAT                    Repeat the loop some number of times
T
CL-USER&gt; (display-iterate-clauses '(for in-vector))
; FOR IN-VECTOR &amp;OPTIONAL FROM UPFROM DOWNFROM TO DOWNTO ABOVE BELOW BY 
;     WITH-INDEX            Elements of a vector
T
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/On_002dline-Help.html">On-line help</a>.</p>
<h3 id="dsetq">dsetq</h3>
<p><code>dsetq</code><em><code>template expr</code></em></p>
<p>Can be used outside iter.</p>
<pre><code class="lisp">CL-USER&gt; (foo)
FIRST
SECOND
CL-USER&gt; (progn
           (dsetq (values a b) (foo))
           (list a b)) ;; undeclared variables warning
(FIRST SECOND)
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Destructuring.html">Destructuring</a>.</p>
<h3 id="else">else</h3>
<p><code>else &amp;rest</code><em><code>forms</code></em></p>
<p>Forms are executed if loop is never entered, but is terminated normally.</p>
<pre><code class="lisp">CL-USER&gt; (iter (for i in '(1 2 3)) (while nil)
           (else (write 'else)))
; ELSE
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Code-Placement.html#index-after_002deach-103">Code Placement</a> and <a href="https://common-lisp.net/project/iterate/doc/Problems-with-Code-Movement.html#Problems-with-Code-Movement">Problems with Code Movement</a>.</p>
<h3 id="finally">finally</h3>
<p><code>finally &amp;rest</code><em><code>forms</code></em></p>
<p>Forms are executed after a normal termination of the loop.</p>
<pre><code class="lisp">CL-USER&gt; (iter (for i in '(1 2 3)) (finally (write 'end)))
; END
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Code-Placement.html#index-after_002deach-103">Code Placement</a> and <a href="https://common-lisp.net/project/iterate/doc/Problems-with-Code-Movement.html#Problems-with-Code-Movement">Problems with Code Movement</a>.</p>
<h3 id="finally-protected">finally-protected</h3>
<p><code>finally-protected &amp;rest</code><em><code>forms</code></em></p>
<p>Forms are executed "always" - regardless of whether the termination was notmal</p>
<pre><code class="lisp">CL-USER&gt; (iter (for i in-vector '(1 2 3)) 
           (finally-protected (write 'error)))
;; warnings
ERROR ; Evaluation aborted on #&lt;SIMPLE-TYPE-ERROR expected-type: VECTOR datum: (1 2 3)&gt;.
CL-USER&gt; (iter (for i in '(1 2 3)) 
           (finally-protected (write 'no-error)))
; NO-ERROR
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Code-Placement.html#index-after_002deach-103">Code Placement</a> and <a href="https://common-lisp.net/project/iterate/doc/Problems-with-Code-Movement.html#Problems-with-Code-Movement">Problems with Code Movement</a>.</p>
<h3 id="finding">finding</h3>
<p><code>finding</code><em><code>expr</code></em><code>such-that</code><em><code>test</code></em><code>&amp;optionally into</code><em><code>var</code></em><code>on-failure</code><em><code>failure-value</code></em></p>
<ul>
<li>The loop terminates (with epilogue code) whenever <em><code>test</code></em> evaluates to non-<code>nil</code>.</li>
<li><em><code>expr</code></em> that satifies the <em><code>test</code></em>, or <em><code>failure-value</code></em>, or <code>nil</code> is returned (unless modified by epilogue).</li>
<li><em><code>failure-value</code></em> is always evaluated.</li>
</ul>
<pre><code class="lisp">CL-USER&gt; (iter (for x in '(1 2 3))
               (finding x such-that #'evenp on-failure 'not-found))
2
CL-USER&gt; (iter (for x in '(1 2 3))
               (finding x such-that #'evenp on-failure (error &quot;not found&quot;)))
; Evaluation aborted on #&lt;SIMPLE-ERROR &quot;not found&quot; {1002F63063}&gt;.
CL-USER&gt; (iter (for x in '(1 2 3))
               (if (evenp x) (leave x))
               (finally (error &quot;not found&quot;)))
2
</code></pre>

<p><code>finding</code><em><code>expr</code></em><code>maximizing</code><em><code>m-expr</code></em><code>&amp;optionally into</code><em><code>var</code></em></p>
<p><code>finding</code><em><code>expr</code></em><code>minimizing</code><em><code>m-expr</code></em><code>&amp;optionally into</code><em><code>var</code></em></p>
<ul>
<li>Returns <em><code>expr</code></em> corresponding to the maximum value of <em><code>m-expr</code></em>. </li>
<li>If <em><code>m-expr</code></em> is never evaluated (how?), the return value is <code>nil</code> or <code>0</code> depending on the type (or its absence) of <em><code>expr</code></em> (or <em><code>var</code></em> if supplied.)</li>
<li>Here, <em><code>m-expr</code></em> can also be a list of two symbols.</li>
</ul>
<pre><code class="lisp">CL-USER&gt; CL-USER&gt; (iter (for list in '((1) (2 3) nil))
               (finding list maximizing (length list)))
(2 3)
CL-USER&gt; (iter (for i in '(1 2 3))
               (finding (* 2 i) maximizing (- i) into (twice neg))
               (finally (return (values twice neg))))
2
-1
</code></pre>

<p>[Example required for the case when <em><code>m-expr</code></em> is not evaluated.]</p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Finders.html">Finders</a>.</p>
<h3 id="finish">finish</h3>
<p><code>finish</code></p>
<p>Stop the loop (and run the epilogue code).</p>
<pre><code class="lisp">CL-USER&gt; (iter (for i in '(1 2 3)) (if (evenp i) (finish)))
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Control-Flow.html">Control Flow</a>.</p>
<h3 id="first-iteration-p">first-iteration-p</h3>
<p><code>first-iteration-p</code></p>
<p><code>t</code> in the first cycle of the loop, otherwise <code>nil</code>.</p>
<pre><code class="lisp">CL-USER&gt; (iter (for el in '(nil 1 2 nil 3))
               (when el
                 (unless (first-iteration-p)
                   (princ &quot;, &quot;))
                 (princ el)))
; , 1, 2, 3
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Boolean-Tests.html">Boolean Tests</a>.</p>
<h3 id="first-time-p">first-time-p</h3>
<p><code>first-iteration-p</code></p>
<p><code>t</code> only when the expression is evaluated for the first time.</p>
<pre><code class="lisp">CL-USER&gt; (iter (for el in '(nil 1 2 nil 3))
               (when el
                 (unless (first-time-p)
                   (princ &quot;, &quot;))
                 (princ el)))
; 1, 2, 3
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Boolean-Tests.html">Boolean Tests</a>.</p>
<h3 id="for">for</h3>
<p>[Undocumented here.]</p>
<p>See</p>
<ul>
<li><a href="https://common-lisp.net/project/iterate/doc/Numerical-Iteration.html">Numeric Iteration</a> </li>
<li><a href="https://common-lisp.net/project/iterate/doc/Sequence-Iteration.html">Sequence Iteration</a></li>
<li><a href="https://common-lisp.net/project/iterate/doc/Variable-Binding-and-Setting.html">Variable Binding and Setting</a></li>
<li><a href="https://common-lisp.net/project/iterate/doc/Generalized-Drivers.html">Generalized Drivers</a> </li>
<li><a href="https://common-lisp.net/project/iterate/doc/Previous-Values-of-Driver-Variables.html">Previous Values of Driver Variables</a></li>
</ul>
<h3 id="generate">generate</h3>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Generators.html">Generators</a> and <a href="#for">for</a>.</p>
<pre><code class="lisp">CL-USER&gt; (iter (for el in '(a b nil c))
               (generate i upfrom 1)
               (if el (collect (cons el (next i)))))
((A . 1) (B . 2) (C . 3))
</code></pre>

<p><code>for</code> can be replaced by <code>generate</code> to achieve the desired result, except in the case of <a href="https://common-lisp.net/project/iterate/doc/Variable-Binding-and-Setting.html">Variable Binding and Setting</a>.</p>
<h3 id="generating">generating</h3>
<p>Alias for <a href="#generate">generate</a></p>
<h3 id="if-first-time">if-first-time</h3>
<p><code>if-first-time</code><em><code>then</code></em><code>&amp;optional</code><em><code>else</code></em></p>
<pre><code class="lisp">CL-USER&gt; (iter (for i in '(1 2 3))
               (if-first-time
                (princ 'first)
                (print 'not-first)))
; FIRST
; NOT-FIRST 
; NOT-FIRST 
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Control-Flow.html">Control Flow</a>.</p>
<h3 id="in">in</h3>
<p><code>in</code><em><code>name</code></em><code>&amp;rest</code><em><code>forms</code></em></p>
<pre><code class="lisp">CL-USER&gt; (defvar ar #2A((1 2 3) (4 5 6)))
AR
CL-USER&gt; (iter outer 
               (for i below (array-dimension ar 0))
               (iter (for j below (array-dimension ar 1))
                     (in outer
                         (collect (aref ar i j)))))
(1 2 3 4 5 6)
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Named-Blocks.html">Named Blocks</a>.</p>
<h3 id="initially">initially</h3>
<p><code>in &amp;rest</code><em><code>forms</code></em>
Place the forms in the prologue of the loop.</p>
<pre><code class="lisp">CL-USER&gt; (iter (initially (princ 'hi))
               (for i below 3)
               (print i))
; HI
; 0 
; 1 
; 2 
NIL
CL-USER&gt; (iter (for i below 3)
               (initially (princ i)))
; -1 ;; this is probably an undefined behaviour.
NIL
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Code-Placement.html#index-after_002deach-103">Code Placement</a> and <a href="https://common-lisp.net/project/iterate/doc/Problems-with-Code-Movement.html#Problems-with-Code-Movement">Problems with Code Movement</a>.</p>
<h3 id="leave">leave</h3>
<p><code>leave &amp;optional</code><em><code>value</code></em></p>
<p>Returns from the current iterate form with <em><code>value</code></em> or <code>nil</code>.</p>
<pre><code class="lisp">CL-USER&gt; (iter (for i below 3)
               (leave
                (iter (for j below 2)
                      (if (oddp j) (leave j)))))
1
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Control-Flow.html">Control Flow</a>.</p>
<h3 id="maximize">maximize</h3>
<p><code>maximize</code><em><code>expr</code></em><code>&amp;optional into</code><em><code>var</code></em></p>
<pre><code class="lisp">CL-USER&gt; (iter (for list in '((1) (1 2) nil))
               (maximize (length list)))
2
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Reductions.html">Reductions</a> and <a href="#finding">finding</a>.</p>
<h3 id="maximizing">maximizing</h3>
<p>Alias for <a href="#maximize">maximize</a>.</p>
<h3 id="minimize">minimize</h3>
<p><code>minimize</code><em><code>expr</code></em><code>&amp;optional into</code><em><code>var</code></em></p>
<pre><code class="lisp">CL-USER&gt; (iter (for list in '((1) (1 2) nil))
               (minimize (length list)))
0
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Reductions.html">Reductions</a> and <a href="#finding">finding</a>.</p>
<h3 id="minimizing">minimizing</h3>
<p>Alias for <a href="#minimize">minimize</a>.</p>
<h3 id="multiply">multiply</h3>
<p><code>multiply</code><em><code>expr</code></em><code>&amp;optional into</code><em><code>var</code></em></p>
<pre><code class="lisp">CL-USER&gt; (iter (for i from 1 to 5)
               (multiply i))
120
</code></pre>

<p>Initial value of <code>*</code>var`* is 1.</p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Reductions.html">Reductions</a>.</p>
<h3 id="multiplying">multiplying</h3>
<p>Alias for [multiply](#</p>
<h3 id="nconcing">nconcing</h3>
<p><code>nconcing</code><em><code>exptr</code></em><code>&amp;optional into</code><em><code>var</code></em><code>test</code><em><code>test</code></em><code>at</code><em><code>place</code></em><code>result-type</code><em><code>type</code></em></p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Accumulations.html">Accumulations</a> and <a href="#collect">collect</a>.</p>
<h3 id="never">never</h3>
<p><code>never</code><em><code>expr</code></em></p>
<p>Effectively <code>(always (not expr))</code>, but does not influence the last value returned by a possible other <code>always</code> clause.</p>
<pre><code class="lisp">CL-USER&gt; (iter (repeat 2)
               (always 2)
               (never nil))
2
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Aggregated-Boolean-Tests.html">Aggregated Boolean Tests</a></p>
<h3 id="next">next</h3>
<p>See <a href="#generate">generate</a>.</p>
<h3 id="next-iteration">next-iteration</h3>
<p><code>next-iteration</code></p>
<pre><code class="lisp">CL-USER&gt; (iter (for i below 3)
               (if (oddp i) 
                   (next-iteration)
                   (collect i)))
(0 2)
</code></pre>

<h3 id="nunioning">nunioning</h3>
<p><code>nunioning</code><em><code>exptr</code></em><code>&amp;optional into</code><em><code>var</code></em><code>test</code><em><code>test</code></em><code>at</code><em><code>place</code></em><code>result-type</code><em><code>type</code></em></p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Accumulations.html">Accumulations</a> and <a href="#collect">collect</a>.</p>
<h3 id="reducing">reducing</h3>
<p><code>reducing</code><em><code>expr</code></em><code>by</code><em><code>func</code></em><code>&amp;optional initial-value</code><em><code>init-val</code></em><code>into</code><em><code>var</code></em></p>
<pre><code class="lisp">CL-USER&gt; (iter (for i in '(1 2 3))
               (reducing i by 
                         (lambda (value-so-far i)
                           (cons i value-so-far))
                         initial-value ()))
(3 2 1)
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Reductions.html">Reductions</a>, <a href="#accumulation-vs-reduction">Accumulation vs Reduction</a> and <a href="#accumulate">accumulate</a>.</p>
<h3 id="repeat">repeat</h3>
<p><code>repeat</code><em><code>n</code></em></p>
<p>Repeat the loop n times.</p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Drivers.html">Drivers</a>.</p>
<pre><code class="lisp">CL-USER&gt; (iter (repeat 3) (print 'doing))

; DOING 
; DOING 
; DOING 
NIL
</code></pre>

<h3 id="sum">sum</h3>
<p><code>sum</code><em><code>expr</code></em><code>&amp;optional into</code><em><code>var</code></em></p>
<pre><code class="lisp">CL-USER&gt; (iter (for i from 1 to 5)
               (sum i))
15
</code></pre>

<h3 id="summing">summing</h3>
<p>Alias for <a href="#sum">sum</a>.</p>
<h3 id="terminate">terminate</h3>
<p>`terminate </p>
<p>Use to terminate <code>for-next</code> clause. Effectively an alias for <code>finish</code> - but use with <code>for-next</code> to maintain compatibility with future versions of <code>iterate</code>(!).</p>
<pre><code class="lisp">CL-USER&gt; (iter (for i upfrom 0)
               (if (&gt; i 5) (terminate) (collect i)))
(0 1 2 3 4 5)
CL-USER&gt; (iter (initially (setq i 0))
               (for i next 
                    (if (&gt; i 10) 
                        (terminate)
                        (incf i))))
NIL

</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Generalized-Drivers.html">Generalized Drivers</a>.</p>
<h3 id="thereis">thereis</h3>
<p><code>thereis</code><em><code>expr</code></em></p>
<ul>
<li>If <em><code>expr</code></em> is ever non-<code>nil</code>, its value is returned without running the epilogue code.</li>
<li>Otherwise epilogue code is run, and <code>nil</code> is returned.</li>
<li>Cannot be used with <code>always</code> or <code>never</code>.</li>
</ul>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Aggregated-Boolean-Tests.html">Aggregated Boolean Tests</a>.</p>
<h3 id="unioning">unioning</h3>
<p><code>unioning</code><em><code>exptr</code></em><code>&amp;optional into</code><em><code>var</code></em><code>test</code><em><code>test</code></em><code>at</code><em><code>place</code></em><code>result-type</code><em><code>type</code></em></p>
<p>See <a href="https://common-lisp.net/project/iterate/doc/Accumulations.html">Accumulations</a> and <a href="#collect">collect</a>.</p>
<h3 id="until">until</h3>
<p><code>until</code><em><code>expr</code></em></p>
<pre><code class="lisp">CL-USER&gt; (iter (for i in '(1 2 3 4 5))
               (until (&gt; i 5))
               (collect i))
(1 2 3 4 5)
</code></pre>

<p>Equivalent to <code>(if expr (finish))</code>.</p>
<p>See <a href="#finish">finish</a> and <a href="https://common-lisp.net/project/iterate/doc/Control-Flow.html">Control Flow</a>.</p>
<h3 id="while">while</h3>
<p><code>repeat</code><em><code>n</code></em>
<code>until</code><em><code>expr</code></em></p>
<p>Equivalent to <code>(if (not expr) (finish))</code>. </p>
<pre><code class="lisp">CL-USER&gt; (iter (for i below 10)
               (while (= 0 (rem i 5)))
               (collect i))
(0)
</code></pre>

<p>See <a href="#finish">finish</a> and <a href="https://common-lisp.net/project/iterate/doc/Control-Flow.html">Control Flow</a>.</p>
<h3 id="with">with</h3>
<p><code>with</code><em><code>var</code></em><code>&amp;optional =</code><em><code>value</code></em></p>
<p><em><code>var</code></em> is bound to <em><code>value</code></em> before the loop is entered. Binding happens sequentially, as while using a <code>let*</code>, and not in parallel as with <code>let</code>.</p>
<pre><code class="lisp">CL-USER&gt; (iter (with i = 0)
               (while (&lt; i 3))
               (collect (incf i)))
(1 2 3)
CL-USER&gt; (iter (with i = 1)
               (for i below 3)
               (collect (incf i)))
; Evaluation aborted on #&lt;SIMPLE-ERROR &quot;Iterate~@[, in ~a~]:~%Duplicate variable: ~a&quot; {1004185183}&gt;.
</code></pre>

<p>See <a href="https://common-lisp.net/project/iterate/doc/Variable-Binding-and-Setting.html">Variable Binding and Setting</a> and <a href="https://common-lisp.net/project/iterate/doc/Parallel-Binding-and-Stepping.html#Parallel-Binding-and-Stepping">Parallel Binding and Stepping</a>.</p>
<h2 id="other-resources-on-iterate">OTHER RESOURCES ON ITERATE</h2>
<ul>
<li><a href="https://common-lisp.net/project/iterate/index.html">The Iterate Manual</a></li>
<li><a href="https://items.sjbach.com/211/comparing-loop-and-iterate">Comparing LOOP and ITERATE</a></li>
<li><a href="https://sites.google.com/site/sabraonthehill/loop-v-iter">Loop v Iterate - SabraOnTheHill</a></li>
</ul>
<hr />
<p>[DLI]: appendix/Don't Loop, Iterate</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../hunchentoot/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../postmodern/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(false);
        };
    </script>

</body>
</html>
