{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"common-lisp-libraries.readthedocs.io In case of any inaccuracies, ambiguities or suggestions, please create an issue here . Introduction Common Lisp documentation - libraries or the HyperSpec - isn't known to be particularly \"modern\" or \"attractive\". While those terms are subjective, ease of introduction to a technology does seem to have some objective component to it. Libraries Installation Each of the below libraries (except asdf and quicklisp) can be installed using quicklisp: (ql:quickload \"alexandria\") ; for example See quicklisp - Getting Started for instructions on installing quicklisp. Optionally, you may want to use trivial-package-local-nicknames for, well, adding package local nicknames . (ql:quickload :trivial-package-local-nicknames) (trivial-package-local-nicknames:add-package-local-nickname :a :alexandria) ; OR (defpackage my-package (:use #:cl) (:local-nicknames (#:a #:alexandria))) ;;; I'm yet to read up on the naming conventions and the reasons behind those conventions ;;; in the context of systems and packages; some conventions do exist. Libraries documented so far See awesome-cl for more libraries. (See the html version of this page , rather than the markdown version for the working links below.) Defacto libraries asdf - build system for softwares (packages*) alexandria - a utility library bordeaux-threads - library for threading cl-ppcre - regular expressions cl-who - DSL for Markup hunchentoot - web server fiveam - regression testing framework iterate - a lispy extensible alternative to loop postmodern - PostgreSQL programming interace quicklisp - library manager utilities - a collection of utility libraries Not yet defacto numcl - lispy clone of numpy unix-opts - minimalistic command line options parser *What one might call packages in other languages are called systems in Common Lisp parlance. Instead, the word package in Common Lisp refers to a data structure providing namespacing for symbols. By contrast, a system is a tool to organize a bunch of files, in accordance with dependencies, and specifying how to perform certain actions on the system. A single system may contain multiple packages. See this StackOverFlow answer for a detailed discussion. Previous Efforts Documentation efforts have been made at: Quickdocs : I didn't like the theme. I want the API at a glance! Honestly, this can improve! But don't look at me. I'm also not very at ease with full automation without human intervention. Quickref : Frankly, this is just too much. As a user, all I want to know is \"What can this library do? And, how do I do it? (What functions, macros or anything is available?)\" Therefore, for a user, the only good place I found was the Packages section here. It is, after all, a Reference Manual. Another excuse is, again, that I do want human intervention in documentation. common-lisp.net : Ultimately, this is the place for most everything Common Lisp. And indeed, most of the work here is based on the official documentation. An attempt is made to \"simplify\" wherever need is felt. CLiki : Again, layout and \"at a glance\"! UltraSpec : I liked this. The only trouble? It isn't \"quick\". UltraSpec I liked (the theme of) UltraSpec . I also liked mkdocs - I am using mkdocs with the pre-provided readthedocs theme. What UltraSpec seems to be good for is larger websites than what is currently here, in that it isn't as straightforward as mkdocs for library-documenters to use it. Additionally, markdown files and dokuwiki files (the format UltraSpec requires) are interconvertible (but the compatibility is untested) using pandoc . (pandoc is indeed useful for a ton of other file formats!) mkdocs As a marketing for mkdocs: mkdocs is as simple as pip install mkdocs # or conda create a .yml configuration file (or copy and edit!) put your markdown files inside docs/ directory (or as mentioned in the .yml file) mkdocs gh-deploy # to deploy on github-pages Done! PS: Regardless of the justifications, all I wanted was a documentation site with a \"sidebar\" that, both, tells the page at glance, and is easy to navigate.","title":"index"},{"location":"#common-lisp-librariesreadthedocsio","text":"In case of any inaccuracies, ambiguities or suggestions, please create an issue here .","title":"common-lisp-libraries.readthedocs.io"},{"location":"#introduction","text":"Common Lisp documentation - libraries or the HyperSpec - isn't known to be particularly \"modern\" or \"attractive\". While those terms are subjective, ease of introduction to a technology does seem to have some objective component to it.","title":"Introduction"},{"location":"#libraries","text":"","title":"Libraries"},{"location":"#installation","text":"Each of the below libraries (except asdf and quicklisp) can be installed using quicklisp: (ql:quickload \"alexandria\") ; for example See quicklisp - Getting Started for instructions on installing quicklisp. Optionally, you may want to use trivial-package-local-nicknames for, well, adding package local nicknames . (ql:quickload :trivial-package-local-nicknames) (trivial-package-local-nicknames:add-package-local-nickname :a :alexandria) ; OR (defpackage my-package (:use #:cl) (:local-nicknames (#:a #:alexandria))) ;;; I'm yet to read up on the naming conventions and the reasons behind those conventions ;;; in the context of systems and packages; some conventions do exist.","title":"Installation"},{"location":"#libraries-documented-so-far","text":"See awesome-cl for more libraries. (See the html version of this page , rather than the markdown version for the working links below.)","title":"Libraries documented so far"},{"location":"#defacto-libraries","text":"asdf - build system for softwares (packages*) alexandria - a utility library bordeaux-threads - library for threading cl-ppcre - regular expressions cl-who - DSL for Markup hunchentoot - web server fiveam - regression testing framework iterate - a lispy extensible alternative to loop postmodern - PostgreSQL programming interace quicklisp - library manager utilities - a collection of utility libraries","title":"Defacto libraries"},{"location":"#not-yet-defacto","text":"numcl - lispy clone of numpy unix-opts - minimalistic command line options parser *What one might call packages in other languages are called systems in Common Lisp parlance. Instead, the word package in Common Lisp refers to a data structure providing namespacing for symbols. By contrast, a system is a tool to organize a bunch of files, in accordance with dependencies, and specifying how to perform certain actions on the system. A single system may contain multiple packages. See this StackOverFlow answer for a detailed discussion.","title":"Not yet defacto"},{"location":"#previous-efforts","text":"Documentation efforts have been made at: Quickdocs : I didn't like the theme. I want the API at a glance! Honestly, this can improve! But don't look at me. I'm also not very at ease with full automation without human intervention. Quickref : Frankly, this is just too much. As a user, all I want to know is \"What can this library do? And, how do I do it? (What functions, macros or anything is available?)\" Therefore, for a user, the only good place I found was the Packages section here. It is, after all, a Reference Manual. Another excuse is, again, that I do want human intervention in documentation. common-lisp.net : Ultimately, this is the place for most everything Common Lisp. And indeed, most of the work here is based on the official documentation. An attempt is made to \"simplify\" wherever need is felt. CLiki : Again, layout and \"at a glance\"! UltraSpec : I liked this. The only trouble? It isn't \"quick\".","title":"Previous Efforts"},{"location":"#ultraspec","text":"I liked (the theme of) UltraSpec . I also liked mkdocs - I am using mkdocs with the pre-provided readthedocs theme. What UltraSpec seems to be good for is larger websites than what is currently here, in that it isn't as straightforward as mkdocs for library-documenters to use it. Additionally, markdown files and dokuwiki files (the format UltraSpec requires) are interconvertible (but the compatibility is untested) using pandoc . (pandoc is indeed useful for a ton of other file formats!)","title":"UltraSpec"},{"location":"#mkdocs","text":"As a marketing for mkdocs: mkdocs is as simple as pip install mkdocs # or conda create a .yml configuration file (or copy and edit!) put your markdown files inside docs/ directory (or as mentioned in the .yml file) mkdocs gh-deploy # to deploy on github-pages Done! PS: Regardless of the justifications, all I wanted was a documentation site with a \"sidebar\" that, both, tells the page at glance, and is easy to navigate.","title":"mkdocs"},{"location":"alexandria/","text":"alexandria - Commonly Used Utilities Version: 1.0.0 Repository: alexandria/alexandria - Gitlab This documentation is modified to markdown from here on 01 March, 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . ALEXANDRIA Alexandria software and associated documentation are in the public domain: Authors dedicate this work to public domain, for the benefit of the public at large and to the detriment of the authors' heirs and successors. Authors intends this dedication to be an overt act of relinquishment in perpetuity of all present and future rights under copyright law, whether vested or contingent, in the work. Authors understands that such relinquishment of all rights includes the relinquishment of all rights to enforce (by lawsuit or otherwise) those copyrights in the work. Authors recognize that, once placed in the public domain, the work may be freely reproduced, distributed, transmitted, used, modified, built upon, or otherwise exploited by anyone for any purpose, commercial or non-commercial, and in any way, including by methods that have not yet been invented or conceived. In those legislations where public domain dedications are not recognized or possible, Alexandria is distributed under the following terms and conditions: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 1. HASH TABLES ensure-gethash Macro: (ensure-gethash key hash-table &optional default) Like gethash , but if key is not found in the hash-table saves the default under key before returning it. Secondary return value is true if key was already in the table. copy-hash-table Function: (copy-hash-table table &key key test size rehash-size rehash-threshold) Returns a copy of hash table table , with the same keys and values as the table . The copy has the same properties as the original, unless overridden by the keyword arguments. Before each of the original values is set into the new hash-table, key is invoked on the value. As key defaults to cl:identity , a shallow copy is returned by default. maphash-keys Function: (maphash-keys function table) Like maphash , but calls function with each key in the hash table table . maphash-values Function: (maphash-values function table) Like maphash , but calls function with each value in the hash table table . hash-table-keys Function: (hash-table-keys table) Returns a list containing the keys of hash table table . hash-table-values Function: (hash-table-values table) Returns a list containing the values of hash table table . hash-table-alist Function: (hash-table-alist table) Returns an association list containing the keys and values of hash table table . hash-table-plist Function: (hash-table-plist table) Returns a property list containing the keys and values of hash table table . alist-hash-table Function: (alist-hash-table alist &rest hash-table-initargs) Returns a hash table containing the keys and values of the association list alist . Hash table is initialized using the hash-table-initargs . plist-hash-table Function: (plist-hash-table plist &rest hash-table-initargs) Returns a hash table containing the keys and values of the property list plist . Hash table is initialized using the hash-table-initargs . 2. DATA AND CONTROL FLOW define-constant Macro: (define-constant name initial-value &key test documentation) Ensures that the global variable named by name is a constant with a value that is equal under test to the result of evaluating initial-value . test is a /function designator/ that defaults to eql . If documentation is given, it becomes the documentation string of the constant. Signals an error if name is already a bound non-constant variable. Signals an error if name is already a constant variable whose value is not equal under test to result of evaluating initial-value . destructuring-case Macro: (destructuring-case keyform &body clauses) destructuring-case , -ccase , and -ecase are a combination of case and destructuring-bind . keyform must evaluate to a cons . Clauses are of the form: ((CASE-KEYS . DESTRUCTURING-LAMBDA-LIST) FORM*) The clause whose case-keys matches car of key , as if by case , ccase , or ecase , is selected, and FORMs are then executed with cdr of key is destructured and bound by the destructuring-lambda-list . Example: (defun dcase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)) ((t &rest rest) (format nil \"unknown: ~S\" rest)))) (dcase (list :foo 1 2)) ; =\"foo: 1, 2\" (dcase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (dcase (list :alt1 1)) ; =\"alt: 1\" (dcase (list :alt2 2)) ; =\"alt: 2\" (dcase (list :quux 1 2 3)) ; =\"unknown: 1, 2, 3\" (defun decase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)))) (decase (list :foo 1 2)) ; =\"foo: 1, 2\" (decase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (decase (list :alt1 1)) ; =\"alt: 1\" (decase (list :alt2 2)) ; =\"alt: 2\" (decase (list :quux 1 2 3)) ; =| error ensure-functionf Macro: (ensure-functionf &rest places) Multiple-place modify macro for ensure-function: ensures that each of places contains a function. multiple-value-prog2 Macro: (multiple-value-prog2 first-form second-form &body forms) Evaluates first-form , then second-form , and then forms . Yields as its value all the value returned by second-form . named-lambda Macro: (named-lambda name lambda-list &body body) Expands into a lambda-expression within whose body name denotes the corresponding function. nth-value-or Macro: (nth-value-or nth-value &body forms) Evaluates form arguments one at a time, until the nth-value returned by one of the forms is true. It then returns all the values returned by evaluating that form. If none of the forms return a true nth value, this form returns nil . if-let Macro: (if-let bindings &body (then-form &optional else-form)) Creates new variable bindings, and conditionally executes either then-form or else-form . else-form defaults to nil . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, the then-form is executed with the bindings in effect, otherwise the else-form is executed with the bindings in effect. when-let Macro: (when-let bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, then forms are executed as an implicit progn . Macro: (when-let* bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) Each initial-form is executed in turn, and the variable bound to the corresponding value. Initial-form expressions can refer to variables previously bound by the when-let* . Execution of when-let* stops immediately if any initial-form evaluates to nil . If all initial-forms evaluate to true, then forms are executed as an implicit progn . switch Macro: (switch whole (object &key test key) &body clauses) Evaluates first matching clause, returning its values, or evaluates and returns the values of default if no keys match. cswitch Macro: (cswitch whole (object &key test key) &body clauses) Like switch , but signals a continuable error if no key matches. eswitch Macro: (eswitch whole (object &key test key) &body clauses) Like switch , but signals an error if no key matches. whichever Macro: (whichever &rest possibilities env) Evaluates exactly one of possibilities , chosen at random. xor Macro: (xor &rest datums) Evaluates its arguments one at a time, from left to right. If more then one argument evaluates to a true value no further datums are evaluated, and nil is returned as both primary and secondary value. If exactly one argument evaluates to true, its value is returned as the primary value after all the arguments have been evaluated, and t is returned as the secondary value. If no arguments evaluate to true nil is retuned as primary, and t as secondary value. disjoin Function: (disjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning the primary value of the first predicate that returns true, without calling the remaining predicates. If none of the predicates returns true, nil is returned. conjoin Function: (conjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning nil if any of the predicates returns false, without calling the remaining predicates. If none of the predicates returns false, returns the primary value of the last predicate. compose Function: (compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to to each in turn, starting from the rightmost of more-functions , and then calling the next one with the primary value of the last. Function: (ensure-function function-designator) Returns the function designated by function-designator: if function-designator is a function, it is returned, otherwise it must be a function name and its fdefinition is returned. multiple-value-compose Function: (multiple-value-compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to each in turn, starting from the rightmost of more-functions , and then calling the next one with all the return values of the last. curry Function: (curry function &rest arguments) Returns a function that applies arguments and the arguments it is called with to function . rcurry Function: (rcurry function &rest arguments) Returns a function that applies the arguments it is called with and arguments to function . 3. CONSES proper-list Type designator for proper lists. Implemented as a satisfies type, hence not recommended for performance intensive use. Main usefullness as a type designator of the expected type in a type-error . circular-list Type designator for circular lists. Implemented as a satisfies type, so not recommended for performance intensive use. Main usefullness as the expected-type designator of a type-error . appendf Macro: (appendf place &rest lists env) Modify-macro for append . Appends lists to the place designated by the first argument. nconcf Macro: (nconcf place &rest lists env) Modify-macro for nconc . Concatenates lists to place designated by the first argument. remove-from-plistf Macro: (remove-from-plistf place &rest keys env) Modify macro for remove-from-plist . delete-from-plistf Macro: (delete-from-plistf place &rest keys env) Modify macro for delete-from-plist . reversef Macro: (reversef place env) Modify-macro for reverse . Copies and reverses the list stored in the given place and saves back the result into the place. nreversef Macro: (nreversef place env) Modify-macro for nreverse . Reverses the list stored in the given place by destructively modifying it and saves back the result into the place. unionf Macro: (unionf place list &rest args env) Modify-macro for union . Saves the union of list and the contents of the place designated by the first argument to the designated place. nunionf Macro: (nunionf place list &rest args env) Modify-macro for nunion . Saves the union of list and the contents of the place designated by the first argument to the designated place. May modify either argument. doplist Macro: (doplist (key val plist &optional values) &body body) Iterates over elements of plist . body can be preceded by declarations, and is like a tagbody . return may be used to terminate the iteration early. If return is not used, returns values . circular-list-p Function: (circular-list-p object) Returns true if object is a circular list, nil otherwise. circular-tree-p Function: (circular-tree-p object) Returns true if object is a circular tree, nil otherwise. proper-list-p Function: (proper-list-p object) Returns true if object is a proper list. alist-plist Function: (alist-plist alist) Returns a property list containing the same keys and values as the association list alist in the same order. plist-alist Function: (plist-alist plist) Returns an association list containing the same keys and values as the property list plist in the same order. circular-list Function: (circular-list &rest elements) Creates a circular list of elements . make-circular-list Function: (make-circular-list length &key initial-element) Creates a circular list of length with the given initial-element . ensure-car Function: (ensure-car thing) If thing is a cons , its car is returned. Otherwise thing is returned. ensure-cons Function: (ensure-cons cons) If cons is a cons, it is returned. Otherwise returns a fresh cons with cons in the car, and nil in the cdr. ensure-list Function: (ensure-list list) If list is a list, it is returned. Otherwise returns the list designated by list . flatten Function: (flatten tree) Traverses the tree in order, collecting non-null leaves into a list. lastcar Function: (lastcar list) Returns the last element of list . Signals a type-error if list is not a proper list. (setf Function: ((setf lastcar)) Sets the last element of list . Signals a type-error if list is not a proper list. proper-list-length Function: (proper-list-length list) Returns length of list , signalling an error if it is not a proper list. mappend Function: (mappend function &rest lists) Applies function to respective element(s) of each list , appending all the all the result list to a single list. function must return a list. map-product Function: (map-product function list &rest more-lists) Returns a list containing the results of calling function with one argument from list , and one from each of more-lists for each combination of arguments. In other words, returns the product of list and more-lists using function . Example: (map-product 'list '(1 2) '(3 4) '(5 6)) =((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6)) remove-from-plist Function: (remove-from-plist plist &rest keys) Returns a propery-list with same keys and values as plist , except that keys in the list designated by keys and values corresponding to them are removed. The returned property-list may share structure with the plist , but plist is not destructively modified. Keys are compared using eq . delete-from-plist Function: (delete-from-plist plist &rest keys) Just like remove-from-plist , but this version may destructively modify the provided plist. set-equal Function: (set-equal list1 list2 &key test key) Returns true if every element of list1 matches some element of list2 and every element of list2 matches some element of list1 . Otherwise returns false. setp Function: (setp object &key test key) Returns true if object is a list that denotes a set, nil otherwise. A list denotes a set if each element of the list is unique under key and test . 4. SEQUENCES proper-sequence Type designator for proper sequences, that is proper lists and sequences that are not lists. deletef Macro: (deletef place item &rest remove-keywords env) Modify-macro for delete . Sets place designated by the first argument to the result of calling delete with item , place, and the remove-keywords . removef Macro: (removef place item &rest remove-keywords env) Modify-macro for remove . Sets place designated by the first argument to the result of calling remove with item , place, and the remove-keywords . rotate Function: (rotate sequence &optional n) Returns a sequence of the same type as sequence , with the elements of sequence rotated by n: n elements are moved from the end of the sequence to the front if n is positive, and -n elements moved from the front to the end if n is negative. sequence must be a proper sequence. n must be an integer, defaulting to 1 . If absolute value of n is greater then the length of the sequence, the results are identical to calling rotate with (* (signum n) (mod n (length sequence))). Note: the original sequence may be destructively altered, and result sequence may share structure with it. shuffle Function: (shuffle sequence &key start end) Returns a random permutation of sequence bounded by start and end . Original sequece may be destructively modified, and share storage with the original one. Signals an error if sequence is not a proper sequence. random-elt Function: (random-elt sequence &key start end) Returns a random element from sequence bounded by start and end . Signals an error if the sequence is not a proper non-empty sequence, or if end and start are not proper bounding index designators for sequence . emptyp Function: (emptyp sequence) Returns true if sequence is an empty sequence. Signals an error if sequence is not a sequence. sequence-of-length-p Function: (sequence-of-length-p sequence length) Return true if sequence is a sequence of length length . Signals an error if sequence is not a sequence. Returns false for circular lists. length= Function: (length= &rest sequences) Takes any number of sequences or integers in any order. Returns true iff the length of all the sequences and the integers are equal. Hint: there's a compiler macro that expands into more efficient code if the first argument is a literal integer. copy-sequence Function: (copy-sequence type sequence) Returns a fresh sequence of type , which has the same elements as sequence . first-elt Function: (first-elt sequence) Returns the first element of sequence . Signals a type-error if sequence is not a sequence, or is an empty sequence. (setf first-elt) Function: ((setf first-elt)) Sets the first element of sequence . Signals a type-error if sequence is not a sequence, is an empty sequence, or if object cannot be stored in sequence . last-elt Function: (last-elt sequence) Returns the last element of sequence . Signals a type-error if sequence is not a proper sequence, or is an empty sequence. (setf last-elt) Function: ((setf last-elt)) Sets the last element of sequence . Signals a type-error if sequence is not a proper sequence, is an empty sequence, or if object cannot be stored in sequence . starts-with Function: (starts-with object sequence &key test key) Returns true if sequence is a sequence whose first element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. starts-with-subseq Function: (starts-with-subseq prefix sequence &rest args &key return-suffix &allow-other-keys) Test whether the first elements of sequence are the same (as per TEST) as the elements of prefix . If return-suffix is t the functions returns, as a second value, a displaced array pointing to the sequence after prefix . ends-with Function: (ends-with object sequence &key test key) Returns true if sequence is a sequence whose last element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. Signals an error if sequence is an improper list. ends-with-subseq Function: (ends-with-subseq suffix sequence &key test) Test whether sequence ends with suffix . In other words: return true if the last (length SUFFIX) elements of sequence are equal to suffix . map-combinations Function: (map-combinations function sequence &key start end length copy) Calls function with each combination of length constructable from the elements of the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of sequence , and length to the length of the delimited subsequence. (So unless length is specified there is only a single combination, which has the same elements as the delimited subsequence.) If copy is true (the default) each combination is freshly allocated. If copy is false all combinations are eq to each other, in which case consequences are specified if a combination is modified by function . map-derangements Function: (map-derangements function sequence &key start end copy) Calls function with each derangement of the subsequence of sequence denoted by the bounding index designators start and end . Derangement is a permutation of the sequence where no element remains in place. sequence is not modified, but individual derangements are eq to each other. Consequences are unspecified if calling function modifies either the derangement or sequence . map-permutations Function: (map-permutations function sequence &key start end length copy) Calls function with each permutation of length constructable from the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of the sequence, and length to the length of the delimited subsequence. 5. IO read-file-into-string Function: (read-file-into-string pathname &key buffer-size external-format) Return the contents of the file denoted by pathname as a fresh string. The external-format parameter will be passed directly to with-open-file unless it's nil , which means the system default. Function: (read-file-into-byte-vector pathname) Read pathname into a freshly allocated (unsigned-byte 8) vector. 6. MACRO WRITING once-only Macro: (once-only specs &body forms) Evaluates forms with symbols specified in specs rebound to temporary variables, ensuring that each initform is evaluated only once. Each of specs must either be a symbol naming the variable to be rebound, or of the form: (symbol initform) Bare symbols in specs are equivalent to (symbol symbol) Example: (defmacro cons1 (x) (once-only (x) `(cons ,x ,x))) (let ((y 0)) (cons1 (incf y))) =(1 . 1) with-gensyms Macro: (with-gensyms names &body forms) Binds each variable named by a symbol in names to a unique symbol around forms . Each of names must either be either a symbol, or of the form: (symbol string-designator) Bare symbols appearing in names are equivalent to: (symbol symbol) The string-designator is used as the argument to gensym when constructing the unique symbol the named variable will be bound to. with-unique-names Macro: (with-unique-names names &body forms) Alias for with-gensyms . featurep Function: (featurep feature-expression) Returns t if the argument matches the state of the *features* list and nil if it does not. feature-expression can be any atom or list acceptable to the reader macros #+ and #- . parse-body Function: (parse-body body &key documentation whole) Parses body into (values remaining-forms declarations doc-string). Documentation strings are recognized only if documentation is true. Syntax errors in body are signalled and whole is used in the signal arguments when given. parse-ordinary-lambda-list Function: (parse-ordinary-lambda-list lambda-list &key normalize allow-specializers normalize-optional normalize-keyword normalize-auxilary) Parses an ordinary lambda-list, returning as multiple values: 1 . Required parameters. 2 . Optional parameter specifications, normalized into form: (name init suppliedp) 3 . Name of the rest parameter, or nil . 4 . Keyword parameter specifications, normalized into form: ((keyword-name name) init suppliedp) 5 . Boolean indicating &allow-other-keys presence. 6 . &aux parameter specifications, normalized into form (name init). Signals a program-error is the lambda-list is malformed. 7. SYMBOLS ensure-symbol Function: (ensure-symbol name &optional package) Returns a symbol with name designated by name , accessible in package designated by package . If symbol is not already accessible in package , it is interned there. Returns a secondary value reflecting the status of the symbol in the package, which matches the secondary return value of intern . Example: (ensure-symbol :cons :cl) =cl:cons, :external format-symbol Function: (format-symbol package control &rest arguments) Constructs a string by applying arguments to string designator control as if by format within with-standard-io-syntax , and then creates a symbol named by that string. If package is nil , returns an uninterned symbol, if package is t , returns a symbol interned in the current package, and otherwise returns a symbol interned in the package designated by package . make-keyword Function: (make-keyword name) Interns the string designated by name in the keyword package. make-gensym Function: (make-gensym name) If name is a non-negative integer, calls gensym using it. Otherwise name must be a string designator, in which case calls gensym using the designated string as the argument. make-gensym-list Function: (make-gensym-list length &optional x) Returns a list of length gensyms, each generated as if with a call to make-gensym , using the second (optional, defaulting to \"G\") argument. symbolicate Function: (symbolicate &rest things) Concatenate together the names of some strings and symbols, producing a symbol in the current package. 8. ARRAYS array-index Type designator for an index into array of `length:` an integer between `0` (inclusive) and `length` (exclusive). `length` defaults to `array-dimension-limit`. ### array-length Type designator for a dimension of an array of length: an integer between 0 (inclusive) and length (inclusive). length defaults to array-dimension-limit . copy-array Function: (copy-array array &key element-type fill-pointer adjustable) Returns an undisplaced copy of array , with same fill-pointer and adjustability (if any) as the original, unless overridden by the keyword arguments. 9. TYPES string-designator A string designator type. A string designator is either a string, a symbol, or a character. coercef Macro: (coercef place type-spec env) Modify-macro for coerce . of-type Function: (of-type type) Returns a function of one argument, which returns true when its argument is of type . type= Function: (type= type1 type2) Returns a primary value of t is type1 and type2 are the same type, and a secondary value that is true is the type equality could be reliably determined: primary value of nil and secondary value of t indicates that the types are not equivalent. 10. NUMBERS maxf Macro: (maxf place &rest numbers env) Modify-macro for max . Sets place designated by the first argument to the maximum of its original value and numbers . minf Macro: (minf place &rest numbers env) Modify-macro for min . Sets place designated by the first argument to the minimum of its original value and numbers . binomial-coefficient Function: (binomial-coefficient n k) Binomial coefficient of n and k , also expressed as n choose k . This is the number of k element combinations given n choises. n must be equal to or greater then k . count-permutations Function: (count-permutations n &optional k) Number of k element permutations for a sequence of n objects. k defaults to n clamp Function: (clamp number min max) Clamps the number into [min, max] range. Returns min if number is lesser then min and max if number is greater then max , otherwise returns number . lerp Function: (lerp v a b) Returns the result of linear interpolation between A and b , using the interpolation coefficient v . factorial Function: (factorial n) Factorial of non-negative integer n . subfactorial Function: (subfactorial n) Subfactorial of the non-negative integer n . gaussian-random Function: (gaussian-random &optional min max) Returns two gaussian random double floats as the primary and secondary value, optionally constrained by min and max . Gaussian random numbers form a standard normal distribution around 0 .0d0. Sufficiently positive min or negative max will cause the algorithm used to take a very long time. If min is positive it should be close to zero, and similarly if max is negative it should be close to zero. iota Function: (iota n &key start step) Return a list of n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Examples: (iota 4) =(0 1 2 3) (iota 3 :start 1 :step 1.0) =(1.0 2.0 3.0) (iota 3 :start -1 :step -1/2) =(-1 -3/2 -2) map-iota Function: (map-iota function n &key start step) Calls function with n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Returns n . Examples: (map-iota #'print 3 :start 1 :step 1.0) =3 ;;; 1.0 ;;; 2.0 ;;; 3.0 mean Function: (mean sample) Returns the mean of sample . sample must be a sequence of numbers. median Function: (median sample) Returns median of sample . sample must be a sequence of real numbers. variance Function: (variance sample &key biased) Variance of sample . Returns the biased variance if biased is true (the default), and the unbiased estimator of variance if biased is false. sample must be a sequence of numbers. standard-deviation Function: (standard-deviation sample &key biased) Standard deviation of sample . Returns the biased standard deviation if biased is true (the default), and the square root of the unbiased estimator for variance if biased is false (which is not the same as the unbiased estimator for standard deviation). sample must be a sequence of numbers.","title":"alexandria - Commonly Used Utilities"},{"location":"alexandria/#alexandria-commonly-used-utilities","text":"Version: 1.0.0 Repository: alexandria/alexandria - Gitlab This documentation is modified to markdown from here on 01 March, 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here .","title":"alexandria - Commonly Used Utilities"},{"location":"alexandria/#alexandria","text":"Alexandria software and associated documentation are in the public domain: Authors dedicate this work to public domain, for the benefit of the public at large and to the detriment of the authors' heirs and successors. Authors intends this dedication to be an overt act of relinquishment in perpetuity of all present and future rights under copyright law, whether vested or contingent, in the work. Authors understands that such relinquishment of all rights includes the relinquishment of all rights to enforce (by lawsuit or otherwise) those copyrights in the work. Authors recognize that, once placed in the public domain, the work may be freely reproduced, distributed, transmitted, used, modified, built upon, or otherwise exploited by anyone for any purpose, commercial or non-commercial, and in any way, including by methods that have not yet been invented or conceived. In those legislations where public domain dedications are not recognized or possible, Alexandria is distributed under the following terms and conditions: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"ALEXANDRIA"},{"location":"alexandria/#1-hash-tables","text":"","title":"1. HASH TABLES"},{"location":"alexandria/#ensure-gethash","text":"Macro: (ensure-gethash key hash-table &optional default) Like gethash , but if key is not found in the hash-table saves the default under key before returning it. Secondary return value is true if key was already in the table.","title":"ensure-gethash"},{"location":"alexandria/#copy-hash-table","text":"Function: (copy-hash-table table &key key test size rehash-size rehash-threshold) Returns a copy of hash table table , with the same keys and values as the table . The copy has the same properties as the original, unless overridden by the keyword arguments. Before each of the original values is set into the new hash-table, key is invoked on the value. As key defaults to cl:identity , a shallow copy is returned by default.","title":"copy-hash-table"},{"location":"alexandria/#maphash-keys","text":"Function: (maphash-keys function table) Like maphash , but calls function with each key in the hash table table .","title":"maphash-keys"},{"location":"alexandria/#maphash-values","text":"Function: (maphash-values function table) Like maphash , but calls function with each value in the hash table table .","title":"maphash-values"},{"location":"alexandria/#hash-table-keys","text":"Function: (hash-table-keys table) Returns a list containing the keys of hash table table .","title":"hash-table-keys"},{"location":"alexandria/#hash-table-values","text":"Function: (hash-table-values table) Returns a list containing the values of hash table table .","title":"hash-table-values"},{"location":"alexandria/#hash-table-alist","text":"Function: (hash-table-alist table) Returns an association list containing the keys and values of hash table table .","title":"hash-table-alist"},{"location":"alexandria/#hash-table-plist","text":"Function: (hash-table-plist table) Returns a property list containing the keys and values of hash table table .","title":"hash-table-plist"},{"location":"alexandria/#alist-hash-table","text":"Function: (alist-hash-table alist &rest hash-table-initargs) Returns a hash table containing the keys and values of the association list alist . Hash table is initialized using the hash-table-initargs .","title":"alist-hash-table"},{"location":"alexandria/#plist-hash-table","text":"Function: (plist-hash-table plist &rest hash-table-initargs) Returns a hash table containing the keys and values of the property list plist . Hash table is initialized using the hash-table-initargs .","title":"plist-hash-table"},{"location":"alexandria/#2-data-and-control-flow","text":"","title":"2. DATA AND CONTROL FLOW"},{"location":"alexandria/#define-constant","text":"Macro: (define-constant name initial-value &key test documentation) Ensures that the global variable named by name is a constant with a value that is equal under test to the result of evaluating initial-value . test is a /function designator/ that defaults to eql . If documentation is given, it becomes the documentation string of the constant. Signals an error if name is already a bound non-constant variable. Signals an error if name is already a constant variable whose value is not equal under test to result of evaluating initial-value .","title":"define-constant"},{"location":"alexandria/#destructuring-case","text":"Macro: (destructuring-case keyform &body clauses) destructuring-case , -ccase , and -ecase are a combination of case and destructuring-bind . keyform must evaluate to a cons . Clauses are of the form: ((CASE-KEYS . DESTRUCTURING-LAMBDA-LIST) FORM*) The clause whose case-keys matches car of key , as if by case , ccase , or ecase , is selected, and FORMs are then executed with cdr of key is destructured and bound by the destructuring-lambda-list . Example: (defun dcase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)) ((t &rest rest) (format nil \"unknown: ~S\" rest)))) (dcase (list :foo 1 2)) ; =\"foo: 1, 2\" (dcase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (dcase (list :alt1 1)) ; =\"alt: 1\" (dcase (list :alt2 2)) ; =\"alt: 2\" (dcase (list :quux 1 2 3)) ; =\"unknown: 1, 2, 3\" (defun decase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)))) (decase (list :foo 1 2)) ; =\"foo: 1, 2\" (decase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (decase (list :alt1 1)) ; =\"alt: 1\" (decase (list :alt2 2)) ; =\"alt: 2\" (decase (list :quux 1 2 3)) ; =| error","title":"destructuring-case"},{"location":"alexandria/#ensure-functionf","text":"Macro: (ensure-functionf &rest places) Multiple-place modify macro for ensure-function: ensures that each of places contains a function.","title":"ensure-functionf"},{"location":"alexandria/#multiple-value-prog2","text":"Macro: (multiple-value-prog2 first-form second-form &body forms) Evaluates first-form , then second-form , and then forms . Yields as its value all the value returned by second-form .","title":"multiple-value-prog2"},{"location":"alexandria/#named-lambda","text":"Macro: (named-lambda name lambda-list &body body) Expands into a lambda-expression within whose body name denotes the corresponding function.","title":"named-lambda"},{"location":"alexandria/#nth-value-or","text":"Macro: (nth-value-or nth-value &body forms) Evaluates form arguments one at a time, until the nth-value returned by one of the forms is true. It then returns all the values returned by evaluating that form. If none of the forms return a true nth value, this form returns nil .","title":"nth-value-or"},{"location":"alexandria/#if-let","text":"Macro: (if-let bindings &body (then-form &optional else-form)) Creates new variable bindings, and conditionally executes either then-form or else-form . else-form defaults to nil . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, the then-form is executed with the bindings in effect, otherwise the else-form is executed with the bindings in effect.","title":"if-let"},{"location":"alexandria/#when-let","text":"Macro: (when-let bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, then forms are executed as an implicit progn . Macro: (when-let* bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) Each initial-form is executed in turn, and the variable bound to the corresponding value. Initial-form expressions can refer to variables previously bound by the when-let* . Execution of when-let* stops immediately if any initial-form evaluates to nil . If all initial-forms evaluate to true, then forms are executed as an implicit progn .","title":"when-let"},{"location":"alexandria/#switch","text":"Macro: (switch whole (object &key test key) &body clauses) Evaluates first matching clause, returning its values, or evaluates and returns the values of default if no keys match.","title":"switch"},{"location":"alexandria/#cswitch","text":"Macro: (cswitch whole (object &key test key) &body clauses) Like switch , but signals a continuable error if no key matches.","title":"cswitch"},{"location":"alexandria/#eswitch","text":"Macro: (eswitch whole (object &key test key) &body clauses) Like switch , but signals an error if no key matches.","title":"eswitch"},{"location":"alexandria/#whichever","text":"Macro: (whichever &rest possibilities env) Evaluates exactly one of possibilities , chosen at random.","title":"whichever"},{"location":"alexandria/#xor","text":"Macro: (xor &rest datums) Evaluates its arguments one at a time, from left to right. If more then one argument evaluates to a true value no further datums are evaluated, and nil is returned as both primary and secondary value. If exactly one argument evaluates to true, its value is returned as the primary value after all the arguments have been evaluated, and t is returned as the secondary value. If no arguments evaluate to true nil is retuned as primary, and t as secondary value.","title":"xor"},{"location":"alexandria/#disjoin","text":"Function: (disjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning the primary value of the first predicate that returns true, without calling the remaining predicates. If none of the predicates returns true, nil is returned.","title":"disjoin"},{"location":"alexandria/#conjoin","text":"Function: (conjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning nil if any of the predicates returns false, without calling the remaining predicates. If none of the predicates returns false, returns the primary value of the last predicate.","title":"conjoin"},{"location":"alexandria/#compose","text":"Function: (compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to to each in turn, starting from the rightmost of more-functions , and then calling the next one with the primary value of the last. Function: (ensure-function function-designator) Returns the function designated by function-designator: if function-designator is a function, it is returned, otherwise it must be a function name and its fdefinition is returned.","title":"compose"},{"location":"alexandria/#multiple-value-compose","text":"Function: (multiple-value-compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to each in turn, starting from the rightmost of more-functions , and then calling the next one with all the return values of the last.","title":"multiple-value-compose"},{"location":"alexandria/#curry","text":"Function: (curry function &rest arguments) Returns a function that applies arguments and the arguments it is called with to function .","title":"curry"},{"location":"alexandria/#rcurry","text":"Function: (rcurry function &rest arguments) Returns a function that applies the arguments it is called with and arguments to function .","title":"rcurry"},{"location":"alexandria/#3-conses","text":"","title":"3. CONSES"},{"location":"alexandria/#proper-list","text":"Type designator for proper lists. Implemented as a satisfies type, hence not recommended for performance intensive use. Main usefullness as a type designator of the expected type in a type-error .","title":"proper-list"},{"location":"alexandria/#circular-list","text":"Type designator for circular lists. Implemented as a satisfies type, so not recommended for performance intensive use. Main usefullness as the expected-type designator of a type-error .","title":"circular-list"},{"location":"alexandria/#appendf","text":"Macro: (appendf place &rest lists env) Modify-macro for append . Appends lists to the place designated by the first argument.","title":"appendf"},{"location":"alexandria/#nconcf","text":"Macro: (nconcf place &rest lists env) Modify-macro for nconc . Concatenates lists to place designated by the first argument.","title":"nconcf"},{"location":"alexandria/#remove-from-plistf","text":"Macro: (remove-from-plistf place &rest keys env) Modify macro for remove-from-plist .","title":"remove-from-plistf"},{"location":"alexandria/#delete-from-plistf","text":"Macro: (delete-from-plistf place &rest keys env) Modify macro for delete-from-plist .","title":"delete-from-plistf"},{"location":"alexandria/#reversef","text":"Macro: (reversef place env) Modify-macro for reverse . Copies and reverses the list stored in the given place and saves back the result into the place.","title":"reversef"},{"location":"alexandria/#nreversef","text":"Macro: (nreversef place env) Modify-macro for nreverse . Reverses the list stored in the given place by destructively modifying it and saves back the result into the place.","title":"nreversef"},{"location":"alexandria/#unionf","text":"Macro: (unionf place list &rest args env) Modify-macro for union . Saves the union of list and the contents of the place designated by the first argument to the designated place.","title":"unionf"},{"location":"alexandria/#nunionf","text":"Macro: (nunionf place list &rest args env) Modify-macro for nunion . Saves the union of list and the contents of the place designated by the first argument to the designated place. May modify either argument.","title":"nunionf"},{"location":"alexandria/#doplist","text":"Macro: (doplist (key val plist &optional values) &body body) Iterates over elements of plist . body can be preceded by declarations, and is like a tagbody . return may be used to terminate the iteration early. If return is not used, returns values .","title":"doplist"},{"location":"alexandria/#circular-list-p","text":"Function: (circular-list-p object) Returns true if object is a circular list, nil otherwise.","title":"circular-list-p"},{"location":"alexandria/#circular-tree-p","text":"Function: (circular-tree-p object) Returns true if object is a circular tree, nil otherwise.","title":"circular-tree-p"},{"location":"alexandria/#proper-list-p","text":"Function: (proper-list-p object) Returns true if object is a proper list.","title":"proper-list-p"},{"location":"alexandria/#alist-plist","text":"Function: (alist-plist alist) Returns a property list containing the same keys and values as the association list alist in the same order.","title":"alist-plist"},{"location":"alexandria/#plist-alist","text":"Function: (plist-alist plist) Returns an association list containing the same keys and values as the property list plist in the same order.","title":"plist-alist"},{"location":"alexandria/#circular-list_1","text":"Function: (circular-list &rest elements) Creates a circular list of elements .","title":"circular-list"},{"location":"alexandria/#make-circular-list","text":"Function: (make-circular-list length &key initial-element) Creates a circular list of length with the given initial-element .","title":"make-circular-list"},{"location":"alexandria/#ensure-car","text":"Function: (ensure-car thing) If thing is a cons , its car is returned. Otherwise thing is returned.","title":"ensure-car"},{"location":"alexandria/#ensure-cons","text":"Function: (ensure-cons cons) If cons is a cons, it is returned. Otherwise returns a fresh cons with cons in the car, and nil in the cdr.","title":"ensure-cons"},{"location":"alexandria/#ensure-list","text":"Function: (ensure-list list) If list is a list, it is returned. Otherwise returns the list designated by list .","title":"ensure-list"},{"location":"alexandria/#flatten","text":"Function: (flatten tree) Traverses the tree in order, collecting non-null leaves into a list.","title":"flatten"},{"location":"alexandria/#lastcar","text":"Function: (lastcar list) Returns the last element of list . Signals a type-error if list is not a proper list.","title":"lastcar"},{"location":"alexandria/#setf","text":"Function: ((setf lastcar)) Sets the last element of list . Signals a type-error if list is not a proper list.","title":"(setf"},{"location":"alexandria/#proper-list-length","text":"Function: (proper-list-length list) Returns length of list , signalling an error if it is not a proper list.","title":"proper-list-length"},{"location":"alexandria/#mappend","text":"Function: (mappend function &rest lists) Applies function to respective element(s) of each list , appending all the all the result list to a single list. function must return a list.","title":"mappend"},{"location":"alexandria/#map-product","text":"Function: (map-product function list &rest more-lists) Returns a list containing the results of calling function with one argument from list , and one from each of more-lists for each combination of arguments. In other words, returns the product of list and more-lists using function . Example: (map-product 'list '(1 2) '(3 4) '(5 6)) =((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6))","title":"map-product"},{"location":"alexandria/#remove-from-plist","text":"Function: (remove-from-plist plist &rest keys) Returns a propery-list with same keys and values as plist , except that keys in the list designated by keys and values corresponding to them are removed. The returned property-list may share structure with the plist , but plist is not destructively modified. Keys are compared using eq .","title":"remove-from-plist"},{"location":"alexandria/#delete-from-plist","text":"Function: (delete-from-plist plist &rest keys) Just like remove-from-plist , but this version may destructively modify the provided plist.","title":"delete-from-plist"},{"location":"alexandria/#set-equal","text":"Function: (set-equal list1 list2 &key test key) Returns true if every element of list1 matches some element of list2 and every element of list2 matches some element of list1 . Otherwise returns false.","title":"set-equal"},{"location":"alexandria/#setp","text":"Function: (setp object &key test key) Returns true if object is a list that denotes a set, nil otherwise. A list denotes a set if each element of the list is unique under key and test .","title":"setp"},{"location":"alexandria/#4-sequences","text":"","title":"4. SEQUENCES"},{"location":"alexandria/#proper-sequence","text":"Type designator for proper sequences, that is proper lists and sequences that are not lists.","title":"proper-sequence"},{"location":"alexandria/#deletef","text":"Macro: (deletef place item &rest remove-keywords env) Modify-macro for delete . Sets place designated by the first argument to the result of calling delete with item , place, and the remove-keywords .","title":"deletef"},{"location":"alexandria/#removef","text":"Macro: (removef place item &rest remove-keywords env) Modify-macro for remove . Sets place designated by the first argument to the result of calling remove with item , place, and the remove-keywords .","title":"removef"},{"location":"alexandria/#rotate","text":"Function: (rotate sequence &optional n) Returns a sequence of the same type as sequence , with the elements of sequence rotated by n: n elements are moved from the end of the sequence to the front if n is positive, and -n elements moved from the front to the end if n is negative. sequence must be a proper sequence. n must be an integer, defaulting to 1 . If absolute value of n is greater then the length of the sequence, the results are identical to calling rotate with (* (signum n) (mod n (length sequence))). Note: the original sequence may be destructively altered, and result sequence may share structure with it.","title":"rotate"},{"location":"alexandria/#shuffle","text":"Function: (shuffle sequence &key start end) Returns a random permutation of sequence bounded by start and end . Original sequece may be destructively modified, and share storage with the original one. Signals an error if sequence is not a proper sequence.","title":"shuffle"},{"location":"alexandria/#random-elt","text":"Function: (random-elt sequence &key start end) Returns a random element from sequence bounded by start and end . Signals an error if the sequence is not a proper non-empty sequence, or if end and start are not proper bounding index designators for sequence .","title":"random-elt"},{"location":"alexandria/#emptyp","text":"Function: (emptyp sequence) Returns true if sequence is an empty sequence. Signals an error if sequence is not a sequence.","title":"emptyp"},{"location":"alexandria/#sequence-of-length-p","text":"Function: (sequence-of-length-p sequence length) Return true if sequence is a sequence of length length . Signals an error if sequence is not a sequence. Returns false for circular lists.","title":"sequence-of-length-p"},{"location":"alexandria/#length","text":"Function: (length= &rest sequences) Takes any number of sequences or integers in any order. Returns true iff the length of all the sequences and the integers are equal. Hint: there's a compiler macro that expands into more efficient code if the first argument is a literal integer.","title":"length="},{"location":"alexandria/#copy-sequence","text":"Function: (copy-sequence type sequence) Returns a fresh sequence of type , which has the same elements as sequence .","title":"copy-sequence"},{"location":"alexandria/#first-elt","text":"Function: (first-elt sequence) Returns the first element of sequence . Signals a type-error if sequence is not a sequence, or is an empty sequence.","title":"first-elt"},{"location":"alexandria/#setf-first-elt","text":"Function: ((setf first-elt)) Sets the first element of sequence . Signals a type-error if sequence is not a sequence, is an empty sequence, or if object cannot be stored in sequence .","title":"(setf first-elt)"},{"location":"alexandria/#last-elt","text":"Function: (last-elt sequence) Returns the last element of sequence . Signals a type-error if sequence is not a proper sequence, or is an empty sequence.","title":"last-elt"},{"location":"alexandria/#setf-last-elt","text":"Function: ((setf last-elt)) Sets the last element of sequence . Signals a type-error if sequence is not a proper sequence, is an empty sequence, or if object cannot be stored in sequence .","title":"(setf last-elt)"},{"location":"alexandria/#starts-with","text":"Function: (starts-with object sequence &key test key) Returns true if sequence is a sequence whose first element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence.","title":"starts-with"},{"location":"alexandria/#starts-with-subseq","text":"Function: (starts-with-subseq prefix sequence &rest args &key return-suffix &allow-other-keys) Test whether the first elements of sequence are the same (as per TEST) as the elements of prefix . If return-suffix is t the functions returns, as a second value, a displaced array pointing to the sequence after prefix .","title":"starts-with-subseq"},{"location":"alexandria/#ends-with","text":"Function: (ends-with object sequence &key test key) Returns true if sequence is a sequence whose last element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. Signals an error if sequence is an improper list.","title":"ends-with"},{"location":"alexandria/#ends-with-subseq","text":"Function: (ends-with-subseq suffix sequence &key test) Test whether sequence ends with suffix . In other words: return true if the last (length SUFFIX) elements of sequence are equal to suffix .","title":"ends-with-subseq"},{"location":"alexandria/#map-combinations","text":"Function: (map-combinations function sequence &key start end length copy) Calls function with each combination of length constructable from the elements of the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of sequence , and length to the length of the delimited subsequence. (So unless length is specified there is only a single combination, which has the same elements as the delimited subsequence.) If copy is true (the default) each combination is freshly allocated. If copy is false all combinations are eq to each other, in which case consequences are specified if a combination is modified by function .","title":"map-combinations"},{"location":"alexandria/#map-derangements","text":"Function: (map-derangements function sequence &key start end copy) Calls function with each derangement of the subsequence of sequence denoted by the bounding index designators start and end . Derangement is a permutation of the sequence where no element remains in place. sequence is not modified, but individual derangements are eq to each other. Consequences are unspecified if calling function modifies either the derangement or sequence .","title":"map-derangements"},{"location":"alexandria/#map-permutations","text":"Function: (map-permutations function sequence &key start end length copy) Calls function with each permutation of length constructable from the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of the sequence, and length to the length of the delimited subsequence.","title":"map-permutations"},{"location":"alexandria/#5-io","text":"","title":"5. IO"},{"location":"alexandria/#read-file-into-string","text":"Function: (read-file-into-string pathname &key buffer-size external-format) Return the contents of the file denoted by pathname as a fresh string. The external-format parameter will be passed directly to with-open-file unless it's nil , which means the system default. Function: (read-file-into-byte-vector pathname) Read pathname into a freshly allocated (unsigned-byte 8) vector.","title":"read-file-into-string"},{"location":"alexandria/#6-macro-writing","text":"","title":"6. MACRO WRITING"},{"location":"alexandria/#once-only","text":"Macro: (once-only specs &body forms) Evaluates forms with symbols specified in specs rebound to temporary variables, ensuring that each initform is evaluated only once. Each of specs must either be a symbol naming the variable to be rebound, or of the form: (symbol initform) Bare symbols in specs are equivalent to (symbol symbol) Example: (defmacro cons1 (x) (once-only (x) `(cons ,x ,x))) (let ((y 0)) (cons1 (incf y))) =(1 . 1)","title":"once-only"},{"location":"alexandria/#with-gensyms","text":"Macro: (with-gensyms names &body forms) Binds each variable named by a symbol in names to a unique symbol around forms . Each of names must either be either a symbol, or of the form: (symbol string-designator) Bare symbols appearing in names are equivalent to: (symbol symbol) The string-designator is used as the argument to gensym when constructing the unique symbol the named variable will be bound to.","title":"with-gensyms"},{"location":"alexandria/#with-unique-names","text":"Macro: (with-unique-names names &body forms) Alias for with-gensyms .","title":"with-unique-names"},{"location":"alexandria/#featurep","text":"Function: (featurep feature-expression) Returns t if the argument matches the state of the *features* list and nil if it does not. feature-expression can be any atom or list acceptable to the reader macros #+ and #- .","title":"featurep"},{"location":"alexandria/#parse-body","text":"Function: (parse-body body &key documentation whole) Parses body into (values remaining-forms declarations doc-string). Documentation strings are recognized only if documentation is true. Syntax errors in body are signalled and whole is used in the signal arguments when given.","title":"parse-body"},{"location":"alexandria/#parse-ordinary-lambda-list","text":"Function: (parse-ordinary-lambda-list lambda-list &key normalize allow-specializers normalize-optional normalize-keyword normalize-auxilary) Parses an ordinary lambda-list, returning as multiple values: 1 . Required parameters. 2 . Optional parameter specifications, normalized into form: (name init suppliedp) 3 . Name of the rest parameter, or nil . 4 . Keyword parameter specifications, normalized into form: ((keyword-name name) init suppliedp) 5 . Boolean indicating &allow-other-keys presence. 6 . &aux parameter specifications, normalized into form (name init). Signals a program-error is the lambda-list is malformed.","title":"parse-ordinary-lambda-list"},{"location":"alexandria/#7-symbols","text":"","title":"7. SYMBOLS"},{"location":"alexandria/#ensure-symbol","text":"Function: (ensure-symbol name &optional package) Returns a symbol with name designated by name , accessible in package designated by package . If symbol is not already accessible in package , it is interned there. Returns a secondary value reflecting the status of the symbol in the package, which matches the secondary return value of intern . Example: (ensure-symbol :cons :cl) =cl:cons, :external","title":"ensure-symbol"},{"location":"alexandria/#format-symbol","text":"Function: (format-symbol package control &rest arguments) Constructs a string by applying arguments to string designator control as if by format within with-standard-io-syntax , and then creates a symbol named by that string. If package is nil , returns an uninterned symbol, if package is t , returns a symbol interned in the current package, and otherwise returns a symbol interned in the package designated by package .","title":"format-symbol"},{"location":"alexandria/#make-keyword","text":"Function: (make-keyword name) Interns the string designated by name in the keyword package.","title":"make-keyword"},{"location":"alexandria/#make-gensym","text":"Function: (make-gensym name) If name is a non-negative integer, calls gensym using it. Otherwise name must be a string designator, in which case calls gensym using the designated string as the argument.","title":"make-gensym"},{"location":"alexandria/#make-gensym-list","text":"Function: (make-gensym-list length &optional x) Returns a list of length gensyms, each generated as if with a call to make-gensym , using the second (optional, defaulting to \"G\") argument.","title":"make-gensym-list"},{"location":"alexandria/#symbolicate","text":"Function: (symbolicate &rest things) Concatenate together the names of some strings and symbols, producing a symbol in the current package.","title":"symbolicate"},{"location":"alexandria/#8-arrays","text":"","title":"8. ARRAYS"},{"location":"alexandria/#array-index","text":"Type designator for an index into array of `length:` an integer between `0` (inclusive) and `length` (exclusive). `length` defaults to `array-dimension-limit`. ### array-length Type designator for a dimension of an array of length: an integer between 0 (inclusive) and length (inclusive). length defaults to array-dimension-limit .","title":"array-index"},{"location":"alexandria/#copy-array","text":"Function: (copy-array array &key element-type fill-pointer adjustable) Returns an undisplaced copy of array , with same fill-pointer and adjustability (if any) as the original, unless overridden by the keyword arguments.","title":"copy-array"},{"location":"alexandria/#9-types","text":"","title":"9. TYPES"},{"location":"alexandria/#string-designator","text":"A string designator type. A string designator is either a string, a symbol, or a character.","title":"string-designator"},{"location":"alexandria/#coercef","text":"Macro: (coercef place type-spec env) Modify-macro for coerce .","title":"coercef"},{"location":"alexandria/#of-type","text":"Function: (of-type type) Returns a function of one argument, which returns true when its argument is of type .","title":"of-type"},{"location":"alexandria/#type","text":"Function: (type= type1 type2) Returns a primary value of t is type1 and type2 are the same type, and a secondary value that is true is the type equality could be reliably determined: primary value of nil and secondary value of t indicates that the types are not equivalent.","title":"type="},{"location":"alexandria/#10-numbers","text":"","title":"10. NUMBERS"},{"location":"alexandria/#maxf","text":"Macro: (maxf place &rest numbers env) Modify-macro for max . Sets place designated by the first argument to the maximum of its original value and numbers .","title":"maxf"},{"location":"alexandria/#minf","text":"Macro: (minf place &rest numbers env) Modify-macro for min . Sets place designated by the first argument to the minimum of its original value and numbers .","title":"minf"},{"location":"alexandria/#binomial-coefficient","text":"Function: (binomial-coefficient n k) Binomial coefficient of n and k , also expressed as n choose k . This is the number of k element combinations given n choises. n must be equal to or greater then k .","title":"binomial-coefficient"},{"location":"alexandria/#count-permutations","text":"Function: (count-permutations n &optional k) Number of k element permutations for a sequence of n objects. k defaults to n","title":"count-permutations"},{"location":"alexandria/#clamp","text":"Function: (clamp number min max) Clamps the number into [min, max] range. Returns min if number is lesser then min and max if number is greater then max , otherwise returns number .","title":"clamp"},{"location":"alexandria/#lerp","text":"Function: (lerp v a b) Returns the result of linear interpolation between A and b , using the interpolation coefficient v .","title":"lerp"},{"location":"alexandria/#factorial","text":"Function: (factorial n) Factorial of non-negative integer n .","title":"factorial"},{"location":"alexandria/#subfactorial","text":"Function: (subfactorial n) Subfactorial of the non-negative integer n .","title":"subfactorial"},{"location":"alexandria/#gaussian-random","text":"Function: (gaussian-random &optional min max) Returns two gaussian random double floats as the primary and secondary value, optionally constrained by min and max . Gaussian random numbers form a standard normal distribution around 0 .0d0. Sufficiently positive min or negative max will cause the algorithm used to take a very long time. If min is positive it should be close to zero, and similarly if max is negative it should be close to zero.","title":"gaussian-random"},{"location":"alexandria/#iota","text":"Function: (iota n &key start step) Return a list of n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Examples: (iota 4) =(0 1 2 3) (iota 3 :start 1 :step 1.0) =(1.0 2.0 3.0) (iota 3 :start -1 :step -1/2) =(-1 -3/2 -2)","title":"iota"},{"location":"alexandria/#map-iota","text":"Function: (map-iota function n &key start step) Calls function with n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Returns n . Examples: (map-iota #'print 3 :start 1 :step 1.0) =3 ;;; 1.0 ;;; 2.0 ;;; 3.0","title":"map-iota"},{"location":"alexandria/#mean","text":"Function: (mean sample) Returns the mean of sample . sample must be a sequence of numbers.","title":"mean"},{"location":"alexandria/#median","text":"Function: (median sample) Returns median of sample . sample must be a sequence of real numbers.","title":"median"},{"location":"alexandria/#variance","text":"Function: (variance sample &key biased) Variance of sample . Returns the biased variance if biased is true (the default), and the unbiased estimator of variance if biased is false. sample must be a sequence of numbers.","title":"variance"},{"location":"alexandria/#standard-deviation","text":"Function: (standard-deviation sample &key biased) Standard deviation of sample . Returns the biased standard deviation if biased is true (the default), and the square root of the unbiased estimator for variance if biased is false (which is not the same as the unbiased estimator for standard deviation). sample must be a sequence of numbers.","title":"standard-deviation"},{"location":"asdf/","text":"asdf - Build System Version: 3.3.1 Repository: asdf/asdf - Gitlab In case of any inaccuracies, ambiguities or suggestions, please create an issue here . ASDF, or Another System Definition Facility, is a build system: a tool for specifying how systems of Common Lisp software are made up of components (sub-systems and files), and how to operate on these components in the right order so that they can be compiled, loaded, tested, etc. ASDF also includes UIOP, currently not documented here. Getting Started All actively maintained lisp implementations these days include a copy of ASDF 3 that can be simply loaded using (require \"asdf\") - in fact, loading quicklisp takes care of require -ing asdf. (asdf:asdf-version) will inform you of the version (should be >3). For details, you may want to refer to the section on Loading ASDF in the manual. ASDF must be configured to find the .asd files containing the system definition. If you are using quicklisp - and we recommend you do - for your own projects, you only need to consider ql:*local-project-directories* . For details, see the section on Configuring ASDF in the manual. Trivial System Definition (defsystem \"foobar\" :description \"A system definition to demonstrate ASDF\" :version \"0.1.0\" :serial t :license \"BSD\" :pathname \"src/\" :depends-on (\"alexandria\" (:version \"some-new-system\" \"0.7.3\")) :components ((:file \"foo\") ; .lisp is implicit for :file (:file \"baz\") ; this lies in src/ (:module \"bar\" :components ((:file \"bar-1\") ; this lies in src/bar/ (:file \"bar-2\"))) (:static-file \"LICENCE\" :pathname #P\"LICENCE\")) :in-order-to ((test-op (test-op \"foobar/tests\"))) ;; The following is not recommended - for demonstration of :perform ;; and operations (see next section) only. :perform (load-op (o c) (format t \"Loading foobar\"))) (defsystem \"foobar/tests\" :depends-on (\"foobar\" \"fiveam\") :components ((:file \"foobar-tests\")) :perform (test-op (o c) (uiop:symbol-call :fiveam '#:run! :foobar))) These definitions should go inside a file named \"foobar.asd\" , located somewhere quicklisp/ASDF can find (see previous section). As of ASDF 3.1, the depends-on version translates to 0.7.3+. (TODO: What about ASDF 3.3? Will this ever change in future?) Usually, you'd be basing yourself on a particular version of quicklisp dist . However, if you actually need it, qlot should be helpful. The :serial t states that each item in the :components depends on all of the previous items. When efficiency is a concern, you may want to explicitly specify the list of dependencies a particular component depends on (:file \"baz\" :depends-on (\"foo\")) . Thus, the way things are defined, the system \"foobar\" can simply be tested by calling (asdf:test-system \"foobar\") . Finally, a note on naming: system names are recommended to be named using lower-cased strings without underscores. There exist what are known as primary systems - with the system name being same as the filename without the .asd extension - and secondary systems. Here, \"foobar\" is the primary system. \"foobar/tests\" is a secondary system. The primary system of a secondary system can be found by noting the / as delimiters. A (secondary) system \"foo/bar\" would be looked up in the file \"foo.asd\". Operations ASDF has the concept of an operation that can act upon a system (or a smaller component thereof). Typical operations that matter to end-users include: load-op for loading a system in the current Lisp image, as used by asdf:load-system , test-op for running tests associated to the system, as used by asdf:test-system , build-op for doing whatever build operation is associated to the system, (which by default is load-op if the system didn't override it), as used by asdf:make . Further operations of interest to users include: compile-op ensure the system is compiled, without necessarily loading all of it, or any bit of it, load-source-op load the system from source without compiling, compile-bundle-op create a single fasl for the entire system, for delivery, monolithic-compile-bundle-op create a single fasl for the entire system and all its transitive dependencies , for delivery, image-op create a development image with this system already loaded, for fast startup, program-op create a standalone application, which we will see below, etc. Whichever operation you want, asdf:operate ( (asdf:operate operation system ) ) will ensure this operation is performed on that system (after all the necessary dependencies of such an action). A short-hand asdf:oos acts as an acronym for asdf:operate . The operation is typically specified as a symbol that names the operation class. Since ASDF 3, you can also use a keyword to specify an action in the ASDF package. Thus, (asdf:oos :load-op :foobar) is equivalent to (asdf:load-system :foobar) . Whichever operation a system is intended to be used with can be invoked with make : (asdf:make :foo) and specified with build-op . (TODO: Confirm make invokes load-op before invoking build-op if both are defined. Why? What's going on under the hood? There is also the concept of dependency between operations.) TODO: Are there other ways to specify what an operation should do other than :perform clause? TODO: What exactly is the utility of a static file? Perhaps, for bundling data files. Data can then be read from such a file by getting asdf:component-pathname . But what happens if you bundle the system into an image? A note on Systems and Packages What one might call packages in other languages are called systems in Common Lisp parlance. Instead, the word package in Common Lisp refers to a data structure providing namespacing for symbols. By contrast, a system is a tool to organize a bunch of files, in accordance with dependencies, and specifying how to perform certain actions on the system. A single system may contain multiple packages. See this StackOverFlow answer for a detailed discussion. ASDF also provides package-inferred-system to make the \"one file, one package, one system\" style easier to use. However, most systems in the wild usually have one main system, several packages, each package spanning several files; each file packing together some relevant functionality. Your IDE (often SLIME) should be the one telling you who calls/sets/macroexpands/etc something. Of use also are M-. (slime-edit-definition) and M-, (slime-pop-find-definition-stack). More Reading ASDF Best Practices ASDF Manual Building self-contained executables - The Common Lisp Cookbook API REFERENCE *central-registry* Variable A list of 'system directory designators' ASDF uses to find systems. A 'system directory designator' is a pathname or an expression which evaluates to a pathname. For example: (setf asdf:*central-registry* (list '*default-pathname-defaults* #p\"/home/me/cl/systems/\" #p\"/usr/share/common-lisp/systems/\")) This variable is for backward compatibility. Going forward, we recommend new users should be using the source-registry. *compile-file-failure-behaviour* Variable How should ASDF react if it encounters a failure (per the ANSI spec of COMPILE-FILE) when compiling a file, which includes any non-style-warning warning. Valid values are :error, :warn, and :ignore. Note that ASDF ALWAYS raises an error if it fails to create an output file when compiling. *compile-file-warnings-behaviour* Variable How should ASDF react if it encounters a warning when compiling a file? Valid values are :error, :warn, and :ignore. *default-encoding* Variable Default encoding for source files. The default value :utf-8 is the portable thing. The legacy behavior was :default. If you (asdf:load-system :asdf-encodings) then you will have autodetection via encoding-detection-hook below, reading emacs-style - - coding: utf-8 - - specifications, and falling back to utf-8 or latin1 if nothing is specified. *default-source-registries* Variable List of default source registries *encoding-detection-hook* Variable Hook for an extension to define a function to automatically detect a file's encoding *encoding-external-format-hook* Variable Hook for an extension (e.g. ASDF-ENCODINGS) to define a better mapping from non-default encodings to and implementation-defined external-format's *resolve-symlinks* Variable Determine whether or not ASDF resolves symlinks when defining systems. Defaults to T. *system-definition-search-functions* Variable A list that controls the ways that ASDF looks for system definitions. It contains symbols to be funcalled in order, with a requested system name as argument, until one returns a non-NIL result (if any), which must then be a fully initialized system object with that name. *user-cache* Variable A specification as per resolve-location of where the user keeps his FASL cache *utf-8-external-format* Variable Default :external-format argument to pass to CL:OPEN and also CL:LOAD or CL:COMPILE-FILE to best process a UTF-8 encoded file. On modern implementations, this will decode UTF-8 code points as CL characters. On legacy implementations, it may fall back on some 8-bit encoding, with non-ASCII code points being read as several CL characters; hopefully, if done consistently, that won't affect program behavior too much. *warnings-file-type* Variable Pathname type for warnings files, or NIL if disabled action-description Generic Function: (action-description operation component) returns a phrase that describes performing this operation on this component, e.g. \"loading /a/b/c\". You can put together sentences using this phrase. additional-input-files Generic Function: (additional-input-files operation component) Additional input files for the operation on this component. These are files that are inferred, rather than explicitly specified, and these are typically NOT files that undergo operations directly. Instead, they are files that it is important for ASDF to know about in order to compute operation times,etc. already-loaded-systems Function: (already-loaded-systems) return a list of the names of the systems that have been successfully loaded so far apply-output-translations Function: (apply-output-translations path) asdf-message Function: (asdf-message format-string &rest format-args) asdf-version Function: (asdf-version) Exported interface to the version of ASDF currently installed. A string. You can compare this string with e.g.: (ASDF: version-satisfies (ASDF: asdf-version ) \"3.4.5.67\"). bad-system-name Condition Direct Slots asdf/component:name Initargs: :NAME Readers: ASDF/COMPONENT:COMPONENT-NAME asdf/component:source-file Initargs: :SOURCE-FILE Readers: ASDF/SYSTEM:SYSTEM-SOURCE-FILE basic-compile-bundle-op Class Base class for compiling into a bundle Direct Slots asdf/bundle::gather-type asdf/bundle:bundle-type build-op Class Since ASDF3, BUILD-OP is the recommended 'master' operation, to operate by default on a system or component, via the function BUILD. Its meaning is configurable via the :BUILD-OPERATION option of a component. which typically specifies the name of a specific operation to which to delegate the build, as a symbol or as a string later read as a symbol (after loading the defsystem-depends-on); if NIL is specified (the default), BUILD-OP falls back to LOAD-OP, that will load the system in the current image. bundle-op Class base class for operations that bundle outputs from multiple components Direct Slots asdf/bundle:bundle-type c-source-file Class Direct Slots type child-component Class A CHILD-COMPONENT is a COMPONENT that may be part of a PARENT-COMPONENT. circular-dependency Condition Direct Slots asdf/action::actions Initargs: :ACTIONS Readers: ASDF/ACTION:CIRCULAR-DEPENDENCY-ACTIONS cl-source-file Class Component class for a Common Lisp source file (using type \"lisp\") Direct Slots type cl-source-file.cl Class Component class for a Common Lisp source file using type \"cl\" Direct Slots type cl-source-file.lsp Class Component class for a Common Lisp source file using type \"lsp\" Direct Slots type clear-configuration Function: (clear-configuration) Call the functions in CLEAR-CONFIGURATION-HOOK clear-output-translations Function: (clear-output-translations) Undoes any initialization of the output translations. clear-source-registry Function: (clear-source-registry) Undoes any initialization of the source registry. clear-system Function: (clear-system system) Clear the entry for a system in the database of systems previously defined. However if the system was registered as PRELOADED (which it is if it is IMMUTABLE), then a new system with the same name will be defined and registered in its place from which build details will have been cleared. Note that this does NOT in any way cause any of the code of the system to be unloaded. Returns T if system was or is now undefined, NIL if a new preloaded system was redefined. coerce-name Function: (coerce-name name) Given a designator for a component name , return the name as a string. The designator can be a component (designing its name; note that a system is a component), a SYMBOL (designing its name, downcased), or a STRING (designing itself). compile-bundle-op Class This operator is an alternative to COMPILE-OP. Build a system and all of its dependencies, but build only a single (\"monolithic\") FASL, instead of one per source file, which may be more resource efficient. That monolithic FASL should be loaded with LOAD-BUNDLE-OP, rather than LOAD-OP. Direct Slots asdf/action:selfward-operation compile-concatenated-source-op Class Operation to compile the result of concatenate-source-op Direct Slots asdf/action:selfward-operation compile-condition Condition Direct Slots uiop/lisp-build::context-format Initargs: :CONTEXT-FORMAT uiop/lisp-build::context-arguments Initargs: :CONTEXT-ARGUMENTS uiop/lisp-build::description Initargs: :DESCRIPTION compile-error Condition compile-failed Condition compile-failed-error Condition compile-failed-warning Condition compile-file* Function: (compile-file* input-file &rest keys &key (compile-check *compile-check*) output-file warnings-file emit-cfasl &allow-other-keys) This function provides a portable wrapper around COMPILE-FILE. It ensures that the output-file value is only returned and the file only actually created if the compilation was successful, even though your implementation may not do that. It also checks an optional user-provided consistency function compile-check to determine success; it will call this function if not NIL at the end of the compilation with the arguments sent to COMPILE-FILE , except with : output-file TMP-FILE where TMP-FILE is the name of a temporary output-file. It also checks two flags (with legacy british spelling from ASDF1), COMPILE-FILE-FAILURE-BEHAVIOUR and COMPILE-FILE-WARNINGS-BEHAVIOUR* with appropriate implementation-dependent defaults, and if a failure (respectively warnings) are reported by COMPILE-FILE, it will consider that an error unless the respective behaviour flag is one of :SUCCESS :WARN :IGNORE. If warnings-file is defined, deferred warnings are saved to that file. On ECL or MKCL, it creates both the linkable object and loadable fasl files. On implementations that erroneously do not recognize standard keyword arguments, it will filter them appropriately. compile-file-error Condition compile-file-pathname* Function: (compile-file-pathname* input-file &rest keys &key output-file &allow-other-keys) Variant of COMPILE-FILE-PATHNAME that works well with COMPILE-FILE* compile-op Class Operation for compiling a Lisp file to a FASL Direct Slots asdf/action:selfward-operation compile-system Function: (compile-system system &rest args &key force force-not verbose version &allow-other-keys) Shorthand for (asdf:operate 'asdf:compile-op system) . See operate for details. compile-warned Condition compile-warned-error Condition compile-warned-warning Condition compiled-file Class Class for a file that is already compiled, e.g. as part of the implementation, of an outer build system that calls into ASDF, or of opaque libraries shipped along the source code. Direct Slots type component Class Base class for all components of a build Direct Slots asdf/component:name asdf/component:version Initargs: :VERSION Readers: ASDF/COMPONENT:COMPONENT-VERSION Writers: (SETF ASDF/COMPONENT:COMPONENT-VERSION) asdf/component:description Initargs: :DESCRIPTION Readers: ASDF/COMPONENT:COMPONENT-DESCRIPTION Writers: (SETF ASDF/COMPONENT:COMPONENT-DESCRIPTION) asdf/component:long-description Initargs: :LONG-DESCRIPTION Readers: ASDF/COMPONENT:COMPONENT-LONG-DESCRIPTION Writers: (SETF ASDF/COMPONENT:COMPONENT-LONG-DESCRIPTION) asdf/component:sideway-dependencies asdf/component:if-feature Initargs: :IF-FEATURE Readers: ASDF/COMPONENT:COMPONENT-IF-FEATURE Writers: (SETF ASDF/COMPONENT:COMPONENT-IF-FEATURE) asdf/component:in-order-to Initargs: :IN-ORDER-TO Readers: ASDF/COMPONENT:COMPONENT-IN-ORDER-TO Writers: (SETF ASDF/COMPONENT:COMPONENT-IN-ORDER-TO) asdf/component:inline-methods asdf/component:relative-pathname Initargs: :PATHNAME asdf/component:absolute-pathname asdf/component:operation-times asdf/component:around-compile Initargs: :AROUND-COMPILE asdf/component:properties Initargs: :PROPERTIES Readers: ASDF/COMPONENT:COMPONENT-PROPERTIES Writers: (SETF ASDF/COMPONENT:COMPONENT-PROPERTIES) asdf/component:%encoding Initargs: :ENCODING Readers: ASDF/COMPONENT::%COMPONENT-ENCODING Writers: (SETF ASDF/COMPONENT::%COMPONENT-ENCODING) asdf/component:parent Initargs: :PARENT Readers: ASDF/COMPONENT:COMPONENT-PARENT asdf/component::build-operation Initargs: :BUILD-OPERATION Readers: ASDF/COMPONENT:COMPONENT-BUILD-OPERATION asdf/component::additional-input-files component-children Generic Function: (component-children object) component-children-by-name Generic Function: (component-children-by-name object) component-depends-on Generic Function: (component-depends-on operation component) Returns a list of dependencies needed by the component to perform the operation. A dependency has one of the following forms: ( *), where is an operation designator with respect to find-operation in the context of the operation argument, and each is a component designator with respect to find-component in the context of the component argument, and means that the component depends on having been performed on each ; [Note: an is an operation designator -- it can be either an operation name or an operation object. Similarly, a may be a component name or a component object. Also note that, the degenerate case of ( ) is a no-op.] Methods specialized on subclasses of existing component types should usually append the results of CALL-NEXT-METHOD to the list. component-encoding Generic Function: (component-encoding component) The encoding of the component . By default, only :utf-8 is supported. Use asdf-encodings to support more encodings. component-external-format Generic Function: (component-external-format component) The external-format of the component . By default, deduced from the component-encoding . component-find-path Function: (component-find-path component) Return a path from a root system to the component . The return value is a list of component NAMES; a list of strings. component-load-dependencies Function: (component-load-dependencies component) DEPRECATED. Please use component-sideway-dependencies instead; or better, define your operations with proper use of sideway-operation , selfward-operation , or define methods on prepare-op , etc. component-loaded-p Function: (component-loaded-p component) Has the given component been successfully loaded in the current image (yet)? Note that this returns true even if the component is not up to date. component-name Generic Function: (component-name component) Name of the component , unique relative to its parent component-parent Generic Function: (component-parent component) The parent of a child component , or NIL for top-level components (a.k.a. systems) component-pathname Generic Function: (component-pathname component) Pathname of the component if any, or NIL. component-property Generic Function: (component-property component property) component-relative-pathname Generic Function: (component-relative-pathname component) Specified pathname of the component , intended to be merged with the pathname of that component's parent if any, using merged-pathnames*. Despite the function's name, the return value can be an absolute pathname, in which case the merge will leave it unmodified. component-sideway-dependencies Generic Function: (component-sideway-dependencies object) component-system Generic Function: (component-system component) Top-level system containing the component component-version Generic Function: (component-version component) Return the version of a component , which must be a string of dot-separated natural numbers, or NIL. compute-source-registry Function: (compute-source-registry &optional (parameter *source-registry-parameter*) (registry *source-registry*)) concatenate-source-op Class Operation to concatenate all sources in a system into a single file define-op Class An operation to record dependencies on loading a .asd file. defsystem Macro: (defsystem name &body options) deliver-asd-op Class produce an asd file for delivering the system as a single fasl Direct Slots asdf/action:selfward-operation disable-deferred-warnings-check Function: (disable-deferred-warnings-check) Disable the saving of deferred warnings disable-output-translations Function: (disable-output-translations) Initialize output translations in a way that maps every file to itself, effectively disabling the output translation facility. dll-op Class Compile the system and produce a dynamic loadable library (.so/.dll) for all the linkable object files associated with the system. Compare with LIB-OP. Direct Slots asdf/bundle::gather-type asdf/bundle:bundle-type doc-file Class downward-operation Generic Function: (downward-operation object) Class A DOWNWARD-OPERATION's dependencies propagate down the component hierarchy. I.e., if O is a DOWNWARD-OPERATION and its DOWNWARD-OPERATION slot designates operation D, then the action (O . M) of O on module M will depends on each of (D . C) for each child C of module M. The default value for slot DOWNWARD-OPERATION is NIL, which designates the operation O itself. E.g. in order for a MODULE to be loaded with LOAD-OP (resp. compiled with COMPILE-OP), all the children of the MODULE must have been loaded with LOAD-OP (resp. compiled with COMPILE-OP. Direct Slots asdf/action:downward-operation duplicate-names Condition Direct Slots asdf/component:name Initargs: :NAME Readers: ASDF/COMPONENT::DUPLICATE-NAMES-NAME enable-asdf-binary-locations-compatibility Function: (enable-asdf-binary-locations-compatibility &key (centralize-lisp-binaries NIL) (default-toplevel-directory (subpathname (user-homedir-pathname) .fasls/)) (include-per-user-information NIL) (map-all-source-files (or NIL)) (source-to-target-mappings NIL) (file-types (quasiquote (,(UIOP/LISP-BUILD:COMPILE-FILE-TYPE) build-report cfasl sbcl-warnings)))) DEPRECATED. Use asdf-output-translations instead. enable-deferred-warnings-check Function: (enable-deferred-warnings-check) Enable the saving of deferred warnings ensure-output-translations Function: (ensure-output-translations) ensure-source-registry Function: (ensure-source-registry &optional parameter) error-component Generic Function: (error-component condition) error-name Generic Function: (error-name condition) error-operation Generic Function: (error-operation condition) error-pathname Generic Function: (error-pathname condition) explain Generic Function: (explain operation component) Display a message describing an action. DEPRECATED. Use ASDF: action-description and/or ASDF::FORMAT-ACTION instead. file-component Class a COMPONENT that represents a file Direct Slots type Initargs: :TYPE Readers: ASDF/COMPONENT:FILE-TYPE Writers: (SETF ASDF/COMPONENT:FILE-TYPE) file-type Generic Function: (file-type object) find-component Generic Function: (find-component base path &key registered) Find a component by resolving the path starting from base parent. If registered is true, only search currently registered systems. find-operation Generic Function: (find-operation context spec) Find an operation by resolving the spec in the context find-system Generic Function: (find-system system &optional error-p) Given a system designator, find the actual corresponding system object. If no system is found, then signal an error if error-p is true (the default), or else return NIL. A system designator is usually a string (conventionally all lowercase) or a symbol, designating the same system as its downcased name; it can also be a system object (designating itself). hostname Function: (hostname) return the hostname of the current host html-file Class Direct Slots type image-op Class create an image file from the system and its dependencies Direct Slots asdf/bundle:bundle-type asdf/bundle::gather-operation asdf/action:selfward-operation implementation-identifier Function: (implementation-identifier) Return a string that identifies the ABI of the current implementation, suitable for use as a directory name to segregate Lisp FASLs, C dynamic libraries, etc. implementation-type Function: (implementation-type) The type of Lisp implementation used, as a short UIOP-standardized keyword initialize-output-translations Function: (initialize-output-translations &optional (parameter *output-translations-parameter*)) read the configuration, initialize the internal configuration variable, return the configuration initialize-source-registry Function: (initialize-source-registry &optional (parameter *source-registry-parameter*)) input-files Generic Function: (input-files operation component) A list of input files corresponding to this action. Methods on perform must call this function to determine where their inputs are located. They may rely on the order of the files to discriminate between inputs. java-source-file Class Direct Slots type lib-op Class Compile the system and produce a linkable static library (.a/.lib) for all the linkable object files associated with the system. Compare with DLL-OP. On most implementations, these object files only include extensions to the runtime written in C or another language with a compiler producing linkable object files. On CLASP, ECL, MKCL, these object files also include the contents of Lisp files themselves. In any case, this operation will produce what you need to further build a static runtime for your system, or a dynamic library to load in an existing runtime. Direct Slots asdf/bundle::gather-type asdf/bundle:bundle-type load-asd Function: (load-asd pathname &key name) Load system definitions from pathname . name if supplied is the name of a system expected to be defined in that file. Do NOT try to load a .asd file directly with CL:LOAD. Always use ASDF: load-asd . load-bundle-op Class This operator is an alternative to LOAD-OP. Build a system and all of its dependencies, using COMPILE-BUNDLE-OP. The difference with respect to LOAD-OP is that it builds only a single FASL, which may be faster and more resource efficient. Direct Slots asdf/action:selfward-operation load-compiled-concatenated-source-op Class Operation to load the result of compile-concatenated-source-op Direct Slots asdf/action:selfward-operation load-concatenated-source-op Class Operation to load the result of concatenate-source-op as source load-op Class Operation for loading the compiled FASL for a Lisp file Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: '(ASDF/LISP-ACTION:PREPARE-OP ASDF/LISP-ACTION:COMPILE-OP) load-source-op Class Operation for loading a Lisp file as source. Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/LISP-ACTION:PREPARE-SOURCE-OP load-system Function: (load-system system &rest keys &key force force-not verbose version &allow-other-keys) Shorthand for (operate 'asdf:load-op system) . See operate for details. load-system-definition-error Condition Direct Slots asdf/component:name Initargs: :NAME Readers: ASDF/FIND-SYSTEM:ERROR-NAME pathname Initargs: :PATHNAME Readers: ASDF/FIND-SYSTEM:ERROR-PATHNAME condition Initargs: :CONDITION Readers: ASDF/FIND-SYSTEM:ERROR-CONDITION load-systems Function: (load-systems &rest systems) Loading multiple systems at once. load-systems* Function: (load-systems* systems &rest keys) Loading multiple systems at once. locate-system Function: (locate-system name) Given a system name designator, try to locate where to load the system from. Returns five values: FOUNDP FOUND-SYSTEM PATHNAME PREVIOUS PREVIOUS-TIME FOUNDP is true when a system was found, either a new unregistered one or a previously registered one. FOUND-SYSTEM when not null is a system object that may be REGISTER-SYSTEM'ed. PATHNAME when not null is a path from which to load the system, either associated with FOUND-SYSTEM, or with the PREVIOUS system. PREVIOUS when not null is a previously loaded system object of same name. PREVIOUS-TIME when not null is the time at which the PREVIOUS system was loaded. make Function: (make system &rest keys) The recommended way to interact with ASDF3.1 is via (ASDF: make :FOO). It will build system FOO using the operation build-op , the meaning of which is configurable by the system, and defaults to load-op , to load it in current image. make-operation Function: (make-operation operation-class) This function creates and memoizes an instance of operation-class . All operation instances MUST be created through this function. Use of INITARGS is not supported at this time. make-plan Generic Function: (make-plan plan-class operation component &key &allow-other-keys) Generate and return a plan for performing operation on component . map-systems Function: (map-systems fn) Apply fn to each defined system. fn should be a function of one argument. It will be called with an object of type asdf:system. missing-component Condition Direct Slots asdf/find-component::requires Initargs: :REQUIRES asdf/component:parent Initargs: :PARENT missing-component-of-version Condition Direct Slots asdf/component:version Initargs: :VERSION missing-dependency Condition Direct Slots asdf/find-component::required-by Initargs: :REQUIRED-BY Readers: ASDF/FIND-COMPONENT:MISSING-REQUIRED-BY missing-dependency-of-version Condition module Class A module is a intermediate component with both a parent and children, typically but not necessarily representing the files in a subdirectory of the build source. module-components Generic Function: (module-components object) monolithic-bundle-op Class operations that are both monolithic-op and bundle-op Direct Slots asdf/bundle:prologue-code Readers: ASDF/BUNDLE:PROLOGUE-CODE Writers: (SETF ASDF/BUNDLE:PROLOGUE-CODE) asdf/bundle:epilogue-code Readers: ASDF/BUNDLE:EPILOGUE-CODE Writers: (SETF ASDF/BUNDLE:EPILOGUE-CODE) monolithic-compile-bundle-op Class Create a single fasl for the system and its dependencies. monolithic-compile-concatenated-source-op Class Operation to compile the result of monolithic-concatenate-source-op Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/CONCATENATE-SOURCE:MONOLITHIC-CONCATENATE-SOURCE-OP monolithic-concatenate-source-op Class Operation to concatenate all sources in a system and its dependencies into a single file monolithic-deliver-asd-op Class produce fasl and asd files for combined system and dependencies. Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: '(ASDF/BUNDLE:MONOLITHIC-COMPILE-BUNDLE-OP) monolithic-dll-op Class Compile the system and produce a dynamic loadable library (.so/.dll) for all the linkable object files associated with the system or its dependencies. See LIB-OP monolithic-lib-op Class Compile the system and produce a linkable static library (.a/.lib) for all the linkable object files associated with the system or its dependencies. See LIB-OP. monolithic-load-bundle-op Class Load a single fasl for the system and its dependencies. Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/BUNDLE:MONOLITHIC-COMPILE-BUNDLE-OP monolithic-load-compiled-concatenated-source-op Class Operation to load the result of monolithic-compile-concatenated-source-op Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/CONCATENATE-SOURCE:MONOLITHIC-COMPILE-CONCATENATED-SOURCE-OP monolithic-load-concatenated-source-op Class Operation to load the result of monolithic-concatenate-source-op as source Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/CONCATENATE-SOURCE:MONOLITHIC-CONCATENATE-SOURCE-OP needed-in-image-p Generic Function: (needed-in-image-p operation component) Is the action of operation on component needed in the current image to be meaningful, or could it just as well have been done in another Lisp image? non-propagating-operation Class A NON-PROPAGATING-OPERATION is an operation that propagates no dependencies whatsoever. It is supplied in order that the programmer be able to specify that s/he is intentionally specifying an operation which invokes no dependencies. non-system-system Condition Direct Slots asdf/component:name Initargs: :NAME class-name Initargs: :CLASS-NAME non-toplevel-system Condition Direct Slots asdf/component:parent Initargs: :PARENT asdf/component:name Initargs: :NAME oos Function: (oos operation component &rest args &key &allow-other-keys) Short for operate on system and an alias for the operate function. Operate does mainly four things for the user: Resolves the operation designator into an operation object. operation is typically a symbol denoting an operation class, instantiated with make-operation . Resolves the component designator into a component object. component is typically a string or symbol naming a system, loaded from disk using find-system . It then calls make-plan with the operation and system as arguments. Finally calls perform-plan on the resulting plan to actually build the system. The entire computation is wrapped in WITH-COMPILATION-UNIT and error handling code. If a version argument is supplied, then operate also ensures that the system found satisfies it using the version-satisfies method. If a PLAN-CLASS argument is supplied, that class is used for the plan. If a PLAN-OPTIONS argument is supplied, the options are passed to the plan. The :FORCE or :FORCE-NOT argument to operate can be: T to force the inside of the specified system to be rebuilt (resp. not), without recursively forcing the other systems we depend on. :ALL to force all systems including other systems we depend on to be rebuilt (resp. not). ( system 1 system 2 ... SYSTEMN) to force systems named in a given list :FORCE-NOT has precedence over :FORCE; builtin systems cannot be forced. For backward compatibility, all keyword arguments are passed to make-operation when instantiating a new operation, that will in turn be inherited by new operations. But do NOT depend on it, for this is deprecated behavior. operate Generic Function: (operate operation component &key plan-class plan-options version verbose on-warnings on-failure &allow-other-keys) Operate does mainly four things for the user: Resolves the operation designator into an operation object. operation is typically a symbol denoting an operation class, instantiated with make-operation . Resolves the component designator into a component object. component is typically a string or symbol naming a system, loaded from disk using find-system . It then calls make-plan with the operation and system as arguments. Finally calls perform-plan on the resulting plan to actually build the system. The entire computation is wrapped in WITH-COMPILATION-UNIT and error handling code. If a version argument is supplied, then operate also ensures that the system found satisfies it using the version-satisfies method. If a plan-class argument is supplied, that class is used for the plan. If a plan-options argument is supplied, the options are passed to the plan. The :FORCE or :FORCE-NOT argument to operate can be: T to force the inside of the specified system to be rebuilt (resp. not), without recursively forcing the other systems we depend on. :ALL to force all systems including other systems we depend on to be rebuilt (resp. not). ( system 1 system 2 ... SYSTEMN) to force systems named in a given list :FORCE-NOT has precedence over :FORCE; builtin systems cannot be forced. For backward compatibility, all keyword arguments are passed to make-operation when instantiating a new operation, that will in turn be inherited by new operations. But do NOT depend on it, for this is deprecated behavior. operation Class The base class for all ASDF operations. ASDF does NOT and never did distinguish between multiple operations of the same class. Therefore, all slots of all operations MUST have :allocation :class and no initargs. No exceptions. operation-definition-error Condition Error condition related to definition of incorrect OPERATION objects. operation-definition-warning Condition Warning condition related to definition of obsolete OPERATION objects. operation-done-p Generic Function: (operation-done-p operation component) Returns a boolean which is NIL if the action must be performed (again). operation-error Condition Direct Slots asdf/component:component Initargs: :COMPONENT Readers: ASDF/BACKWARD-INTERFACE:ERROR-COMPONENT asdf/operation:operation Initargs: :OPERATION Readers: ASDF/BACKWARD-INTERFACE:ERROR-OPERATION operation-monolithic-p Function: (operation-monolithic-p op) operation-on-failure Generic Function: (operation-on-failure operation) DEPRECATED. Please use UIOP: COMPILE-FILE-FAILURE-BEHAVIOUR instead. operation-on-warnings Generic Function: (operation-on-warnings operation) DEPRECATED. Please use UIOP: COMPILE-FILE-WARNINGS-BEHAVIOUR instead. output-file Function: (output-file operation component) The unique output file of performing operation on component output-files Generic Function: (output-files operation component) Methods for this function return two values: a list of output files corresponding to this action, and a boolean indicating if they have already been subjected to relevant output translations and should not be further translated. Methods on perform must call this function to determine where their outputs are to be located. They may rely on the order of the files to discriminate between outputs. package-inferred-system Class Class for primary systems for which secondary systems are automatically in the one-file, one-file, one-system style: system names are mapped to files under the primary system's system-source-directory, dependencies are inferred from the first defpackage form in every such file package-inferred-system-missing-package-error Condition Direct Slots asdf/system:system Initargs: :SYSTEM pathname Initargs: :PATHNAME package-system Class parent-component Class A PARENT-COMPONENT is a component that may have children. Direct Slots asdf/component:children Initargs: :COMPONENTS asdf/component:children-by-name asdf/component:default-component-class Initargs: :DEFAULT-COMPONENT-CLASS Readers: ASDF/COMPONENT:MODULE-DEFAULT-COMPONENT-CLASS Writers: (SETF ASDF/COMPONENT:MODULE-DEFAULT-COMPONENT-CLASS) perform Generic Function: (perform operation component) perform an action, consuming its input-files and building its output-files perform-plan Generic Function: (perform-plan plan &key) Actually perform a plan and build the requested actions perform-with-restarts Generic Function: (perform-with-restarts operation component) perform an action in a context where suitable restarts are in place. precompiled-system Class Class For a system that is delivered as a precompiled fasl Direct Slots asdf/system:build-pathname Initargs: :FASL, :FASB prepare-bundle-op Class Operation class for loading the bundles of a system's dependencies Direct Slots asdf/action:sideway-operation Allocation: :CLASS Initform: 'ASDF/LISP-ACTION:LOAD-OP prepare-op Class Load the dependencies for the COMPILE-OP or LOAD-OP of a given COMPONENT. Direct Slots asdf/action:sideway-operation Allocation: :CLASS Initform: 'ASDF/LISP-ACTION:LOAD-OP prepare-source-op Class Operation for loading the dependencies of a Lisp file as source. Direct Slots asdf/action:sideway-operation Allocation: :CLASS Initform: 'ASDF/LISP-ACTION:LOAD-SOURCE-OP primary-system-name Function: (primary-system-name system-designator) Given a system designator NAME, return the name of the corresponding primary system, after which the .asd file is named. That's the first component when dividing the name as a string by / slashes. A component designates its system. process-source-registry Generic Function: (process-source-registry spec &key inherit register) program-op Class create an executable file from the system and its dependencies Direct Slots asdf/bundle:bundle-type Allocation: :CLASS Initform: :PROGRAM program-system Class Direct Slots asdf/bundle:prologue-code Initargs: :PROLOGUE-CODE Readers: ASDF/BUNDLE:PROLOGUE-CODE asdf/bundle:epilogue-code Initargs: :EPILOGUE-CODE Readers: ASDF/BUNDLE:EPILOGUE-CODE asdf/bundle::no-uiop Initargs: :NO-UIOP asdf/bundle::prefix-lisp-object-files Initargs: :PREFIX-LISP-OBJECT-FILES asdf/bundle::postfix-lisp-object-files Initargs: :POSTFIX-LISP-OBJECT-FILES asdf/bundle::extra-object-files Initargs: :EXTRA-OBJECT-FILES asdf/bundle::extra-build-args Initargs: :EXTRA-BUILD-ARGS register-immutable-system Function: (register-immutable-system system-name &rest keys) Register system-name as preloaded and immutable. It will automatically be considered as passed to FORCE-NOT in a plan. register-preloaded-system Function: (register-preloaded-system system-name &rest keys &key (version t) &allow-other-keys) Register a system as being preloaded. If the system has not been loaded from the filesystem yet, or if its build information is later cleared with clear-system , a dummy system will be registered without backing filesystem information, based on keys (e.g. to provide a version ). If version is the default T, and a system was already loaded, then its version will be preserved. register-system-packages Function: (register-system-packages system packages) Register system as providing packages . registered-system Function: (registered-system name) Return a system of given name that was registered already, if such a system exists. name is a system designator, to be normalized by coerce-name . The value returned is a system object, or NIL if not found. registered-systems Function: (registered-systems) Return a list of the names of every registered system. require-system Function: (require-system system &rest keys &key &allow-other-keys) Ensure the specified system is loaded, passing the keys to operate , but do not update the system or its dependencies if it has already been loaded. Class A SYSTEM subclass whose processing is handled by the implementation's REQUIRE rather than by internal ASDF mechanisms. Direct Slots asdf/component:module Initargs: :MODULE required-components Function: (required-components system &rest keys &key (goal-operation (quote load-op)) &allow-other-keys) Given a system and a goal-operation (default load-op ), traverse the dependencies and return a list of the components involved in building the desired action. resolve-location Function: (resolve-location x &key ensure-directory wilden directory) Resolve location designator x into a PATHNAME run-shell-command Function: (run-shell-command control-string &rest args) PLEASE DO NOT USE. This function is not just DEPRECATED, but also dysfunctional. Please use UIOP:RUN-PROGRAM instead. search-for-system-definition Function: (search-for-system-definition system) selfward-operation Generic Function: (selfward-operation object) Class A SELFWARD-OPERATION depends on another operation on the same component. I.e., if O is a SELFWARD-OPERATION, and its SELFWARD-OPERATION designates a list of operations L, then the action (O . C) of O on component C depends on each (S . C) for S in L. E.g. before a component may be loaded by LOAD-OP, it must have been compiled by COMPILE-OP. A operation-designator designates a singleton list of the designated operation; a list of operation-designators designates the list of designated operations; NIL is not a valid operation designator in that context. Note that any dependency ordering between the operations in a list of SELFWARD-OPERATION should be specified separately in the respective operation's COMPONENT-DEPENDS-ON methods so that they be scheduled properly. Direct Slots asdf/action:selfward-operation Type: (OR ASDF/ACTION::OPERATION-DESIGNATOR LIST) Allocation: :CLASS Readers: ASDF/ACTION:SELFWARD-OPERATION sequential-plan Class Simplest, default plan class, accumulating a sequence of actions sideway-operation Generic Function: (sideway-operation object) Class A SIDEWAY-OPERATION has dependencies that propagate \"sideway\" to siblings that a component depends on. I.e. if O is a SIDEWAY-OPERATION, and its SIDEWAY-OPERATION slot designates operation S (where NIL designates O itself), then the action (O . C) of O on component C depends on each of (S . D) where D is a declared dependency of C. E.g. in order for a COMPONENT to be prepared for loading or compiling with PREPARE-OP, each of its declared dependencies must first be loaded as by LOAD-OP. Direct Slots asdf/action:sideway-operation Type: ASDF/ACTION::OPERATION-DESIGNATOR Allocation: :CLASS Readers: ASDF/ACTION:SIDEWAY-OPERATION source-file Class Direct Slots type Readers: ASDF/COMPONENT:SOURCE-FILE-EXPLICIT-TYPE Writers: (SETF ASDF/COMPONENT:SOURCE-FILE-EXPLICIT-TYPE) source-file-type Generic Function: (source-file-type component system) DEPRECATED. Use the file-type of a component instead. static-file Class Component for a file to be included as is in the build output Direct Slots type sysdef-immutable-system-search Function: (sysdef-immutable-system-search requested) sysdef-preloaded-system-search Function: (sysdef-preloaded-system-search requested) If requested names a system registered as preloaded, return a new system with its registration information. system Class SYSTEM is the base class for top-level components that users may request ASDF to build. Direct Slots asdf/component:description Readers: ASDF/SYSTEM:SYSTEM-DESCRIPTION Writers: (SETF ASDF/SYSTEM:SYSTEM-DESCRIPTION) asdf/component:long-description Readers: ASDF/SYSTEM:SYSTEM-LONG-DESCRIPTION Writers: (SETF ASDF/SYSTEM:SYSTEM-LONG-DESCRIPTION) asdf/component:author Initargs: :AUTHOR Readers: ASDF/SYSTEM:SYSTEM-AUTHOR Writers: (SETF ASDF/SYSTEM:SYSTEM-AUTHOR) asdf/component:maintainer Initargs: :MAINTAINER Readers: ASDF/SYSTEM:SYSTEM-MAINTAINER Writers: (SETF ASDF/SYSTEM:SYSTEM-MAINTAINER) asdf/component:licence Initargs: :LICENSE, :LICENCE Readers: ASDF/SYSTEM:SYSTEM-LICENSE, ASDF/SYSTEM:SYSTEM-LICENCE Writers: (SETF ASDF/SYSTEM:SYSTEM-LICENSE), (SETF ASDF/SYSTEM:SYSTEM-LICENCE) asdf/system:homepage Initargs: :HOMEPAGE Readers: ASDF/SYSTEM:SYSTEM-HOMEPAGE Writers: (SETF ASDF/SYSTEM:SYSTEM-HOMEPAGE) asdf/system:bug-tracker Initargs: :BUG-TRACKER Readers: ASDF/SYSTEM:SYSTEM-BUG-TRACKER Writers: (SETF ASDF/SYSTEM:SYSTEM-BUG-TRACKER) asdf/system:mailto Initargs: :MAILTO Readers: ASDF/SYSTEM:SYSTEM-MAILTO Writers: (SETF ASDF/SYSTEM:SYSTEM-MAILTO) asdf/system:long-name Initargs: :LONG-NAME Readers: ASDF/SYSTEM:SYSTEM-LONG-NAME Writers: (SETF ASDF/SYSTEM:SYSTEM-LONG-NAME) asdf/system:source-control Initargs: :SOURCE-CONTROL Readers: ASDF/SYSTEM:SYSTEM-SOURCE-CONTROL Writers: (SETF ASDF/SYSTEM:SYSTEM-SOURCE-CONTROL) asdf/system:builtin-system-p Initargs: :BUILTIN-SYSTEM-P Readers: ASDF/SYSTEM:BUILTIN-SYSTEM-P Writers: (SETF ASDF/SYSTEM:BUILTIN-SYSTEM-P) asdf/system:build-pathname Initargs: :BUILD-PATHNAME Readers: ASDF/SYSTEM:COMPONENT-BUILD-PATHNAME Writers: (SETF ASDF/SYSTEM:COMPONENT-BUILD-PATHNAME) asdf/system:entry-point Initargs: :ENTRY-POINT Readers: ASDF/SYSTEM:COMPONENT-ENTRY-POINT Writers: (SETF ASDF/SYSTEM:COMPONENT-ENTRY-POINT) asdf/component:source-file Initargs: :SOURCE-FILE Readers: ASDF/SYSTEM:SYSTEM-SOURCE-FILE Writers: (SETF ASDF/SYSTEM:SYSTEM-SOURCE-FILE) asdf/component:defsystem-depends-on Initargs: :DEFSYSTEM-DEPENDS-ON Readers: ASDF/SYSTEM:SYSTEM-DEFSYSTEM-DEPENDS-ON asdf/system::depends-on Initargs: :DEFSYSTEM-DEPENDS-ON Readers: ASDF/SYSTEM:SYSTEM-DEFSYSTEM-DEPENDS-ON asdf/system::weakly-depends-on Readers: ASDF/SYSTEM:SYSTEM-WEAKLY-DEPENDS-ON system-author Generic Function: (system-author object) system-bug-tracker Generic Function: (system-bug-tracker object) system-definition-error Condition system-definition-pathname Function: (system-definition-pathname x) DEPRECATED. This function used to expose ASDF internals with subtle differences with respect to user expectations, that have been refactored away since. We recommend you use ASDF: system-source-file instead for a mostly compatible replacement that we're supporting, or even ASDF: system-source-directory or ASDF: system-relative-pathname if that's whay you mean. system-defsystem-depends-on Generic Function: (system-defsystem-depends-on object) system-depends-on Generic Function: (system-depends-on object) system-description Generic Function: (system-description object) system-homepage Generic Function: (system-homepage object) system-licence Generic Function: (system-licence object) system-license Generic Function: (system-license object) system-long-description Generic Function: (system-long-description object) system-long-name Generic Function: (system-long-name object) system-mailto Generic Function: (system-mailto object) system-maintainer Generic Function: (system-maintainer object) system-out-of-date Condition condition signaled when a system is detected as being out of date Direct Slots asdf/component:name Initargs: :NAME Readers: ASDF/COMPONENT:COMPONENT-NAME system-output-translations-directory-pathname Function: (system-output-translations-directory-pathname &key (direction :input)) system-output-translations-pathname Function: (system-output-translations-pathname &key (direction :input)) system-registered-p Function: (system-registered-p name) DEPRECATED. Return a generalized boolean that is true if a system of given name was registered already. name is a system designator, to be normalized by coerce-name . The value returned if true is a pair of a timestamp and a system object. system-relative-pathname Function: (system-relative-pathname system name &key type) Given a system , and a (Unix-style relative path) name of a file (or directory) of given type , return the absolute pathname of a corresponding file under that system's source code pathname. system-source-control Generic Function: (system-source-control object) system-source-directory Function: (system-source-directory system-designator) Return a pathname object corresponding to the directory in which the system specification (.asd file) is located. system-source-file Generic Function: (system-source-file system) Return the source file in which system is defined. system-source-registry Function: (system-source-registry &key (direction :input)) system-source-registry-directory Function: (system-source-registry-directory &key (direction :input)) system-weakly-depends-on Generic Function: (system-weakly-depends-on object) test-op Class Operation for running the tests for system. If the tests fail, an error will be signaled. Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/LISP-ACTION:LOAD-OP test-system Function: (test-system system &rest args &key force force-not verbose version &allow-other-keys) Shorthand for (asdf:operate 'asdf:test-op system) . See operate for details. traverse Generic Function: (traverse operation component &key plan-class &allow-other-keys) DEPRECATED. Use make-plan and PLAN-ACTIONS, or required-components , or some other supported interface instead. Generate and return a plan for performing operation on component . The plan returned is a list of dotted-pairs. Each pair is the CONS of ASDF operation object and a component object. The pairs will be processed in order by operate . upgrade-asdf Function: (upgrade-asdf) Try to upgrade of ASDF. If a different version was used, return T. We need do that before we operate on anything that may possibly depend on ASDF. upward-operation Generic Function: (upward-operation object) Class An UPWARD-OPERATION has dependencies that propagate up the component hierarchy. I.e., if O is an instance of UPWARD-OPERATION, and its UPWARD-OPERATION slot designates operation U, then the action (O . C) of O on a component C that has the parent P will depends on (U . P). The default value for slot UPWARD-OPERATION is NIL, which designates the operation O itself. E.g. in order for a COMPONENT to be prepared for loading or compiling with PREPARE-OP, its PARENT must first be prepared for loading or compiling with PREPARE-OP. Direct Slots asdf/action:upward-operation Allocation: :CLASS Readers: ASDF/ACTION:UPWARD-OPERATION user-output-translations-directory-pathname Function: (user-output-translations-directory-pathname &key (direction :input)) user-output-translations-pathname Function: (user-output-translations-pathname &key (direction :input)) user-source-registry Function: (user-source-registry &key (direction :input)) user-source-registry-directory Function: (user-source-registry-directory &key (direction :input)) version-satisfies Generic Function: (version-satisfies component version) Check whether a component satisfies the constraint of being at least as recent as the specified version , which must be a string of dot-separated natural numbers, or NIL.","title":"asdf - Build System"},{"location":"asdf/#asdf-build-system","text":"Version: 3.3.1 Repository: asdf/asdf - Gitlab In case of any inaccuracies, ambiguities or suggestions, please create an issue here . ASDF, or Another System Definition Facility, is a build system: a tool for specifying how systems of Common Lisp software are made up of components (sub-systems and files), and how to operate on these components in the right order so that they can be compiled, loaded, tested, etc. ASDF also includes UIOP, currently not documented here.","title":"asdf - Build System"},{"location":"asdf/#getting-started","text":"All actively maintained lisp implementations these days include a copy of ASDF 3 that can be simply loaded using (require \"asdf\") - in fact, loading quicklisp takes care of require -ing asdf. (asdf:asdf-version) will inform you of the version (should be >3). For details, you may want to refer to the section on Loading ASDF in the manual. ASDF must be configured to find the .asd files containing the system definition. If you are using quicklisp - and we recommend you do - for your own projects, you only need to consider ql:*local-project-directories* . For details, see the section on Configuring ASDF in the manual.","title":"Getting Started"},{"location":"asdf/#trivial-system-definition","text":"(defsystem \"foobar\" :description \"A system definition to demonstrate ASDF\" :version \"0.1.0\" :serial t :license \"BSD\" :pathname \"src/\" :depends-on (\"alexandria\" (:version \"some-new-system\" \"0.7.3\")) :components ((:file \"foo\") ; .lisp is implicit for :file (:file \"baz\") ; this lies in src/ (:module \"bar\" :components ((:file \"bar-1\") ; this lies in src/bar/ (:file \"bar-2\"))) (:static-file \"LICENCE\" :pathname #P\"LICENCE\")) :in-order-to ((test-op (test-op \"foobar/tests\"))) ;; The following is not recommended - for demonstration of :perform ;; and operations (see next section) only. :perform (load-op (o c) (format t \"Loading foobar\"))) (defsystem \"foobar/tests\" :depends-on (\"foobar\" \"fiveam\") :components ((:file \"foobar-tests\")) :perform (test-op (o c) (uiop:symbol-call :fiveam '#:run! :foobar))) These definitions should go inside a file named \"foobar.asd\" , located somewhere quicklisp/ASDF can find (see previous section). As of ASDF 3.1, the depends-on version translates to 0.7.3+. (TODO: What about ASDF 3.3? Will this ever change in future?) Usually, you'd be basing yourself on a particular version of quicklisp dist . However, if you actually need it, qlot should be helpful. The :serial t states that each item in the :components depends on all of the previous items. When efficiency is a concern, you may want to explicitly specify the list of dependencies a particular component depends on (:file \"baz\" :depends-on (\"foo\")) . Thus, the way things are defined, the system \"foobar\" can simply be tested by calling (asdf:test-system \"foobar\") . Finally, a note on naming: system names are recommended to be named using lower-cased strings without underscores. There exist what are known as primary systems - with the system name being same as the filename without the .asd extension - and secondary systems. Here, \"foobar\" is the primary system. \"foobar/tests\" is a secondary system. The primary system of a secondary system can be found by noting the / as delimiters. A (secondary) system \"foo/bar\" would be looked up in the file \"foo.asd\".","title":"Trivial System Definition"},{"location":"asdf/#operations","text":"ASDF has the concept of an operation that can act upon a system (or a smaller component thereof). Typical operations that matter to end-users include: load-op for loading a system in the current Lisp image, as used by asdf:load-system , test-op for running tests associated to the system, as used by asdf:test-system , build-op for doing whatever build operation is associated to the system, (which by default is load-op if the system didn't override it), as used by asdf:make . Further operations of interest to users include: compile-op ensure the system is compiled, without necessarily loading all of it, or any bit of it, load-source-op load the system from source without compiling, compile-bundle-op create a single fasl for the entire system, for delivery, monolithic-compile-bundle-op create a single fasl for the entire system and all its transitive dependencies , for delivery, image-op create a development image with this system already loaded, for fast startup, program-op create a standalone application, which we will see below, etc. Whichever operation you want, asdf:operate ( (asdf:operate operation system ) ) will ensure this operation is performed on that system (after all the necessary dependencies of such an action). A short-hand asdf:oos acts as an acronym for asdf:operate . The operation is typically specified as a symbol that names the operation class. Since ASDF 3, you can also use a keyword to specify an action in the ASDF package. Thus, (asdf:oos :load-op :foobar) is equivalent to (asdf:load-system :foobar) . Whichever operation a system is intended to be used with can be invoked with make : (asdf:make :foo) and specified with build-op . (TODO: Confirm make invokes load-op before invoking build-op if both are defined. Why? What's going on under the hood? There is also the concept of dependency between operations.) TODO: Are there other ways to specify what an operation should do other than :perform clause? TODO: What exactly is the utility of a static file? Perhaps, for bundling data files. Data can then be read from such a file by getting asdf:component-pathname . But what happens if you bundle the system into an image?","title":"Operations"},{"location":"asdf/#a-note-on-systems-and-packages","text":"What one might call packages in other languages are called systems in Common Lisp parlance. Instead, the word package in Common Lisp refers to a data structure providing namespacing for symbols. By contrast, a system is a tool to organize a bunch of files, in accordance with dependencies, and specifying how to perform certain actions on the system. A single system may contain multiple packages. See this StackOverFlow answer for a detailed discussion. ASDF also provides package-inferred-system to make the \"one file, one package, one system\" style easier to use. However, most systems in the wild usually have one main system, several packages, each package spanning several files; each file packing together some relevant functionality. Your IDE (often SLIME) should be the one telling you who calls/sets/macroexpands/etc something. Of use also are M-. (slime-edit-definition) and M-, (slime-pop-find-definition-stack).","title":"A note on Systems and Packages"},{"location":"asdf/#more-reading","text":"ASDF Best Practices ASDF Manual Building self-contained executables - The Common Lisp Cookbook","title":"More Reading"},{"location":"asdf/#api-reference","text":"","title":"API REFERENCE"},{"location":"asdf/#central-registry","text":"Variable A list of 'system directory designators' ASDF uses to find systems. A 'system directory designator' is a pathname or an expression which evaluates to a pathname. For example: (setf asdf:*central-registry* (list '*default-pathname-defaults* #p\"/home/me/cl/systems/\" #p\"/usr/share/common-lisp/systems/\")) This variable is for backward compatibility. Going forward, we recommend new users should be using the source-registry.","title":"*central-registry*"},{"location":"asdf/#compile-file-failure-behaviour","text":"Variable How should ASDF react if it encounters a failure (per the ANSI spec of COMPILE-FILE) when compiling a file, which includes any non-style-warning warning. Valid values are :error, :warn, and :ignore. Note that ASDF ALWAYS raises an error if it fails to create an output file when compiling.","title":"*compile-file-failure-behaviour*"},{"location":"asdf/#compile-file-warnings-behaviour","text":"Variable How should ASDF react if it encounters a warning when compiling a file? Valid values are :error, :warn, and :ignore.","title":"*compile-file-warnings-behaviour*"},{"location":"asdf/#default-encoding","text":"Variable Default encoding for source files. The default value :utf-8 is the portable thing. The legacy behavior was :default. If you (asdf:load-system :asdf-encodings) then you will have autodetection via encoding-detection-hook below, reading emacs-style - - coding: utf-8 - - specifications, and falling back to utf-8 or latin1 if nothing is specified.","title":"*default-encoding*"},{"location":"asdf/#default-source-registries","text":"Variable List of default source registries","title":"*default-source-registries*"},{"location":"asdf/#encoding-detection-hook","text":"Variable Hook for an extension to define a function to automatically detect a file's encoding","title":"*encoding-detection-hook*"},{"location":"asdf/#encoding-external-format-hook","text":"Variable Hook for an extension (e.g. ASDF-ENCODINGS) to define a better mapping from non-default encodings to and implementation-defined external-format's","title":"*encoding-external-format-hook*"},{"location":"asdf/#resolve-symlinks","text":"Variable Determine whether or not ASDF resolves symlinks when defining systems. Defaults to T.","title":"*resolve-symlinks*"},{"location":"asdf/#system-definition-search-functions","text":"Variable A list that controls the ways that ASDF looks for system definitions. It contains symbols to be funcalled in order, with a requested system name as argument, until one returns a non-NIL result (if any), which must then be a fully initialized system object with that name.","title":"*system-definition-search-functions*"},{"location":"asdf/#user-cache","text":"Variable A specification as per resolve-location of where the user keeps his FASL cache","title":"*user-cache*"},{"location":"asdf/#utf-8-external-format","text":"Variable Default :external-format argument to pass to CL:OPEN and also CL:LOAD or CL:COMPILE-FILE to best process a UTF-8 encoded file. On modern implementations, this will decode UTF-8 code points as CL characters. On legacy implementations, it may fall back on some 8-bit encoding, with non-ASCII code points being read as several CL characters; hopefully, if done consistently, that won't affect program behavior too much.","title":"*utf-8-external-format*"},{"location":"asdf/#warnings-file-type","text":"Variable Pathname type for warnings files, or NIL if disabled","title":"*warnings-file-type*"},{"location":"asdf/#action-description","text":"Generic Function: (action-description operation component) returns a phrase that describes performing this operation on this component, e.g. \"loading /a/b/c\". You can put together sentences using this phrase.","title":"action-description"},{"location":"asdf/#additional-input-files","text":"Generic Function: (additional-input-files operation component) Additional input files for the operation on this component. These are files that are inferred, rather than explicitly specified, and these are typically NOT files that undergo operations directly. Instead, they are files that it is important for ASDF to know about in order to compute operation times,etc.","title":"additional-input-files"},{"location":"asdf/#already-loaded-systems","text":"Function: (already-loaded-systems) return a list of the names of the systems that have been successfully loaded so far","title":"already-loaded-systems"},{"location":"asdf/#apply-output-translations","text":"Function: (apply-output-translations path)","title":"apply-output-translations"},{"location":"asdf/#asdf-message","text":"Function: (asdf-message format-string &rest format-args)","title":"asdf-message"},{"location":"asdf/#asdf-version","text":"Function: (asdf-version) Exported interface to the version of ASDF currently installed. A string. You can compare this string with e.g.: (ASDF: version-satisfies (ASDF: asdf-version ) \"3.4.5.67\").","title":"asdf-version"},{"location":"asdf/#bad-system-name","text":"Condition Direct Slots asdf/component:name Initargs: :NAME Readers: ASDF/COMPONENT:COMPONENT-NAME asdf/component:source-file Initargs: :SOURCE-FILE Readers: ASDF/SYSTEM:SYSTEM-SOURCE-FILE","title":"bad-system-name"},{"location":"asdf/#basic-compile-bundle-op","text":"Class Base class for compiling into a bundle Direct Slots asdf/bundle::gather-type asdf/bundle:bundle-type","title":"basic-compile-bundle-op"},{"location":"asdf/#build-op","text":"Class Since ASDF3, BUILD-OP is the recommended 'master' operation, to operate by default on a system or component, via the function BUILD. Its meaning is configurable via the :BUILD-OPERATION option of a component. which typically specifies the name of a specific operation to which to delegate the build, as a symbol or as a string later read as a symbol (after loading the defsystem-depends-on); if NIL is specified (the default), BUILD-OP falls back to LOAD-OP, that will load the system in the current image.","title":"build-op"},{"location":"asdf/#bundle-op","text":"Class base class for operations that bundle outputs from multiple components Direct Slots asdf/bundle:bundle-type","title":"bundle-op"},{"location":"asdf/#c-source-file","text":"Class Direct Slots type","title":"c-source-file"},{"location":"asdf/#child-component","text":"Class A CHILD-COMPONENT is a COMPONENT that may be part of a PARENT-COMPONENT.","title":"child-component"},{"location":"asdf/#circular-dependency","text":"Condition Direct Slots asdf/action::actions Initargs: :ACTIONS Readers: ASDF/ACTION:CIRCULAR-DEPENDENCY-ACTIONS","title":"circular-dependency"},{"location":"asdf/#cl-source-file","text":"Class Component class for a Common Lisp source file (using type \"lisp\") Direct Slots type","title":"cl-source-file"},{"location":"asdf/#cl-source-filecl","text":"Class Component class for a Common Lisp source file using type \"cl\" Direct Slots type","title":"cl-source-file.cl"},{"location":"asdf/#cl-source-filelsp","text":"Class Component class for a Common Lisp source file using type \"lsp\" Direct Slots type","title":"cl-source-file.lsp"},{"location":"asdf/#clear-configuration","text":"Function: (clear-configuration) Call the functions in CLEAR-CONFIGURATION-HOOK","title":"clear-configuration"},{"location":"asdf/#clear-output-translations","text":"Function: (clear-output-translations) Undoes any initialization of the output translations.","title":"clear-output-translations"},{"location":"asdf/#clear-source-registry","text":"Function: (clear-source-registry) Undoes any initialization of the source registry.","title":"clear-source-registry"},{"location":"asdf/#clear-system","text":"Function: (clear-system system) Clear the entry for a system in the database of systems previously defined. However if the system was registered as PRELOADED (which it is if it is IMMUTABLE), then a new system with the same name will be defined and registered in its place from which build details will have been cleared. Note that this does NOT in any way cause any of the code of the system to be unloaded. Returns T if system was or is now undefined, NIL if a new preloaded system was redefined.","title":"clear-system"},{"location":"asdf/#coerce-name","text":"Function: (coerce-name name) Given a designator for a component name , return the name as a string. The designator can be a component (designing its name; note that a system is a component), a SYMBOL (designing its name, downcased), or a STRING (designing itself).","title":"coerce-name"},{"location":"asdf/#compile-bundle-op","text":"Class This operator is an alternative to COMPILE-OP. Build a system and all of its dependencies, but build only a single (\"monolithic\") FASL, instead of one per source file, which may be more resource efficient. That monolithic FASL should be loaded with LOAD-BUNDLE-OP, rather than LOAD-OP. Direct Slots asdf/action:selfward-operation","title":"compile-bundle-op"},{"location":"asdf/#compile-concatenated-source-op","text":"Class Operation to compile the result of concatenate-source-op Direct Slots asdf/action:selfward-operation","title":"compile-concatenated-source-op"},{"location":"asdf/#compile-condition","text":"Condition Direct Slots uiop/lisp-build::context-format Initargs: :CONTEXT-FORMAT uiop/lisp-build::context-arguments Initargs: :CONTEXT-ARGUMENTS uiop/lisp-build::description Initargs: :DESCRIPTION","title":"compile-condition"},{"location":"asdf/#compile-error","text":"Condition","title":"compile-error"},{"location":"asdf/#compile-failed","text":"Condition","title":"compile-failed"},{"location":"asdf/#compile-failed-error","text":"Condition","title":"compile-failed-error"},{"location":"asdf/#compile-failed-warning","text":"Condition","title":"compile-failed-warning"},{"location":"asdf/#compile-file","text":"Function: (compile-file* input-file &rest keys &key (compile-check *compile-check*) output-file warnings-file emit-cfasl &allow-other-keys) This function provides a portable wrapper around COMPILE-FILE. It ensures that the output-file value is only returned and the file only actually created if the compilation was successful, even though your implementation may not do that. It also checks an optional user-provided consistency function compile-check to determine success; it will call this function if not NIL at the end of the compilation with the arguments sent to COMPILE-FILE , except with : output-file TMP-FILE where TMP-FILE is the name of a temporary output-file. It also checks two flags (with legacy british spelling from ASDF1), COMPILE-FILE-FAILURE-BEHAVIOUR and COMPILE-FILE-WARNINGS-BEHAVIOUR* with appropriate implementation-dependent defaults, and if a failure (respectively warnings) are reported by COMPILE-FILE, it will consider that an error unless the respective behaviour flag is one of :SUCCESS :WARN :IGNORE. If warnings-file is defined, deferred warnings are saved to that file. On ECL or MKCL, it creates both the linkable object and loadable fasl files. On implementations that erroneously do not recognize standard keyword arguments, it will filter them appropriately.","title":"compile-file*"},{"location":"asdf/#compile-file-error","text":"Condition","title":"compile-file-error"},{"location":"asdf/#compile-file-pathname","text":"Function: (compile-file-pathname* input-file &rest keys &key output-file &allow-other-keys) Variant of COMPILE-FILE-PATHNAME that works well with COMPILE-FILE*","title":"compile-file-pathname*"},{"location":"asdf/#compile-op","text":"Class Operation for compiling a Lisp file to a FASL Direct Slots asdf/action:selfward-operation","title":"compile-op"},{"location":"asdf/#compile-system","text":"Function: (compile-system system &rest args &key force force-not verbose version &allow-other-keys) Shorthand for (asdf:operate 'asdf:compile-op system) . See operate for details.","title":"compile-system"},{"location":"asdf/#compile-warned","text":"Condition","title":"compile-warned"},{"location":"asdf/#compile-warned-error","text":"Condition","title":"compile-warned-error"},{"location":"asdf/#compile-warned-warning","text":"Condition","title":"compile-warned-warning"},{"location":"asdf/#compiled-file","text":"Class Class for a file that is already compiled, e.g. as part of the implementation, of an outer build system that calls into ASDF, or of opaque libraries shipped along the source code. Direct Slots type","title":"compiled-file"},{"location":"asdf/#component","text":"Class Base class for all components of a build Direct Slots asdf/component:name asdf/component:version Initargs: :VERSION Readers: ASDF/COMPONENT:COMPONENT-VERSION Writers: (SETF ASDF/COMPONENT:COMPONENT-VERSION) asdf/component:description Initargs: :DESCRIPTION Readers: ASDF/COMPONENT:COMPONENT-DESCRIPTION Writers: (SETF ASDF/COMPONENT:COMPONENT-DESCRIPTION) asdf/component:long-description Initargs: :LONG-DESCRIPTION Readers: ASDF/COMPONENT:COMPONENT-LONG-DESCRIPTION Writers: (SETF ASDF/COMPONENT:COMPONENT-LONG-DESCRIPTION) asdf/component:sideway-dependencies asdf/component:if-feature Initargs: :IF-FEATURE Readers: ASDF/COMPONENT:COMPONENT-IF-FEATURE Writers: (SETF ASDF/COMPONENT:COMPONENT-IF-FEATURE) asdf/component:in-order-to Initargs: :IN-ORDER-TO Readers: ASDF/COMPONENT:COMPONENT-IN-ORDER-TO Writers: (SETF ASDF/COMPONENT:COMPONENT-IN-ORDER-TO) asdf/component:inline-methods asdf/component:relative-pathname Initargs: :PATHNAME asdf/component:absolute-pathname asdf/component:operation-times asdf/component:around-compile Initargs: :AROUND-COMPILE asdf/component:properties Initargs: :PROPERTIES Readers: ASDF/COMPONENT:COMPONENT-PROPERTIES Writers: (SETF ASDF/COMPONENT:COMPONENT-PROPERTIES) asdf/component:%encoding Initargs: :ENCODING Readers: ASDF/COMPONENT::%COMPONENT-ENCODING Writers: (SETF ASDF/COMPONENT::%COMPONENT-ENCODING) asdf/component:parent Initargs: :PARENT Readers: ASDF/COMPONENT:COMPONENT-PARENT asdf/component::build-operation Initargs: :BUILD-OPERATION Readers: ASDF/COMPONENT:COMPONENT-BUILD-OPERATION asdf/component::additional-input-files","title":"component"},{"location":"asdf/#component-children","text":"Generic Function: (component-children object)","title":"component-children"},{"location":"asdf/#component-children-by-name","text":"Generic Function: (component-children-by-name object)","title":"component-children-by-name"},{"location":"asdf/#component-depends-on","text":"Generic Function: (component-depends-on operation component) Returns a list of dependencies needed by the component to perform the operation. A dependency has one of the following forms: ( *), where is an operation designator with respect to find-operation in the context of the operation argument, and each is a component designator with respect to find-component in the context of the component argument, and means that the component depends on having been performed on each ; [Note: an is an operation designator -- it can be either an operation name or an operation object. Similarly, a may be a component name or a component object. Also note that, the degenerate case of ( ) is a no-op.] Methods specialized on subclasses of existing component types should usually append the results of CALL-NEXT-METHOD to the list.","title":"component-depends-on"},{"location":"asdf/#component-encoding","text":"Generic Function: (component-encoding component) The encoding of the component . By default, only :utf-8 is supported. Use asdf-encodings to support more encodings.","title":"component-encoding"},{"location":"asdf/#component-external-format","text":"Generic Function: (component-external-format component) The external-format of the component . By default, deduced from the component-encoding .","title":"component-external-format"},{"location":"asdf/#component-find-path","text":"Function: (component-find-path component) Return a path from a root system to the component . The return value is a list of component NAMES; a list of strings.","title":"component-find-path"},{"location":"asdf/#component-load-dependencies","text":"Function: (component-load-dependencies component) DEPRECATED. Please use component-sideway-dependencies instead; or better, define your operations with proper use of sideway-operation , selfward-operation , or define methods on prepare-op , etc.","title":"component-load-dependencies"},{"location":"asdf/#component-loaded-p","text":"Function: (component-loaded-p component) Has the given component been successfully loaded in the current image (yet)? Note that this returns true even if the component is not up to date.","title":"component-loaded-p"},{"location":"asdf/#component-name","text":"Generic Function: (component-name component) Name of the component , unique relative to its parent","title":"component-name"},{"location":"asdf/#component-parent","text":"Generic Function: (component-parent component) The parent of a child component , or NIL for top-level components (a.k.a. systems)","title":"component-parent"},{"location":"asdf/#component-pathname","text":"Generic Function: (component-pathname component) Pathname of the component if any, or NIL.","title":"component-pathname"},{"location":"asdf/#component-property","text":"Generic Function: (component-property component property)","title":"component-property"},{"location":"asdf/#component-relative-pathname","text":"Generic Function: (component-relative-pathname component) Specified pathname of the component , intended to be merged with the pathname of that component's parent if any, using merged-pathnames*. Despite the function's name, the return value can be an absolute pathname, in which case the merge will leave it unmodified.","title":"component-relative-pathname"},{"location":"asdf/#component-sideway-dependencies","text":"Generic Function: (component-sideway-dependencies object)","title":"component-sideway-dependencies"},{"location":"asdf/#component-system","text":"Generic Function: (component-system component) Top-level system containing the component","title":"component-system"},{"location":"asdf/#component-version","text":"Generic Function: (component-version component) Return the version of a component , which must be a string of dot-separated natural numbers, or NIL.","title":"component-version"},{"location":"asdf/#compute-source-registry","text":"Function: (compute-source-registry &optional (parameter *source-registry-parameter*) (registry *source-registry*))","title":"compute-source-registry"},{"location":"asdf/#concatenate-source-op","text":"Class Operation to concatenate all sources in a system into a single file","title":"concatenate-source-op"},{"location":"asdf/#define-op","text":"Class An operation to record dependencies on loading a .asd file.","title":"define-op"},{"location":"asdf/#defsystem","text":"Macro: (defsystem name &body options)","title":"defsystem"},{"location":"asdf/#deliver-asd-op","text":"Class produce an asd file for delivering the system as a single fasl Direct Slots asdf/action:selfward-operation","title":"deliver-asd-op"},{"location":"asdf/#disable-deferred-warnings-check","text":"Function: (disable-deferred-warnings-check) Disable the saving of deferred warnings","title":"disable-deferred-warnings-check"},{"location":"asdf/#disable-output-translations","text":"Function: (disable-output-translations) Initialize output translations in a way that maps every file to itself, effectively disabling the output translation facility.","title":"disable-output-translations"},{"location":"asdf/#dll-op","text":"Class Compile the system and produce a dynamic loadable library (.so/.dll) for all the linkable object files associated with the system. Compare with LIB-OP. Direct Slots asdf/bundle::gather-type asdf/bundle:bundle-type","title":"dll-op"},{"location":"asdf/#doc-file","text":"Class","title":"doc-file"},{"location":"asdf/#downward-operation","text":"Generic Function: (downward-operation object) Class A DOWNWARD-OPERATION's dependencies propagate down the component hierarchy. I.e., if O is a DOWNWARD-OPERATION and its DOWNWARD-OPERATION slot designates operation D, then the action (O . M) of O on module M will depends on each of (D . C) for each child C of module M. The default value for slot DOWNWARD-OPERATION is NIL, which designates the operation O itself. E.g. in order for a MODULE to be loaded with LOAD-OP (resp. compiled with COMPILE-OP), all the children of the MODULE must have been loaded with LOAD-OP (resp. compiled with COMPILE-OP. Direct Slots asdf/action:downward-operation","title":"downward-operation"},{"location":"asdf/#duplicate-names","text":"Condition Direct Slots asdf/component:name Initargs: :NAME Readers: ASDF/COMPONENT::DUPLICATE-NAMES-NAME","title":"duplicate-names"},{"location":"asdf/#enable-asdf-binary-locations-compatibility","text":"Function: (enable-asdf-binary-locations-compatibility &key (centralize-lisp-binaries NIL) (default-toplevel-directory (subpathname (user-homedir-pathname) .fasls/)) (include-per-user-information NIL) (map-all-source-files (or NIL)) (source-to-target-mappings NIL) (file-types (quasiquote (,(UIOP/LISP-BUILD:COMPILE-FILE-TYPE) build-report cfasl sbcl-warnings)))) DEPRECATED. Use asdf-output-translations instead.","title":"enable-asdf-binary-locations-compatibility"},{"location":"asdf/#enable-deferred-warnings-check","text":"Function: (enable-deferred-warnings-check) Enable the saving of deferred warnings","title":"enable-deferred-warnings-check"},{"location":"asdf/#ensure-output-translations","text":"Function: (ensure-output-translations)","title":"ensure-output-translations"},{"location":"asdf/#ensure-source-registry","text":"Function: (ensure-source-registry &optional parameter)","title":"ensure-source-registry"},{"location":"asdf/#error-component","text":"Generic Function: (error-component condition)","title":"error-component"},{"location":"asdf/#error-name","text":"Generic Function: (error-name condition)","title":"error-name"},{"location":"asdf/#error-operation","text":"Generic Function: (error-operation condition)","title":"error-operation"},{"location":"asdf/#error-pathname","text":"Generic Function: (error-pathname condition)","title":"error-pathname"},{"location":"asdf/#explain","text":"Generic Function: (explain operation component) Display a message describing an action. DEPRECATED. Use ASDF: action-description and/or ASDF::FORMAT-ACTION instead.","title":"explain"},{"location":"asdf/#file-component","text":"Class a COMPONENT that represents a file Direct Slots type Initargs: :TYPE Readers: ASDF/COMPONENT:FILE-TYPE Writers: (SETF ASDF/COMPONENT:FILE-TYPE)","title":"file-component"},{"location":"asdf/#file-type","text":"Generic Function: (file-type object)","title":"file-type"},{"location":"asdf/#find-component","text":"Generic Function: (find-component base path &key registered) Find a component by resolving the path starting from base parent. If registered is true, only search currently registered systems.","title":"find-component"},{"location":"asdf/#find-operation","text":"Generic Function: (find-operation context spec) Find an operation by resolving the spec in the context","title":"find-operation"},{"location":"asdf/#find-system","text":"Generic Function: (find-system system &optional error-p) Given a system designator, find the actual corresponding system object. If no system is found, then signal an error if error-p is true (the default), or else return NIL. A system designator is usually a string (conventionally all lowercase) or a symbol, designating the same system as its downcased name; it can also be a system object (designating itself).","title":"find-system"},{"location":"asdf/#hostname","text":"Function: (hostname) return the hostname of the current host","title":"hostname"},{"location":"asdf/#html-file","text":"Class Direct Slots type","title":"html-file"},{"location":"asdf/#image-op","text":"Class create an image file from the system and its dependencies Direct Slots asdf/bundle:bundle-type asdf/bundle::gather-operation asdf/action:selfward-operation","title":"image-op"},{"location":"asdf/#implementation-identifier","text":"Function: (implementation-identifier) Return a string that identifies the ABI of the current implementation, suitable for use as a directory name to segregate Lisp FASLs, C dynamic libraries, etc.","title":"implementation-identifier"},{"location":"asdf/#implementation-type","text":"Function: (implementation-type) The type of Lisp implementation used, as a short UIOP-standardized keyword","title":"implementation-type"},{"location":"asdf/#initialize-output-translations","text":"Function: (initialize-output-translations &optional (parameter *output-translations-parameter*)) read the configuration, initialize the internal configuration variable, return the configuration","title":"initialize-output-translations"},{"location":"asdf/#initialize-source-registry","text":"Function: (initialize-source-registry &optional (parameter *source-registry-parameter*))","title":"initialize-source-registry"},{"location":"asdf/#input-files","text":"Generic Function: (input-files operation component) A list of input files corresponding to this action. Methods on perform must call this function to determine where their inputs are located. They may rely on the order of the files to discriminate between inputs.","title":"input-files"},{"location":"asdf/#java-source-file","text":"Class Direct Slots type","title":"java-source-file"},{"location":"asdf/#lib-op","text":"Class Compile the system and produce a linkable static library (.a/.lib) for all the linkable object files associated with the system. Compare with DLL-OP. On most implementations, these object files only include extensions to the runtime written in C or another language with a compiler producing linkable object files. On CLASP, ECL, MKCL, these object files also include the contents of Lisp files themselves. In any case, this operation will produce what you need to further build a static runtime for your system, or a dynamic library to load in an existing runtime. Direct Slots asdf/bundle::gather-type asdf/bundle:bundle-type","title":"lib-op"},{"location":"asdf/#load-asd","text":"Function: (load-asd pathname &key name) Load system definitions from pathname . name if supplied is the name of a system expected to be defined in that file. Do NOT try to load a .asd file directly with CL:LOAD. Always use ASDF: load-asd .","title":"load-asd"},{"location":"asdf/#load-bundle-op","text":"Class This operator is an alternative to LOAD-OP. Build a system and all of its dependencies, using COMPILE-BUNDLE-OP. The difference with respect to LOAD-OP is that it builds only a single FASL, which may be faster and more resource efficient. Direct Slots asdf/action:selfward-operation","title":"load-bundle-op"},{"location":"asdf/#load-compiled-concatenated-source-op","text":"Class Operation to load the result of compile-concatenated-source-op Direct Slots asdf/action:selfward-operation","title":"load-compiled-concatenated-source-op"},{"location":"asdf/#load-concatenated-source-op","text":"Class Operation to load the result of concatenate-source-op as source","title":"load-concatenated-source-op"},{"location":"asdf/#load-op","text":"Class Operation for loading the compiled FASL for a Lisp file Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: '(ASDF/LISP-ACTION:PREPARE-OP ASDF/LISP-ACTION:COMPILE-OP)","title":"load-op"},{"location":"asdf/#load-source-op","text":"Class Operation for loading a Lisp file as source. Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/LISP-ACTION:PREPARE-SOURCE-OP","title":"load-source-op"},{"location":"asdf/#load-system","text":"Function: (load-system system &rest keys &key force force-not verbose version &allow-other-keys) Shorthand for (operate 'asdf:load-op system) . See operate for details.","title":"load-system"},{"location":"asdf/#load-system-definition-error","text":"Condition Direct Slots asdf/component:name Initargs: :NAME Readers: ASDF/FIND-SYSTEM:ERROR-NAME pathname Initargs: :PATHNAME Readers: ASDF/FIND-SYSTEM:ERROR-PATHNAME condition Initargs: :CONDITION Readers: ASDF/FIND-SYSTEM:ERROR-CONDITION","title":"load-system-definition-error"},{"location":"asdf/#load-systems","text":"Function: (load-systems &rest systems) Loading multiple systems at once.","title":"load-systems"},{"location":"asdf/#load-systems_1","text":"Function: (load-systems* systems &rest keys) Loading multiple systems at once.","title":"load-systems*"},{"location":"asdf/#locate-system","text":"Function: (locate-system name) Given a system name designator, try to locate where to load the system from. Returns five values: FOUNDP FOUND-SYSTEM PATHNAME PREVIOUS PREVIOUS-TIME FOUNDP is true when a system was found, either a new unregistered one or a previously registered one. FOUND-SYSTEM when not null is a system object that may be REGISTER-SYSTEM'ed. PATHNAME when not null is a path from which to load the system, either associated with FOUND-SYSTEM, or with the PREVIOUS system. PREVIOUS when not null is a previously loaded system object of same name. PREVIOUS-TIME when not null is the time at which the PREVIOUS system was loaded.","title":"locate-system"},{"location":"asdf/#make","text":"Function: (make system &rest keys) The recommended way to interact with ASDF3.1 is via (ASDF: make :FOO). It will build system FOO using the operation build-op , the meaning of which is configurable by the system, and defaults to load-op , to load it in current image.","title":"make"},{"location":"asdf/#make-operation","text":"Function: (make-operation operation-class) This function creates and memoizes an instance of operation-class . All operation instances MUST be created through this function. Use of INITARGS is not supported at this time.","title":"make-operation"},{"location":"asdf/#make-plan","text":"Generic Function: (make-plan plan-class operation component &key &allow-other-keys) Generate and return a plan for performing operation on component .","title":"make-plan"},{"location":"asdf/#map-systems","text":"Function: (map-systems fn) Apply fn to each defined system. fn should be a function of one argument. It will be called with an object of type asdf:system.","title":"map-systems"},{"location":"asdf/#missing-component","text":"Condition Direct Slots asdf/find-component::requires Initargs: :REQUIRES asdf/component:parent Initargs: :PARENT","title":"missing-component"},{"location":"asdf/#missing-component-of-version","text":"Condition Direct Slots asdf/component:version Initargs: :VERSION","title":"missing-component-of-version"},{"location":"asdf/#missing-dependency","text":"Condition Direct Slots asdf/find-component::required-by Initargs: :REQUIRED-BY Readers: ASDF/FIND-COMPONENT:MISSING-REQUIRED-BY","title":"missing-dependency"},{"location":"asdf/#missing-dependency-of-version","text":"Condition","title":"missing-dependency-of-version"},{"location":"asdf/#module","text":"Class A module is a intermediate component with both a parent and children, typically but not necessarily representing the files in a subdirectory of the build source.","title":"module"},{"location":"asdf/#module-components","text":"Generic Function: (module-components object)","title":"module-components"},{"location":"asdf/#monolithic-bundle-op","text":"Class operations that are both monolithic-op and bundle-op Direct Slots asdf/bundle:prologue-code Readers: ASDF/BUNDLE:PROLOGUE-CODE Writers: (SETF ASDF/BUNDLE:PROLOGUE-CODE) asdf/bundle:epilogue-code Readers: ASDF/BUNDLE:EPILOGUE-CODE Writers: (SETF ASDF/BUNDLE:EPILOGUE-CODE)","title":"monolithic-bundle-op"},{"location":"asdf/#monolithic-compile-bundle-op","text":"Class Create a single fasl for the system and its dependencies.","title":"monolithic-compile-bundle-op"},{"location":"asdf/#monolithic-compile-concatenated-source-op","text":"Class Operation to compile the result of monolithic-concatenate-source-op Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/CONCATENATE-SOURCE:MONOLITHIC-CONCATENATE-SOURCE-OP","title":"monolithic-compile-concatenated-source-op"},{"location":"asdf/#monolithic-concatenate-source-op","text":"Class Operation to concatenate all sources in a system and its dependencies into a single file","title":"monolithic-concatenate-source-op"},{"location":"asdf/#monolithic-deliver-asd-op","text":"Class produce fasl and asd files for combined system and dependencies. Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: '(ASDF/BUNDLE:MONOLITHIC-COMPILE-BUNDLE-OP)","title":"monolithic-deliver-asd-op"},{"location":"asdf/#monolithic-dll-op","text":"Class Compile the system and produce a dynamic loadable library (.so/.dll) for all the linkable object files associated with the system or its dependencies. See LIB-OP","title":"monolithic-dll-op"},{"location":"asdf/#monolithic-lib-op","text":"Class Compile the system and produce a linkable static library (.a/.lib) for all the linkable object files associated with the system or its dependencies. See LIB-OP.","title":"monolithic-lib-op"},{"location":"asdf/#monolithic-load-bundle-op","text":"Class Load a single fasl for the system and its dependencies. Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/BUNDLE:MONOLITHIC-COMPILE-BUNDLE-OP","title":"monolithic-load-bundle-op"},{"location":"asdf/#monolithic-load-compiled-concatenated-source-op","text":"Class Operation to load the result of monolithic-compile-concatenated-source-op Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/CONCATENATE-SOURCE:MONOLITHIC-COMPILE-CONCATENATED-SOURCE-OP","title":"monolithic-load-compiled-concatenated-source-op"},{"location":"asdf/#monolithic-load-concatenated-source-op","text":"Class Operation to load the result of monolithic-concatenate-source-op as source Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/CONCATENATE-SOURCE:MONOLITHIC-CONCATENATE-SOURCE-OP","title":"monolithic-load-concatenated-source-op"},{"location":"asdf/#needed-in-image-p","text":"Generic Function: (needed-in-image-p operation component) Is the action of operation on component needed in the current image to be meaningful, or could it just as well have been done in another Lisp image?","title":"needed-in-image-p"},{"location":"asdf/#non-propagating-operation","text":"Class A NON-PROPAGATING-OPERATION is an operation that propagates no dependencies whatsoever. It is supplied in order that the programmer be able to specify that s/he is intentionally specifying an operation which invokes no dependencies.","title":"non-propagating-operation"},{"location":"asdf/#non-system-system","text":"Condition Direct Slots asdf/component:name Initargs: :NAME class-name Initargs: :CLASS-NAME","title":"non-system-system"},{"location":"asdf/#non-toplevel-system","text":"Condition Direct Slots asdf/component:parent Initargs: :PARENT asdf/component:name Initargs: :NAME","title":"non-toplevel-system"},{"location":"asdf/#oos","text":"Function: (oos operation component &rest args &key &allow-other-keys) Short for operate on system and an alias for the operate function. Operate does mainly four things for the user: Resolves the operation designator into an operation object. operation is typically a symbol denoting an operation class, instantiated with make-operation . Resolves the component designator into a component object. component is typically a string or symbol naming a system, loaded from disk using find-system . It then calls make-plan with the operation and system as arguments. Finally calls perform-plan on the resulting plan to actually build the system. The entire computation is wrapped in WITH-COMPILATION-UNIT and error handling code. If a version argument is supplied, then operate also ensures that the system found satisfies it using the version-satisfies method. If a PLAN-CLASS argument is supplied, that class is used for the plan. If a PLAN-OPTIONS argument is supplied, the options are passed to the plan. The :FORCE or :FORCE-NOT argument to operate can be: T to force the inside of the specified system to be rebuilt (resp. not), without recursively forcing the other systems we depend on. :ALL to force all systems including other systems we depend on to be rebuilt (resp. not). ( system 1 system 2 ... SYSTEMN) to force systems named in a given list :FORCE-NOT has precedence over :FORCE; builtin systems cannot be forced. For backward compatibility, all keyword arguments are passed to make-operation when instantiating a new operation, that will in turn be inherited by new operations. But do NOT depend on it, for this is deprecated behavior.","title":"oos"},{"location":"asdf/#operate","text":"Generic Function: (operate operation component &key plan-class plan-options version verbose on-warnings on-failure &allow-other-keys) Operate does mainly four things for the user: Resolves the operation designator into an operation object. operation is typically a symbol denoting an operation class, instantiated with make-operation . Resolves the component designator into a component object. component is typically a string or symbol naming a system, loaded from disk using find-system . It then calls make-plan with the operation and system as arguments. Finally calls perform-plan on the resulting plan to actually build the system. The entire computation is wrapped in WITH-COMPILATION-UNIT and error handling code. If a version argument is supplied, then operate also ensures that the system found satisfies it using the version-satisfies method. If a plan-class argument is supplied, that class is used for the plan. If a plan-options argument is supplied, the options are passed to the plan. The :FORCE or :FORCE-NOT argument to operate can be: T to force the inside of the specified system to be rebuilt (resp. not), without recursively forcing the other systems we depend on. :ALL to force all systems including other systems we depend on to be rebuilt (resp. not). ( system 1 system 2 ... SYSTEMN) to force systems named in a given list :FORCE-NOT has precedence over :FORCE; builtin systems cannot be forced. For backward compatibility, all keyword arguments are passed to make-operation when instantiating a new operation, that will in turn be inherited by new operations. But do NOT depend on it, for this is deprecated behavior.","title":"operate"},{"location":"asdf/#operation","text":"Class The base class for all ASDF operations. ASDF does NOT and never did distinguish between multiple operations of the same class. Therefore, all slots of all operations MUST have :allocation :class and no initargs. No exceptions.","title":"operation"},{"location":"asdf/#operation-definition-error","text":"Condition Error condition related to definition of incorrect OPERATION objects.","title":"operation-definition-error"},{"location":"asdf/#operation-definition-warning","text":"Condition Warning condition related to definition of obsolete OPERATION objects.","title":"operation-definition-warning"},{"location":"asdf/#operation-done-p","text":"Generic Function: (operation-done-p operation component) Returns a boolean which is NIL if the action must be performed (again).","title":"operation-done-p"},{"location":"asdf/#operation-error","text":"Condition Direct Slots asdf/component:component Initargs: :COMPONENT Readers: ASDF/BACKWARD-INTERFACE:ERROR-COMPONENT asdf/operation:operation Initargs: :OPERATION Readers: ASDF/BACKWARD-INTERFACE:ERROR-OPERATION","title":"operation-error"},{"location":"asdf/#operation-monolithic-p","text":"Function: (operation-monolithic-p op)","title":"operation-monolithic-p"},{"location":"asdf/#operation-on-failure","text":"Generic Function: (operation-on-failure operation) DEPRECATED. Please use UIOP: COMPILE-FILE-FAILURE-BEHAVIOUR instead.","title":"operation-on-failure"},{"location":"asdf/#operation-on-warnings","text":"Generic Function: (operation-on-warnings operation) DEPRECATED. Please use UIOP: COMPILE-FILE-WARNINGS-BEHAVIOUR instead.","title":"operation-on-warnings"},{"location":"asdf/#output-file","text":"Function: (output-file operation component) The unique output file of performing operation on component","title":"output-file"},{"location":"asdf/#output-files","text":"Generic Function: (output-files operation component) Methods for this function return two values: a list of output files corresponding to this action, and a boolean indicating if they have already been subjected to relevant output translations and should not be further translated. Methods on perform must call this function to determine where their outputs are to be located. They may rely on the order of the files to discriminate between outputs.","title":"output-files"},{"location":"asdf/#package-inferred-system","text":"Class Class for primary systems for which secondary systems are automatically in the one-file, one-file, one-system style: system names are mapped to files under the primary system's system-source-directory, dependencies are inferred from the first defpackage form in every such file","title":"package-inferred-system"},{"location":"asdf/#package-inferred-system-missing-package-error","text":"Condition Direct Slots asdf/system:system Initargs: :SYSTEM pathname Initargs: :PATHNAME","title":"package-inferred-system-missing-package-error"},{"location":"asdf/#package-system","text":"Class","title":"package-system"},{"location":"asdf/#parent-component","text":"Class A PARENT-COMPONENT is a component that may have children. Direct Slots asdf/component:children Initargs: :COMPONENTS asdf/component:children-by-name asdf/component:default-component-class Initargs: :DEFAULT-COMPONENT-CLASS Readers: ASDF/COMPONENT:MODULE-DEFAULT-COMPONENT-CLASS Writers: (SETF ASDF/COMPONENT:MODULE-DEFAULT-COMPONENT-CLASS)","title":"parent-component"},{"location":"asdf/#perform","text":"Generic Function: (perform operation component) perform an action, consuming its input-files and building its output-files","title":"perform"},{"location":"asdf/#perform-plan","text":"Generic Function: (perform-plan plan &key) Actually perform a plan and build the requested actions","title":"perform-plan"},{"location":"asdf/#perform-with-restarts","text":"Generic Function: (perform-with-restarts operation component) perform an action in a context where suitable restarts are in place.","title":"perform-with-restarts"},{"location":"asdf/#precompiled-system","text":"Class Class For a system that is delivered as a precompiled fasl Direct Slots asdf/system:build-pathname Initargs: :FASL, :FASB","title":"precompiled-system"},{"location":"asdf/#prepare-bundle-op","text":"Class Operation class for loading the bundles of a system's dependencies Direct Slots asdf/action:sideway-operation Allocation: :CLASS Initform: 'ASDF/LISP-ACTION:LOAD-OP","title":"prepare-bundle-op"},{"location":"asdf/#prepare-op","text":"Class Load the dependencies for the COMPILE-OP or LOAD-OP of a given COMPONENT. Direct Slots asdf/action:sideway-operation Allocation: :CLASS Initform: 'ASDF/LISP-ACTION:LOAD-OP","title":"prepare-op"},{"location":"asdf/#prepare-source-op","text":"Class Operation for loading the dependencies of a Lisp file as source. Direct Slots asdf/action:sideway-operation Allocation: :CLASS Initform: 'ASDF/LISP-ACTION:LOAD-SOURCE-OP","title":"prepare-source-op"},{"location":"asdf/#primary-system-name","text":"Function: (primary-system-name system-designator) Given a system designator NAME, return the name of the corresponding primary system, after which the .asd file is named. That's the first component when dividing the name as a string by / slashes. A component designates its system.","title":"primary-system-name"},{"location":"asdf/#process-source-registry","text":"Generic Function: (process-source-registry spec &key inherit register)","title":"process-source-registry"},{"location":"asdf/#program-op","text":"Class create an executable file from the system and its dependencies Direct Slots asdf/bundle:bundle-type Allocation: :CLASS Initform: :PROGRAM","title":"program-op"},{"location":"asdf/#program-system","text":"Class Direct Slots asdf/bundle:prologue-code Initargs: :PROLOGUE-CODE Readers: ASDF/BUNDLE:PROLOGUE-CODE asdf/bundle:epilogue-code Initargs: :EPILOGUE-CODE Readers: ASDF/BUNDLE:EPILOGUE-CODE asdf/bundle::no-uiop Initargs: :NO-UIOP asdf/bundle::prefix-lisp-object-files Initargs: :PREFIX-LISP-OBJECT-FILES asdf/bundle::postfix-lisp-object-files Initargs: :POSTFIX-LISP-OBJECT-FILES asdf/bundle::extra-object-files Initargs: :EXTRA-OBJECT-FILES asdf/bundle::extra-build-args Initargs: :EXTRA-BUILD-ARGS","title":"program-system"},{"location":"asdf/#register-immutable-system","text":"Function: (register-immutable-system system-name &rest keys) Register system-name as preloaded and immutable. It will automatically be considered as passed to FORCE-NOT in a plan.","title":"register-immutable-system"},{"location":"asdf/#register-preloaded-system","text":"Function: (register-preloaded-system system-name &rest keys &key (version t) &allow-other-keys) Register a system as being preloaded. If the system has not been loaded from the filesystem yet, or if its build information is later cleared with clear-system , a dummy system will be registered without backing filesystem information, based on keys (e.g. to provide a version ). If version is the default T, and a system was already loaded, then its version will be preserved.","title":"register-preloaded-system"},{"location":"asdf/#register-system-packages","text":"Function: (register-system-packages system packages) Register system as providing packages .","title":"register-system-packages"},{"location":"asdf/#registered-system","text":"Function: (registered-system name) Return a system of given name that was registered already, if such a system exists. name is a system designator, to be normalized by coerce-name . The value returned is a system object, or NIL if not found.","title":"registered-system"},{"location":"asdf/#registered-systems","text":"Function: (registered-systems) Return a list of the names of every registered system.","title":"registered-systems"},{"location":"asdf/#require-system","text":"Function: (require-system system &rest keys &key &allow-other-keys) Ensure the specified system is loaded, passing the keys to operate , but do not update the system or its dependencies if it has already been loaded. Class A SYSTEM subclass whose processing is handled by the implementation's REQUIRE rather than by internal ASDF mechanisms. Direct Slots asdf/component:module Initargs: :MODULE","title":"require-system"},{"location":"asdf/#required-components","text":"Function: (required-components system &rest keys &key (goal-operation (quote load-op)) &allow-other-keys) Given a system and a goal-operation (default load-op ), traverse the dependencies and return a list of the components involved in building the desired action.","title":"required-components"},{"location":"asdf/#resolve-location","text":"Function: (resolve-location x &key ensure-directory wilden directory) Resolve location designator x into a PATHNAME","title":"resolve-location"},{"location":"asdf/#run-shell-command","text":"Function: (run-shell-command control-string &rest args) PLEASE DO NOT USE. This function is not just DEPRECATED, but also dysfunctional. Please use UIOP:RUN-PROGRAM instead.","title":"run-shell-command"},{"location":"asdf/#search-for-system-definition","text":"Function: (search-for-system-definition system)","title":"search-for-system-definition"},{"location":"asdf/#selfward-operation","text":"Generic Function: (selfward-operation object) Class A SELFWARD-OPERATION depends on another operation on the same component. I.e., if O is a SELFWARD-OPERATION, and its SELFWARD-OPERATION designates a list of operations L, then the action (O . C) of O on component C depends on each (S . C) for S in L. E.g. before a component may be loaded by LOAD-OP, it must have been compiled by COMPILE-OP. A operation-designator designates a singleton list of the designated operation; a list of operation-designators designates the list of designated operations; NIL is not a valid operation designator in that context. Note that any dependency ordering between the operations in a list of SELFWARD-OPERATION should be specified separately in the respective operation's COMPONENT-DEPENDS-ON methods so that they be scheduled properly. Direct Slots asdf/action:selfward-operation Type: (OR ASDF/ACTION::OPERATION-DESIGNATOR LIST) Allocation: :CLASS Readers: ASDF/ACTION:SELFWARD-OPERATION","title":"selfward-operation"},{"location":"asdf/#sequential-plan","text":"Class Simplest, default plan class, accumulating a sequence of actions","title":"sequential-plan"},{"location":"asdf/#sideway-operation","text":"Generic Function: (sideway-operation object) Class A SIDEWAY-OPERATION has dependencies that propagate \"sideway\" to siblings that a component depends on. I.e. if O is a SIDEWAY-OPERATION, and its SIDEWAY-OPERATION slot designates operation S (where NIL designates O itself), then the action (O . C) of O on component C depends on each of (S . D) where D is a declared dependency of C. E.g. in order for a COMPONENT to be prepared for loading or compiling with PREPARE-OP, each of its declared dependencies must first be loaded as by LOAD-OP. Direct Slots asdf/action:sideway-operation Type: ASDF/ACTION::OPERATION-DESIGNATOR Allocation: :CLASS Readers: ASDF/ACTION:SIDEWAY-OPERATION","title":"sideway-operation"},{"location":"asdf/#source-file","text":"Class Direct Slots type Readers: ASDF/COMPONENT:SOURCE-FILE-EXPLICIT-TYPE Writers: (SETF ASDF/COMPONENT:SOURCE-FILE-EXPLICIT-TYPE)","title":"source-file"},{"location":"asdf/#source-file-type","text":"Generic Function: (source-file-type component system) DEPRECATED. Use the file-type of a component instead.","title":"source-file-type"},{"location":"asdf/#static-file","text":"Class Component for a file to be included as is in the build output Direct Slots type","title":"static-file"},{"location":"asdf/#sysdef-immutable-system-search","text":"Function: (sysdef-immutable-system-search requested)","title":"sysdef-immutable-system-search"},{"location":"asdf/#sysdef-preloaded-system-search","text":"Function: (sysdef-preloaded-system-search requested) If requested names a system registered as preloaded, return a new system with its registration information.","title":"sysdef-preloaded-system-search"},{"location":"asdf/#system","text":"Class SYSTEM is the base class for top-level components that users may request ASDF to build. Direct Slots asdf/component:description Readers: ASDF/SYSTEM:SYSTEM-DESCRIPTION Writers: (SETF ASDF/SYSTEM:SYSTEM-DESCRIPTION) asdf/component:long-description Readers: ASDF/SYSTEM:SYSTEM-LONG-DESCRIPTION Writers: (SETF ASDF/SYSTEM:SYSTEM-LONG-DESCRIPTION) asdf/component:author Initargs: :AUTHOR Readers: ASDF/SYSTEM:SYSTEM-AUTHOR Writers: (SETF ASDF/SYSTEM:SYSTEM-AUTHOR) asdf/component:maintainer Initargs: :MAINTAINER Readers: ASDF/SYSTEM:SYSTEM-MAINTAINER Writers: (SETF ASDF/SYSTEM:SYSTEM-MAINTAINER) asdf/component:licence Initargs: :LICENSE, :LICENCE Readers: ASDF/SYSTEM:SYSTEM-LICENSE, ASDF/SYSTEM:SYSTEM-LICENCE Writers: (SETF ASDF/SYSTEM:SYSTEM-LICENSE), (SETF ASDF/SYSTEM:SYSTEM-LICENCE) asdf/system:homepage Initargs: :HOMEPAGE Readers: ASDF/SYSTEM:SYSTEM-HOMEPAGE Writers: (SETF ASDF/SYSTEM:SYSTEM-HOMEPAGE) asdf/system:bug-tracker Initargs: :BUG-TRACKER Readers: ASDF/SYSTEM:SYSTEM-BUG-TRACKER Writers: (SETF ASDF/SYSTEM:SYSTEM-BUG-TRACKER) asdf/system:mailto Initargs: :MAILTO Readers: ASDF/SYSTEM:SYSTEM-MAILTO Writers: (SETF ASDF/SYSTEM:SYSTEM-MAILTO) asdf/system:long-name Initargs: :LONG-NAME Readers: ASDF/SYSTEM:SYSTEM-LONG-NAME Writers: (SETF ASDF/SYSTEM:SYSTEM-LONG-NAME) asdf/system:source-control Initargs: :SOURCE-CONTROL Readers: ASDF/SYSTEM:SYSTEM-SOURCE-CONTROL Writers: (SETF ASDF/SYSTEM:SYSTEM-SOURCE-CONTROL) asdf/system:builtin-system-p Initargs: :BUILTIN-SYSTEM-P Readers: ASDF/SYSTEM:BUILTIN-SYSTEM-P Writers: (SETF ASDF/SYSTEM:BUILTIN-SYSTEM-P) asdf/system:build-pathname Initargs: :BUILD-PATHNAME Readers: ASDF/SYSTEM:COMPONENT-BUILD-PATHNAME Writers: (SETF ASDF/SYSTEM:COMPONENT-BUILD-PATHNAME) asdf/system:entry-point Initargs: :ENTRY-POINT Readers: ASDF/SYSTEM:COMPONENT-ENTRY-POINT Writers: (SETF ASDF/SYSTEM:COMPONENT-ENTRY-POINT) asdf/component:source-file Initargs: :SOURCE-FILE Readers: ASDF/SYSTEM:SYSTEM-SOURCE-FILE Writers: (SETF ASDF/SYSTEM:SYSTEM-SOURCE-FILE) asdf/component:defsystem-depends-on Initargs: :DEFSYSTEM-DEPENDS-ON Readers: ASDF/SYSTEM:SYSTEM-DEFSYSTEM-DEPENDS-ON asdf/system::depends-on Initargs: :DEFSYSTEM-DEPENDS-ON Readers: ASDF/SYSTEM:SYSTEM-DEFSYSTEM-DEPENDS-ON asdf/system::weakly-depends-on Readers: ASDF/SYSTEM:SYSTEM-WEAKLY-DEPENDS-ON","title":"system"},{"location":"asdf/#system-author","text":"Generic Function: (system-author object)","title":"system-author"},{"location":"asdf/#system-bug-tracker","text":"Generic Function: (system-bug-tracker object)","title":"system-bug-tracker"},{"location":"asdf/#system-definition-error","text":"Condition","title":"system-definition-error"},{"location":"asdf/#system-definition-pathname","text":"Function: (system-definition-pathname x) DEPRECATED. This function used to expose ASDF internals with subtle differences with respect to user expectations, that have been refactored away since. We recommend you use ASDF: system-source-file instead for a mostly compatible replacement that we're supporting, or even ASDF: system-source-directory or ASDF: system-relative-pathname if that's whay you mean.","title":"system-definition-pathname"},{"location":"asdf/#system-defsystem-depends-on","text":"Generic Function: (system-defsystem-depends-on object)","title":"system-defsystem-depends-on"},{"location":"asdf/#system-depends-on","text":"Generic Function: (system-depends-on object)","title":"system-depends-on"},{"location":"asdf/#system-description","text":"Generic Function: (system-description object)","title":"system-description"},{"location":"asdf/#system-homepage","text":"Generic Function: (system-homepage object)","title":"system-homepage"},{"location":"asdf/#system-licence","text":"Generic Function: (system-licence object)","title":"system-licence"},{"location":"asdf/#system-license","text":"Generic Function: (system-license object)","title":"system-license"},{"location":"asdf/#system-long-description","text":"Generic Function: (system-long-description object)","title":"system-long-description"},{"location":"asdf/#system-long-name","text":"Generic Function: (system-long-name object)","title":"system-long-name"},{"location":"asdf/#system-mailto","text":"Generic Function: (system-mailto object)","title":"system-mailto"},{"location":"asdf/#system-maintainer","text":"Generic Function: (system-maintainer object)","title":"system-maintainer"},{"location":"asdf/#system-out-of-date","text":"Condition condition signaled when a system is detected as being out of date Direct Slots asdf/component:name Initargs: :NAME Readers: ASDF/COMPONENT:COMPONENT-NAME","title":"system-out-of-date"},{"location":"asdf/#system-output-translations-directory-pathname","text":"Function: (system-output-translations-directory-pathname &key (direction :input))","title":"system-output-translations-directory-pathname"},{"location":"asdf/#system-output-translations-pathname","text":"Function: (system-output-translations-pathname &key (direction :input))","title":"system-output-translations-pathname"},{"location":"asdf/#system-registered-p","text":"Function: (system-registered-p name) DEPRECATED. Return a generalized boolean that is true if a system of given name was registered already. name is a system designator, to be normalized by coerce-name . The value returned if true is a pair of a timestamp and a system object.","title":"system-registered-p"},{"location":"asdf/#system-relative-pathname","text":"Function: (system-relative-pathname system name &key type) Given a system , and a (Unix-style relative path) name of a file (or directory) of given type , return the absolute pathname of a corresponding file under that system's source code pathname.","title":"system-relative-pathname"},{"location":"asdf/#system-source-control","text":"Generic Function: (system-source-control object)","title":"system-source-control"},{"location":"asdf/#system-source-directory","text":"Function: (system-source-directory system-designator) Return a pathname object corresponding to the directory in which the system specification (.asd file) is located.","title":"system-source-directory"},{"location":"asdf/#system-source-file","text":"Generic Function: (system-source-file system) Return the source file in which system is defined.","title":"system-source-file"},{"location":"asdf/#system-source-registry","text":"Function: (system-source-registry &key (direction :input))","title":"system-source-registry"},{"location":"asdf/#system-source-registry-directory","text":"Function: (system-source-registry-directory &key (direction :input))","title":"system-source-registry-directory"},{"location":"asdf/#system-weakly-depends-on","text":"Generic Function: (system-weakly-depends-on object)","title":"system-weakly-depends-on"},{"location":"asdf/#test-op","text":"Class Operation for running the tests for system. If the tests fail, an error will be signaled. Direct Slots asdf/action:selfward-operation Allocation: :CLASS Initform: 'ASDF/LISP-ACTION:LOAD-OP","title":"test-op"},{"location":"asdf/#test-system","text":"Function: (test-system system &rest args &key force force-not verbose version &allow-other-keys) Shorthand for (asdf:operate 'asdf:test-op system) . See operate for details.","title":"test-system"},{"location":"asdf/#traverse","text":"Generic Function: (traverse operation component &key plan-class &allow-other-keys) DEPRECATED. Use make-plan and PLAN-ACTIONS, or required-components , or some other supported interface instead. Generate and return a plan for performing operation on component . The plan returned is a list of dotted-pairs. Each pair is the CONS of ASDF operation object and a component object. The pairs will be processed in order by operate .","title":"traverse"},{"location":"asdf/#upgrade-asdf","text":"Function: (upgrade-asdf) Try to upgrade of ASDF. If a different version was used, return T. We need do that before we operate on anything that may possibly depend on ASDF.","title":"upgrade-asdf"},{"location":"asdf/#upward-operation","text":"Generic Function: (upward-operation object) Class An UPWARD-OPERATION has dependencies that propagate up the component hierarchy. I.e., if O is an instance of UPWARD-OPERATION, and its UPWARD-OPERATION slot designates operation U, then the action (O . C) of O on a component C that has the parent P will depends on (U . P). The default value for slot UPWARD-OPERATION is NIL, which designates the operation O itself. E.g. in order for a COMPONENT to be prepared for loading or compiling with PREPARE-OP, its PARENT must first be prepared for loading or compiling with PREPARE-OP. Direct Slots asdf/action:upward-operation Allocation: :CLASS Readers: ASDF/ACTION:UPWARD-OPERATION","title":"upward-operation"},{"location":"asdf/#user-output-translations-directory-pathname","text":"Function: (user-output-translations-directory-pathname &key (direction :input))","title":"user-output-translations-directory-pathname"},{"location":"asdf/#user-output-translations-pathname","text":"Function: (user-output-translations-pathname &key (direction :input))","title":"user-output-translations-pathname"},{"location":"asdf/#user-source-registry","text":"Function: (user-source-registry &key (direction :input))","title":"user-source-registry"},{"location":"asdf/#user-source-registry-directory","text":"Function: (user-source-registry-directory &key (direction :input))","title":"user-source-registry-directory"},{"location":"asdf/#version-satisfies","text":"Generic Function: (version-satisfies component version) Check whether a component satisfies the constraint of being at least as recent as the specified version , which must be a string of dot-separated natural numbers, or NIL.","title":"version-satisfies"},{"location":"bordeaux-threads/","text":"bordeaux-threads - Threading Version: 0.8.7 Repository: sionescu/bordeaux-threads - Github This page was possible due to the official documentation , albeit its a bit outdated. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . BORDEAUX-THREADS is a proposed standard for a minimal MP/threading interface. It is similar to the CLIM-SYS threading and lock support, but for the following broad differences: Some behaviours are defined in additional detail: attention has been given to special variable interaction, whether and when cleanup forms are run. Some behaviours are defined in less detail: an implementation that does not support multiple threads is not required to use a new list (nil) for a lock, for example. Many functions which would be difficult, dangerous or inefficient to provide on some implementations have been removed. Chiefly these are functions such as thread-wait which expect for efficiency that the thread scheduler is written in Lisp and 'hookable', which can't sensibly be done if the scheduler is external to the Lisp image, or the system has more than one CPU. Unbalanced ACQUIRE-LOCK and RELEASE-LOCK functions have been added. Posix-style condition variables have been added, as it's not otherwise possible to implement them correctly using the other operations that are specified. Threads may be implemented using whatever applicable techniques are provided by the operating system: user-space scheduling, kernel-based LWPs or anything else that does the job. Some parts of this specification can also be implemented in a Lisp that does not support multiple threads. Thread creation and some thread inspection operations will not work, but the locking functions are still present (though they may do nothing) so that thread-safe code can be compiled on both multithread and single-thread implementations without need of conditionals. To avoid conflict with existing MP/threading interfaces in implementations, these symbols live in the BORDEAUX-THREADS package. Implementations and/or users may also make them visible or exported in other more traditionally named packages. *default-special-bindings* Variable This variable holds an alist associating special variable symbols to forms to evaluate. Special variables named in this list will be locally bound in the new thread before it begins executing user code. This variable may be rebound around calls to make-thread to add/alter default bindings. The effect of mutating this list is undefined, but earlier forms take precedence over later forms for the same symbol, so defaults may be overridden by consing to the head of the list. *standard-io-bindings* Variable Standard bindings of printer/reader control variables as per CL:WITH-STANDARD-IO-SYNTAX. *supports-threads-p* Variable This should be set to T if the running instance has thread support. acquire-lock Function: (acquire-lock lock &optional (wait-p t)) Acquire the lock lock for the calling thread. wait-p governs what happens if the lock is not available: if wait-p is true, the calling thread will wait until the lock is available and then acquire it; if wait-p is NIL, acquire-lock will return immediately. acquire-lock returns true if the lock was acquired and NIL otherwise. This specification does not define what happens if a thread attempts to acquire a lock that it already holds. For applications that require locks to be safe when acquired recursively, see instead make-recursive-lock and friends. acquire-recursive-lock Function: (acquire-recursive-lock lock) As for acquire-lock , but for recursive locks. all-threads Function: (all-threads) Returns a sequence of all of the threads. This may not be freshly-allocated, so the caller should not modify it. condition-notify Function: (condition-notify condition-variable) Notify at least one of the threads waiting for condition-variable . It is implementation-dependent whether one or more than one (and possibly all) threads are woken, but if the implementation is capable of waking only a single thread (not all are) this is probably preferable for efficiency reasons. The order of wakeup is unspecified and does not necessarily relate to the order that the threads went to sleep in. condition-notify has no useful return value. In an implementation that does not support multiple threads, it has no effect. condition-wait Function: (condition-wait condition-variable lock &key timeout) Atomically release lock and enqueue the calling thread waiting for condition-variable . The thread will resume when another thread has notified it using condition-notify ; it may also resume if interrupted by some external event or in other implementation-dependent circumstances: the caller must always test on waking that there is threading to be done, instead of assuming that it can go ahead. It is an error to call function this unless from the thread that holds lock . If timeout is nil or not provided, the system always reacquires lock before returning to the caller. In this case T is returned. If timeout is non-nil, the call will return after at most timeout seconds (approximately), whether or not a notification has occurred. Either NIL or T will be returned. A return of NIL indicates that the lock is no longer held and that the timeout has expired. A return of T indicates that the lock is held, in which case the timeout may or may not have expired. NOTE : The behavior of condition-wait with timeout diverges from the POSIX function pthread_cond_timedwait. The former may return without the lock being held while the latter always returns with the lock held. In an implementation that does not support multiple threads, this function signals an error. current-thread Function: (current-thread) Returns the thread object for the calling thread. This is the same kind of object as would be returned by make-thread . destroy-thread Function: (destroy-thread thread) Terminates the thread thread , which is an object as returned by make-thread . This should be used with caution: it is implementation-defined whether the thread runs cleanup forms or releases its locks first. Destroying the calling thread is an error. interrupt-thread Function: (interrupt-thread thread function &rest args) Interrupt thread and cause it to evaluate function before continuing with the interrupted path of execution. This may not be a good idea if thread is holding locks or doing anything important. On systems that do not support multiple threads, this function signals an error. join-thread Function: (join-thread thread) Wait until thread terminates. If thread has already terminated, return immediately. The return values of the thread function are returned. lock lock-p Function: (lock-p object) Returns T if object is a lock; returns NIL otherwise. make-condition-variable Function: (make-condition-variable &key name) Returns a new condition-variable object for use with condition-wait and condition-notify . make-lock Function: (make-lock &optional name) Creates a lock (a mutex) whose name is name . If the system does not support multiple threads this will still return some object, but it may not be used for very much. make-recursive-lock Function: (make-recursive-lock &optional name) Create and return a recursive lock whose name is name . A recursive lock differs from an ordinary lock in that a thread that already holds the recursive lock can acquire it again without blocking. The thread must then release the lock twice before it becomes available for another thread. make-semaphore Function: (make-semaphore &key name (count 0)) Create a semaphore with the supplied name and initial counter value count . make-thread Function: (make-thread function &key name (initial-bindings *default-special-bindings*)) Creates and returns a thread named name , which will call the function function with no arguments: when function returns, the thread terminates. name defaults to \"Anonymous thread\" if unsupplied. On systems that do not support multi-threading, make-thread will signal an error. The interaction between threads and dynamic variables is in some cases complex, and depends on whether the variable has only a global binding (as established by e.g. DEFVAR/DEFPARAMETER/top-level SETQ) or has been bound locally (e.g. with LET or LET*) in the calling thread. Global bindings are shared between threads: the initial value of a global variable in the new thread will be the same as in the parent, and an assignment to such a variable in any thread will be visible to all threads in which the global binding is visible. Local bindings, such as the ones introduced by initial-bindings , are local to the thread they are introduced in, except that Local bindings in the the caller of make-thread may or may not be shared with the new thread that it creates: this is implementation-defined. Portable code should not depend on particular behaviour in this case, nor should it assign to such variables without first rebinding them in the new thread. recursive-lock recursive-lock-p Function: (recursive-lock-p object) Returns T if object is a recursive lock; returns NIL otherwise. release-lock Function: (release-lock lock) Release lock . It is an error to call this unless the lock has previously been acquired (and not released) by the same thread. If other threads are waiting for the lock, the acquire-lock call in one of them will now be able to continue. This function has no interesting return value. release-recursive-lock Function: (release-recursive-lock lock) Release the recursive lock . The lock will only become free after as many Release operations as there have been Acquire operations. See release-lock for other information. semaphore semaphore-p Function: (semaphore-p object) Returns T if object is a semaphore; returns NIL otherwise. signal-semaphore Function: (signal-semaphore semaphore &key (count 1)) Increment semaphore by count . If there are threads waiting on this semaphore, then count of them are woken up. start-multiprocessing Function: (start-multiprocessing) If the host implementation uses user-level threads, start the scheduler and multiprocessing, otherwise do nothing. It is safe to call repeatedly. thread thread-alive-p Function: (thread-alive-p thread) Returns true if thread is alive, that is, if destroy-thread has not been called on it. thread-name Function: (thread-name thread) Returns the name of the thread, as supplied to make-thread . thread-yield Function: (thread-yield) Allows other threads to run. It may be necessary or desirable to call this periodically in some implementations; others may schedule threads automatically. On systems that do not support multi-threading, this does nothing. threadp Function: (threadp object) Returns true if object is a thread, otherwise NIL. timeout wait-on-semaphore Function: (wait-on-semaphore semaphore &key timeout) Decrement the count of semaphore by 1 if the count would not be negative. Else blocks until the semaphore can be decremented. Returns generalized boolean T on success. If timeout is given, it is the maximum number of seconds to wait. If the count cannot be decremented in that time, returns NIL without decrementing the count. with-lock-held Macro: (with-lock-held (place) &body body) Evaluates body with the lock named by place , the value of which is a lock created by make-lock . Before the forms in body are evaluated, the lock is acquired as if by using acquire-lock . After the forms in body have been evaluated, or if a non-local control transfer is caused (e.g. by THROW or SIGNAL), the lock is released as if by release-lock . Note that if the debugger is entered, it is unspecified whether the lock is released at debugger entry or at debugger exit when execution is restarted. with-recursive-lock-held Macro: (with-recursive-lock-held (place) &body body) Evaluates body with the recursive lock named by place , which is a reference to a recursive lock created by make-recursive-lock . See with-lock-held etc etc with-timeout Macro: (with-timeout (timeout) &body body)","title":"bordeaux-threads - Threading"},{"location":"bordeaux-threads/#bordeaux-threads-threading","text":"Version: 0.8.7 Repository: sionescu/bordeaux-threads - Github This page was possible due to the official documentation , albeit its a bit outdated. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . BORDEAUX-THREADS is a proposed standard for a minimal MP/threading interface. It is similar to the CLIM-SYS threading and lock support, but for the following broad differences: Some behaviours are defined in additional detail: attention has been given to special variable interaction, whether and when cleanup forms are run. Some behaviours are defined in less detail: an implementation that does not support multiple threads is not required to use a new list (nil) for a lock, for example. Many functions which would be difficult, dangerous or inefficient to provide on some implementations have been removed. Chiefly these are functions such as thread-wait which expect for efficiency that the thread scheduler is written in Lisp and 'hookable', which can't sensibly be done if the scheduler is external to the Lisp image, or the system has more than one CPU. Unbalanced ACQUIRE-LOCK and RELEASE-LOCK functions have been added. Posix-style condition variables have been added, as it's not otherwise possible to implement them correctly using the other operations that are specified. Threads may be implemented using whatever applicable techniques are provided by the operating system: user-space scheduling, kernel-based LWPs or anything else that does the job. Some parts of this specification can also be implemented in a Lisp that does not support multiple threads. Thread creation and some thread inspection operations will not work, but the locking functions are still present (though they may do nothing) so that thread-safe code can be compiled on both multithread and single-thread implementations without need of conditionals. To avoid conflict with existing MP/threading interfaces in implementations, these symbols live in the BORDEAUX-THREADS package. Implementations and/or users may also make them visible or exported in other more traditionally named packages.","title":"bordeaux-threads - Threading"},{"location":"bordeaux-threads/#default-special-bindings","text":"Variable This variable holds an alist associating special variable symbols to forms to evaluate. Special variables named in this list will be locally bound in the new thread before it begins executing user code. This variable may be rebound around calls to make-thread to add/alter default bindings. The effect of mutating this list is undefined, but earlier forms take precedence over later forms for the same symbol, so defaults may be overridden by consing to the head of the list.","title":"*default-special-bindings*"},{"location":"bordeaux-threads/#standard-io-bindings","text":"Variable Standard bindings of printer/reader control variables as per CL:WITH-STANDARD-IO-SYNTAX.","title":"*standard-io-bindings*"},{"location":"bordeaux-threads/#supports-threads-p","text":"Variable This should be set to T if the running instance has thread support.","title":"*supports-threads-p*"},{"location":"bordeaux-threads/#acquire-lock","text":"Function: (acquire-lock lock &optional (wait-p t)) Acquire the lock lock for the calling thread. wait-p governs what happens if the lock is not available: if wait-p is true, the calling thread will wait until the lock is available and then acquire it; if wait-p is NIL, acquire-lock will return immediately. acquire-lock returns true if the lock was acquired and NIL otherwise. This specification does not define what happens if a thread attempts to acquire a lock that it already holds. For applications that require locks to be safe when acquired recursively, see instead make-recursive-lock and friends.","title":"acquire-lock"},{"location":"bordeaux-threads/#acquire-recursive-lock","text":"Function: (acquire-recursive-lock lock) As for acquire-lock , but for recursive locks.","title":"acquire-recursive-lock"},{"location":"bordeaux-threads/#all-threads","text":"Function: (all-threads) Returns a sequence of all of the threads. This may not be freshly-allocated, so the caller should not modify it.","title":"all-threads"},{"location":"bordeaux-threads/#condition-notify","text":"Function: (condition-notify condition-variable) Notify at least one of the threads waiting for condition-variable . It is implementation-dependent whether one or more than one (and possibly all) threads are woken, but if the implementation is capable of waking only a single thread (not all are) this is probably preferable for efficiency reasons. The order of wakeup is unspecified and does not necessarily relate to the order that the threads went to sleep in. condition-notify has no useful return value. In an implementation that does not support multiple threads, it has no effect.","title":"condition-notify"},{"location":"bordeaux-threads/#condition-wait","text":"Function: (condition-wait condition-variable lock &key timeout) Atomically release lock and enqueue the calling thread waiting for condition-variable . The thread will resume when another thread has notified it using condition-notify ; it may also resume if interrupted by some external event or in other implementation-dependent circumstances: the caller must always test on waking that there is threading to be done, instead of assuming that it can go ahead. It is an error to call function this unless from the thread that holds lock . If timeout is nil or not provided, the system always reacquires lock before returning to the caller. In this case T is returned. If timeout is non-nil, the call will return after at most timeout seconds (approximately), whether or not a notification has occurred. Either NIL or T will be returned. A return of NIL indicates that the lock is no longer held and that the timeout has expired. A return of T indicates that the lock is held, in which case the timeout may or may not have expired. NOTE : The behavior of condition-wait with timeout diverges from the POSIX function pthread_cond_timedwait. The former may return without the lock being held while the latter always returns with the lock held. In an implementation that does not support multiple threads, this function signals an error.","title":"condition-wait"},{"location":"bordeaux-threads/#current-thread","text":"Function: (current-thread) Returns the thread object for the calling thread. This is the same kind of object as would be returned by make-thread .","title":"current-thread"},{"location":"bordeaux-threads/#destroy-thread","text":"Function: (destroy-thread thread) Terminates the thread thread , which is an object as returned by make-thread . This should be used with caution: it is implementation-defined whether the thread runs cleanup forms or releases its locks first. Destroying the calling thread is an error.","title":"destroy-thread"},{"location":"bordeaux-threads/#interrupt-thread","text":"Function: (interrupt-thread thread function &rest args) Interrupt thread and cause it to evaluate function before continuing with the interrupted path of execution. This may not be a good idea if thread is holding locks or doing anything important. On systems that do not support multiple threads, this function signals an error.","title":"interrupt-thread"},{"location":"bordeaux-threads/#join-thread","text":"Function: (join-thread thread) Wait until thread terminates. If thread has already terminated, return immediately. The return values of the thread function are returned.","title":"join-thread"},{"location":"bordeaux-threads/#lock","text":"","title":"lock"},{"location":"bordeaux-threads/#lock-p","text":"Function: (lock-p object) Returns T if object is a lock; returns NIL otherwise.","title":"lock-p"},{"location":"bordeaux-threads/#make-condition-variable","text":"Function: (make-condition-variable &key name) Returns a new condition-variable object for use with condition-wait and condition-notify .","title":"make-condition-variable"},{"location":"bordeaux-threads/#make-lock","text":"Function: (make-lock &optional name) Creates a lock (a mutex) whose name is name . If the system does not support multiple threads this will still return some object, but it may not be used for very much.","title":"make-lock"},{"location":"bordeaux-threads/#make-recursive-lock","text":"Function: (make-recursive-lock &optional name) Create and return a recursive lock whose name is name . A recursive lock differs from an ordinary lock in that a thread that already holds the recursive lock can acquire it again without blocking. The thread must then release the lock twice before it becomes available for another thread.","title":"make-recursive-lock"},{"location":"bordeaux-threads/#make-semaphore","text":"Function: (make-semaphore &key name (count 0)) Create a semaphore with the supplied name and initial counter value count .","title":"make-semaphore"},{"location":"bordeaux-threads/#make-thread","text":"Function: (make-thread function &key name (initial-bindings *default-special-bindings*)) Creates and returns a thread named name , which will call the function function with no arguments: when function returns, the thread terminates. name defaults to \"Anonymous thread\" if unsupplied. On systems that do not support multi-threading, make-thread will signal an error. The interaction between threads and dynamic variables is in some cases complex, and depends on whether the variable has only a global binding (as established by e.g. DEFVAR/DEFPARAMETER/top-level SETQ) or has been bound locally (e.g. with LET or LET*) in the calling thread. Global bindings are shared between threads: the initial value of a global variable in the new thread will be the same as in the parent, and an assignment to such a variable in any thread will be visible to all threads in which the global binding is visible. Local bindings, such as the ones introduced by initial-bindings , are local to the thread they are introduced in, except that Local bindings in the the caller of make-thread may or may not be shared with the new thread that it creates: this is implementation-defined. Portable code should not depend on particular behaviour in this case, nor should it assign to such variables without first rebinding them in the new thread.","title":"make-thread"},{"location":"bordeaux-threads/#recursive-lock","text":"","title":"recursive-lock"},{"location":"bordeaux-threads/#recursive-lock-p","text":"Function: (recursive-lock-p object) Returns T if object is a recursive lock; returns NIL otherwise.","title":"recursive-lock-p"},{"location":"bordeaux-threads/#release-lock","text":"Function: (release-lock lock) Release lock . It is an error to call this unless the lock has previously been acquired (and not released) by the same thread. If other threads are waiting for the lock, the acquire-lock call in one of them will now be able to continue. This function has no interesting return value.","title":"release-lock"},{"location":"bordeaux-threads/#release-recursive-lock","text":"Function: (release-recursive-lock lock) Release the recursive lock . The lock will only become free after as many Release operations as there have been Acquire operations. See release-lock for other information.","title":"release-recursive-lock"},{"location":"bordeaux-threads/#semaphore","text":"","title":"semaphore"},{"location":"bordeaux-threads/#semaphore-p","text":"Function: (semaphore-p object) Returns T if object is a semaphore; returns NIL otherwise.","title":"semaphore-p"},{"location":"bordeaux-threads/#signal-semaphore","text":"Function: (signal-semaphore semaphore &key (count 1)) Increment semaphore by count . If there are threads waiting on this semaphore, then count of them are woken up.","title":"signal-semaphore"},{"location":"bordeaux-threads/#start-multiprocessing","text":"Function: (start-multiprocessing) If the host implementation uses user-level threads, start the scheduler and multiprocessing, otherwise do nothing. It is safe to call repeatedly.","title":"start-multiprocessing"},{"location":"bordeaux-threads/#thread","text":"","title":"thread"},{"location":"bordeaux-threads/#thread-alive-p","text":"Function: (thread-alive-p thread) Returns true if thread is alive, that is, if destroy-thread has not been called on it.","title":"thread-alive-p"},{"location":"bordeaux-threads/#thread-name","text":"Function: (thread-name thread) Returns the name of the thread, as supplied to make-thread .","title":"thread-name"},{"location":"bordeaux-threads/#thread-yield","text":"Function: (thread-yield) Allows other threads to run. It may be necessary or desirable to call this periodically in some implementations; others may schedule threads automatically. On systems that do not support multi-threading, this does nothing.","title":"thread-yield"},{"location":"bordeaux-threads/#threadp","text":"Function: (threadp object) Returns true if object is a thread, otherwise NIL.","title":"threadp"},{"location":"bordeaux-threads/#timeout","text":"","title":"timeout"},{"location":"bordeaux-threads/#wait-on-semaphore","text":"Function: (wait-on-semaphore semaphore &key timeout) Decrement the count of semaphore by 1 if the count would not be negative. Else blocks until the semaphore can be decremented. Returns generalized boolean T on success. If timeout is given, it is the maximum number of seconds to wait. If the count cannot be decremented in that time, returns NIL without decrementing the count.","title":"wait-on-semaphore"},{"location":"bordeaux-threads/#with-lock-held","text":"Macro: (with-lock-held (place) &body body) Evaluates body with the lock named by place , the value of which is a lock created by make-lock . Before the forms in body are evaluated, the lock is acquired as if by using acquire-lock . After the forms in body have been evaluated, or if a non-local control transfer is caused (e.g. by THROW or SIGNAL), the lock is released as if by release-lock . Note that if the debugger is entered, it is unspecified whether the lock is released at debugger entry or at debugger exit when execution is restarted.","title":"with-lock-held"},{"location":"bordeaux-threads/#with-recursive-lock-held","text":"Macro: (with-recursive-lock-held (place) &body body) Evaluates body with the recursive lock named by place , which is a reference to a recursive lock created by make-recursive-lock . See with-lock-held etc etc","title":"with-recursive-lock-held"},{"location":"bordeaux-threads/#with-timeout","text":"Macro: (with-timeout (timeout) &body body)","title":"with-timeout"},{"location":"cl-ppcre/","text":"cl-ppcre - Regular Expressions Version: 2.1.1 Nickname: ppcre Repository: edicl/cl-ppcre - Github This documentation is possible the excellent official documentation as of 4th May 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . CL-PPCRE is a Portable Perl-Compatible Regular Expressions library for Common Lisp. This is also thread-safe, and allows specifying regular expressions using S-expressions . GETTING STARTED Using perl regex Per the name, cl-ppcre is more or less compatible with perl 5.8 including extended features like non-greedy repetitions, positive and negative look-ahead and look-behind assertions, \"standalone\" subexpressions, and conditional subpatterns. The following Perl features are (currently) not supported: (?{ code }) and (??{ code }) because they obviously don't make sense in Lisp. \\N{name} (named characters), \\x{263a} (wide hex characters), \\l , \\u , \\L , and \\U because they're actually not part of Perl's regex syntax - but see CL-INTERPOL . \\X (extended Unicode), and \\C (single character). But you can of course use all characters supported by your CL implementation. Posix character classes like [[:alpha]] . Load (asdf:load-system :cl-ppcre-unicode) to install unicode-preperty-resolver as your property-resolver . See cl-unicode for the supported unicode properties and their naming conventions. \\G for Perl's pos() because we don't have it. Note, however, that \\t , \\n , \\r , \\f , \\a , \\e , \\033 (octal character codes), \\x1B (hexadecimal character codes), \\c[ (control characters), \\w , \\W , \\s , \\S , \\d , \\D , \\b , \\B , \\A , \\Z , and \\z are supported. Users can straightaway start with: scan scan-to-strings split quote-meta-chars register-groups-bind regex-replace Register groups simply refer to the captured groups. For instance: CL-USER> (register-groups-bind (a b) (\"([^ ]+) ([^ ]+)\" \"hello world\") (list a b)) (\"hello\" \"world\") See the other macros for iterative versions of these. Those wanting to get into perl regular expressions, might find their official documentation useful. Users comfortable with regular expressions might also want to try cl-interpol - which provides string interpolation facilities to the lisp reader. (Yes, it's defacto!) Using s-expressions The basics: +------- Common Lisp Equivalent -------+----------- Perl Equivalent -----------+ | String / Character | Literal treatment | | :void | Empty string | | :everything | Dot | | :(non-)word-boundary | \\b, \\B (non) | | :(non-)digit-class | \\d, \\D (non) | | :(non-)word-char-class | \\w, \\W (non) | | :(non-)whitespace-char-class | \\s, \\S (non) | | :start/end-anchor | ^ [start], $ [end | | :modeless-start/end-anchor | \\A [start], \\Z [end] | | :modeless-end-anchor-no-newline | \\z | | :case-(in)sensitive-p | (?i), (?-i) [insensitive] | | :(not)-multi-line-mode-p | (?m), (?-m) [not] | | :(not)-single-line-mode-p | (?s), (?-s) [not] | | (anything else) | Syntax Error | +--------------------------------------+---------------------------------------+ Simple combinations include :sequence , :group , :flags , :register , :greedy-repetition , :non-greedy-repetition . You could play around with parse-string to learn more about the equivalence. For instance: * (parse-string \"(ab)*\") (:GREEDY-REPETITION 0 `NIL` (:REGISTER \"ab\")) * (parse-string \"(a(b))\") (:REGISTER (:SEQUENCE #\\a (:REGISTER #\\b))) * (parse-string \"(?:abc){3,5}\") (:GREEDY-REPETITION 3 5 (:GROUP \"abc\")) ;; (:GREEDY-REPETITION 3 5 \"abc\") would also be OK * (parse-string \"a(?i)b(?-i)c\") (:SEQUENCE #\\a (:SEQUENCE (:FLAGS :CASE-INSENSITIVE-P) (:SEQUENCE #\\b (:SEQUENCE (:FLAGS :CASE-SENSITIVE-P) #\\c)))) ;; same as (:SEQUENCE #\\a :CASE-INSENSITIVE-P #\\b :CASE-SENSITIVE-P #\\c) * (parse-string \"(?=a)b\") (:SEQUENCE (:POSITIVE-LOOKAHEAD #\\a) #\\b) * (parse-string \"aa|aaa\") (:ALTERNATION \"aa\" \"aaa\") See the manual for the more detailed equivalence. Thus, you could equivalently use parse-trees for the functions and macros that expect regex. * (all-matches-as-strings '(:greedy-repetition 1 nil #\\a) \"aaaa\") (\"aaaa\") Performance Aspects cl-ppcre was intended to be fast. Indeed, when it first appeared, it was perhaps the fastest . However, in 2020, it can be five times as slow as Perl: time perl -e '\"@{['x' x 50000000]}\" =~ /([xy])*/' real 0m0.245s user 0m0.161s sys 0m0.084s CL-USER> (time (progn (scan \"([xy])*\" (make-string 50000000 :element-type 'base-char :initial-element #\\x)) nil)) Evaluation took: 1.116 seconds of real time 1.115901 seconds of total run time (1.111972 user, 0.003929 system) 100.00% CPU 2,463,959,814 processor cycles 50,000,032 bytes consed But still (more than) 5 times faster than python: time python3 -c 'import re; x = re.search(\"([xy])*\", \"x\"*50000000)' real 0m7.458s user 0m4.563s sys 0m2.892s Or slower as well: $ ~ time python3 -c 'import re; x = re.search(\"x*\", \"x\"*50000000)' real 0m0.146s user 0m0.109s sys 0m0.036s Honestly, though, it should be possible to use implementation specific means to speed things up - or copying the developments in the perl and/or python world. Perhaps, see the manual for hints on speeding things up. FUNCTIONS AND MACROS all-matches Function: (all-matches regex target-string &key (start 0) (end (length target-string))) Returns a list containing the start and end positions of all matches of regex against target-string , i.e. if there are N matches the list contains (* 2 N) elements. If regex matches an empty string the scan is continued one position behind this match. all-matches-as-strings Function: (all-matches-as-strings regex target-string &key (start 0) (end (length target-string)) sharedp) Returns a list containing all substrings of target-string which match regex . If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . create-optimized-test-function Function: (create-optimized-test-function test-function &key (start 0) (end *regex-char-code-limit*) (kind *optimize-char-classes*)) Given a unary test function which is applicable to characters returns a function which yields the same boolean results for all characters with character codes from start to (excluding) end . If kind is nil , test-function will simply be returned. Otherwise, kind should be one of: :hash-table - builds a hash table representing all characters which satisfy the test and returns a closure which checks if a character is in that hash table :charset - instead of a hash table uses a \"charset\" which is a data structure using non-linear hashing and optimized to represent (sparse) sets of characters in a fast and space-efficient way (contributed by Nikodemus Siivola) :charmap - instead of a hash table uses a bit vector to represent the set of characters You can also use :hash-table* or :charset* which are like :hash-table and :charset but use the complement of the set if the set contains more than half of all characters between start and end . This saves space but needs an additional pass across all characters to create the data structure. There is no corresponding :charmap* kind as the bit vectors are already created to cover the smallest possible interval which contains either the set or its complement. create-scanner Function: (create-scanner regex &key case-insensitive-mode multi-line-mode single-line-mode extended-mode destructive) Accepts a regular expression - either as a parse-tree or as a string - and returns a scan closure which will scan strings for this regular expression and a list mapping registers to their names ( nil stands for unnamed ones). The \"mode\" keyword arguments are equivalent to the imsx modifiers in Perl. If destructive is not nil , the function is allowed to destructively modify its first argument (but only if it's a parse tree). (More in the manual!) define-parse-tree-synonym Macro: (define-parse-tree-synonym name parse-tree) Defines the symbol name to be a synonym for the parse tree parse-tree . Both arguments are quoted. do-matches Macro: (do-matches (match-start match-end regex target-string &optional result-form &key start end) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with match-start and match-end bound to the start/end positions of each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-matches ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. body may start with declarations. do-matches-as-strings Macro: (do-matches-as-strings (match-var regex target-string &optional result-form &key start end sharedp) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with match-var bound to the substring of target-string corresponding to each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-matches-as-strings ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . body may start with declarations. do-register-groups Macro: (do-register-groups var-list (regex target-string &optional result-form &key start end sharedp) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with the variables in var-list bound to the corresponding register groups for each match in turn, i.e. each variable is either bound to a string or to nil . For each element of var-list which is nil there's no binding to the corresponding register group. The number of variables in var-list must not be greater than the number of register groups. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-register-groups ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . body may start with declarations. do-scans Macro: (do-scans (match-start match-end reg-starts reg-ends regex target-string &optional result-form &key start end) &body body) Iterates over target-string and tries to match regex as often as possible evaluating BODY with match-start , match-end , reg-starts , and reg-ends bound to the four return values of each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-scans ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. body may start with declarations. parse-string Function: (parse-string string) Translate the regex string string into a parse tree. parse-tree-synonym Function: (parse-tree-synonym symbol) Returns the parse tree the symbol symbol is a synonym for. Returns nil is symbol wasn't yet defined to be a synonym. ppcre-error Every error signaled by CL-PPCRE is of type ppcre-error . This is a direct subtype of simple-error without any additional slots or options. ppcre-invocation-error Errors of type ppcre-invocation-error are signaled if one of the exported functions of CL-PPCRE is called with wrong or inconsistent arguments. This is a direct subtype of ppcre-error without any additional slots or options. ppcre-syntax-error An error of type ppcre-syntax-error is signaled if CL-PPCRE's parser encounters an error when trying to parse a regex string or to convert a parse tree into its internal representation. This is a direct subtype of ppcre-error with two additional slots. These denote the regex string which HTML-PPCRE was parsing and the position within the string where the error occurred. If the error happens while CL-PPCRE is converting a parse tree, both of these slots contain NIL. (See the next two entries on how to access these slots.) ppcre-syntax-error-pos Function: (ppcre-syntax-error-pos condition) Returns the position within the string where the error occurred (or nil if the error happened while trying to convert a parse tree ppcre-syntax-error-string Function: (ppcre-syntax-error-string condition) Returns the string the parser was parsing when the error was encountered (or nil if the error happened while trying to convert a parse tree). quote-meta-chars Function: (quote-meta-chars string &key (start 0) (end (length string))) Quote, i.e. prefix all non-word characters in string with #\\\\ . regex-apropos Function: (regex-apropos regex &optional packages &key (case-insensitive t)) Similar to the standard function apropos but returns a list of all symbols which match the regular expression REGEX. If case-insensitive is true and regex isn't already a scanner, a case-insensitive scanner is used. regex-apropos-list Function: (regex-apropos-list regex &optional packages &key (case-insensitive t)) Similar to the standard function apropos-list but returns a list of all symbols which match the regular expression regex . If case-insensitive is true and regex isn't already a scanner, a case-insensitive scanner is used. regex-replace Function: (regex-replace regex target-string replacement &key (start 0) (end (length target-string)) preserve-case simple-calls (element-type 'character)) Try to match target-string between start and end against regex and replace the first match with replacement . Two values are returned; the modified string, and t if regex matched or nil otherwise. replacement can be a string which may contain the special substrings \"\\&\" for the whole match, \"`\" for the part of target-string before the match, \"\\'\" for the part of target-string after the match, \"\\N\" or \"{N}\" for the Nth register where N is a positive integer. replacement can also be a function designator in which case the match will be replaced with the result of calling the function designated by replacement with the arguments target-string , start , end , match-start , match-end , reg-starts , and reg-ends . ( reg-starts and reg-ends are arrays holding the start and end positions of matched registers or nil - the meaning of the other arguments should be obvious.) Finally, replacement can be a list where each element is a string, one of the symbols :match , :before-match , or :after-match - corresponding to \"\\&\", \"`\", and \"\\'\" above -, an integer N - representing register (1+ N) -, or a function designator. If preserve-case is true, the replacement will try to preserve the case (all upper case, all lower case, or capitalized) of the match. The result will always be a fresh string, even if regex doesn't match. element-type is the element type of the resulting string. regex-replace-all Function: (regex-replace-all regex target-string replacement &key (start 0) (end (length target-string)) preserve-case simple-calls (element-type 'character)) Try to match target-string between start and end against regex and replace all matches with replacement . Two values are returned; the modified string, and T if regex matched or nil otherwise. replacement can be a string which may contain the special substrings \"\\&\" for the whole match, \"`\" for the part of target-string before the match, \"\\'\" for the part of target-string after the match, \"\\N\" or \"{N}\" for the Nth register where N is a positive integer. replacement can also be a function designator in which case the match will be replaced with the result of calling the function designated by replacement with the arguments target-string , start , end , match-start , match-end , reg-starts , and reg-ends . ( reg-starts and reg-ends are arrays holding the start and end positions of matched registers or nil - the meaning of the other arguments should be obvious.) Finally, replacement can be a list where each element is a string, one of the symbols :match , :before-match , or :after-match - corresponding to \"\\&\", \"`\", and \"\\'\" above -, an integer N - representing register (1+ N) -, or a function designator. If preserve-case is true, the replacement will try to preserve the case (all upper case, all lower case, or capitalized) of the match. The result will always be a fresh string, even if regex doesn't match. element-type is the element type of the resulting string. register-groups-bind Macro: (register-groups-bind var-list (regex target-string &key start end sharedp) &body body) Executes body with the variables in var-list bound to the corresponding register groups after target-string has been matched against regex , i.e. each variable is either bound to a string or to nil . If there is no match, body is not executed. For each element of var-list which is nil there's no binding to the corresponding register group. The number of variables in var-list must not be greater than the number of register groups. If sharedp is true, the substrings may share structure with target-string . scan Function: (scan regex target-string &key start end real-start-pos) Searches target-string from start to end and tries to match regex . On success returns four values - the start of the match, the end of the match, and two arrays denoting the beginnings and ends of register matches. On failure returns nil . regex can be a string which will be parsed according to Perl syntax, a parse tree, or a pre-compiled scanner created by create-scanner . target-string will be coerced to a simple string if it isn't one already. The real-start-pos parameter should be ignored - it exists only for internal purposes. scan-to-strings Function: (scan-to-strings regex target-string &key (start 0) (end (length target-string)) sharedp) Like scan but returns substrings of target-string instead of positions, i.e. this function returns two values on success: the whole match as a string plus an array of substrings (or nil s) corresponding to the matched registers. If sharedp is true, the substrings may share structure with target-string . split Function: (split regex target-string &key (start 0) (end (length target-string)) limit with-registers-p omit-unmatched-p sharedp) Matches regex against target-string as often as possible and returns a list of the substrings between the matches. If with-registers-p is true, substrings corresponding to matched registers are inserted into the list as well. If omit-unmatched-p is true, unmatched registers will simply be left out, otherwise they will show up as nil . limit limits the number of elements returned - registers aren't counted. If limit is nil (or 0 which is equivalent), trailing empty strings are removed from the result list. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . CONFIGURATION VARIABLES *allow-named-registers* Whether the parser should support AllegroCL's named registers (?<name>\"<regex>\") and back-reference \\k syntax. *allow-quoting* Whether the parser should support Perl's \\Q and \\E. *look-ahead-for-suffix* Controls whether scanners will optimistically look ahead for a constant suffix of a regular expression, if there is one. *optimize-char-classes* Whether character classes should be compiled into look-ups into O(1) data structures. This is usually fast but will be costly in terms of scanner creation time and might be costly in terms of size if *regex-char-code-limit* is high. This value will be used as the :kind keyword argument to create-optimized-test-function - see there for the possible non- NIL values. *property-resolver* Should be NIL or a designator for a function which accepts strings and returns unary character test functions or NIL . This 'resolver' is intended to handle character properties' like \\p{IsAlpha}. If *property-resolver* is NIL , then the parser will simply treat \\p and \\P as #\\p and #\\P as in older versions of CL-PPCRE. *regex-char-code-limit* The upper exclusive bound on the char-codes of characters which can occur in character classes. Change this value BEFORE creating scanners if you don't need the (full) Unicode support of implementations like AllegroCL, CLISP, LispWorks, or SBCL. *use-bmh-matchers* Whether the scanners created by create-scanner should use the (fast but large) Boyer-Moore-Horspool matchers. SUPPORT The development version of cl-ppcre can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"cl-ppcre - Regular Expressions"},{"location":"cl-ppcre/#cl-ppcre-regular-expressions","text":"Version: 2.1.1 Nickname: ppcre Repository: edicl/cl-ppcre - Github This documentation is possible the excellent official documentation as of 4th May 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . CL-PPCRE is a Portable Perl-Compatible Regular Expressions library for Common Lisp. This is also thread-safe, and allows specifying regular expressions using S-expressions .","title":"cl-ppcre - Regular Expressions"},{"location":"cl-ppcre/#getting-started","text":"","title":"GETTING STARTED"},{"location":"cl-ppcre/#using-perl-regex","text":"Per the name, cl-ppcre is more or less compatible with perl 5.8 including extended features like non-greedy repetitions, positive and negative look-ahead and look-behind assertions, \"standalone\" subexpressions, and conditional subpatterns. The following Perl features are (currently) not supported: (?{ code }) and (??{ code }) because they obviously don't make sense in Lisp. \\N{name} (named characters), \\x{263a} (wide hex characters), \\l , \\u , \\L , and \\U because they're actually not part of Perl's regex syntax - but see CL-INTERPOL . \\X (extended Unicode), and \\C (single character). But you can of course use all characters supported by your CL implementation. Posix character classes like [[:alpha]] . Load (asdf:load-system :cl-ppcre-unicode) to install unicode-preperty-resolver as your property-resolver . See cl-unicode for the supported unicode properties and their naming conventions. \\G for Perl's pos() because we don't have it. Note, however, that \\t , \\n , \\r , \\f , \\a , \\e , \\033 (octal character codes), \\x1B (hexadecimal character codes), \\c[ (control characters), \\w , \\W , \\s , \\S , \\d , \\D , \\b , \\B , \\A , \\Z , and \\z are supported. Users can straightaway start with: scan scan-to-strings split quote-meta-chars register-groups-bind regex-replace Register groups simply refer to the captured groups. For instance: CL-USER> (register-groups-bind (a b) (\"([^ ]+) ([^ ]+)\" \"hello world\") (list a b)) (\"hello\" \"world\") See the other macros for iterative versions of these. Those wanting to get into perl regular expressions, might find their official documentation useful. Users comfortable with regular expressions might also want to try cl-interpol - which provides string interpolation facilities to the lisp reader. (Yes, it's defacto!)","title":"Using perl regex"},{"location":"cl-ppcre/#using-s-expressions","text":"The basics: +------- Common Lisp Equivalent -------+----------- Perl Equivalent -----------+ | String / Character | Literal treatment | | :void | Empty string | | :everything | Dot | | :(non-)word-boundary | \\b, \\B (non) | | :(non-)digit-class | \\d, \\D (non) | | :(non-)word-char-class | \\w, \\W (non) | | :(non-)whitespace-char-class | \\s, \\S (non) | | :start/end-anchor | ^ [start], $ [end | | :modeless-start/end-anchor | \\A [start], \\Z [end] | | :modeless-end-anchor-no-newline | \\z | | :case-(in)sensitive-p | (?i), (?-i) [insensitive] | | :(not)-multi-line-mode-p | (?m), (?-m) [not] | | :(not)-single-line-mode-p | (?s), (?-s) [not] | | (anything else) | Syntax Error | +--------------------------------------+---------------------------------------+ Simple combinations include :sequence , :group , :flags , :register , :greedy-repetition , :non-greedy-repetition . You could play around with parse-string to learn more about the equivalence. For instance: * (parse-string \"(ab)*\") (:GREEDY-REPETITION 0 `NIL` (:REGISTER \"ab\")) * (parse-string \"(a(b))\") (:REGISTER (:SEQUENCE #\\a (:REGISTER #\\b))) * (parse-string \"(?:abc){3,5}\") (:GREEDY-REPETITION 3 5 (:GROUP \"abc\")) ;; (:GREEDY-REPETITION 3 5 \"abc\") would also be OK * (parse-string \"a(?i)b(?-i)c\") (:SEQUENCE #\\a (:SEQUENCE (:FLAGS :CASE-INSENSITIVE-P) (:SEQUENCE #\\b (:SEQUENCE (:FLAGS :CASE-SENSITIVE-P) #\\c)))) ;; same as (:SEQUENCE #\\a :CASE-INSENSITIVE-P #\\b :CASE-SENSITIVE-P #\\c) * (parse-string \"(?=a)b\") (:SEQUENCE (:POSITIVE-LOOKAHEAD #\\a) #\\b) * (parse-string \"aa|aaa\") (:ALTERNATION \"aa\" \"aaa\") See the manual for the more detailed equivalence. Thus, you could equivalently use parse-trees for the functions and macros that expect regex. * (all-matches-as-strings '(:greedy-repetition 1 nil #\\a) \"aaaa\") (\"aaaa\")","title":"Using s-expressions"},{"location":"cl-ppcre/#performance-aspects","text":"cl-ppcre was intended to be fast. Indeed, when it first appeared, it was perhaps the fastest . However, in 2020, it can be five times as slow as Perl: time perl -e '\"@{['x' x 50000000]}\" =~ /([xy])*/' real 0m0.245s user 0m0.161s sys 0m0.084s CL-USER> (time (progn (scan \"([xy])*\" (make-string 50000000 :element-type 'base-char :initial-element #\\x)) nil)) Evaluation took: 1.116 seconds of real time 1.115901 seconds of total run time (1.111972 user, 0.003929 system) 100.00% CPU 2,463,959,814 processor cycles 50,000,032 bytes consed But still (more than) 5 times faster than python: time python3 -c 'import re; x = re.search(\"([xy])*\", \"x\"*50000000)' real 0m7.458s user 0m4.563s sys 0m2.892s Or slower as well: $ ~ time python3 -c 'import re; x = re.search(\"x*\", \"x\"*50000000)' real 0m0.146s user 0m0.109s sys 0m0.036s Honestly, though, it should be possible to use implementation specific means to speed things up - or copying the developments in the perl and/or python world. Perhaps, see the manual for hints on speeding things up.","title":"Performance Aspects"},{"location":"cl-ppcre/#functions-and-macros","text":"","title":"FUNCTIONS AND MACROS"},{"location":"cl-ppcre/#all-matches","text":"Function: (all-matches regex target-string &key (start 0) (end (length target-string))) Returns a list containing the start and end positions of all matches of regex against target-string , i.e. if there are N matches the list contains (* 2 N) elements. If regex matches an empty string the scan is continued one position behind this match.","title":"all-matches"},{"location":"cl-ppcre/#all-matches-as-strings","text":"Function: (all-matches-as-strings regex target-string &key (start 0) (end (length target-string)) sharedp) Returns a list containing all substrings of target-string which match regex . If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string .","title":"all-matches-as-strings"},{"location":"cl-ppcre/#create-optimized-test-function","text":"Function: (create-optimized-test-function test-function &key (start 0) (end *regex-char-code-limit*) (kind *optimize-char-classes*)) Given a unary test function which is applicable to characters returns a function which yields the same boolean results for all characters with character codes from start to (excluding) end . If kind is nil , test-function will simply be returned. Otherwise, kind should be one of: :hash-table - builds a hash table representing all characters which satisfy the test and returns a closure which checks if a character is in that hash table :charset - instead of a hash table uses a \"charset\" which is a data structure using non-linear hashing and optimized to represent (sparse) sets of characters in a fast and space-efficient way (contributed by Nikodemus Siivola) :charmap - instead of a hash table uses a bit vector to represent the set of characters You can also use :hash-table* or :charset* which are like :hash-table and :charset but use the complement of the set if the set contains more than half of all characters between start and end . This saves space but needs an additional pass across all characters to create the data structure. There is no corresponding :charmap* kind as the bit vectors are already created to cover the smallest possible interval which contains either the set or its complement.","title":"create-optimized-test-function"},{"location":"cl-ppcre/#create-scanner","text":"Function: (create-scanner regex &key case-insensitive-mode multi-line-mode single-line-mode extended-mode destructive) Accepts a regular expression - either as a parse-tree or as a string - and returns a scan closure which will scan strings for this regular expression and a list mapping registers to their names ( nil stands for unnamed ones). The \"mode\" keyword arguments are equivalent to the imsx modifiers in Perl. If destructive is not nil , the function is allowed to destructively modify its first argument (but only if it's a parse tree). (More in the manual!)","title":"create-scanner"},{"location":"cl-ppcre/#define-parse-tree-synonym","text":"Macro: (define-parse-tree-synonym name parse-tree) Defines the symbol name to be a synonym for the parse tree parse-tree . Both arguments are quoted.","title":"define-parse-tree-synonym"},{"location":"cl-ppcre/#do-matches","text":"Macro: (do-matches (match-start match-end regex target-string &optional result-form &key start end) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with match-start and match-end bound to the start/end positions of each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-matches ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. body may start with declarations.","title":"do-matches"},{"location":"cl-ppcre/#do-matches-as-strings","text":"Macro: (do-matches-as-strings (match-var regex target-string &optional result-form &key start end sharedp) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with match-var bound to the substring of target-string corresponding to each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-matches-as-strings ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . body may start with declarations.","title":"do-matches-as-strings"},{"location":"cl-ppcre/#do-register-groups","text":"Macro: (do-register-groups var-list (regex target-string &optional result-form &key start end sharedp) &body body) Iterates over target-string and tries to match regex as often as possible evaluating body with the variables in var-list bound to the corresponding register groups for each match in turn, i.e. each variable is either bound to a string or to nil . For each element of var-list which is nil there's no binding to the corresponding register group. The number of variables in var-list must not be greater than the number of register groups. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-register-groups ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string . body may start with declarations.","title":"do-register-groups"},{"location":"cl-ppcre/#do-scans","text":"Macro: (do-scans (match-start match-end reg-starts reg-ends regex target-string &optional result-form &key start end) &body body) Iterates over target-string and tries to match regex as often as possible evaluating BODY with match-start , match-end , reg-starts , and reg-ends bound to the four return values of each match in turn. After the last match, returns result-form if provided or nil otherwise. An implicit block named nil surrounds do-scans ; return may be used to terminate the loop immediately. If regex matches an empty string the scan is continued one position behind this match. body may start with declarations.","title":"do-scans"},{"location":"cl-ppcre/#parse-string","text":"Function: (parse-string string) Translate the regex string string into a parse tree.","title":"parse-string"},{"location":"cl-ppcre/#parse-tree-synonym","text":"Function: (parse-tree-synonym symbol) Returns the parse tree the symbol symbol is a synonym for. Returns nil is symbol wasn't yet defined to be a synonym.","title":"parse-tree-synonym"},{"location":"cl-ppcre/#ppcre-error","text":"Every error signaled by CL-PPCRE is of type ppcre-error . This is a direct subtype of simple-error without any additional slots or options.","title":"ppcre-error"},{"location":"cl-ppcre/#ppcre-invocation-error","text":"Errors of type ppcre-invocation-error are signaled if one of the exported functions of CL-PPCRE is called with wrong or inconsistent arguments. This is a direct subtype of ppcre-error without any additional slots or options.","title":"ppcre-invocation-error"},{"location":"cl-ppcre/#ppcre-syntax-error","text":"An error of type ppcre-syntax-error is signaled if CL-PPCRE's parser encounters an error when trying to parse a regex string or to convert a parse tree into its internal representation. This is a direct subtype of ppcre-error with two additional slots. These denote the regex string which HTML-PPCRE was parsing and the position within the string where the error occurred. If the error happens while CL-PPCRE is converting a parse tree, both of these slots contain NIL. (See the next two entries on how to access these slots.)","title":"ppcre-syntax-error"},{"location":"cl-ppcre/#ppcre-syntax-error-pos","text":"Function: (ppcre-syntax-error-pos condition) Returns the position within the string where the error occurred (or nil if the error happened while trying to convert a parse tree","title":"ppcre-syntax-error-pos"},{"location":"cl-ppcre/#ppcre-syntax-error-string","text":"Function: (ppcre-syntax-error-string condition) Returns the string the parser was parsing when the error was encountered (or nil if the error happened while trying to convert a parse tree).","title":"ppcre-syntax-error-string"},{"location":"cl-ppcre/#quote-meta-chars","text":"Function: (quote-meta-chars string &key (start 0) (end (length string))) Quote, i.e. prefix all non-word characters in string with #\\\\ .","title":"quote-meta-chars"},{"location":"cl-ppcre/#regex-apropos","text":"Function: (regex-apropos regex &optional packages &key (case-insensitive t)) Similar to the standard function apropos but returns a list of all symbols which match the regular expression REGEX. If case-insensitive is true and regex isn't already a scanner, a case-insensitive scanner is used.","title":"regex-apropos"},{"location":"cl-ppcre/#regex-apropos-list","text":"Function: (regex-apropos-list regex &optional packages &key (case-insensitive t)) Similar to the standard function apropos-list but returns a list of all symbols which match the regular expression regex . If case-insensitive is true and regex isn't already a scanner, a case-insensitive scanner is used.","title":"regex-apropos-list"},{"location":"cl-ppcre/#regex-replace","text":"Function: (regex-replace regex target-string replacement &key (start 0) (end (length target-string)) preserve-case simple-calls (element-type 'character)) Try to match target-string between start and end against regex and replace the first match with replacement . Two values are returned; the modified string, and t if regex matched or nil otherwise. replacement can be a string which may contain the special substrings \"\\&\" for the whole match, \"`\" for the part of target-string before the match, \"\\'\" for the part of target-string after the match, \"\\N\" or \"{N}\" for the Nth register where N is a positive integer. replacement can also be a function designator in which case the match will be replaced with the result of calling the function designated by replacement with the arguments target-string , start , end , match-start , match-end , reg-starts , and reg-ends . ( reg-starts and reg-ends are arrays holding the start and end positions of matched registers or nil - the meaning of the other arguments should be obvious.) Finally, replacement can be a list where each element is a string, one of the symbols :match , :before-match , or :after-match - corresponding to \"\\&\", \"`\", and \"\\'\" above -, an integer N - representing register (1+ N) -, or a function designator. If preserve-case is true, the replacement will try to preserve the case (all upper case, all lower case, or capitalized) of the match. The result will always be a fresh string, even if regex doesn't match. element-type is the element type of the resulting string.","title":"regex-replace"},{"location":"cl-ppcre/#regex-replace-all","text":"Function: (regex-replace-all regex target-string replacement &key (start 0) (end (length target-string)) preserve-case simple-calls (element-type 'character)) Try to match target-string between start and end against regex and replace all matches with replacement . Two values are returned; the modified string, and T if regex matched or nil otherwise. replacement can be a string which may contain the special substrings \"\\&\" for the whole match, \"`\" for the part of target-string before the match, \"\\'\" for the part of target-string after the match, \"\\N\" or \"{N}\" for the Nth register where N is a positive integer. replacement can also be a function designator in which case the match will be replaced with the result of calling the function designated by replacement with the arguments target-string , start , end , match-start , match-end , reg-starts , and reg-ends . ( reg-starts and reg-ends are arrays holding the start and end positions of matched registers or nil - the meaning of the other arguments should be obvious.) Finally, replacement can be a list where each element is a string, one of the symbols :match , :before-match , or :after-match - corresponding to \"\\&\", \"`\", and \"\\'\" above -, an integer N - representing register (1+ N) -, or a function designator. If preserve-case is true, the replacement will try to preserve the case (all upper case, all lower case, or capitalized) of the match. The result will always be a fresh string, even if regex doesn't match. element-type is the element type of the resulting string.","title":"regex-replace-all"},{"location":"cl-ppcre/#register-groups-bind","text":"Macro: (register-groups-bind var-list (regex target-string &key start end sharedp) &body body) Executes body with the variables in var-list bound to the corresponding register groups after target-string has been matched against regex , i.e. each variable is either bound to a string or to nil . If there is no match, body is not executed. For each element of var-list which is nil there's no binding to the corresponding register group. The number of variables in var-list must not be greater than the number of register groups. If sharedp is true, the substrings may share structure with target-string .","title":"register-groups-bind"},{"location":"cl-ppcre/#scan","text":"Function: (scan regex target-string &key start end real-start-pos) Searches target-string from start to end and tries to match regex . On success returns four values - the start of the match, the end of the match, and two arrays denoting the beginnings and ends of register matches. On failure returns nil . regex can be a string which will be parsed according to Perl syntax, a parse tree, or a pre-compiled scanner created by create-scanner . target-string will be coerced to a simple string if it isn't one already. The real-start-pos parameter should be ignored - it exists only for internal purposes.","title":"scan"},{"location":"cl-ppcre/#scan-to-strings","text":"Function: (scan-to-strings regex target-string &key (start 0) (end (length target-string)) sharedp) Like scan but returns substrings of target-string instead of positions, i.e. this function returns two values on success: the whole match as a string plus an array of substrings (or nil s) corresponding to the matched registers. If sharedp is true, the substrings may share structure with target-string .","title":"scan-to-strings"},{"location":"cl-ppcre/#split","text":"Function: (split regex target-string &key (start 0) (end (length target-string)) limit with-registers-p omit-unmatched-p sharedp) Matches regex against target-string as often as possible and returns a list of the substrings between the matches. If with-registers-p is true, substrings corresponding to matched registers are inserted into the list as well. If omit-unmatched-p is true, unmatched registers will simply be left out, otherwise they will show up as nil . limit limits the number of elements returned - registers aren't counted. If limit is nil (or 0 which is equivalent), trailing empty strings are removed from the result list. If regex matches an empty string the scan is continued one position behind this match. If sharedp is true, the substrings may share structure with target-string .","title":"split"},{"location":"cl-ppcre/#configuration-variables","text":"","title":"CONFIGURATION VARIABLES"},{"location":"cl-ppcre/#allow-named-registers","text":"Whether the parser should support AllegroCL's named registers (?<name>\"<regex>\") and back-reference \\k syntax.","title":"*allow-named-registers*"},{"location":"cl-ppcre/#allow-quoting","text":"Whether the parser should support Perl's \\Q and \\E.","title":"*allow-quoting*"},{"location":"cl-ppcre/#look-ahead-for-suffix","text":"Controls whether scanners will optimistically look ahead for a constant suffix of a regular expression, if there is one.","title":"*look-ahead-for-suffix*"},{"location":"cl-ppcre/#optimize-char-classes","text":"Whether character classes should be compiled into look-ups into O(1) data structures. This is usually fast but will be costly in terms of scanner creation time and might be costly in terms of size if *regex-char-code-limit* is high. This value will be used as the :kind keyword argument to create-optimized-test-function - see there for the possible non- NIL values.","title":"*optimize-char-classes*"},{"location":"cl-ppcre/#property-resolver","text":"Should be NIL or a designator for a function which accepts strings and returns unary character test functions or NIL . This 'resolver' is intended to handle character properties' like \\p{IsAlpha}. If *property-resolver* is NIL , then the parser will simply treat \\p and \\P as #\\p and #\\P as in older versions of CL-PPCRE.","title":"*property-resolver*"},{"location":"cl-ppcre/#regex-char-code-limit","text":"The upper exclusive bound on the char-codes of characters which can occur in character classes. Change this value BEFORE creating scanners if you don't need the (full) Unicode support of implementations like AllegroCL, CLISP, LispWorks, or SBCL.","title":"*regex-char-code-limit*"},{"location":"cl-ppcre/#use-bmh-matchers","text":"Whether the scanners created by create-scanner should use the (fast but large) Boyer-Moore-Horspool matchers.","title":"*use-bmh-matchers*"},{"location":"cl-ppcre/#support","text":"The development version of cl-ppcre can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"SUPPORT"},{"location":"cl-who/","text":"cl-who - DSL for Markup Version: 1.1.4 Nickname: who Repository: edicl/cl-who - Github This documentation is possible due to the excellent official documentation as of 5th May 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . CL-WHO primarily provides a single macro with-html-output to convert S-expressions intermingled with code into (X)HTML, XML and the likes. GETTING STARTED with-html-output and with-html-output-to-string are the basic macros to get going: CL-USER> (defparameter *site-alist* '((\"http://zappa.com/\" . \"Frank Zappa\") (\"http://marcusmiller.com/\" . \"Marcus Miller\") (\"http://www.milesdavis.com/\" . \"Miles Davis\"))) *SITE-ALIST* CL-USER> (format t (with-html-output-to-string (s nil :indent t) (loop for (link . title) in *site-alist* do (htm (:a :href link (:b (str title))) ; <- note the str! :br)))) <a href='http://zappa.com/'> <b>Frank Zappa </b> </a> <br /> <a href='http://marcusmiller.com/'> <b>Marcus Miller </b> </a> <br /> <a href='http://www.milesdavis.com/'> <b>Miles Davis </b> </a> <br /> NIL CL-USER> (format t (with-output-to-string (s) (with-html-output (s s :indent t) (loop for (link . title) in *site-alist* do (htm (:a :href link (:b (str title))) ; <- note the str! :br))))) <a href='http://zappa.com/'> <b>Frank Zappa </b> </a> <br /> <a href='http://marcusmiller.com/'> <b>Marcus Miller </b> </a> <br /> <a href='http://www.milesdavis.com/'> <b>Miles Davis </b> </a> <br /> Inside these macros, there exist the lexically scoped macros: esc as short-hand for escape-string fmt as short-hand for cl:format htm as short-hand for (another) with-html-output . str as short-hand for, well, writing to the \"inner html\" rather than attributes; basically the difference between these two: CL-USER> (let ((string \"hello\") (class \"world\")) (with-html-output-to-string (s nil :indent t) (htm (:div :class class string)))) \" <div class='world'> </div>\" CL-USER> (let ((string \"hello\") (class \"world\")) (with-html-output-to-string (s nil :indent t) (htm (:div :class class (str string))))) \" <div class='world'>hello </div>\" In this case, str could equivalently be replaced by fmt or esc . Also see html-mode . Detailed transformation rules are available in the official documentation . CONFIGURATION VARIABLES *attribute-quote-char* Variable Quote character for attributes. *downcase-tokens-p* Variable If NIL, a keyword symbol representing a tag or attribute name will not be automatically converted to lowercase. If T, the tag and attribute name will be converted to lowercase only if it is in the same case. This is useful when one needs to output case sensitive XML. *empty-attribute-syntax* Variable Set this to t to enable attribute minimization (also called \"boolean attributes\", or \"empty attribute syntax\" according to the w3 html standard ). In XHTML attribute minimization is forbidden, and all attributes must have a value. Thus in XHTML boolean attributes must be defined as <input disabled='disabled' />. In HTML5 boolean attributes can be defined as <input disabled> If it is NIL the attribute will be left out completely. (:td :nowrap nil) => \"<td />\" *escape-char-p* Variable Used by escape-string to test whether a character should be escaped. *html-empty-tag-aware-p* Variable Set this to NIL to if you want to use CL-WHO as a strict XML generator. Otherwise, CL-WHO will only write empty tags listed in *html-empty-tags* as <tag/> (XHTML mode) or <tag> (SGML mode and HTML5 mode). For all other tags, it will always generate <tag></tag>. *html-empty-tags* Variable The list of HTML tags that should be output as empty tags. See *html-empty-tag-aware-p* . *html-no-indent-tags* Variable The list of HTML tags that should disable indentation inside them. The initial value is a list containing only :pre and :textarea . *prologue* Variable This is the first line that'll be printed if the :prologue keyword argument is T FUNCTIONS AND MACROS conc Function: (conc &rest string-list) Concatenates all arguments which should be string into one string. convert-attributes Function: (convert-attributes attr-list) Helper function for convert-tag-to-string-list which converts the alist attr-list of attributes into a list of strings and/or Lisp forms. convert-tag-to-string-list Generic Function: (convert-tag-to-string-list tag attr-list body body-fn) Used by cl-who::process-tag to convert HTML into a list of strings. tag is a keyword symbol naming the outer tag, attr-list is an alist of its attributes (the car is the attribute's name as a keyword, the cdr is its value), body is the tag's body, and body-fn is a function which should be applied to body . The function must return a list of strings or Lisp forms. esc escape-char Function: (escape-char char &key (test *escape-char-p*)) Returns an escaped version of the character char if char satisfies the predicate test . Always returns a string. escape-char-all Function: (escape-char-all char) Escapes characters which aren't in the 7-bit ASCII character set. escape-char-iso-8859-1 Function: (escape-char-iso-8859-1 char) Escapes characters that aren't defined in ISO-8859-9. escape-char-minimal Function: (escape-char-minimal char) Escapes only #<, #>, and #& characters. escape-char-minimal-plus-quotes Function: (escape-char-minimal-plus-quotes char) Like escape-char-minimal but also escapes quotes. escape-string Function: (escape-string string &key (test *escape-char-p*)) Escape all characters in string which pass test . This function is not guaranteed to return a fresh string. Note that you can pass NIL for string which'll just be returned. escape-string-all Function: (escape-string-all string) Escapes all characters in string which aren't in the 7-bit ASCII character set. escape-string-iso-8859-1 Function: (escape-string-iso-8859-1 string) Escapes all characters in string which aren't defined in ISO-8859-1. escape-string-minimal Function: (escape-string-minimal string) Escapes only #<, #>, and #& in string . escape-string-minimal-plus-quotes Function: (escape-string-minimal-plus-quotes string) Like escape-string-minimal but also escapes quotes. fmt htm html-mode Function: (html-mode) Returns the current HTML mode. :SGML for (SGML-)HTML, :XML for XHTML and :HTML5 for HTML5 (HTML syntax). Function: (setf (html-mode) mode) Sets the output mode to XHTML or (SGML-)HTML. MODE can be :SGML for HTML, :XML for XHTML or :HTML5 for HTML5 (HTML syntax). str with-html-output Macro: (with-html-output (var &optional stream &rest rest &key prologue indent) &body body) Transform the enclosed body consisting of HTML as s-expressions into Lisp code to write the corresponding HTML as strings to var - which should either hold a stream or which'll be bound to STREAM if supplied. with-html-output-to-string Macro: (with-html-output-to-string (var &optional string-form &key prologue indent) &body body) Transform the enclosed body consisting of HTML as s-expressions into Lisp code which creates the corresponding HTML as a string.","title":"cl-who - DSL for Markup"},{"location":"cl-who/#cl-who-dsl-for-markup","text":"Version: 1.1.4 Nickname: who Repository: edicl/cl-who - Github This documentation is possible due to the excellent official documentation as of 5th May 2020. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . CL-WHO primarily provides a single macro with-html-output to convert S-expressions intermingled with code into (X)HTML, XML and the likes.","title":"cl-who - DSL for Markup"},{"location":"cl-who/#getting-started","text":"with-html-output and with-html-output-to-string are the basic macros to get going: CL-USER> (defparameter *site-alist* '((\"http://zappa.com/\" . \"Frank Zappa\") (\"http://marcusmiller.com/\" . \"Marcus Miller\") (\"http://www.milesdavis.com/\" . \"Miles Davis\"))) *SITE-ALIST* CL-USER> (format t (with-html-output-to-string (s nil :indent t) (loop for (link . title) in *site-alist* do (htm (:a :href link (:b (str title))) ; <- note the str! :br)))) <a href='http://zappa.com/'> <b>Frank Zappa </b> </a> <br /> <a href='http://marcusmiller.com/'> <b>Marcus Miller </b> </a> <br /> <a href='http://www.milesdavis.com/'> <b>Miles Davis </b> </a> <br /> NIL CL-USER> (format t (with-output-to-string (s) (with-html-output (s s :indent t) (loop for (link . title) in *site-alist* do (htm (:a :href link (:b (str title))) ; <- note the str! :br))))) <a href='http://zappa.com/'> <b>Frank Zappa </b> </a> <br /> <a href='http://marcusmiller.com/'> <b>Marcus Miller </b> </a> <br /> <a href='http://www.milesdavis.com/'> <b>Miles Davis </b> </a> <br /> Inside these macros, there exist the lexically scoped macros: esc as short-hand for escape-string fmt as short-hand for cl:format htm as short-hand for (another) with-html-output . str as short-hand for, well, writing to the \"inner html\" rather than attributes; basically the difference between these two: CL-USER> (let ((string \"hello\") (class \"world\")) (with-html-output-to-string (s nil :indent t) (htm (:div :class class string)))) \" <div class='world'> </div>\" CL-USER> (let ((string \"hello\") (class \"world\")) (with-html-output-to-string (s nil :indent t) (htm (:div :class class (str string))))) \" <div class='world'>hello </div>\" In this case, str could equivalently be replaced by fmt or esc . Also see html-mode . Detailed transformation rules are available in the official documentation .","title":"GETTING STARTED"},{"location":"cl-who/#configuration-variables","text":"","title":"CONFIGURATION VARIABLES"},{"location":"cl-who/#attribute-quote-char","text":"Variable Quote character for attributes.","title":"*attribute-quote-char*"},{"location":"cl-who/#downcase-tokens-p","text":"Variable If NIL, a keyword symbol representing a tag or attribute name will not be automatically converted to lowercase. If T, the tag and attribute name will be converted to lowercase only if it is in the same case. This is useful when one needs to output case sensitive XML.","title":"*downcase-tokens-p*"},{"location":"cl-who/#empty-attribute-syntax","text":"Variable Set this to t to enable attribute minimization (also called \"boolean attributes\", or \"empty attribute syntax\" according to the w3 html standard ). In XHTML attribute minimization is forbidden, and all attributes must have a value. Thus in XHTML boolean attributes must be defined as <input disabled='disabled' />. In HTML5 boolean attributes can be defined as <input disabled> If it is NIL the attribute will be left out completely. (:td :nowrap nil) => \"<td />\"","title":"*empty-attribute-syntax*"},{"location":"cl-who/#escape-char-p","text":"Variable Used by escape-string to test whether a character should be escaped.","title":"*escape-char-p*"},{"location":"cl-who/#html-empty-tag-aware-p","text":"Variable Set this to NIL to if you want to use CL-WHO as a strict XML generator. Otherwise, CL-WHO will only write empty tags listed in *html-empty-tags* as <tag/> (XHTML mode) or <tag> (SGML mode and HTML5 mode). For all other tags, it will always generate <tag></tag>.","title":"*html-empty-tag-aware-p*"},{"location":"cl-who/#html-empty-tags","text":"Variable The list of HTML tags that should be output as empty tags. See *html-empty-tag-aware-p* .","title":"*html-empty-tags*"},{"location":"cl-who/#html-no-indent-tags","text":"Variable The list of HTML tags that should disable indentation inside them. The initial value is a list containing only :pre and :textarea .","title":"*html-no-indent-tags*"},{"location":"cl-who/#prologue","text":"Variable This is the first line that'll be printed if the :prologue keyword argument is T","title":"*prologue*"},{"location":"cl-who/#functions-and-macros","text":"","title":"FUNCTIONS AND MACROS"},{"location":"cl-who/#conc","text":"Function: (conc &rest string-list) Concatenates all arguments which should be string into one string.","title":"conc"},{"location":"cl-who/#convert-attributes","text":"Function: (convert-attributes attr-list) Helper function for convert-tag-to-string-list which converts the alist attr-list of attributes into a list of strings and/or Lisp forms.","title":"convert-attributes"},{"location":"cl-who/#convert-tag-to-string-list","text":"Generic Function: (convert-tag-to-string-list tag attr-list body body-fn) Used by cl-who::process-tag to convert HTML into a list of strings. tag is a keyword symbol naming the outer tag, attr-list is an alist of its attributes (the car is the attribute's name as a keyword, the cdr is its value), body is the tag's body, and body-fn is a function which should be applied to body . The function must return a list of strings or Lisp forms.","title":"convert-tag-to-string-list"},{"location":"cl-who/#esc","text":"","title":"esc"},{"location":"cl-who/#escape-char","text":"Function: (escape-char char &key (test *escape-char-p*)) Returns an escaped version of the character char if char satisfies the predicate test . Always returns a string.","title":"escape-char"},{"location":"cl-who/#escape-char-all","text":"Function: (escape-char-all char) Escapes characters which aren't in the 7-bit ASCII character set.","title":"escape-char-all"},{"location":"cl-who/#escape-char-iso-8859-1","text":"Function: (escape-char-iso-8859-1 char) Escapes characters that aren't defined in ISO-8859-9.","title":"escape-char-iso-8859-1"},{"location":"cl-who/#escape-char-minimal","text":"Function: (escape-char-minimal char) Escapes only #<, #>, and #& characters.","title":"escape-char-minimal"},{"location":"cl-who/#escape-char-minimal-plus-quotes","text":"Function: (escape-char-minimal-plus-quotes char) Like escape-char-minimal but also escapes quotes.","title":"escape-char-minimal-plus-quotes"},{"location":"cl-who/#escape-string","text":"Function: (escape-string string &key (test *escape-char-p*)) Escape all characters in string which pass test . This function is not guaranteed to return a fresh string. Note that you can pass NIL for string which'll just be returned.","title":"escape-string"},{"location":"cl-who/#escape-string-all","text":"Function: (escape-string-all string) Escapes all characters in string which aren't in the 7-bit ASCII character set.","title":"escape-string-all"},{"location":"cl-who/#escape-string-iso-8859-1","text":"Function: (escape-string-iso-8859-1 string) Escapes all characters in string which aren't defined in ISO-8859-1.","title":"escape-string-iso-8859-1"},{"location":"cl-who/#escape-string-minimal","text":"Function: (escape-string-minimal string) Escapes only #<, #>, and #& in string .","title":"escape-string-minimal"},{"location":"cl-who/#escape-string-minimal-plus-quotes","text":"Function: (escape-string-minimal-plus-quotes string) Like escape-string-minimal but also escapes quotes.","title":"escape-string-minimal-plus-quotes"},{"location":"cl-who/#fmt","text":"","title":"fmt"},{"location":"cl-who/#htm","text":"","title":"htm"},{"location":"cl-who/#html-mode","text":"Function: (html-mode) Returns the current HTML mode. :SGML for (SGML-)HTML, :XML for XHTML and :HTML5 for HTML5 (HTML syntax). Function: (setf (html-mode) mode) Sets the output mode to XHTML or (SGML-)HTML. MODE can be :SGML for HTML, :XML for XHTML or :HTML5 for HTML5 (HTML syntax).","title":"html-mode"},{"location":"cl-who/#str","text":"","title":"str"},{"location":"cl-who/#with-html-output","text":"Macro: (with-html-output (var &optional stream &rest rest &key prologue indent) &body body) Transform the enclosed body consisting of HTML as s-expressions into Lisp code to write the corresponding HTML as strings to var - which should either hold a stream or which'll be bound to STREAM if supplied.","title":"with-html-output"},{"location":"cl-who/#with-html-output-to-string","text":"Macro: (with-html-output-to-string (var &optional string-form &key prologue indent) &body body) Transform the enclosed body consisting of HTML as s-expressions into Lisp code which creates the corresponding HTML as a string.","title":"with-html-output-to-string"},{"location":"fiveam/","text":"fiveam - Regression Testing Framework Version: 1.4.1 Nickname: 5am Repository: sionescu/fiveam - Github This documentation was possible due to Tomek Kurez's tutorial on fiveam and the excellent official documentation . In case of any inaccuracies, ambiguities or suggestions, please create an issue here . GETTING STARTED Checks and Tests A check, defined using the macro is , is a line of code that makes sure something is indeed true. A basic check definition is of the form (is test &rest reason-args) . However, checks can only be defined in the context of tests: (test test-demo \"This demonstrates the basic use of test and check.\" (is (listp (list 1 2))) (is (= 5 (+ 2 3)) \"This should pass.\") ; &rest reason-args (is (= 4 4.1) \"~D and ~D are not = to each other.\" 4 4.1)) To run the test, simply, call run! : (run! 'test-demo) ;; Running test TEST-DEMO ..f ;; Did 3 checks. ;; Pass: 2 (66%) ;; Skip: 0 ( 0%) ;; Fail: 1 (33%) ;; ;; Failure Details: ;; -------------------------------- ;; TEST-DEMO [This demonstrates the basic use of test and check.]: ;; 4 and 4.1 are not = to each other. ;; ;; (= 4 4.1) ;; ;; was NIL.. ;; -------------------------------- Tests can automatically be run on (re)compilation by setting *run-test-when-defined* to t . So, simply compiling (test another-test (is (eq t t))) ;; ;; Running test ANOTHER-TEST . ;; Did 1 check. ;; Pass: 1 (100%) ;; Skip: 0 ( 0%) ;; Fail: 0 ( 0%) runs the test. (Also see other Configuration Variables .) (run!) can be called without arguments to run all the tests. Suites Tests can be grouped into suites. In fact, suites can also parent other suites. Suites can be defined using def-suite , and similar to* in-package , the current suite can be specified using in-suite . (def-suite suite-one) (def-suite suite-two) (in-suite suite-one) (test first-test (is (= 1 1))) (test (second-test :suite suite-two) ; perhaps, not recommended (is (null nil))) (in-suite suite-two) (test third-test (is (eq 'done 'done))) All tests can be run with run-all-tests . Also see the arguments to run! . (run-all-tests) ;; Running test suite NIL ;; Running test FIRST-TEST . ;; Running test THIRD-TEST . ;; Running test suite SUITE-TWO ;; Running test SECOND-TEST . ;; Did 3 checks. ;; Pass: 3 (100%) ;; Skip: 0 ( 0%) ;; Fail: 0 ( 0%) More Things Tests can be removed using rem-test . See generators for utilities for generating random data. These are to be used in conjunction with the for-all macro. Generators are merely closures and you can define your own. fiveam also provides the ability to def-fixture and with-fixture ; however, (as of 2016) it is recommended to just use macros instead . The signals macro can be used to check if conditions are signalled appropriately. CONFIGURATION VARIABLES *debug-on-error* T if we should drop into the debugger on error, NIL otherwise. OBSOLETE: superseded by *ON-ERROR* *debug-on-failure* T if we should drop into the debugger on a failing check, NIL otherwise. OBSOLETE: superseded by *ON-FAILURE* *default-test-compilation-time* *max-trials* Number of total times we attempt to run the body of the FOR-ALL test including when the body is skipped due to failed guard conditions. Since we have guard conditions we may get into infinite loops where the test code is never run due to the guards never returning true. This second run limit prevents that. *num-trials* Number of times we attempt to run the body of the FOR-ALL test. *on-error* The action to perform on error: - :DEBUG if we should drop into the debugger - :BACKTRACE to print a backtrace - NIL to simply continue *on-failure* The action to perform on check failure: - :DEBUG if we should drop into the debugger - :BACKTRACE to print a backtrace - NIL to simply continue *print-names* T if we should print test running progress, NIL otherwise. *run-test-when-defined* When non-NIL tests are run as soon as they are defined. *test-dribble* *verbose-failures* T if we should print the expression failing, NIL otherwise. FUNCTIONS AND MACROS ! Function: (!) Rerun the most recently run test and explain the results. !! Function: (!!) Rerun the second most recently run test and explain the results. !!! Function: (!!!) Rerun the third most recently run test and explain the results. debug! Function: (debug! &optional (test-spec *suite*)) Calls (run! test-spec) but enters the debugger if any kind of error happens. def-fixture Macro: (def-fixture name (&rest args) &body body) Defines a fixture named NAME. A fixture is very much like a macro but is used only for simple templating. A fixture created with DEF-FIXTURE is a macro which can use the special macrolet &BODY to specify where the body should go. See Also: WITH-FIXTURE . def-suite Macro: (def-suite name &key description in) Define a new test-suite named NAME. IN (a symbol), if provided, causes this suite te be nested in the suite named by IN. NB: This macro is built on top of make-suite, as such it, like make-suite, will overrwrite any existing suite named NAME. def-suite* Macro: (def-suite* name &rest def-suite-args) def-test Macro: (def-test name (&key depends-on (suite) fixture (compile-at) profile) &body body) Create a test named NAME. NAME is the symbol which names the test. DEPENDS-ON is a list of the form: (AND . test-names) - This test is run only if all of the tests in TEST-NAMES have passed, otherwise a single test-skipped result is generated. (OR . test-names) - If any of TEST-NAMES has passed this test is run, otherwise a test-skipped result is generated. (NOT test-name) - This is test is run only if TEST-NAME failed. AND, OR and NOT can be combined to produce complex dependencies. If DEPENDS-ON is a symbol it is interpreted as `(AND ,depends-on), this is accomadate the common case of one test depending on another. FIXTURE specifies a fixture to wrap the body in. If PROFILE is T profiling information will be collected as well. explain! Function: (explain! result-list) Explain the results of RESULT-LIST using a detailed-text-explainer with output going to test-dribble . Return a boolean indicating whether no tests failed. fail Macro: (fail &rest message-args) Simply generate a FAIL. finishes Macro: (finishes &body body) Generates a pass if BODY executes to normal completion. In other words if body does signal, return-from or throw this test fails. for-all Macro: (for-all bindings &body body) Bind BINDINGS to random variables and test BODY num-trials times. BINDINGS is a list of binding forms, each element is a list of (BINDING VALUE &optional GUARD) . Value, which is evaluated once when the for-all is evaluated, must return a generator which be called each time BODY is evaluated. BINDING is either a symbol or a list which will be passed to destructuring-bind. GUARD is a form which, if present, stops BODY from executing when IT returns NIL. The GUARDS are evaluated after all the random data has been generated and they can refer to the current value of any binding. NB: Generator forms, unlike guard forms, can not contain references to the bound variables. Examples: (for-all ((a (gen-integer))) (is (integerp a))) (for-all ((a (gen-integer) (plusp a))) (is (integerp a)) (is (plusp a))) (for-all ((less (gen-integer)) (more (gen-integer) (< less more))) (is (<= less more))) (for-all (((a b) (gen-two-integers))) (is (integerp a)) (is (integerp b))) gen-buffer Function: (gen-buffer &key (length (gen-integer min 0 max 50)) (element-type '(unsigned-byte 8)) (elements (gen-integer :min 0 :max (1- (expt 2 8))))) gen-character Function: (gen-character &key (code-limit char-code-limit) (code (gen-integer :min 0 :max (1- code-limit))) (alphanumericp nil)) Returns a generator of characters. CODE must be a generator of random integers. ALPHANUMERICP, if non-NIL, limits the returned chars to those which pass alphanumericp. gen-float Function: (gen-float &key bound (type 'short-float)) Returns a generator which produces floats of type TYPE. BOUND, if specified, constrains the results to be in the range (-BOUND, BOUND). gen-integer Function: (gen-integer &key (max (1+ most-positive-fixnum)) (min (1- most-negative-fixnum))) Returns a generator which produces random integers greater than or equal to MIN and less than or equal to MAX. gen-list Function: (gen-list &key (length (gen-integer :min 0 :max 10)) (elements (gen-integer :min -10 :max 10))) Returns a generator which produces random lists. LENGTH must be an integer generator and ELEMENTS must be a generator which produces objects. gen-one-element Function: (gen-one-element &rest elements) gen-string Function: (gen-string &key (length (gen-integer :min 0 :max 80)) (elements (gen-character)) (element-type 'character)) Returns a generator which produces random strings. LENGTH must be a generator which produces integers, ELEMENTS must be a generator which produces characters of type ELEMENT-TYPE. gen-tree Function: (gen-tree &key (size 20) (elements (gen-integer :min -10 :max 10))) Returns a generator which produces random trees. SIZE controls the approximate size of the tree, but don't try anything above 30, you have been warned. ELEMENTS must be a generator which will produce the elements. get-fixture Function: (get-fixture key &optional default) get-test Function: (get-test key &optional default) in-suite Macro: (in-suite suite-name) Set the suite special variable so that all tests defined after the execution of this form are, unless specified otherwise, in the test-suite named SUITE-NAME. See also: DEF-SUITE SUITE in-suite* Macro: (in-suite* suite-name &key in) Just like in-suite, but silently creates missing suites. is Macro: (is test &rest reason-args) The DWIM checking operator. If TEST returns a true value a test-passed result is generated, otherwise a test-failure result is generated. The reason, unless REASON-ARGS is provided, is generated based on the form of TEST: (predicate expected actual) - Means that we want to check whether, according to PREDICATE, the ACTUAL value is in fact what we EXPECTED. (predicate value) - Means that we want to ensure that VALUE satisfies PREDICATE. Wrapping the TEST form in a NOT simply produces a negated reason string. is-every Macro: (is-every predicate &body clauses) The input is either a list of lists, or a list of pairs. Generates (is (,predicate ,expr ,value)) for each pair of elements or (is (,predicate ,expr ,value) ,@reason) for each list. is-false Macro: (is-false condition &rest reason-args) Generates a pass if CONDITION returns false, generates a failure otherwise. Like IS-TRUE, and unlike IS, IS-FALSE does not inspect CONDITION to determine what reason to give it case of test failure is-true Macro: (is-true condition &rest reason-args) Like IS this check generates a pass if CONDITION returns true and a failure if CONDITION returns false. Unlike IS this check does not inspect CONDITION to determine how to report the failure. make-fixture make-suite Function: (make-suite name &key description ((in parent-suite))) Create a new test suite object. Overrides any existing suite named NAME. make-test pass Macro: (pass &rest message-args) Simply generate a PASS. rem-fixture Function: (rem-fixture key) rem-test Function: (rem-test key) results-status Function: (results-status result-list) Given a list of test results (generated while running a test) return true if no results are of type TEST-FAILURE. Returns second and third values, which are the set of failed tests and skipped tests respectively. run Function: (run test-spec &key (print-names *print-names*)) Run the test specified by TEST-SPEC. TEST-SPEC can be either a symbol naming a test or test suite, or a testable-object object. This function changes the operations performed by the !, !! and !!! functions. run! Function: (run! &optional (test-spec *suite*) &key (print-names *print-names*)) Equivalent to (explain! (run TEST-SPEC)). run-all-tests Function: (run-all-tests &key (summary :end)) Runs all defined test suites, T if all tests passed and NIL otherwise. SUMMARY can be :END to print a summary at the end, :SUITE to print it after each suite or NIL to skip explanations. signals Macro: (signals condition-spec &body body) Generates a pass if BODY signals a condition of type CONDITION. BODY is evaluated in a block named NIL, CONDITION is not evaluated. skip Macro: (skip &rest reason) Generates a TEST-SKIPPED result. test Macro: (test name &body body) Create a test named NAME. If NAME is a list it must be of the form: (name &key depends-on suite fixture compile-at profile) NAME is the symbol which names the test. DEPENDS-ON is a list of the form: (AND . test-names) - This test is run only if all of the tests in TEST-NAMES have passed, otherwise a single test-skipped result is generated. (OR . test-names) - If any of TEST-NAMES has passed this test is run, otherwise a test-skipped result is generated. (NOT test-name) - This is test is run only if TEST-NAME failed. AND, OR and NOT can be combined to produce complex dependencies. If DEPENDS-ON is a symbol it is interpreted as `(AND ,depends-on), this is accomadate the common case of one test depending on another. FIXTURE specifies a fixture to wrap the body in. If PROFILE is T profiling information will be collected as well. test-names Function: (test-names) with-fixture Macro: (with-fixture fixture-name (&rest args) &body body) Insert BODY into the fixture named FIXTURE-NAME. See Also: DEF-FIXTURE .","title":"fiveam - Regression Testing Framework"},{"location":"fiveam/#fiveam-regression-testing-framework","text":"Version: 1.4.1 Nickname: 5am Repository: sionescu/fiveam - Github This documentation was possible due to Tomek Kurez's tutorial on fiveam and the excellent official documentation . In case of any inaccuracies, ambiguities or suggestions, please create an issue here .","title":"fiveam - Regression Testing Framework"},{"location":"fiveam/#getting-started","text":"","title":"GETTING STARTED"},{"location":"fiveam/#checks-and-tests","text":"A check, defined using the macro is , is a line of code that makes sure something is indeed true. A basic check definition is of the form (is test &rest reason-args) . However, checks can only be defined in the context of tests: (test test-demo \"This demonstrates the basic use of test and check.\" (is (listp (list 1 2))) (is (= 5 (+ 2 3)) \"This should pass.\") ; &rest reason-args (is (= 4 4.1) \"~D and ~D are not = to each other.\" 4 4.1)) To run the test, simply, call run! : (run! 'test-demo) ;; Running test TEST-DEMO ..f ;; Did 3 checks. ;; Pass: 2 (66%) ;; Skip: 0 ( 0%) ;; Fail: 1 (33%) ;; ;; Failure Details: ;; -------------------------------- ;; TEST-DEMO [This demonstrates the basic use of test and check.]: ;; 4 and 4.1 are not = to each other. ;; ;; (= 4 4.1) ;; ;; was NIL.. ;; -------------------------------- Tests can automatically be run on (re)compilation by setting *run-test-when-defined* to t . So, simply compiling (test another-test (is (eq t t))) ;; ;; Running test ANOTHER-TEST . ;; Did 1 check. ;; Pass: 1 (100%) ;; Skip: 0 ( 0%) ;; Fail: 0 ( 0%) runs the test. (Also see other Configuration Variables .) (run!) can be called without arguments to run all the tests.","title":"Checks and Tests"},{"location":"fiveam/#suites","text":"Tests can be grouped into suites. In fact, suites can also parent other suites. Suites can be defined using def-suite , and similar to* in-package , the current suite can be specified using in-suite . (def-suite suite-one) (def-suite suite-two) (in-suite suite-one) (test first-test (is (= 1 1))) (test (second-test :suite suite-two) ; perhaps, not recommended (is (null nil))) (in-suite suite-two) (test third-test (is (eq 'done 'done))) All tests can be run with run-all-tests . Also see the arguments to run! . (run-all-tests) ;; Running test suite NIL ;; Running test FIRST-TEST . ;; Running test THIRD-TEST . ;; Running test suite SUITE-TWO ;; Running test SECOND-TEST . ;; Did 3 checks. ;; Pass: 3 (100%) ;; Skip: 0 ( 0%) ;; Fail: 0 ( 0%)","title":"Suites"},{"location":"fiveam/#more-things","text":"Tests can be removed using rem-test . See generators for utilities for generating random data. These are to be used in conjunction with the for-all macro. Generators are merely closures and you can define your own. fiveam also provides the ability to def-fixture and with-fixture ; however, (as of 2016) it is recommended to just use macros instead . The signals macro can be used to check if conditions are signalled appropriately.","title":"More Things"},{"location":"fiveam/#configuration-variables","text":"","title":"CONFIGURATION VARIABLES"},{"location":"fiveam/#debug-on-error","text":"T if we should drop into the debugger on error, NIL otherwise. OBSOLETE: superseded by *ON-ERROR*","title":"*debug-on-error*"},{"location":"fiveam/#debug-on-failure","text":"T if we should drop into the debugger on a failing check, NIL otherwise. OBSOLETE: superseded by *ON-FAILURE*","title":"*debug-on-failure*"},{"location":"fiveam/#default-test-compilation-time","text":"","title":"*default-test-compilation-time*"},{"location":"fiveam/#max-trials","text":"Number of total times we attempt to run the body of the FOR-ALL test including when the body is skipped due to failed guard conditions. Since we have guard conditions we may get into infinite loops where the test code is never run due to the guards never returning true. This second run limit prevents that.","title":"*max-trials*"},{"location":"fiveam/#num-trials","text":"Number of times we attempt to run the body of the FOR-ALL test.","title":"*num-trials*"},{"location":"fiveam/#on-error","text":"The action to perform on error: - :DEBUG if we should drop into the debugger - :BACKTRACE to print a backtrace - NIL to simply continue","title":"*on-error*"},{"location":"fiveam/#on-failure","text":"The action to perform on check failure: - :DEBUG if we should drop into the debugger - :BACKTRACE to print a backtrace - NIL to simply continue","title":"*on-failure*"},{"location":"fiveam/#print-names","text":"T if we should print test running progress, NIL otherwise.","title":"*print-names*"},{"location":"fiveam/#run-test-when-defined","text":"When non-NIL tests are run as soon as they are defined.","title":"*run-test-when-defined*"},{"location":"fiveam/#test-dribble","text":"","title":"*test-dribble*"},{"location":"fiveam/#verbose-failures","text":"T if we should print the expression failing, NIL otherwise.","title":"*verbose-failures*"},{"location":"fiveam/#functions-and-macros","text":"","title":"FUNCTIONS AND MACROS"},{"location":"fiveam/#_1","text":"Function: (!) Rerun the most recently run test and explain the results.","title":"!"},{"location":"fiveam/#_2","text":"Function: (!!) Rerun the second most recently run test and explain the results.","title":"!!"},{"location":"fiveam/#_3","text":"Function: (!!!) Rerun the third most recently run test and explain the results.","title":"!!!"},{"location":"fiveam/#debug","text":"Function: (debug! &optional (test-spec *suite*)) Calls (run! test-spec) but enters the debugger if any kind of error happens.","title":"debug!"},{"location":"fiveam/#def-fixture","text":"Macro: (def-fixture name (&rest args) &body body) Defines a fixture named NAME. A fixture is very much like a macro but is used only for simple templating. A fixture created with DEF-FIXTURE is a macro which can use the special macrolet &BODY to specify where the body should go. See Also: WITH-FIXTURE .","title":"def-fixture"},{"location":"fiveam/#def-suite","text":"Macro: (def-suite name &key description in) Define a new test-suite named NAME. IN (a symbol), if provided, causes this suite te be nested in the suite named by IN. NB: This macro is built on top of make-suite, as such it, like make-suite, will overrwrite any existing suite named NAME.","title":"def-suite"},{"location":"fiveam/#def-suite_1","text":"Macro: (def-suite* name &rest def-suite-args)","title":"def-suite*"},{"location":"fiveam/#def-test","text":"Macro: (def-test name (&key depends-on (suite) fixture (compile-at) profile) &body body) Create a test named NAME. NAME is the symbol which names the test. DEPENDS-ON is a list of the form: (AND . test-names) - This test is run only if all of the tests in TEST-NAMES have passed, otherwise a single test-skipped result is generated. (OR . test-names) - If any of TEST-NAMES has passed this test is run, otherwise a test-skipped result is generated. (NOT test-name) - This is test is run only if TEST-NAME failed. AND, OR and NOT can be combined to produce complex dependencies. If DEPENDS-ON is a symbol it is interpreted as `(AND ,depends-on), this is accomadate the common case of one test depending on another. FIXTURE specifies a fixture to wrap the body in. If PROFILE is T profiling information will be collected as well.","title":"def-test"},{"location":"fiveam/#explain","text":"Function: (explain! result-list) Explain the results of RESULT-LIST using a detailed-text-explainer with output going to test-dribble . Return a boolean indicating whether no tests failed.","title":"explain!"},{"location":"fiveam/#fail","text":"Macro: (fail &rest message-args) Simply generate a FAIL.","title":"fail"},{"location":"fiveam/#finishes","text":"Macro: (finishes &body body) Generates a pass if BODY executes to normal completion. In other words if body does signal, return-from or throw this test fails.","title":"finishes"},{"location":"fiveam/#for-all","text":"Macro: (for-all bindings &body body) Bind BINDINGS to random variables and test BODY num-trials times. BINDINGS is a list of binding forms, each element is a list of (BINDING VALUE &optional GUARD) . Value, which is evaluated once when the for-all is evaluated, must return a generator which be called each time BODY is evaluated. BINDING is either a symbol or a list which will be passed to destructuring-bind. GUARD is a form which, if present, stops BODY from executing when IT returns NIL. The GUARDS are evaluated after all the random data has been generated and they can refer to the current value of any binding. NB: Generator forms, unlike guard forms, can not contain references to the bound variables. Examples: (for-all ((a (gen-integer))) (is (integerp a))) (for-all ((a (gen-integer) (plusp a))) (is (integerp a)) (is (plusp a))) (for-all ((less (gen-integer)) (more (gen-integer) (< less more))) (is (<= less more))) (for-all (((a b) (gen-two-integers))) (is (integerp a)) (is (integerp b)))","title":"for-all"},{"location":"fiveam/#gen-buffer","text":"Function: (gen-buffer &key (length (gen-integer min 0 max 50)) (element-type '(unsigned-byte 8)) (elements (gen-integer :min 0 :max (1- (expt 2 8)))))","title":"gen-buffer"},{"location":"fiveam/#gen-character","text":"Function: (gen-character &key (code-limit char-code-limit) (code (gen-integer :min 0 :max (1- code-limit))) (alphanumericp nil)) Returns a generator of characters. CODE must be a generator of random integers. ALPHANUMERICP, if non-NIL, limits the returned chars to those which pass alphanumericp.","title":"gen-character"},{"location":"fiveam/#gen-float","text":"Function: (gen-float &key bound (type 'short-float)) Returns a generator which produces floats of type TYPE. BOUND, if specified, constrains the results to be in the range (-BOUND, BOUND).","title":"gen-float"},{"location":"fiveam/#gen-integer","text":"Function: (gen-integer &key (max (1+ most-positive-fixnum)) (min (1- most-negative-fixnum))) Returns a generator which produces random integers greater than or equal to MIN and less than or equal to MAX.","title":"gen-integer"},{"location":"fiveam/#gen-list","text":"Function: (gen-list &key (length (gen-integer :min 0 :max 10)) (elements (gen-integer :min -10 :max 10))) Returns a generator which produces random lists. LENGTH must be an integer generator and ELEMENTS must be a generator which produces objects.","title":"gen-list"},{"location":"fiveam/#gen-one-element","text":"Function: (gen-one-element &rest elements)","title":"gen-one-element"},{"location":"fiveam/#gen-string","text":"Function: (gen-string &key (length (gen-integer :min 0 :max 80)) (elements (gen-character)) (element-type 'character)) Returns a generator which produces random strings. LENGTH must be a generator which produces integers, ELEMENTS must be a generator which produces characters of type ELEMENT-TYPE.","title":"gen-string"},{"location":"fiveam/#gen-tree","text":"Function: (gen-tree &key (size 20) (elements (gen-integer :min -10 :max 10))) Returns a generator which produces random trees. SIZE controls the approximate size of the tree, but don't try anything above 30, you have been warned. ELEMENTS must be a generator which will produce the elements.","title":"gen-tree"},{"location":"fiveam/#get-fixture","text":"Function: (get-fixture key &optional default)","title":"get-fixture"},{"location":"fiveam/#get-test","text":"Function: (get-test key &optional default)","title":"get-test"},{"location":"fiveam/#in-suite","text":"Macro: (in-suite suite-name) Set the suite special variable so that all tests defined after the execution of this form are, unless specified otherwise, in the test-suite named SUITE-NAME. See also: DEF-SUITE SUITE","title":"in-suite"},{"location":"fiveam/#in-suite_1","text":"Macro: (in-suite* suite-name &key in) Just like in-suite, but silently creates missing suites.","title":"in-suite*"},{"location":"fiveam/#is","text":"Macro: (is test &rest reason-args) The DWIM checking operator. If TEST returns a true value a test-passed result is generated, otherwise a test-failure result is generated. The reason, unless REASON-ARGS is provided, is generated based on the form of TEST: (predicate expected actual) - Means that we want to check whether, according to PREDICATE, the ACTUAL value is in fact what we EXPECTED. (predicate value) - Means that we want to ensure that VALUE satisfies PREDICATE. Wrapping the TEST form in a NOT simply produces a negated reason string.","title":"is"},{"location":"fiveam/#is-every","text":"Macro: (is-every predicate &body clauses) The input is either a list of lists, or a list of pairs. Generates (is (,predicate ,expr ,value)) for each pair of elements or (is (,predicate ,expr ,value) ,@reason) for each list.","title":"is-every"},{"location":"fiveam/#is-false","text":"Macro: (is-false condition &rest reason-args) Generates a pass if CONDITION returns false, generates a failure otherwise. Like IS-TRUE, and unlike IS, IS-FALSE does not inspect CONDITION to determine what reason to give it case of test failure","title":"is-false"},{"location":"fiveam/#is-true","text":"Macro: (is-true condition &rest reason-args) Like IS this check generates a pass if CONDITION returns true and a failure if CONDITION returns false. Unlike IS this check does not inspect CONDITION to determine how to report the failure.","title":"is-true"},{"location":"fiveam/#make-fixture","text":"","title":"make-fixture"},{"location":"fiveam/#make-suite","text":"Function: (make-suite name &key description ((in parent-suite))) Create a new test suite object. Overrides any existing suite named NAME.","title":"make-suite"},{"location":"fiveam/#make-test","text":"","title":"make-test"},{"location":"fiveam/#pass","text":"Macro: (pass &rest message-args) Simply generate a PASS.","title":"pass"},{"location":"fiveam/#rem-fixture","text":"Function: (rem-fixture key)","title":"rem-fixture"},{"location":"fiveam/#rem-test","text":"Function: (rem-test key)","title":"rem-test"},{"location":"fiveam/#results-status","text":"Function: (results-status result-list) Given a list of test results (generated while running a test) return true if no results are of type TEST-FAILURE. Returns second and third values, which are the set of failed tests and skipped tests respectively.","title":"results-status"},{"location":"fiveam/#run","text":"Function: (run test-spec &key (print-names *print-names*)) Run the test specified by TEST-SPEC. TEST-SPEC can be either a symbol naming a test or test suite, or a testable-object object. This function changes the operations performed by the !, !! and !!! functions.","title":"run"},{"location":"fiveam/#run_1","text":"Function: (run! &optional (test-spec *suite*) &key (print-names *print-names*)) Equivalent to (explain! (run TEST-SPEC)).","title":"run!"},{"location":"fiveam/#run-all-tests","text":"Function: (run-all-tests &key (summary :end)) Runs all defined test suites, T if all tests passed and NIL otherwise. SUMMARY can be :END to print a summary at the end, :SUITE to print it after each suite or NIL to skip explanations.","title":"run-all-tests"},{"location":"fiveam/#signals","text":"Macro: (signals condition-spec &body body) Generates a pass if BODY signals a condition of type CONDITION. BODY is evaluated in a block named NIL, CONDITION is not evaluated.","title":"signals"},{"location":"fiveam/#skip","text":"Macro: (skip &rest reason) Generates a TEST-SKIPPED result.","title":"skip"},{"location":"fiveam/#test","text":"Macro: (test name &body body) Create a test named NAME. If NAME is a list it must be of the form: (name &key depends-on suite fixture compile-at profile) NAME is the symbol which names the test. DEPENDS-ON is a list of the form: (AND . test-names) - This test is run only if all of the tests in TEST-NAMES have passed, otherwise a single test-skipped result is generated. (OR . test-names) - If any of TEST-NAMES has passed this test is run, otherwise a test-skipped result is generated. (NOT test-name) - This is test is run only if TEST-NAME failed. AND, OR and NOT can be combined to produce complex dependencies. If DEPENDS-ON is a symbol it is interpreted as `(AND ,depends-on), this is accomadate the common case of one test depending on another. FIXTURE specifies a fixture to wrap the body in. If PROFILE is T profiling information will be collected as well.","title":"test"},{"location":"fiveam/#test-names","text":"Function: (test-names)","title":"test-names"},{"location":"fiveam/#with-fixture","text":"Macro: (with-fixture fixture-name (&rest args) &body body) Insert BODY into the fixture named FIXTURE-NAME. See Also: DEF-FIXTURE .","title":"with-fixture"},{"location":"hunchentoot/","text":"hunchentoot - Web Server Version: 1.2.38 Repository: edicl/hunchentoot - Github This page was possible due to the excellent official documentation as well as the page on Web Development on The Common Lisp Cookbook . In case of any inaccuracies, ambiguities or suggestions, please create an issue here . *hunchentoot was formerly known as TBNL. INTRODUCTION Hunchentoot is a web server written in Common Lisp and a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. Hunchentoot provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client. It does not include functionality to programmatically generate HTML output. For this task you can use any library you like, e.g. CL-WHO or HTML-TEMPLATE . Hunchentoot should work with most popular lisp implementations including SBCL, CCL, LispWorks and all Lisps which are supported by the compatibility layers usocket and Bordeaux Threads . Hunchentoot talks with its front-end or with the client over TCP/IP sockets and optionally uses multiprocessing to handle several requests at the same time. Therefore, it cannot be implemented completely in portable Common Lisp . Hunchentoot comes with a BSD-style license so you can basically do with it whatever you want. Official documentation for Hunchentoot can be found in the docs directory or at the project website . GETTING STARTED Installation using quicklisp See the section on Installation under Defacto Libraries on Home Page . Serving local files To start the server, simply (defvar *acceptor*) (setq *acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4242)) (hunchentoot:start *acceptor*) You should see something - but not very interesting - at \" http://127.0.0.1:4242/ \" in your browser. By default, Hunchentoot serves files from the www/ directory from its source tree. In the distribution, that directory contains a HTML version of the documentation as well as the error templates. If installed via quicklisp, see (ql:where-is-system \"hunchentoot\") . See acceptor slots for a list of various slots (with or without initargs ). And configuration variables for a list of various configuration options for hunchentoot, such as whether to *catch-errors-p or *log-lisp-errors-p* and more. Acceptors provided with hunchentoot: acceptor easy-acceptor ssl-acceptor easy-ssl-acceptor Going dynamic create-X-dispatcher To bind an existing function to a route, we create-prefix-dispatcher that we push onto the *dispatch-table* (just a global list of dispatch functions): (defun hello () (format nil \"Hello, it works!\")) (push (hunchentoot:create-prefix-dispatcher \"/hello.html\" 'hello) hunchentoot:*dispatch-table*) To create a route with a regexp, we use create-regex-dispatcher , where the url-as-regexp can be a string, an s-expression or a cl-ppcre scanner. In all, there exist create-folder-dispatcher-and-handler create-prefix-dispatcher create-regex-dispatcher create-static-file-dispatcher-and-handler define-easy-handler define-easy-handler allows to create a function and to bind it to an uri at once. For instance: (hunchentoot:define-easy-handler (say-yo :uri \"/yo\") (name) (setf (hunchentoot:content-type*) \"text/plain\") (format nil \"Hey~@[ ~A~]!\" name)) Visit http://localhost:4242/yo or add parameters to the url: http://localhost:4242/yo?name=Alice . Note that we didn't explicitly ask Hunchentoot to add this route to our first acceptor of the port 4242. This handler also works for another acceptor, say another one opened at port 4444: http://localhost:4444/yo?name=Bob In fact, define-easy-handler accepts an acceptor-names parameter that defines which acceptors it works for. Accessing GET and POST parameters Query parameters are accessible with (hunchentoot:parameter \"my-param\") while in the context of a request . It acts on the default *request* object which is passed to all handlers. There also are get-paramater and post-parameter . See also the Variables in the context of a request . More documentation, tutorials and add-ons Adam Petersen has written a book called \"Lisp for the Web\" which explains how Hunchentoot and some other libraries can be used to build web sites. See also the Web Development - Cookbook . Implementing a blog in Common Lisp - Vetle Roeim Extensions and related softwares: Clack is a web server abstraction layer, defaulting to Hunchentoot. hunchentoot-cgi (by Cyrus Harmo) provides CGI handlers for Hunchentoot. CL-WEBDAV is a WebDAV server based on Hunchentoot. RESTAS is a web framework based on Hunchentoot. Caveman , Radiance , Snooze or again Weblocks are frameworks compatible with it. API REFERENCE 1. ACCEPTOR Class To create a Hunchentoot webserver, you make an instance of this class and use the generic function START to start it (and STOP to stop it). Use the :PORT initarg if you don't want to listen on the default http port 80. There are other initargs most of which you probably won't need very often. They are explained in detail in the docstrings of the slot definitions for this class. Unless you are in a Lisp without MP capabilities, you can have several active instances of ACCEPTOR (listening on different ports) at the same time. Direct superclasses: STANDARD-OBJECT Direct subclasses: EASY-ACCEPTOR , SSL-ACCEPTOR RELEVANT METHODS accept-connections Function: (accept-connections acceptor) In a loop, accepts a connection and hands it over to the acceptor's taskmaster for processing using HANDLE-INCOMING-CONNECTION. On LispWorks, this function returns immediately, on other Lisps it retusn only once the acceptor has been stopped. acceptor-log-access Function: (acceptor-log-access acceptor &key return-code) Function to call to log access to the acceptor. The RETURN-CODE, CONTENT and CONTENT-LENGTH keyword arguments contain additional information about the request to log. In addition, it can use the standard request accessor functions that are available to handler functions to find out more information about the request. acceptor-log-message Function: (acceptor-log-message acceptor log-level format-string &rest format-arguments) Function to call to log messages by the ACCEPTOR. It must accept a severity level for the message, which will be one of :ERROR, :INFO, or :WARNING, a format string and an arbitary number of formatting arguments. acceptor-status-message Function: (acceptor-status-message acceptor http-status-code &key &allow-other-keys) This function is called after the request's handler has been invoked to convert the HTTP-STATUS-CODE to a HTML message to be displayed to the user. If this function returns a string, that string is sent to the client instead of the content produced by the handler, if any. If an ERROR-TEMPLATE-DIRECTORY is set in the current acceptor and the directory contains a file corresponding to HTTP-STATUS-CODE named \\<code>.html, that file is sent to the client after variable substitution. Variables are referenced by ${ }. Additional keyword arguments may be provided which are made available to the templating logic as substitution variables. These variables can be interpolated into error message templates in, which contains the current URL relative to the server and without GET parameters. In addition to the variables corresponding to keyword arguments, the script-name, lisp-implementation-type, lisp-implementation-version and hunchentoot-version variables are available. detach-socket Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function. initialize-connection-stream Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use. process-connection Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. Handlers may call to the DETACH-SOCKET generic function to indicate that no further requests should be handled on the connection by Hunchentoot, and that responsibility for the socket is assumed by third-party software. This can be used by specialized handlers that wish to hand over connection polling or processing to functions outside of Hunchentoot, i.e. for connection multiplexing or implementing specialized client protocols. Hunchentoot will finish processing the request and the PROCESS-CONNECTION function will return without closing the connection. At that point, the acceptor may interact with the socket in whatever fashion required. reset-connection-stream Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream. start Function: (start acceptor) Starts the ACCEPTOR so that it begins accepting connections. Returns the acceptor. start-listening Function: (start-listening acceptor) Sets up a listen socket for the given ACCEPTOR and enables it to listen to incoming connections. This function is called from the thread that starts the acceptor initially and may return errors resulting from the listening operation (like 'address in use' or similar). stop Function: (stop acceptor &key soft) Stops the ACCEPTOR so that it no longer accepts requests. If SOFT is true, and there are any requests in progress, wait until all requests are fully processed, but meanwhile do not accept new requests. Note that SOFT must not be set when calling STOP from within a request handler, as that will deadlock. started-p Function: (started-p acceptor) Tells if ACCEPTOR has been started. The default implementation simply queries ACCEPTOR for its listening status, so if T is returned to the calling thread, then some thread has called START or some thread's call to STOP hasn't finished. If NIL is returned either some thread has called STOP, or some thread's call to START hasn't finished or START was never called at all for ACCEPTOR. SLOTS acceptor-shutdown-p Initform: T A flag that makes the acceptor shutdown itself when set to something other than NIL. access-log-destination Initargs: :access-log-destination Readers: hunchentoot:acceptor-access-log-destination Writers: (setf hunchentoot:acceptor-access-log-destination) Destination of the access log which contains one log entry per request handled in a format similar to Apache's access.log. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging. address Initargs: :address Readers: hunchentoot:acceptor-address The address the acceptor is listening on. If address is a string denoting an IP address, then the server only receives connections for that address. This must be one of the addresses associated with the machine and allowed values are host names such as \"www.zappa.com\" and address strings such as \"72.3.247.29\". If address is NIL, then the server will receive connections to all IP addresses on the machine. This is the default. document-root Initargs: :document-root Readers: hunchentoot:acceptor-document-root Writers: (setf hunchentoot:acceptor-document-root) Directory pathname that points to files that are served by the acceptor if no more specific acceptor-dispatch-request method handles the request. error-template-directory Initargs: :error-template-directory Readers: hunchentoot:acceptor-error-template-directory Writers: (setf hunchentoot:acceptor-error-template-directory) Directory pathname that contains error message template files for server-generated error messages. Files must be named .html with representing the HTTP return code that the file applies to, i.e. 404.html would be used as the content for a HTTP 404 Not found response. listen-backlog Initargs: :listen-backlog Readers: hunchentoot:acceptor-listen-backlog Number of pending connections allowed in the listen socket before the kernel rejects further incoming connections. listen-socket The socket listening for incoming connections. message-log-destination Initargs: :message-log-destination Readers: hunchentoot:acceptor-message-log-destination Writers: (setf hunchentoot:acceptor-message-log-destination) Destination of the server error log which is used to log informational, warning and error messages in a free-text format intended for human inspection. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging. input-chunking-p Initargs: :input-chunking-p Readers: hunchentoot:acceptor-input-chunking-p Writers: (setf hunchentoot:acceptor-input-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for input, i.e. when accepting request bodies from the client. The default is T and there's usually no reason to change this to NIL. name Initargs: :name Readers: hunchentoot:acceptor-name Writers: (setf hunchentoot:acceptor-name) The optional name of the acceptor, a symbol. This name can be utilized when defining \"easy handlers\" - see DEFINE-EASY-HANDLER. The default name is an uninterned symbol as returned by GENSYM. output-chunking-p Initargs: :output-chunking-p Readers: hunchentoot:acceptor-output-chunking-p Writers: (setf hunchentoot:acceptor-output-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for output, i.e. when sending data to the client. The default is T and there's usually no reason to change this to NIL. persistent-connections-p Initargs: :persistent-connections-p Readers: hunchentoot:acceptor-persistent-connections-p Writers: (setf hunchentoot:acceptor-persistent-connections-p) A generalized boolean denoting whether the acceptor supports persistent connections, which is the default for threaded acceptors. If this property is NIL, Hunchentoot closes each incoming connection after having processed one request. This is the default for non-threaded acceptors. port Initargs: :port Readers: hunchentoot:acceptor-port The port the acceptor is listening on. The default is 80. Note that depending on your operating system you might need special privileges to listen on port 80. When 0, the port will be chosen by the system the first time the acceptor is started. read-timeout Initargs: :read-timeout Readers: hunchentoot:acceptor-read-timeout The read timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout. reply-class Initargs: :reply-class Readers: hunchentoot:acceptor-reply-class Writers: (setf hunchentoot:acceptor-reply-class) Determines which class of reply objects is created when a request is served in and should be (a symbol naming) a class which inherits from REPLY. The default is the symbol REPLY. request-class Initargs: :request-class Readers: hunchentoot:acceptor-request-class Writers: (setf hunchentoot:acceptor-request-class) Determines which class of request objects is created when a request comes in and should be (a symbol naming) a class which inherits from REQUEST. The default is the symbol REQUEST. requests-in-progress Initform: 0 The number of requests currently in progress. shutdown-lock The lock protecting the shutdown-queue condition variable and the requests-in-progress counter. shutdown-queue A condition variable used with soft shutdown, signaled when all requests have been processed. taskmaster Initargs: :taskmaster The taskmaster (i.e. an instance of a subclass of TASKMASTER) that is responsible for scheduling the work for this acceptor. The default depends on the MP capabilities of the underlying Lisp. write-timeout Initargs: :write-timeout Readers: hunchentoot:acceptor-write-timeout The write timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout. 2. EASY-ACCEPTOR Class This is the acceptor of the \"easy\" Hunchentoot framework. Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR 3. DEFINE-EASY-HANDLER Macro: (define-easy-handler description lambda-list &body body) Defines a handler with the body BODY and optionally registers it with a URI so that it will be found by DISPATCH-EASY-HANDLERS . DESCRIPTION is either a symbol NAME or a list matching the destructuring lambda list (name &key uri acceptor-names default-parameter-type default-request-type) LAMBDA-LIST is a list the elements of which are either a symbol VAR or a list matching the destructuring lambda list (var &key real-name parameter-type init-form request-type) The resulting handler will be a Lisp function with the name NAME and keyword parameters named by the VAR symbols. Each VAR will be bound to the value of the GET or POST parameter called REAL-NAME (a string) before BODY is executed. If REAL-NAME is not provided, it will be computed by downcasing the symbol name of VAR. If URI (which is evaluated) is provided, then it must be a string or a function designator for a function of one argument. In this case, the handler will be returned by DISPATCH-EASY-HANDLERS, if URI is a string and the script name of a request is URI, or if URI designates a function and applying this function to the current request object returns a true value. ACCEPTOR-NAMES (which is evaluated) can be a list of symbols which means that the handler will be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). ACCEPTOR-NAMES can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor. Whether the GET or POST parameter (or both) will be taken into consideration, depends on REQUEST-TYPE which can be :GET, :POST, :BOTH, or NIL. In the last case, the value of DEFAULT-REQUEST-TYPE (the default of which is :BOTH) will be used. The value of VAR will usually be a string (unless it resulted from a file upload in which case it won't be converted at all), but if PARAMETER-TYPE (which is evaluated) is provided, the string will be converted to another Lisp type by the following rules: If the corresponding GET or POST parameter wasn't provided by the client, VAR's value will be NIL. If PARAMETER-TYPE is 'STRING, VAR's value remains as is. If PARAMETER-TYPE is 'INTEGER and the parameter string consists solely of decimal digits, VAR's value will be the corresponding integer, otherwise NIL. If PARAMETER-TYPE is 'KEYWORD, VAR's value will be the keyword obtained by interning the upcased parameter string into the keyword package. If PARAMETER-TYPE is 'CHARACTER and the parameter string is of length one, VAR's value will be the single character of this string, otherwise NIL. If PARAMETER-TYPE is 'BOOLEAN, VAR's value will always be T (unless it is NIL by the first rule above, of course). If PARAMETER-TYPE is any other atom, it is supposed to be a function designator for a unary function which will be called to convert the string to something else. Those were the rules for simple' types, but PARAMETER-TYPE can also be a list starting with one of the symbols LIST, ARRAY, or HASH-TABLE. The second value of the list must always be a simple parameter type as in the last paragraph - we'll call it the inner type' below. In the case of 'LIST, all GET/POST parameters called REAL-NAME will be collected, converted to the inner type, and assembled into a list which will be the value of VAR. In the case of 'ARRAY, all GET/POST parameters which have a name like the result of (format nil \"~A[~A]\" real-name n) where N is a non-negative integer, will be assembled into an array where the Nth element will be set accordingly, after conversion to the inner type. The array, which will become the value of VAR, will be big enough to hold all matching parameters, but not bigger. Array elements not set as described above will be NIL. Note that VAR will always be bound to an array, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. The full form of a 'HASH-TABLE parameter type is (hash-table inner-type key-type test-function), but KEY-TYPE and TEST-FUNCTION can be left out in which case they default to 'STRING and 'EQUAL, respectively. For this parameter type, all GET/POST parameters which have a name like the result of (format nil \"~A{~A}\" real-name key) (where KEY is a string that doesn't contain curly brackets) will become the values (after conversion to INNER-TYPE) of a hash table with test function TEST-FUNCTION where KEY (after conversion to KEY-TYPE) will be the corresponding key. Note that VAR will always be bound to a hash table, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. To make matters even more complicated, the three compound parameter types also have an abbreviated form - just one of the symbols LIST, ARRAY, or HASH-TABLE. In this case, the inner type will default to 'STRING. If PARAMETER-TYPE is not provided or NIL, DEFAULT-PARAMETER-TYPE (the default of which is 'STRING) will be used instead. If the result of the computations above would be that VAR would be bound to NIL, then INIT-FORM (if provided) will be evaluated instead, and VAR will be bound to the result of this evaluation. Handlers built with this macro are constructed in such a way that the resulting Lisp function is useful even outside of Hunchentoot. Specifically, all the parameter computations above will only happen if *REQUEST* is bound, i.e. if we're within a Hunchentoot request. Otherwise, VAR will always be bound to the result of evaluating INIT-FORM unless a corresponding keyword argument is provided. 4. SSL-ACCEPTOR Class Create and START an instance of this class (instead of ACCEPTOR) if you want an https server. There are two required initargs, :SSL-CERTIFICATE-FILE and :SSL-PRIVATEKEY-FILE, for pathname designators denoting the certificate file and the key file in PEM format. On LispWorks, you can have both in one file in which case the second initarg is optional. You can also use the :SSL-PRIVATEKEY-PASSWORD initarg to provide a password (as a string) for the key file (or NIL, the default, for no password). The default port for SSL-ACCEPTOR instances is 443 instead of 80 Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR DIRECT SLOTS Also see slots for the superclass. ssl-certificate-file Initargs: :ssl-certificate-file Readers: hunchentoot:acceptor-ssl-certificate-file A pathname designator for a certificate file in PEM format. ssl-privatekey-file Initargs: :ssl-privatekey-file Readers: hunchentoot:acceptor-ssl-privatekey-file A pathname designator for a private key file in PEM format, or (only on LispWorks) NIL if the certificate file contains the private key. ssl-privatekey-password Initargs: :ssl-privatekey-password Readers: hunchentoot:acceptor-ssl-privatekey-password The password for the private key file or NIL for no password. 5. EASY-SSL-ACCEPTOR Class This is an acceptor that mixes the \"easy\" Hunchentoot with SSL connections. Direct superclasses: EASY-ACCEPTOR , SSL-ACCEPTOR No subclasses. 6. REPLY Class Objects of this class hold all the information about an outgoing reply. They are created automatically by Hunchentoot and can be accessed and modified by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REPLY in order to implement your own behaviour. See the REPLY-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses. RELEVANT METHODS headers-out* Function: (headers-out* &optional (reply *reply*)) Returns an alist of the outgoing headers associated with the REPLY object REPLY. content-length* Function: (content-length* &optional (reply *reply*)) The outgoing 'Content-Length' http header of REPLY. content-type* Function: (content-type* &optional (reply *reply*)) The outgoing 'Content-Type' http header of REPLY. cookie-out Function: (cookie-out name &optional (reply *reply*)) Returns the current value of the outgoing cookie named NAME. Search is case-sensitive. cookies-out* Function: (cookies-out* &optional (reply *reply*)) Returns an alist of the outgoing cookies associated with the REPLY object REPLY. return-code* Function: (return-code* &optional (reply *reply*)) The http return code of REPLY. The return codes Hunchentoot can handle are defined in specials.lisp. send-headers Function: (send-headers) Sends the initial status line and all headers as determined by the REPLY object *REPLY*. Returns a binary stream to which the body of the reply can be written. Once this function has been called, further changes to *REPLY* don't have any effect. Also, automatic handling of errors (i.e. sending the corresponding status code to the browser, etc.) is turned off for this request. If your handlers return the full body as a string or as an array of octets you should NOT call this function. This function does not return control to the caller during HEAD request processing. reply-external-format* Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output. SLOTS content-type Readers: hunchentoot:content-type The outgoing 'Content-Type' http header which defaults to the value of *DEFAULT-CONTENT-TYPE*. content-length Readers: hunchentoot:content-length The outgoing 'Content-Length' http header which defaults NIL. If this is NIL, Hunchentoot will compute the content length. headers-out Readers: hunchentoot:headers-out An alist of the outgoing http headers not including the 'Set-Cookie', 'Content-Length', and 'Content-Type' headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot. return-code Initform: hunchentoot:+http-ok+ Readers: hunchentoot:return-code Writers: (setf hunchentoot:return-code) The http return code of this reply. The return codes Hunchentoot can handle are defined in specials.lisp. external-format Initform: hunchentoot:*hunchentoot-default-external-format* Readers: hunchentoot:reply-external-format Writers: (setf hunchentoot:reply-external-format) The external format of the reply - used for character output. cookies-out Readers: hunchentoot:cookies-out Writers: (setf hunchentoot:cookies-out) The outgoing cookies. This slot's value should only be modified by the functions defined in cookies.lisp. 7. REQUEST Class Objects of this class hold all the information about an incoming request. They are created automatically by acceptors and can be accessed by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REQUEST in order to implement your own behaviour. See the REQUEST-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses. RELEVANT METHODS real-remote-addr Function: (real-remote-addr &optional (request *request*)) Returns the 'X-Forwarded-For' incoming http header as the second value in the form of a list of IP addresses and the first element of this list as the first value if this header exists. Otherwise returns the value of REMOTE-ADDR as the only value. parameter Function: (parameter name &optional (request *request*)) Returns the GET or the POST parameter with name NAME (a string) - or NIL if there is none. If both a GET and a POST parameter with the same name exist the GET parameter is returned. Search is case-sensitive. get-parameter Function: (get-parameter name &optional (request *request*)) Returns the GET parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive. get-parameters* Function: (get-parameters* &optional (request *request*)) Returns an alist of the GET parameters associated with the REQUEST object REQUEST. post-parameter Function: (post-parameter name &optional (request *request*)) Returns the POST parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive. post-parameters* Function: (post-parameters* &optional (request *request*)) Returns an alist of the POST parameters associated with the REQUEST object REQUEST. cookie-in Function: (cookie-in name &optional (request *request*)) Returns the cookie with the name NAME (a string) as sent by the browser - or NIL if there is none. cookies-in* Function: (cookies-in* &optional (request *request*)) Returns an alist of all cookies associated with the REQUEST object REQUEST. host Function: (host &optional (request *request*)) Returns the 'Host' incoming http header value. query-string* Function: (query-string* &optional (request *request*)) Returns the query string of the REQUEST object REQUEST. That's the part behind the question mark (i.e. the GET parameters). referer Function: (referer &optional (request *request*)) Returns the 'Referer' (sic!) http header. request-method* Function: (request-method* &optional (request *request*)) Returns the request method as a Lisp keyword. request-uri* Function: (request-uri* &optional (request *request*)) Returns the request URI. server-protocol* Function: (server-protocol* &optional (request *request*)) Returns the request protocol as a Lisp keyword. user-agent Function: (user-agent &optional (request *request*)) Returns the 'User-Agent' http header. header-in* Function: (header-in* name &optional (request *request*)) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string. headers-in* Function: (headers-in* &optional (request *request*)) Returns an alist of the incoming headers associated with the REQUEST object REQUEST. remote-addr* Function: (remote-addr* &optional (request *request*)) Returns the address the current request originated from. remote-port* Function: (remote-port* &optional (request *request*)) Returns the port the current request originated from. local-addr* Function: (local-addr* &optional (request *request*)) Returns the address the current request connected to. local-port* Function: (local-port* &optional (request *request*)) Returns the port the current request connected to. script-name* Function: (script-name* &optional (request *request*)) Returns the file name of the REQUEST object REQUEST. That's the requested URI without the query string (i.e the GET parameters). aux-request-value Function: (aux-request-value symbol &optional (request *request*)) Returns the value associated with SYMBOL from the request object REQUEST (the default is the current request) if it exists. The second return value is true if such a value was found. Sets the value associated with SYMBOL from the request object REQUEST (default is *REQUEST*). If there is already a value associated with SYMBOL it will be replaced. delete-aux-request-value Function: (delete-aux-request-value symbol &optional (request *request*)) Removes the value associated with SYMBOL from the request object REQUEST. authorization Function: (authorization &optional (request *request*)) Returns as two values the user and password (if any) as encoded in the 'AUTHORIZATION' header. Returns NIL if there is no such header. raw-post-data Function: (raw-post-data &key (request *request*) external-format force-text force-binary want-stream) Returns the content sent by the client if there was any (unless the content type was \"multipart/form-data\"). By default, the result is a string if the type of the Content-Type' media type is \"text\", and a vector of octets otherwise. In the case of a string, the external format to be used to decode the content will be determined from the charset' parameter sent by the client (or otherwise *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used). You can also provide an external format explicitly (through EXTERNAL-FORMAT) in which case the result will unconditionally be a string. Likewise, you can provide a true value for FORCE-TEXT which will force Hunchentoot to act as if the type of the media type had been \"text\". Or you can provide a true value for FORCE-BINARY which means that you want a vector of octets at any rate. If, however, you provide a true value for WANT-STREAM, the other parameters are ignored and you'll get the content (flexi) stream to read from it yourself. It is then your responsibility to read the correct amount of data, because otherwise you won't be able to return a response to the client. If the content type of the request was multipart/form-data' or application/x-www-form-urlencoded', the content has been read by Hunchentoot already and you can't read from the stream anymore. You can call RAW-POST-DATA more than once per request, but you can't mix calls which have different values for WANT-STREAM. Note that this function is slightly misnamed because a client can send content even if the request method is not POST. recompute-request-parameters Function: (recompute-request-parameters &key (request *request*) (external-format *hunchentoot-default-external-format*)) Recomputes the GET and POST parameters for the REQUEST object REQUEST. This only makes sense if you're switching external formats during the request. process-request Function: (process-request request) This function is called by PROCESS-CONNECTION after the incoming headers have been read. It calls HANDLE-REQUEST to select and call a handler and sends the output of this handler to the client using START-OUTPUT. Note that PROCESS-CONNECTION is called once per connection and loops in case of a persistent connection while PROCESS-REQUEST is called anew for each request. Essentially, you can view process-request as a thin wrapper around HANDLE-REQUEST. The return value of this function is ignored. handle-request Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers. handle-request Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers. acceptor-dispatch-request Function: (acceptor-dispatch-request acceptor request) This function is called to actually dispatch the request once the standard logging and error handling has been set up. ACCEPTOR subclasses implement methods for this function in order to perform their own request routing. If a method does not want to handle the request, it is supposed to invoke CALL-NEXT-METHOD so that the next ACCEPTOR in the inheritance chain gets a chance to handle the request. SLOTS acceptor Initargs: :acceptor Readers: hunchentoot:request-acceptor The acceptor which created this request object. headers-in Initargs: :headers-in Readers: hunchentoot:headers-in An alist of the incoming headers. method Initargs: :method Readers: hunchentoot:request-method The request method as a keyword. uri Initargs: :uri Readers: hunchentoot:request-uri The request URI as a string. server-protocol Initargs: :server-protocol Readers: hunchentoot:server-protocol The HTTP protocol as a keyword. local-addr Initargs: :local-addr Readers: hunchentoot:local-addr The IP address of the local system that the client connected to. local-port Initargs: :local-port Readers: hunchentoot:local-port The TCP port number of the local system that the client connected to. remote-addr Initargs: :remote-addr Readers: hunchentoot:remote-addr The IP address of the client that initiated this request. remote-port Initargs: :remote-port Readers: hunchentoot:remote-port The TCP port number of the client socket from which this request originated. content-stream Initargs: :content-stream A stream from which the request body can be read if there is one. cookies-in Readers: hunchentoot:cookies-in An alist of the cookies sent by the client. get-parameters Readers: hunchentoot:get-parameters An alist of the GET parameters sent by the client. post-parameters Readers: hunchentoot:post-parameters An alist of the POST parameters sent by the client. script-name Readers: hunchentoot:script-name The URI requested by the client without the query string. query-string Readers: hunchentoot:query-string The query string of this request. session Readers: hunchentoot:session Writers: (setf hunchentoot:session) The session object associated with this request. aux-data Used to keep a user-modifiable alist with arbitrary data during the request. raw-post-data The raw string sent as the body of a POST request, populated only if not a multipart/form-data request. 8. SESSION Class SESSION objects are automatically maintained by Hunchentoot. They should not be created explicitly with MAKE-INSTANCE but implicitly with START-SESSION and they should be treated as opaque objects. You can ignore Hunchentoot's SESSION objects altogether and implement your own sessions if you provide corresponding methods for SESSION-COOKIE-VALUE and SESSION-VERIFY. Direct superclasses: STANDARD-OBJECT No subclasses. Hunchentoot supports sessions : Once a request handler has called START-SESSION , Hunchentoot uses either cookies or (if the client doesn't send the cookies back) rewrites URLs to keep track of this client, i.e. to provide a kind of 'state' for the stateless http protocol. Hunchentoot makes some reasonable effort to prevent eavesdroppers from hijacking sessions (see below), but this should not be considered really secure. Don't store sensitive data in sessions and rely solely on the session mechanism as a safeguard against malicious users who want to get at this data! For each request there's one SESSION object which is accessible to the handler via the special variable *SESSION* . This object holds all the information available about the session and can be accessed with the functions described in this chapter. Note that the internal structure of SESSION objects should be considered opaque and may change in future releases of Hunchentoot. Sessions are automatically verified for validity and age when the REQUEST object is instantiated, i.e. if *SESSION* is not NIL then this session is valid (as far as Hunchentoot is concerned) and not too old . Old sessions are automatically removed . Hunchentoot also provides a SESSION-REGENERATE-COOKIE-VALUE function that creates a new cookie value. This helps to prevent against session fixation attacks , and should be used when a user logs in according to the application. RELEVANT METHODS start-session Function: (start-session) Returns the current SESSION object. If there is no current session, creates one and updates the corresponding data structures. In this case the function will also send a session cookie to the browser. session-value Function: (session-value symbol &optional (session *session*)) Returns the value associated with SYMBOL from the session object SESSION (the default is the current session) if it exists. Sets the value associated with SYMBOL from the session object SESSION. If there is already a value associated with SYMBOL it will be replaced. Will automatically start a session if none was supplied and there's no session for the current request. delete-session-value Function: (delete-session-value symbol &optional (session *session*)) Removes the value associated with SYMBOL from SESSION if there is one. remove-session Function: (remove-session session) Completely removes the SESSION object SESSION from Hunchentoot's internal session database. SLOTS session-id Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session. session-string The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter. user-agent Initform: (hunchentoot:user-agent hunchentoot:*request*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created. remote-addr Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR. session-start Initform: (GET-UNIVERSAL-TIME) Readers: hunchentoot:session-start The time this session was started. last-click The last time this session was used. session-data Initargs: :session-data Data associated with this session - see SESSION-VALUE. max-time Type: fixnum Initargs: :max-time Initform: hunchentoot:*session-max-time* Readers: hunchentoot:session-max-time Writers: (setf hunchentoot:session-max-time) The time (in seconds) after which this session expires if it's not used. session-id Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session. session-string The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter. user-agent Initform: (HUNCHENTOOT:USER-AGENT HUNCHENTOOT:*REQUEST*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created. remote-addr Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR. session-start Initform: (get-universal-time) Readers: hunchentoot:session-start The time this session was started. 9. MISCELLANEOUS FUNCTIONS bad-request Class Direct superclasses: HUNCHENTOOT-ERROR No subclasses. client-as-string Function: (client-as-string socket) A helper function which returns the client's address and port as a string and tries to act robustly in the presence of network problems. create-folder-dispatcher-and-handler Function: (create-folder-dispatcher-and-handler uri-prefix base-path &optional content-type) Creates and returns a dispatch function which will dispatch to a handler function which emits the file relative to BASE-PATH that is denoted by the URI of the request relative to URI-PREFIX. URI-PREFIX must be a string ending with a slash, BASE-PATH must be a pathname designator for an existing directory. If CONTENT-TYPE is not NIL, it'll be the content type used for all files in the folder. create-prefix-dispatcher Function: (create-prefix-dispatcher prefix handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request starts with the string PREFIX. create-regex-dispatcher Function: (create-regex-dispatcher regex handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request matches the CL-PPCRE regular expression REGEX. create-request-handler-thread Function: (create-request-handler-thread taskmaster socket) Create a new thread in which to process the request. This thread will call PROCESS-CONNECTION to process the request. create-static-file-dispatcher-and-handler Function: (create-static-file-dispatcher-and-handler uri path &optional content-type) Creates and returns a request dispatch function which will dispatch to a handler function which emits the file denoted by the pathname designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of the request matches the string URI. If CONTENT-TYPE is NIL, tries to determine the content type via the file's suffix. decrement-taskmaster-thread-count Function: (decrement-taskmaster-thread-count taskmaster) Atomically decrement the number of taskmaster requests default-document-directory Function: (default-document-directory &optional sub-directory) detach-socket Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function. dispatch-easy-handlers Function: (dispatch-easy-handlers request) This is a dispatcher which returns the appropriate handler defined with DEFINE-EASY-HANDLER, if there is one. escape-for-html Function: (escape-for-html string) Escapes the characters #\\<, #>, #\\', #\\\", and #\\& for HTML output. handle-if-modified-since Function: (handle-if-modified-since time &optional (request *request*)) Handles the 'If-Modified-Since' header of REQUEST. The date string is compared to the one generated from the supplied universal time TIME. handle-static-file Function: (handle-static-file pathname &optional content-type) A function which acts like a Hunchentoot handler for the file denoted by PATHNAME. Sends a content type header corresponding to CONTENT-TYPE or (if that is NIL) tries to determine the content type via the file's suffix. http-token-p Function: (http-token-p token) This function tests whether OBJECT is a non-empty string which is a TOKEN according to RFC 2068 (i.e. whether it may be used for, say, cookie names). hunchentoot-error Function: (hunchentoot-error format-control &rest format-arguments) Signals an error of type HUNCHENTOOT-SIMPLE-ERROR with the provided format control and arguments. Superclass for all errors related to Hunchentoot. increment-taskmaster-thread-count Function: (increment-taskmaster-thread-count taskmaster) Atomically increment the number of taskmaster requests. initialize-connection-stream Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use. log-message* Function: (log-message* log-level format-string &rest format-arguments) Convenience function which calls the message logger of the current acceptor (if there is one) with the same arguments it accepts. This is the function which Hunchentoot itself uses to log errors it catches during request processing. maybe-invoke-debugger Function: (maybe-invoke-debugger condition) This generic function is called whenever a condition CONDITION is signaled in Hunchentoot. You might want to specialize it on specific condition classes for debugging purposes. mime-type Function: (mime-type pathspec) Given a pathname designator PATHSPEC returns the MIME type (as a string) corresponding to the suffix of the file denoted by PATHSPEC (or NIL). next-session-id Function: (next-session-id acceptor) Returns the next sequential session ID, an integer, which should be unique per session. The default method uses a simple global counter and isn't guarded by a lock. For a high-performance production environment you might consider using a more robust implementation. no-cache Function: (no-cache) Adds appropriate headers to completely prevent caching on most browsers. parameter-error Function: (parameter-error format-control &rest format-arguments) Signals an error of type PARAMETER-ERROR with the provided format control and arguments. Signalled if a function was called with incosistent or illegal parameters. process-connection Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. reason-phrase Function: (reason-phrase return-code) Returns a reason phrase for the HTTP return code RETURN-CODE (which should be an integer) or NIL for return codes Hunchentoot doesn't know. redirect Function: (redirect target &key (host (host *request*) host-provided-p) port (protocol (if (ssl-p) :https :http)) (add-session-id (not (or host-provided-p (starts-with-scheme-p target) (cookie-in (session-cookie-name *acceptor*))))) (code +http-moved-temporarily+)) Redirects the browser to TARGET which should be a string. If TARGET is a full URL starting with a scheme, HOST, PORT and PROTOCOL are ignored. Otherwise, TARGET should denote the path part of a URL, PROTOCOL must be one of the keywords :HTTP or :HTTPS, and the URL to redirect to will be constructed from HOST, PORT, PROTOCOL, and TARGET. Adds a session ID if ADD-SESSION-ID is true. If CODE is a 3xx redirection code, it will be sent as status code. regenerate-session-cookie-value Function: (regenerate-session-cookie-value session) Regenerates the cookie value. This should be used when a user logs in according to the application to prevent against session fixation attacks. The cookie value being dependent on ID, USER-AGENT, REMOTE-ADDR, START, and *SESSION-SECRET*, the only value we can change is START to regenerate a new value. Since we're generating a new cookie, it makes sense to have the session being restarted, in time. That said, because of this fact, calling this function twice in the same second will regenerate twice the same value. reply-external-format* Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output. request-pathname Function: (request-pathname &optional (request *request*) drop-prefix) Construct a relative pathname from the request's SCRIPT-NAME. If DROP-PREFIX is given, pathname construction starts at the first path segment after the prefix. require-authorization Function: (require-authorization &optional (realm hunchentoot)) Sends back appropriate headers to require basic HTTP authentication (see RFC 2617) for the realm REALM. reset-connection-stream Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream. reset-session-secret Function: (reset-session-secret) Sets *SESSION-SECRET* to a new random value. All old sessions will cease to be valid. reset-sessions Function: (reset-sessions &optional (acceptor *acceptor*)) Removes ALL stored sessions of ACCEPTOR. rfc-1123-date Function: (rfc-1123-date &optional (time (get-universal-time))) Generates a time string according to RFC 1123. Default is current time. This can be used to send a 'Last-Modified' header - see HANDLE-IF-MODIFIED-SINCE. script-name Function: (script-name object) server-protocol Function: (server-protocol object) session-cookie-name Function: (session-cookie-name acceptor) Returns the name (a string) of the cookie (or the GET parameter) which is used to store a session on the client side. The default is to use the string \"hunchentoot-session\", but you can specialize this function if you want another name. session-cookie-value Function: (session-cookie-value session) Returns a string which can be used to safely restore the session SESSION if as session has already been established. This is used as the value stored in the session cookie or in the corresponding GET parameter and verified by SESSION-VERIFY. A default method is provided and there's no reason to change it unless you want to use your own session objects. session-created Function: (session-created acceptor new-session) This function is called whenever a new session has been created. There's a default method which might trigger a session GC based on the value of *SESSION-GC-FREQUENCY*. The return value is ignored. session-db Function: (session-db acceptor) Returns the current session database which is an alist where each car is a session's ID and the cdr is the corresponding SESSION object itself. The default is to use a global list for all acceptors. session-db-lock Function: (session-db-lock acceptor &key whole-db-p) A function which returns a lock that will be used to prevent concurrent access to sessions. The first argument will be the acceptor that handles the current request, the second argument is true if the whole (current) session database is modified. If it is NIL, only one existing session in the database is modified. This function can return NIL which means that sessions or session databases will be modified without a lock held (for example for single-threaded environments). The default is to always return a global lock (ignoring the ACCEPTOR argument) for Lisps that support threads and NIL otherwise. session-gc Function: (session-gc) Removes sessions from the current session database which are too old - see SESSION-TOO-OLD-P. session-too-old-p Function: (session-too-old-p session) Returns true if the SESSION object SESSION has not been active in the last (SESSION-MAX-TIME SESSION) seconds. session-verify Function: (session-verify request) Tries to get a session identifier from the cookies (or alternatively from the GET parameters) sent by the client (see SESSION-COOKIE-NAME and SESSION-COOKIE-VALUE). This identifier is then checked for validity against the REQUEST object REQUEST. On success the corresponding session object (if not too old) is returned (and updated). Otherwise NIL is returned. A default method is provided and you only need to write your own one if you want to maintain your own sessions. set-cookie Function: (set-cookie name &key (value \"\") expires max-age path domain secure http-only (reply *reply*)) Creates a cookie object from the parameters provided and adds it to the outgoing cookies of the REPLY object REPLY. If a cookie with the name NAME (case-sensitive) already exists, it is replaced. set-cookie* Function: (set-cookie* cookie &optional (reply *reply*)) Adds the COOKIE object COOKIE to the outgoing cookies of the REPLY object REPLY. If a cookie with the same name (case-sensitive) already exists, it is replaced. ssl-p Function: (ssl-p &optional (acceptor *acceptor*)) Whether the current connection to the client is secure. See ACCEPTOR-SSL-P. taskmaster-max-accept-count Function: (taskmaster-max-accept-count taskmaster) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT. taskmaster-max-thread-count Function: (taskmaster-max-thread-count taskmaster) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit. taskmaster-thread-count Function: (taskmaster-thread-count taskmaster) Returns the current number of taskmaster requests. too-many-taskmaster-requests Function: (too-many-taskmaster-requests taskmaster socket) Signal a \"too many requests\" error, just prior to closing the connection. url-decode Function: (url-decode string &optional (external-format *hunchentoot-default-external-format*)) Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. url-encode Function: (url-encode string &optional (external-format *hunchentoot-default-external-format*)) URL-encodes a string using the external format EXTERNAL-FORMAT. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. within-request-p Function: (within-request-p) True if we're in the context of a request, otherwise nil. 10. CONFIGURATION VARIABLES *catch-errors-p* Variable Whether Hunchentoot should catch and log errors (or rather invoke the debugger). *content-types-for-url-rewrite* Variable The content types for which url-rewriting is OK. See *REWRITE-FOR-SESSION-URLS* . *default-connection-timeout* Variable The default connection timeout used when an acceptor is reading from and writing to a socket stream. *default-content-type* Variable The default content-type header which is returned to the client. If this is text content type, the character set used for encoding the response will automatically be added to the content type in a ``charset'' attribute. *dispatch-table* Variable A global list of dispatch functions. *file-upload-hook* Variable If this is not NIL, it should be a unary function which will be called with a pathname for each file which is uploaded to Hunchentoot. The pathname denotes the temporary file to which the uploaded file is written. The hook is called directly before the file is created. *handle-http-errors-p* *header-stream* Variable If this variable is not NIL, it should be bound to a stream to which incoming and outgoing headers will be written for debugging purposes. *http-error-handler* *hunchentoot-default-external-format* Variable The external format used to compute the REQUEST object. *hunchentoot-version* *lisp-errors-log-level* Variable Log level for Lisp errors. Should be one of :ERROR (the default), :WARNING, or :INFO. *lisp-warnings-log-level* Variable Log level for Lisp warnings. Should be one of :ERROR, :WARNING (the default), or :INFO. *log-lisp-backtraces-p* Variable Whether Lisp backtraces should be logged. Only has an effect if [*LOG-LISP-ERRORS-P*](#log-lisp-errors-p] is true as well. *log-lisp-errors-p* Variable Whether Lisp errors in request handlers should be logged. *log-lisp-warnings-p* Variable Whether Lisp warnings in request handlers should be logged. *methods-for-post-parameters* Variable A list of the request method types (as keywords) for which Hunchentoot will try to compute POST-PARAMETERS . *rewrite-for-session-urls* Variable Whether HTML pages should possibly be rewritten for cookie-less session-management. *session-gc-frequency* Variable A session GC (see function SESSION-GC) will happen every *SESSION-GC-FREQUENCY* requests (counting only requests which create a new session) if this variable is not NIL. See SESSION-CREATED . *session-max-time* Variable The default time (in seconds) after which a session times out. *session-secret* Variable A random ASCII string that's used to encode the public session data. This variable is initially unbound and will be set (using RESET-SESSION-SECRET ) the first time a session is created, if necessary. You can prevent this from happening if you set the value yourself before starting acceptors. *show-lisp-backtraces-p* Variable Whether Lisp errors shown in HTML output should contain backtrace information. *show-lisp-errors-p* Variable Whether Lisp errors in request handlers should be shown in HTML output. *tmp-directory* Variable Directory for temporary files created by MAKE-TMP-FILE-NAME. *use-remote-addr-for-sessions* Variable Whether the client's remote IP (as returned by REAL-REMOTE-ADDR ) should be encoded into the session string. If this value is true, a session will cease to be accessible if the client's remote IP changes. This might for example be an issue if the client uses a proxy server which doesn't send correct 'X_FORWARDED_FOR' headers. *use-user-agent-for-sessions* Variable Whether the 'User-Agent' header should be encoded into the session string. If this value is true, a session will cease to be accessible if the client sends a different 'User-Agent' header. 11. VARIABLES IN THE CONTEXT OF A REQUEST *acceptor* Variable The current ACCEPTOR object. *reply* Variable The current REPLY object. *request* Variable The current REQUEST object. *session* Variable The current SESSION (can be NIL). 12. CONSTANTS +http-accepted+ Constant: 202 HTTP return code (202) for 'Accepted'. +http-authorization-required+ Constant: 401 HTTP return code (401) for 'Authorization Required'. +http-bad-gateway+ Constant: 502 HTTP return code (502) for 'Bad Gateway'. +http-bad-request+ Constant: 400 HTTP return code (400) for 'Bad Request'. +http-conflict+ Constant: 409 HTTP return code (409) for 'Conflict'. +http-continue+ Constant: 100 HTTP return code (100) for 'Continue'. +http-created+ Constant: 201 HTTP return code (201) for 'Created'. +http-expectation-failed+ Constant: 417 HTTP return code (417) for 'Expectation Failed'. +http-failed-dependency+ Constant: 424 HTTP return code (424) for 'Failed Dependency'. +http-forbidden+ Constant: 403 HTTP return code (403) for 'Forbidden'. +http-gateway-time-out+ Constant: 504 HTTP return code (504) for 'Gateway Time-out'. +http-gone+ Constant: 410 HTTP return code (410) for 'Gone'. +http-internal-server-error+ Constant: 500 HTTP return code (500) for 'Internal Server Error'. +http-length-required+ Constant: 411 HTTP return code (411) for 'Length Required'. +http-method-not-allowed+ Constant: 405 HTTP return code (405) for 'Method Not Allowed'. +http-moved-permanently+ Constant: 301 HTTP return code (301) for 'Moved Permanently'. +http-moved-temporarily+ Constant: 302 HTTP return code (302) for 'Moved Temporarily'. +http-multi-status+ Constant: 207 HTTP return code (207) for 'Multi-Status'. +http-multiple-choices+ Constant: 300 HTTP return code (300) for 'Multiple Choices'. +http-network-authentication-required+ Constant: 511 HTTP return code (511) for 'Network Authentication Required'. +http-no-content+ Constant: 204 HTTP return code (204) for 'No Content'. +http-non-authoritative-information+ Constant: 203 HTTP return code (203) for 'Non-Authoritative Information'. +http-not-acceptable+ Constant: 406 HTTP return code (406) for 'Not Acceptable'. +http-not-found+ Constant: 404 HTTP return code (404) for 'Not Found'. +http-not-implemented+ Constant: 501 HTTP return code (501) for 'Not Implemented'. +http-not-modified+ Constant: 304 HTTP return code (304) for 'Not Modified'. +http-ok+ Constant: 200 HTTP return code (200) for 'OK'. +http-partial-content+ Constant: 206 HTTP return code (206) for 'Partial Content'. +http-payment-required+ Constant: 402 HTTP return code (402) for 'Payment Required'. +http-precondition-failed+ Constant: 412 HTTP return code (412) for 'Precondition Failed'. +http-precondition-required+ Constant: 428 HTTP return code (428) for 'Precondition Required'. +http-proxy-authentication-required+ Constant: 407 HTTP return code (407) for 'Proxy Authentication Required'. +http-request-entity-too-large+ Constant: 413 HTTP return code (413) for 'Request Entity Too Large'. +http-request-header-fields-too-large+ Constant: 431 HTTP return code (431) for 'Request Header Fields Too Large'. +http-request-time-out+ Constant: 408 HTTP return code (408) for 'Request Time-out'. +http-request-uri-too-large+ Constant: 414 HTTP return code (414) for 'Request-URI Too Large'. +http-requested-range-not-satisfiable+ Constant: 416 HTTP return code (416) for 'Requested range not satisfiable'. +http-reset-content+ Constant: 205 HTTP return code (205) for 'Reset Content'. +http-see-other+ Constant: 303 HTTP return code (303) for 'See Other'. +http-service-unavailable+ Constant: 503 HTTP return code (503) for 'Service Unavailable'. +http-switching-protocols+ Constant: 101 HTTP return code (101) for 'Switching Protocols'. +http-temporary-redirect+ Constant: 307 HTTP return code (307) for 'Temporary Redirect'. +http-too-many-requests+ Constant: 429 HTTP return code (429) for 'Too Many Requests'. +http-unsupported-media-type+ Constant: 415 HTTP return code (415) for 'Unsupported Media Type'. +http-use-proxy+ Constant: 305 HTTP return code (305) for 'Use Proxy'. +http-version-not-supported+ Constant: 505 HTTP return code (505) for 'Version not supported'. 13. HUNCHENTOOT-CONDITION Class Superclass for all conditions related to Hunchentoot. 14. HUNCHENTOOT-WARNING Class Superclass for all warnings related to Hunchentoot. 15. TASKMASTER taskmaster Class An instance of this class is responsible for distributing the work of handling requests for its acceptor. This is an \"abstract\" class in the sense that usually only instances of subclasses of TASKMASTER will be used. Direct superclasses: STANDARD-OBJECT Direct subclasses: MULTI-THREADED-TASKMASTER , SINGLE-THREADED-TASKMASTER RELEVANT METHODS shutdown Function: (shutdown taskmaster) Shuts down the taskmaster, i.e. frees all resources that were set up by it. For example, a multi-threaded taskmaster might terminate all threads that are currently associated with it. This function is called by the acceptor's STOP method. execute-acceptor Function: (execute-acceptor taskmaster) This is a callback called by the acceptor once it has performed all initial processing to start listening for incoming connections (see START-LISTENING). It usually calls the ACCEPT-CONNECTIONS method of the acceptor, but depending on the taskmaster instance the method might be called from a new thread. handle-incoming-connection Function: (handle-incoming-connection taskmaster socket) This function is called by the acceptor to start processing of requests on a new incoming connection. SOCKET is the usocket instance that represents the new connection (or a socket handle on LispWorks). The taskmaster starts processing requests on the incoming connection by calling the PROCESS-CONNECTION method of the acceptor instance. The SOCKET argument is passed to PROCESS-CONNECTION as an argument. start-thread Function: (start-thread taskmaster thunk &key name) Start a name thread in which to call the THUNK, in the context of the given TASKMASTER. Keyword arguments provide TASKMASTER-dependent options. Return a thread object. Hunchentoot taskmaster methods will call it with the taskmaster as the context, allowing hunchentoot extensions to define specialized methods that may e.g. wrap the thunk within a proper set of bindings and condition handlers. DIRECT SLOTS acceptor Readers: taskmaster-acceptor Writers: (setf taskmaster-acceptor) A backpointer to the acceptor instance this taskmaster works for. multi-threaded-taskmaster Class An abstract class for taskmasters that use multiple threads. For a concrete class to instantiate, use one-thread-per-connection-taskmaster. Direct superclasses: TASKMASTER Direct subclasses: ONE-THREAD-PER-CONNECTION-TASKMASTER DIRECT SLOTS acceptor-process A process that accepts incoming connections and hands them off to new processes for request handling. one-thread-per-connection-taskmaster Class A taskmaster that starts one thread for listening to incoming requests and one new thread for each incoming connection. If MAX-THREAD-COUNT is null, a new thread will always be created for each request. If MAX-THREAD-COUNT is supplied, the number of request threads is limited to that. Furthermore, if MAX-ACCEPT-COUNT is not supplied, an HTTP 503 will be sent if the thread limit is exceeded. Otherwise, if MAX-ACCEPT-COUNT is supplied, it must be greater than MAX-THREAD-COUNT; in this case, requests are accepted up to MAX-ACCEPT-COUNT, and only then is HTTP 503 sent. It is important to note that MAX-ACCEPT-COUNT and the HTTP 503 behavior described above is racing with the acceptor listen backlog. If we are receiving requests faster than threads can be spawned and 503 sent, the requests will be silently rejected by the kernel. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide MAX-THREAD-COUNT but leave MAX-ACCEPT-COUNT null. This will immediately result in HTTP 503 when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both MAX-THREAD-COUNT and a somewhat larger value for MAX-ACCEPT-COUNT. This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be HTTP 503. This is the default taskmaster implementation for multi-threaded Lisp implementations. Direct superclasses: MULTI-THREADED-TASKMASTER No subclasses. DIRECT SLOTS max-thread-count Type: (OR INTEGER NULL) Initargs: :max-thread-count Readers: taskmaster-max-thread-count Writers: (setf taskmaster-max-thread-count) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit. thread-count Type: INTEGER Initform: 0 Readers: taskmaster-thread-count Writers: (setf taskmaster-thread-count) The number of taskmaster processing threads currently running. thread-count-lock In the absence of 'atomic-incf', we need this to atomically increment and decrement the request count. max-accept-count Type: (OR INTEGER NULL) Initargs: :max-accept-count Readers: taskmaster-max-accept-count Writers: (setf taskmaster-max-accept-count) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT. accept-count Type: INTEGER Initform: 0 The number of connection currently accepted by the taskmaster. These connections are not ensured to be processed, thay may be waiting for an empty processing slot or rejected because the load is too heavy. accept-count-lock In the absence of 'atomic-incf', we need this to atomically increment and decrement the accept count. wait-queue A queue that we use to wait for a free connection. wait-lock The lock for the connection wait queue. worker-thread-name-format Type: (OR STRING NULL) Initargs: :worker-thread-name-format Initform: \"hunchentoot-worker-~A\" single-threaded-taskmaster Class A taskmaster that runs synchronously in the thread where the START function was invoked (or in the case of LispWorks in the thread started by COMM:START-UP-SERVER). This is the simplest possible taskmaster implementation in that its methods do nothing but calling their acceptor \"sister\" methods - EXECUTE-ACCEPTOR calls ACCEPT-CONNECTIONS, HANDLE-INCOMING-CONNECTION calls PROCESS-CONNECTION. Direct superclasses: TASKMASTER ADVANCED TOPICS CUSTOMIZING SESSION BEHAVIOUR For everyday session usage, you will probably just use START-SESSION , SESSION-VALUE , and maybe DELETE-SESSION-VALUE and *SESSION* . However, there are two ways to customize the way Hunchentoot maintains sessions. One way is to mostly leave the session mechanism intact but to tweak it a bit: The publicly visible part of a session is encoded using a secret which you can set yourself. And it is stored using a cookie (or GET parameter) name that you can override. Each session receives a new ID when it is created and you can implement a more robust way to do that. You can arrange to be called whenever a session is created to trigger some action. You might also do this to invent your own session garbage collection . By default, all sessions are stored in a global alist in memory. You can't change the alist part, but you can distribute your sessions over different \"databases\" . By default, every operation which modifies sessions or one of the session databases is guarded by a global lock, but you can arrange to provide different locks for this. The other way to customize Hunchentoot's sessions is to completely replace them. This is actually pretty easy: Create your own class to store state (which doesn't have to and probably shouldn't inherit from SESSION ) and implement methods for SESSION-VERIFY and SESSION-COOKIE-VALUE - that's it. Hunchentoot will continue to use cookies and/or to rewrite URLs to keep track of session state and it will store \"the current session\" (whatever that is in your implementation) in *SESSION* . Everything else (like persisting sessions, GC, getting and setting values) you'll have to take care of yourself and the other session functions (like START-SESSION or SESSION-VALUE ) won't work anymore. (Almost) total freedom, but a lot of responsibility as well... :) reset-session-secret session-cookie-name session-cookie-value session-created next-session-id session-db session-db-lock session-verify CUSTOMIZING ACCEPTOR BEHAVIOUR If you want to modify what acceptors do, you should subclass ACCEPTOR (or SSL-ACCEPTOR ) and specialize the generic functions that constitute their behaviour (see example below). The life of an acceptor looks like this: It is started with the function START which immediately calls START-LISTENING and then applies the function EXECUTE-ACCEPTOR to its taskmaster . This function will eventually call ACCEPT-CONNECTIONS which is responsible for setting things up to wait for clients to connect. For each incoming connection which comes in, HANDLE-INCOMING-CONNECTION is applied to the taskmaster which will either call PROCESS-CONNECTION directly, or will create a thread to call it. PROCESS-CONNECTION calls INITIALIZE-CONNECTION-STREAM before it does anything else, then it selects and calls a function which handles the request , and finally it sends the reply to the client before it calls RESET-CONNECTION-STREAM . If the connection is persistent, this procedure is repeated (except for the intialization step) in a loop until the connection is closed. The acceptor is stopped with STOP . If you just want to use the standard acceptors that come with Hunchentoot, you don't need to know anything about the functions listed in this section. start-listening accept-connections acceptor-log-access acceptor-log-message acceptor-status-message detach-socket initialize-connection-stream process-connection reset-connection-stream An example of how to subclass ACCEPTOR This example shows how to subclass ACCEPTOR in order to provide Hunchentoot with basic virtual host support. It assumes Hunchentoot is sitting behind an Internet-facing reverse-proxy web server that maps the host (or domain) part of incoming HTTP requests to unique localhost ports. (ql:quickload '(\"hunchentoot\" \"drakma\")) ;;; Subclass ACCEPTOR (defclass vhost (hunchentoot:acceptor) ;; slots ((dispatch-table :initform '() :accessor dispatch-table :documentation \"List of dispatch functions\")) ;; options (:default-initargs ; default-initargs must be used :address \"127.0.0.1\")) ; because ACCEPTOR uses it ;;; Specialise ACCEPTOR-DISPATCH-REQUEST for VHOSTs (defmethod hunchentoot:acceptor-dispatch-request ((vhost vhost) request) ;; try REQUEST on each dispatcher in turn (mapc (lambda (dispatcher) (let ((handler (funcall dispatcher request))) (when handler ; Handler found. FUNCALL it and return result (return-from hunchentoot:acceptor-dispatch-request (funcall handler))))) (dispatch-table vhost)) (call-next-method)) ;;; ====================================================================== ;;; Now all we need to do is test it ;;; Instantiate VHOSTs (defvar vhost1 (make-instance 'vhost :port 50001)) (defvar vhost2 (make-instance 'vhost :port 50002)) ;;; Populate each dispatch table (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo1) (dispatch-table vhost1)) (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo2) (dispatch-table vhost2)) ;;; Define handlers (defun foo1 () \"Hello\") (defun foo2 () \"Goodbye\") ;;; Start VHOSTs (hunchentoot:start vhost1) (hunchentoot:start vhost2) ;;; Make some requests (drakma:http-request \"http://127.0.0.1:50001/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:39] \"GET /foo HTTP/1.1\" 200 5 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Hello\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"5\") (:DATE . \"Fri, 08 Jun 2012 14:30:39 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50001/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CA90059}> ;;; T ;;; \"OK\" (drakma:http-request \"http://127.0.0.1:50002/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:47] \"GET /foo HTTP/1.1\" 200 7 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Goodbye\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"7\") (:DATE . \"Fri, 08 Jun 2012 14:30:47 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50002/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CAE8059}> ;;; T ;;; \"OK\" How to make each VHOST write to separate access log streams (or files) is left as an exercise to the reader. TASKMASTERS As a \"normal\" Hunchentoot user, you can completely ignore taskmasters and skip this section. But if you're still reading, here are the dirty details: Each acceptor has a taskmaster associated with it at creation time. It is the taskmaster's job to distribute the work of accepting and handling incoming connections. The acceptor calls the taskmaster if appropriate and the taskmaster calls back into the acceptor. This is done using the generic functions described in this and the previous section. Hunchentoot comes with two standard taskmaster implementations - one (which is the default used on multi-threaded Lisps) which starts a new thread for each incoming connection and one which handles all requests sequentially. It should for example be relatively straightforward to create a taskmaster which allocates threads from a fixed pool instead of creating a new one for each connection. You can control the resources consumed by a threaded taskmaster via two initargs. :max-thread-count lets you set the maximum number of request threads that can be processes simultaneously. If this is nil , the is no thread limit imposed. :max-accept-count lets you set the maximum number of requests that can be outstanding (i.e. being processed or queued for processing). If :max-thread-count is supplied and :max-accept-count is NIL , then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated if there are more than the max-thread-count threads processing requests. If both :max-thread-count and :max-accept-count are supplied, then max-thread-count must be less than max-accept-count; if more than max-thread-count requests are being processed, then requests up to max-accept-count will be queued until a thread becomes available. If more than max-accept-count requests are outstanding, then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide :max-thread-count but leave :max-accept-count null. This will immediately result in +HTTP-SERVICE-UNAVAILABLE+ when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both :max-thread-count and a somewhat larger value for :max-accept-count . This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be +HTTP-SERVICE-UNAVAILABLE+ . The default for these values is 100 and 120, respectively. If you want to implement your own taskmasters, you should subclass TASKMASTER or one of its subclasses, SINGLE-THREADED-TASKMASTER or ONE-THREAD-PER-CONNECTION-TASKMASTER , and specialize the generic functions in this section. execute-acceptor handle-incoming-connection start-thread create-request-handler-thread shutdown Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. SOME MORE TECHNICAL DETAILS Hunchentoot will only work with Lisps where the character codes of all Latin-1 characters coincide with their Unicode code points (which is the case for all current implementations I know). Source code can be downloaded from https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz . The current development version of Hunchentoot can be found at https://github.com/edicl/hunchentoot . If you want to send patches, please fork the github repository and send pull requests. Without cl+ssl You can compile Hunchentoot without SSL support - and thus without the need to have CL+SSL - if you add :HUNCHENTOOT-NO-SSL to *FEATURES* before you compile it. clbuild Hunchentoot and its dependencies can also be installed with clbuild . Gentoo Linux There's also a port for Gentoo Linux thanks to Matthew Kennedy. Running Hunchentoot on port 80 Hunchentoot does not come with code to help with running it on a privileged port (i.e. port 80 or 443) on Unix-like operating systems. Modern Unix-like systems have specific, non-portable ways to allow non-root users to listen to privileged ports, so including such functionality in Hunchentoot was considered unnecessary. Please refer to online resources for help. At the time of this writing, the YAWS documentation has a comprehensive writeup on the topic. Hunchentoot behind a proxy If you're feeling unsecure about exposing Hunchentoot to the wild, wild Internet or if your Lisp web application is part of a larger website, you can hide it behind a proxy server . One approach that I have used several times is to employ Apache's mod_proxy module with a configuration that looks like this: ProxyPass /hunchentoot http://127.0.0.1:3000/hunchentoot ProxyPassReverse /hunchentoot http://127.0.0.1:3000/hunchentoot This will tunnel all requests where the URI path begins with \"/hunchentoot\" to a (Hunchentoot) server listening on port 3000 on the same machine. Of course, there are several other (more lightweight) web proxies that you could use instead of Apache. SUPPORT The development version of Hunchentoot can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"hunchentoot - Web Server"},{"location":"hunchentoot/#hunchentoot-web-server","text":"Version: 1.2.38 Repository: edicl/hunchentoot - Github This page was possible due to the excellent official documentation as well as the page on Web Development on The Common Lisp Cookbook . In case of any inaccuracies, ambiguities or suggestions, please create an issue here . *hunchentoot was formerly known as TBNL.","title":"hunchentoot - Web Server"},{"location":"hunchentoot/#introduction","text":"Hunchentoot is a web server written in Common Lisp and a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. Hunchentoot provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client. It does not include functionality to programmatically generate HTML output. For this task you can use any library you like, e.g. CL-WHO or HTML-TEMPLATE . Hunchentoot should work with most popular lisp implementations including SBCL, CCL, LispWorks and all Lisps which are supported by the compatibility layers usocket and Bordeaux Threads . Hunchentoot talks with its front-end or with the client over TCP/IP sockets and optionally uses multiprocessing to handle several requests at the same time. Therefore, it cannot be implemented completely in portable Common Lisp . Hunchentoot comes with a BSD-style license so you can basically do with it whatever you want. Official documentation for Hunchentoot can be found in the docs directory or at the project website .","title":"INTRODUCTION"},{"location":"hunchentoot/#getting-started","text":"","title":"GETTING STARTED"},{"location":"hunchentoot/#installation-using-quicklisp","text":"See the section on Installation under Defacto Libraries on Home Page .","title":"Installation using quicklisp"},{"location":"hunchentoot/#serving-local-files","text":"To start the server, simply (defvar *acceptor*) (setq *acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4242)) (hunchentoot:start *acceptor*) You should see something - but not very interesting - at \" http://127.0.0.1:4242/ \" in your browser. By default, Hunchentoot serves files from the www/ directory from its source tree. In the distribution, that directory contains a HTML version of the documentation as well as the error templates. If installed via quicklisp, see (ql:where-is-system \"hunchentoot\") . See acceptor slots for a list of various slots (with or without initargs ). And configuration variables for a list of various configuration options for hunchentoot, such as whether to *catch-errors-p or *log-lisp-errors-p* and more. Acceptors provided with hunchentoot: acceptor easy-acceptor ssl-acceptor easy-ssl-acceptor","title":"Serving local files"},{"location":"hunchentoot/#going-dynamic","text":"","title":"Going dynamic"},{"location":"hunchentoot/#create-x-dispatcher","text":"To bind an existing function to a route, we create-prefix-dispatcher that we push onto the *dispatch-table* (just a global list of dispatch functions): (defun hello () (format nil \"Hello, it works!\")) (push (hunchentoot:create-prefix-dispatcher \"/hello.html\" 'hello) hunchentoot:*dispatch-table*) To create a route with a regexp, we use create-regex-dispatcher , where the url-as-regexp can be a string, an s-expression or a cl-ppcre scanner. In all, there exist create-folder-dispatcher-and-handler create-prefix-dispatcher create-regex-dispatcher create-static-file-dispatcher-and-handler","title":"create-X-dispatcher"},{"location":"hunchentoot/#define-easy-handler","text":"define-easy-handler allows to create a function and to bind it to an uri at once. For instance: (hunchentoot:define-easy-handler (say-yo :uri \"/yo\") (name) (setf (hunchentoot:content-type*) \"text/plain\") (format nil \"Hey~@[ ~A~]!\" name)) Visit http://localhost:4242/yo or add parameters to the url: http://localhost:4242/yo?name=Alice . Note that we didn't explicitly ask Hunchentoot to add this route to our first acceptor of the port 4242. This handler also works for another acceptor, say another one opened at port 4444: http://localhost:4444/yo?name=Bob In fact, define-easy-handler accepts an acceptor-names parameter that defines which acceptors it works for.","title":"define-easy-handler"},{"location":"hunchentoot/#accessing-get-and-post-parameters","text":"Query parameters are accessible with (hunchentoot:parameter \"my-param\") while in the context of a request . It acts on the default *request* object which is passed to all handlers. There also are get-paramater and post-parameter . See also the Variables in the context of a request .","title":"Accessing GET and POST parameters"},{"location":"hunchentoot/#more-documentation-tutorials-and-add-ons","text":"Adam Petersen has written a book called \"Lisp for the Web\" which explains how Hunchentoot and some other libraries can be used to build web sites. See also the Web Development - Cookbook . Implementing a blog in Common Lisp - Vetle Roeim Extensions and related softwares: Clack is a web server abstraction layer, defaulting to Hunchentoot. hunchentoot-cgi (by Cyrus Harmo) provides CGI handlers for Hunchentoot. CL-WEBDAV is a WebDAV server based on Hunchentoot. RESTAS is a web framework based on Hunchentoot. Caveman , Radiance , Snooze or again Weblocks are frameworks compatible with it.","title":"More documentation, tutorials and add-ons"},{"location":"hunchentoot/#api-reference","text":"","title":"API REFERENCE"},{"location":"hunchentoot/#1-acceptor","text":"Class To create a Hunchentoot webserver, you make an instance of this class and use the generic function START to start it (and STOP to stop it). Use the :PORT initarg if you don't want to listen on the default http port 80. There are other initargs most of which you probably won't need very often. They are explained in detail in the docstrings of the slot definitions for this class. Unless you are in a Lisp without MP capabilities, you can have several active instances of ACCEPTOR (listening on different ports) at the same time. Direct superclasses: STANDARD-OBJECT Direct subclasses: EASY-ACCEPTOR , SSL-ACCEPTOR","title":"1. ACCEPTOR"},{"location":"hunchentoot/#relevant-methods","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#accept-connections","text":"Function: (accept-connections acceptor) In a loop, accepts a connection and hands it over to the acceptor's taskmaster for processing using HANDLE-INCOMING-CONNECTION. On LispWorks, this function returns immediately, on other Lisps it retusn only once the acceptor has been stopped.","title":"accept-connections"},{"location":"hunchentoot/#acceptor-log-access","text":"Function: (acceptor-log-access acceptor &key return-code) Function to call to log access to the acceptor. The RETURN-CODE, CONTENT and CONTENT-LENGTH keyword arguments contain additional information about the request to log. In addition, it can use the standard request accessor functions that are available to handler functions to find out more information about the request.","title":"acceptor-log-access"},{"location":"hunchentoot/#acceptor-log-message","text":"Function: (acceptor-log-message acceptor log-level format-string &rest format-arguments) Function to call to log messages by the ACCEPTOR. It must accept a severity level for the message, which will be one of :ERROR, :INFO, or :WARNING, a format string and an arbitary number of formatting arguments.","title":"acceptor-log-message"},{"location":"hunchentoot/#acceptor-status-message","text":"Function: (acceptor-status-message acceptor http-status-code &key &allow-other-keys) This function is called after the request's handler has been invoked to convert the HTTP-STATUS-CODE to a HTML message to be displayed to the user. If this function returns a string, that string is sent to the client instead of the content produced by the handler, if any. If an ERROR-TEMPLATE-DIRECTORY is set in the current acceptor and the directory contains a file corresponding to HTTP-STATUS-CODE named \\<code>.html, that file is sent to the client after variable substitution. Variables are referenced by ${ }. Additional keyword arguments may be provided which are made available to the templating logic as substitution variables. These variables can be interpolated into error message templates in, which contains the current URL relative to the server and without GET parameters. In addition to the variables corresponding to keyword arguments, the script-name, lisp-implementation-type, lisp-implementation-version and hunchentoot-version variables are available.","title":"acceptor-status-message"},{"location":"hunchentoot/#detach-socket","text":"Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function.","title":"detach-socket"},{"location":"hunchentoot/#initialize-connection-stream","text":"Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use.","title":"initialize-connection-stream"},{"location":"hunchentoot/#process-connection","text":"Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. Handlers may call to the DETACH-SOCKET generic function to indicate that no further requests should be handled on the connection by Hunchentoot, and that responsibility for the socket is assumed by third-party software. This can be used by specialized handlers that wish to hand over connection polling or processing to functions outside of Hunchentoot, i.e. for connection multiplexing or implementing specialized client protocols. Hunchentoot will finish processing the request and the PROCESS-CONNECTION function will return without closing the connection. At that point, the acceptor may interact with the socket in whatever fashion required.","title":"process-connection"},{"location":"hunchentoot/#reset-connection-stream","text":"Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream.","title":"reset-connection-stream"},{"location":"hunchentoot/#start","text":"Function: (start acceptor) Starts the ACCEPTOR so that it begins accepting connections. Returns the acceptor.","title":"start"},{"location":"hunchentoot/#start-listening","text":"Function: (start-listening acceptor) Sets up a listen socket for the given ACCEPTOR and enables it to listen to incoming connections. This function is called from the thread that starts the acceptor initially and may return errors resulting from the listening operation (like 'address in use' or similar).","title":"start-listening"},{"location":"hunchentoot/#stop","text":"Function: (stop acceptor &key soft) Stops the ACCEPTOR so that it no longer accepts requests. If SOFT is true, and there are any requests in progress, wait until all requests are fully processed, but meanwhile do not accept new requests. Note that SOFT must not be set when calling STOP from within a request handler, as that will deadlock.","title":"stop"},{"location":"hunchentoot/#started-p","text":"Function: (started-p acceptor) Tells if ACCEPTOR has been started. The default implementation simply queries ACCEPTOR for its listening status, so if T is returned to the calling thread, then some thread has called START or some thread's call to STOP hasn't finished. If NIL is returned either some thread has called STOP, or some thread's call to START hasn't finished or START was never called at all for ACCEPTOR.","title":"started-p"},{"location":"hunchentoot/#slots","text":"","title":"SLOTS"},{"location":"hunchentoot/#acceptor-shutdown-p","text":"Initform: T A flag that makes the acceptor shutdown itself when set to something other than NIL.","title":"acceptor-shutdown-p"},{"location":"hunchentoot/#access-log-destination","text":"Initargs: :access-log-destination Readers: hunchentoot:acceptor-access-log-destination Writers: (setf hunchentoot:acceptor-access-log-destination) Destination of the access log which contains one log entry per request handled in a format similar to Apache's access.log. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging.","title":"access-log-destination"},{"location":"hunchentoot/#address","text":"Initargs: :address Readers: hunchentoot:acceptor-address The address the acceptor is listening on. If address is a string denoting an IP address, then the server only receives connections for that address. This must be one of the addresses associated with the machine and allowed values are host names such as \"www.zappa.com\" and address strings such as \"72.3.247.29\". If address is NIL, then the server will receive connections to all IP addresses on the machine. This is the default.","title":"address"},{"location":"hunchentoot/#document-root","text":"Initargs: :document-root Readers: hunchentoot:acceptor-document-root Writers: (setf hunchentoot:acceptor-document-root) Directory pathname that points to files that are served by the acceptor if no more specific acceptor-dispatch-request method handles the request.","title":"document-root"},{"location":"hunchentoot/#error-template-directory","text":"Initargs: :error-template-directory Readers: hunchentoot:acceptor-error-template-directory Writers: (setf hunchentoot:acceptor-error-template-directory) Directory pathname that contains error message template files for server-generated error messages. Files must be named .html with representing the HTTP return code that the file applies to, i.e. 404.html would be used as the content for a HTTP 404 Not found response.","title":"error-template-directory"},{"location":"hunchentoot/#listen-backlog","text":"Initargs: :listen-backlog Readers: hunchentoot:acceptor-listen-backlog Number of pending connections allowed in the listen socket before the kernel rejects further incoming connections.","title":"listen-backlog"},{"location":"hunchentoot/#listen-socket","text":"The socket listening for incoming connections.","title":"listen-socket"},{"location":"hunchentoot/#message-log-destination","text":"Initargs: :message-log-destination Readers: hunchentoot:acceptor-message-log-destination Writers: (setf hunchentoot:acceptor-message-log-destination) Destination of the server error log which is used to log informational, warning and error messages in a free-text format intended for human inspection. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging.","title":"message-log-destination"},{"location":"hunchentoot/#input-chunking-p","text":"Initargs: :input-chunking-p Readers: hunchentoot:acceptor-input-chunking-p Writers: (setf hunchentoot:acceptor-input-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for input, i.e. when accepting request bodies from the client. The default is T and there's usually no reason to change this to NIL.","title":"input-chunking-p"},{"location":"hunchentoot/#name","text":"Initargs: :name Readers: hunchentoot:acceptor-name Writers: (setf hunchentoot:acceptor-name) The optional name of the acceptor, a symbol. This name can be utilized when defining \"easy handlers\" - see DEFINE-EASY-HANDLER. The default name is an uninterned symbol as returned by GENSYM.","title":"name"},{"location":"hunchentoot/#output-chunking-p","text":"Initargs: :output-chunking-p Readers: hunchentoot:acceptor-output-chunking-p Writers: (setf hunchentoot:acceptor-output-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for output, i.e. when sending data to the client. The default is T and there's usually no reason to change this to NIL.","title":"output-chunking-p"},{"location":"hunchentoot/#persistent-connections-p","text":"Initargs: :persistent-connections-p Readers: hunchentoot:acceptor-persistent-connections-p Writers: (setf hunchentoot:acceptor-persistent-connections-p) A generalized boolean denoting whether the acceptor supports persistent connections, which is the default for threaded acceptors. If this property is NIL, Hunchentoot closes each incoming connection after having processed one request. This is the default for non-threaded acceptors.","title":"persistent-connections-p"},{"location":"hunchentoot/#port","text":"Initargs: :port Readers: hunchentoot:acceptor-port The port the acceptor is listening on. The default is 80. Note that depending on your operating system you might need special privileges to listen on port 80. When 0, the port will be chosen by the system the first time the acceptor is started.","title":"port"},{"location":"hunchentoot/#read-timeout","text":"Initargs: :read-timeout Readers: hunchentoot:acceptor-read-timeout The read timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout.","title":"read-timeout"},{"location":"hunchentoot/#reply-class","text":"Initargs: :reply-class Readers: hunchentoot:acceptor-reply-class Writers: (setf hunchentoot:acceptor-reply-class) Determines which class of reply objects is created when a request is served in and should be (a symbol naming) a class which inherits from REPLY. The default is the symbol REPLY.","title":"reply-class"},{"location":"hunchentoot/#request-class","text":"Initargs: :request-class Readers: hunchentoot:acceptor-request-class Writers: (setf hunchentoot:acceptor-request-class) Determines which class of request objects is created when a request comes in and should be (a symbol naming) a class which inherits from REQUEST. The default is the symbol REQUEST.","title":"request-class"},{"location":"hunchentoot/#requests-in-progress","text":"Initform: 0 The number of requests currently in progress.","title":"requests-in-progress"},{"location":"hunchentoot/#shutdown-lock","text":"The lock protecting the shutdown-queue condition variable and the requests-in-progress counter.","title":"shutdown-lock"},{"location":"hunchentoot/#shutdown-queue","text":"A condition variable used with soft shutdown, signaled when all requests have been processed.","title":"shutdown-queue"},{"location":"hunchentoot/#taskmaster","text":"Initargs: :taskmaster The taskmaster (i.e. an instance of a subclass of TASKMASTER) that is responsible for scheduling the work for this acceptor. The default depends on the MP capabilities of the underlying Lisp.","title":"taskmaster"},{"location":"hunchentoot/#write-timeout","text":"Initargs: :write-timeout Readers: hunchentoot:acceptor-write-timeout The write timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout.","title":"write-timeout"},{"location":"hunchentoot/#2-easy-acceptor","text":"Class This is the acceptor of the \"easy\" Hunchentoot framework. Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR","title":"2. EASY-ACCEPTOR"},{"location":"hunchentoot/#3-define-easy-handler","text":"Macro: (define-easy-handler description lambda-list &body body) Defines a handler with the body BODY and optionally registers it with a URI so that it will be found by DISPATCH-EASY-HANDLERS . DESCRIPTION is either a symbol NAME or a list matching the destructuring lambda list (name &key uri acceptor-names default-parameter-type default-request-type) LAMBDA-LIST is a list the elements of which are either a symbol VAR or a list matching the destructuring lambda list (var &key real-name parameter-type init-form request-type) The resulting handler will be a Lisp function with the name NAME and keyword parameters named by the VAR symbols. Each VAR will be bound to the value of the GET or POST parameter called REAL-NAME (a string) before BODY is executed. If REAL-NAME is not provided, it will be computed by downcasing the symbol name of VAR. If URI (which is evaluated) is provided, then it must be a string or a function designator for a function of one argument. In this case, the handler will be returned by DISPATCH-EASY-HANDLERS, if URI is a string and the script name of a request is URI, or if URI designates a function and applying this function to the current request object returns a true value. ACCEPTOR-NAMES (which is evaluated) can be a list of symbols which means that the handler will be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). ACCEPTOR-NAMES can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor. Whether the GET or POST parameter (or both) will be taken into consideration, depends on REQUEST-TYPE which can be :GET, :POST, :BOTH, or NIL. In the last case, the value of DEFAULT-REQUEST-TYPE (the default of which is :BOTH) will be used. The value of VAR will usually be a string (unless it resulted from a file upload in which case it won't be converted at all), but if PARAMETER-TYPE (which is evaluated) is provided, the string will be converted to another Lisp type by the following rules: If the corresponding GET or POST parameter wasn't provided by the client, VAR's value will be NIL. If PARAMETER-TYPE is 'STRING, VAR's value remains as is. If PARAMETER-TYPE is 'INTEGER and the parameter string consists solely of decimal digits, VAR's value will be the corresponding integer, otherwise NIL. If PARAMETER-TYPE is 'KEYWORD, VAR's value will be the keyword obtained by interning the upcased parameter string into the keyword package. If PARAMETER-TYPE is 'CHARACTER and the parameter string is of length one, VAR's value will be the single character of this string, otherwise NIL. If PARAMETER-TYPE is 'BOOLEAN, VAR's value will always be T (unless it is NIL by the first rule above, of course). If PARAMETER-TYPE is any other atom, it is supposed to be a function designator for a unary function which will be called to convert the string to something else. Those were the rules for simple' types, but PARAMETER-TYPE can also be a list starting with one of the symbols LIST, ARRAY, or HASH-TABLE. The second value of the list must always be a simple parameter type as in the last paragraph - we'll call it the inner type' below. In the case of 'LIST, all GET/POST parameters called REAL-NAME will be collected, converted to the inner type, and assembled into a list which will be the value of VAR. In the case of 'ARRAY, all GET/POST parameters which have a name like the result of (format nil \"~A[~A]\" real-name n) where N is a non-negative integer, will be assembled into an array where the Nth element will be set accordingly, after conversion to the inner type. The array, which will become the value of VAR, will be big enough to hold all matching parameters, but not bigger. Array elements not set as described above will be NIL. Note that VAR will always be bound to an array, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. The full form of a 'HASH-TABLE parameter type is (hash-table inner-type key-type test-function), but KEY-TYPE and TEST-FUNCTION can be left out in which case they default to 'STRING and 'EQUAL, respectively. For this parameter type, all GET/POST parameters which have a name like the result of (format nil \"~A{~A}\" real-name key) (where KEY is a string that doesn't contain curly brackets) will become the values (after conversion to INNER-TYPE) of a hash table with test function TEST-FUNCTION where KEY (after conversion to KEY-TYPE) will be the corresponding key. Note that VAR will always be bound to a hash table, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. To make matters even more complicated, the three compound parameter types also have an abbreviated form - just one of the symbols LIST, ARRAY, or HASH-TABLE. In this case, the inner type will default to 'STRING. If PARAMETER-TYPE is not provided or NIL, DEFAULT-PARAMETER-TYPE (the default of which is 'STRING) will be used instead. If the result of the computations above would be that VAR would be bound to NIL, then INIT-FORM (if provided) will be evaluated instead, and VAR will be bound to the result of this evaluation. Handlers built with this macro are constructed in such a way that the resulting Lisp function is useful even outside of Hunchentoot. Specifically, all the parameter computations above will only happen if *REQUEST* is bound, i.e. if we're within a Hunchentoot request. Otherwise, VAR will always be bound to the result of evaluating INIT-FORM unless a corresponding keyword argument is provided.","title":"3. DEFINE-EASY-HANDLER"},{"location":"hunchentoot/#4-ssl-acceptor","text":"Class Create and START an instance of this class (instead of ACCEPTOR) if you want an https server. There are two required initargs, :SSL-CERTIFICATE-FILE and :SSL-PRIVATEKEY-FILE, for pathname designators denoting the certificate file and the key file in PEM format. On LispWorks, you can have both in one file in which case the second initarg is optional. You can also use the :SSL-PRIVATEKEY-PASSWORD initarg to provide a password (as a string) for the key file (or NIL, the default, for no password). The default port for SSL-ACCEPTOR instances is 443 instead of 80 Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR","title":"4. SSL-ACCEPTOR"},{"location":"hunchentoot/#direct-slots","text":"Also see slots for the superclass.","title":"DIRECT SLOTS"},{"location":"hunchentoot/#ssl-certificate-file","text":"Initargs: :ssl-certificate-file Readers: hunchentoot:acceptor-ssl-certificate-file A pathname designator for a certificate file in PEM format.","title":"ssl-certificate-file"},{"location":"hunchentoot/#ssl-privatekey-file","text":"Initargs: :ssl-privatekey-file Readers: hunchentoot:acceptor-ssl-privatekey-file A pathname designator for a private key file in PEM format, or (only on LispWorks) NIL if the certificate file contains the private key.","title":"ssl-privatekey-file"},{"location":"hunchentoot/#ssl-privatekey-password","text":"Initargs: :ssl-privatekey-password Readers: hunchentoot:acceptor-ssl-privatekey-password The password for the private key file or NIL for no password.","title":"ssl-privatekey-password"},{"location":"hunchentoot/#5-easy-ssl-acceptor","text":"Class This is an acceptor that mixes the \"easy\" Hunchentoot with SSL connections. Direct superclasses: EASY-ACCEPTOR , SSL-ACCEPTOR No subclasses.","title":"5. EASY-SSL-ACCEPTOR"},{"location":"hunchentoot/#6-reply","text":"Class Objects of this class hold all the information about an outgoing reply. They are created automatically by Hunchentoot and can be accessed and modified by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REPLY in order to implement your own behaviour. See the REPLY-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses.","title":"6. REPLY"},{"location":"hunchentoot/#relevant-methods_1","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#headers-out","text":"Function: (headers-out* &optional (reply *reply*)) Returns an alist of the outgoing headers associated with the REPLY object REPLY.","title":"headers-out*"},{"location":"hunchentoot/#content-length","text":"Function: (content-length* &optional (reply *reply*)) The outgoing 'Content-Length' http header of REPLY.","title":"content-length*"},{"location":"hunchentoot/#content-type","text":"Function: (content-type* &optional (reply *reply*)) The outgoing 'Content-Type' http header of REPLY.","title":"content-type*"},{"location":"hunchentoot/#cookie-out","text":"Function: (cookie-out name &optional (reply *reply*)) Returns the current value of the outgoing cookie named NAME. Search is case-sensitive.","title":"cookie-out"},{"location":"hunchentoot/#cookies-out","text":"Function: (cookies-out* &optional (reply *reply*)) Returns an alist of the outgoing cookies associated with the REPLY object REPLY.","title":"cookies-out*"},{"location":"hunchentoot/#return-code","text":"Function: (return-code* &optional (reply *reply*)) The http return code of REPLY. The return codes Hunchentoot can handle are defined in specials.lisp.","title":"return-code*"},{"location":"hunchentoot/#send-headers","text":"Function: (send-headers) Sends the initial status line and all headers as determined by the REPLY object *REPLY*. Returns a binary stream to which the body of the reply can be written. Once this function has been called, further changes to *REPLY* don't have any effect. Also, automatic handling of errors (i.e. sending the corresponding status code to the browser, etc.) is turned off for this request. If your handlers return the full body as a string or as an array of octets you should NOT call this function. This function does not return control to the caller during HEAD request processing.","title":"send-headers"},{"location":"hunchentoot/#reply-external-format","text":"Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output.","title":"reply-external-format*"},{"location":"hunchentoot/#slots_1","text":"","title":"SLOTS"},{"location":"hunchentoot/#content-type_1","text":"Readers: hunchentoot:content-type The outgoing 'Content-Type' http header which defaults to the value of *DEFAULT-CONTENT-TYPE*.","title":"content-type"},{"location":"hunchentoot/#content-length_1","text":"Readers: hunchentoot:content-length The outgoing 'Content-Length' http header which defaults NIL. If this is NIL, Hunchentoot will compute the content length.","title":"content-length"},{"location":"hunchentoot/#headers-out_1","text":"Readers: hunchentoot:headers-out An alist of the outgoing http headers not including the 'Set-Cookie', 'Content-Length', and 'Content-Type' headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot.","title":"headers-out"},{"location":"hunchentoot/#return-code_1","text":"Initform: hunchentoot:+http-ok+ Readers: hunchentoot:return-code Writers: (setf hunchentoot:return-code) The http return code of this reply. The return codes Hunchentoot can handle are defined in specials.lisp.","title":"return-code"},{"location":"hunchentoot/#external-format","text":"Initform: hunchentoot:*hunchentoot-default-external-format* Readers: hunchentoot:reply-external-format Writers: (setf hunchentoot:reply-external-format) The external format of the reply - used for character output.","title":"external-format"},{"location":"hunchentoot/#cookies-out_1","text":"Readers: hunchentoot:cookies-out Writers: (setf hunchentoot:cookies-out) The outgoing cookies. This slot's value should only be modified by the functions defined in cookies.lisp.","title":"cookies-out"},{"location":"hunchentoot/#7-request","text":"Class Objects of this class hold all the information about an incoming request. They are created automatically by acceptors and can be accessed by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REQUEST in order to implement your own behaviour. See the REQUEST-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses.","title":"7. REQUEST"},{"location":"hunchentoot/#relevant-methods_2","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#real-remote-addr","text":"Function: (real-remote-addr &optional (request *request*)) Returns the 'X-Forwarded-For' incoming http header as the second value in the form of a list of IP addresses and the first element of this list as the first value if this header exists. Otherwise returns the value of REMOTE-ADDR as the only value.","title":"real-remote-addr"},{"location":"hunchentoot/#parameter","text":"Function: (parameter name &optional (request *request*)) Returns the GET or the POST parameter with name NAME (a string) - or NIL if there is none. If both a GET and a POST parameter with the same name exist the GET parameter is returned. Search is case-sensitive.","title":"parameter"},{"location":"hunchentoot/#get-parameter","text":"Function: (get-parameter name &optional (request *request*)) Returns the GET parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive.","title":"get-parameter"},{"location":"hunchentoot/#get-parameters","text":"Function: (get-parameters* &optional (request *request*)) Returns an alist of the GET parameters associated with the REQUEST object REQUEST.","title":"get-parameters*"},{"location":"hunchentoot/#post-parameter","text":"Function: (post-parameter name &optional (request *request*)) Returns the POST parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive.","title":"post-parameter"},{"location":"hunchentoot/#post-parameters","text":"Function: (post-parameters* &optional (request *request*)) Returns an alist of the POST parameters associated with the REQUEST object REQUEST.","title":"post-parameters*"},{"location":"hunchentoot/#cookie-in","text":"Function: (cookie-in name &optional (request *request*)) Returns the cookie with the name NAME (a string) as sent by the browser - or NIL if there is none.","title":"cookie-in"},{"location":"hunchentoot/#cookies-in","text":"Function: (cookies-in* &optional (request *request*)) Returns an alist of all cookies associated with the REQUEST object REQUEST.","title":"cookies-in*"},{"location":"hunchentoot/#host","text":"Function: (host &optional (request *request*)) Returns the 'Host' incoming http header value.","title":"host"},{"location":"hunchentoot/#query-string","text":"Function: (query-string* &optional (request *request*)) Returns the query string of the REQUEST object REQUEST. That's the part behind the question mark (i.e. the GET parameters).","title":"query-string*"},{"location":"hunchentoot/#referer","text":"Function: (referer &optional (request *request*)) Returns the 'Referer' (sic!) http header.","title":"referer"},{"location":"hunchentoot/#request-method","text":"Function: (request-method* &optional (request *request*)) Returns the request method as a Lisp keyword.","title":"request-method*"},{"location":"hunchentoot/#request-uri","text":"Function: (request-uri* &optional (request *request*)) Returns the request URI.","title":"request-uri*"},{"location":"hunchentoot/#server-protocol","text":"Function: (server-protocol* &optional (request *request*)) Returns the request protocol as a Lisp keyword.","title":"server-protocol*"},{"location":"hunchentoot/#user-agent","text":"Function: (user-agent &optional (request *request*)) Returns the 'User-Agent' http header.","title":"user-agent"},{"location":"hunchentoot/#header-in","text":"Function: (header-in* name &optional (request *request*)) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string.","title":"header-in*"},{"location":"hunchentoot/#headers-in","text":"Function: (headers-in* &optional (request *request*)) Returns an alist of the incoming headers associated with the REQUEST object REQUEST.","title":"headers-in*"},{"location":"hunchentoot/#remote-addr","text":"Function: (remote-addr* &optional (request *request*)) Returns the address the current request originated from.","title":"remote-addr*"},{"location":"hunchentoot/#remote-port","text":"Function: (remote-port* &optional (request *request*)) Returns the port the current request originated from.","title":"remote-port*"},{"location":"hunchentoot/#local-addr","text":"Function: (local-addr* &optional (request *request*)) Returns the address the current request connected to.","title":"local-addr*"},{"location":"hunchentoot/#local-port","text":"Function: (local-port* &optional (request *request*)) Returns the port the current request connected to.","title":"local-port*"},{"location":"hunchentoot/#script-name","text":"Function: (script-name* &optional (request *request*)) Returns the file name of the REQUEST object REQUEST. That's the requested URI without the query string (i.e the GET parameters).","title":"script-name*"},{"location":"hunchentoot/#aux-request-value","text":"Function: (aux-request-value symbol &optional (request *request*)) Returns the value associated with SYMBOL from the request object REQUEST (the default is the current request) if it exists. The second return value is true if such a value was found. Sets the value associated with SYMBOL from the request object REQUEST (default is *REQUEST*). If there is already a value associated with SYMBOL it will be replaced.","title":"aux-request-value"},{"location":"hunchentoot/#delete-aux-request-value","text":"Function: (delete-aux-request-value symbol &optional (request *request*)) Removes the value associated with SYMBOL from the request object REQUEST.","title":"delete-aux-request-value"},{"location":"hunchentoot/#authorization","text":"Function: (authorization &optional (request *request*)) Returns as two values the user and password (if any) as encoded in the 'AUTHORIZATION' header. Returns NIL if there is no such header.","title":"authorization"},{"location":"hunchentoot/#raw-post-data","text":"Function: (raw-post-data &key (request *request*) external-format force-text force-binary want-stream) Returns the content sent by the client if there was any (unless the content type was \"multipart/form-data\"). By default, the result is a string if the type of the Content-Type' media type is \"text\", and a vector of octets otherwise. In the case of a string, the external format to be used to decode the content will be determined from the charset' parameter sent by the client (or otherwise *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used). You can also provide an external format explicitly (through EXTERNAL-FORMAT) in which case the result will unconditionally be a string. Likewise, you can provide a true value for FORCE-TEXT which will force Hunchentoot to act as if the type of the media type had been \"text\". Or you can provide a true value for FORCE-BINARY which means that you want a vector of octets at any rate. If, however, you provide a true value for WANT-STREAM, the other parameters are ignored and you'll get the content (flexi) stream to read from it yourself. It is then your responsibility to read the correct amount of data, because otherwise you won't be able to return a response to the client. If the content type of the request was multipart/form-data' or application/x-www-form-urlencoded', the content has been read by Hunchentoot already and you can't read from the stream anymore. You can call RAW-POST-DATA more than once per request, but you can't mix calls which have different values for WANT-STREAM. Note that this function is slightly misnamed because a client can send content even if the request method is not POST.","title":"raw-post-data"},{"location":"hunchentoot/#recompute-request-parameters","text":"Function: (recompute-request-parameters &key (request *request*) (external-format *hunchentoot-default-external-format*)) Recomputes the GET and POST parameters for the REQUEST object REQUEST. This only makes sense if you're switching external formats during the request.","title":"recompute-request-parameters"},{"location":"hunchentoot/#process-request","text":"Function: (process-request request) This function is called by PROCESS-CONNECTION after the incoming headers have been read. It calls HANDLE-REQUEST to select and call a handler and sends the output of this handler to the client using START-OUTPUT. Note that PROCESS-CONNECTION is called once per connection and loops in case of a persistent connection while PROCESS-REQUEST is called anew for each request. Essentially, you can view process-request as a thin wrapper around HANDLE-REQUEST. The return value of this function is ignored.","title":"process-request"},{"location":"hunchentoot/#handle-request","text":"Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers.","title":"handle-request"},{"location":"hunchentoot/#handle-request_1","text":"Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers.","title":"handle-request"},{"location":"hunchentoot/#acceptor-dispatch-request","text":"Function: (acceptor-dispatch-request acceptor request) This function is called to actually dispatch the request once the standard logging and error handling has been set up. ACCEPTOR subclasses implement methods for this function in order to perform their own request routing. If a method does not want to handle the request, it is supposed to invoke CALL-NEXT-METHOD so that the next ACCEPTOR in the inheritance chain gets a chance to handle the request.","title":"acceptor-dispatch-request"},{"location":"hunchentoot/#slots_2","text":"","title":"SLOTS"},{"location":"hunchentoot/#acceptor","text":"Initargs: :acceptor Readers: hunchentoot:request-acceptor The acceptor which created this request object.","title":"acceptor"},{"location":"hunchentoot/#headers-in_1","text":"Initargs: :headers-in Readers: hunchentoot:headers-in An alist of the incoming headers.","title":"headers-in"},{"location":"hunchentoot/#method","text":"Initargs: :method Readers: hunchentoot:request-method The request method as a keyword.","title":"method"},{"location":"hunchentoot/#uri","text":"Initargs: :uri Readers: hunchentoot:request-uri The request URI as a string.","title":"uri"},{"location":"hunchentoot/#server-protocol_1","text":"Initargs: :server-protocol Readers: hunchentoot:server-protocol The HTTP protocol as a keyword.","title":"server-protocol"},{"location":"hunchentoot/#local-addr_1","text":"Initargs: :local-addr Readers: hunchentoot:local-addr The IP address of the local system that the client connected to.","title":"local-addr"},{"location":"hunchentoot/#local-port_1","text":"Initargs: :local-port Readers: hunchentoot:local-port The TCP port number of the local system that the client connected to.","title":"local-port"},{"location":"hunchentoot/#remote-addr_1","text":"Initargs: :remote-addr Readers: hunchentoot:remote-addr The IP address of the client that initiated this request.","title":"remote-addr"},{"location":"hunchentoot/#remote-port_1","text":"Initargs: :remote-port Readers: hunchentoot:remote-port The TCP port number of the client socket from which this request originated.","title":"remote-port"},{"location":"hunchentoot/#content-stream","text":"Initargs: :content-stream A stream from which the request body can be read if there is one.","title":"content-stream"},{"location":"hunchentoot/#cookies-in_1","text":"Readers: hunchentoot:cookies-in An alist of the cookies sent by the client.","title":"cookies-in"},{"location":"hunchentoot/#get-parameters_1","text":"Readers: hunchentoot:get-parameters An alist of the GET parameters sent by the client.","title":"get-parameters"},{"location":"hunchentoot/#post-parameters_1","text":"Readers: hunchentoot:post-parameters An alist of the POST parameters sent by the client.","title":"post-parameters"},{"location":"hunchentoot/#script-name_1","text":"Readers: hunchentoot:script-name The URI requested by the client without the query string.","title":"script-name"},{"location":"hunchentoot/#query-string_1","text":"Readers: hunchentoot:query-string The query string of this request.","title":"query-string"},{"location":"hunchentoot/#session","text":"Readers: hunchentoot:session Writers: (setf hunchentoot:session) The session object associated with this request.","title":"session"},{"location":"hunchentoot/#aux-data","text":"Used to keep a user-modifiable alist with arbitrary data during the request.","title":"aux-data"},{"location":"hunchentoot/#raw-post-data_1","text":"The raw string sent as the body of a POST request, populated only if not a multipart/form-data request.","title":"raw-post-data"},{"location":"hunchentoot/#8-session","text":"Class SESSION objects are automatically maintained by Hunchentoot. They should not be created explicitly with MAKE-INSTANCE but implicitly with START-SESSION and they should be treated as opaque objects. You can ignore Hunchentoot's SESSION objects altogether and implement your own sessions if you provide corresponding methods for SESSION-COOKIE-VALUE and SESSION-VERIFY. Direct superclasses: STANDARD-OBJECT No subclasses. Hunchentoot supports sessions : Once a request handler has called START-SESSION , Hunchentoot uses either cookies or (if the client doesn't send the cookies back) rewrites URLs to keep track of this client, i.e. to provide a kind of 'state' for the stateless http protocol. Hunchentoot makes some reasonable effort to prevent eavesdroppers from hijacking sessions (see below), but this should not be considered really secure. Don't store sensitive data in sessions and rely solely on the session mechanism as a safeguard against malicious users who want to get at this data! For each request there's one SESSION object which is accessible to the handler via the special variable *SESSION* . This object holds all the information available about the session and can be accessed with the functions described in this chapter. Note that the internal structure of SESSION objects should be considered opaque and may change in future releases of Hunchentoot. Sessions are automatically verified for validity and age when the REQUEST object is instantiated, i.e. if *SESSION* is not NIL then this session is valid (as far as Hunchentoot is concerned) and not too old . Old sessions are automatically removed . Hunchentoot also provides a SESSION-REGENERATE-COOKIE-VALUE function that creates a new cookie value. This helps to prevent against session fixation attacks , and should be used when a user logs in according to the application.","title":"8. SESSION"},{"location":"hunchentoot/#relevant-methods_3","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#start-session","text":"Function: (start-session) Returns the current SESSION object. If there is no current session, creates one and updates the corresponding data structures. In this case the function will also send a session cookie to the browser.","title":"start-session"},{"location":"hunchentoot/#session-value","text":"Function: (session-value symbol &optional (session *session*)) Returns the value associated with SYMBOL from the session object SESSION (the default is the current session) if it exists. Sets the value associated with SYMBOL from the session object SESSION. If there is already a value associated with SYMBOL it will be replaced. Will automatically start a session if none was supplied and there's no session for the current request.","title":"session-value"},{"location":"hunchentoot/#delete-session-value","text":"Function: (delete-session-value symbol &optional (session *session*)) Removes the value associated with SYMBOL from SESSION if there is one.","title":"delete-session-value"},{"location":"hunchentoot/#remove-session","text":"Function: (remove-session session) Completely removes the SESSION object SESSION from Hunchentoot's internal session database.","title":"remove-session"},{"location":"hunchentoot/#slots_3","text":"","title":"SLOTS"},{"location":"hunchentoot/#session-id","text":"Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session.","title":"session-id"},{"location":"hunchentoot/#session-string","text":"The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter.","title":"session-string"},{"location":"hunchentoot/#user-agent_1","text":"Initform: (hunchentoot:user-agent hunchentoot:*request*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created.","title":"user-agent"},{"location":"hunchentoot/#remote-addr_2","text":"Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR.","title":"remote-addr"},{"location":"hunchentoot/#session-start","text":"Initform: (GET-UNIVERSAL-TIME) Readers: hunchentoot:session-start The time this session was started.","title":"session-start"},{"location":"hunchentoot/#last-click","text":"The last time this session was used.","title":"last-click"},{"location":"hunchentoot/#session-data","text":"Initargs: :session-data Data associated with this session - see SESSION-VALUE.","title":"session-data"},{"location":"hunchentoot/#max-time","text":"Type: fixnum Initargs: :max-time Initform: hunchentoot:*session-max-time* Readers: hunchentoot:session-max-time Writers: (setf hunchentoot:session-max-time) The time (in seconds) after which this session expires if it's not used.","title":"max-time"},{"location":"hunchentoot/#session-id_1","text":"Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session.","title":"session-id"},{"location":"hunchentoot/#session-string_1","text":"The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter.","title":"session-string"},{"location":"hunchentoot/#user-agent_2","text":"Initform: (HUNCHENTOOT:USER-AGENT HUNCHENTOOT:*REQUEST*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created.","title":"user-agent"},{"location":"hunchentoot/#remote-addr_3","text":"Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR.","title":"remote-addr"},{"location":"hunchentoot/#session-start_1","text":"Initform: (get-universal-time) Readers: hunchentoot:session-start The time this session was started.","title":"session-start"},{"location":"hunchentoot/#9-miscellaneous-functions","text":"","title":"9. MISCELLANEOUS FUNCTIONS"},{"location":"hunchentoot/#bad-request","text":"Class Direct superclasses: HUNCHENTOOT-ERROR No subclasses.","title":"bad-request"},{"location":"hunchentoot/#client-as-string","text":"Function: (client-as-string socket) A helper function which returns the client's address and port as a string and tries to act robustly in the presence of network problems.","title":"client-as-string"},{"location":"hunchentoot/#create-folder-dispatcher-and-handler","text":"Function: (create-folder-dispatcher-and-handler uri-prefix base-path &optional content-type) Creates and returns a dispatch function which will dispatch to a handler function which emits the file relative to BASE-PATH that is denoted by the URI of the request relative to URI-PREFIX. URI-PREFIX must be a string ending with a slash, BASE-PATH must be a pathname designator for an existing directory. If CONTENT-TYPE is not NIL, it'll be the content type used for all files in the folder.","title":"create-folder-dispatcher-and-handler"},{"location":"hunchentoot/#create-prefix-dispatcher","text":"Function: (create-prefix-dispatcher prefix handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request starts with the string PREFIX.","title":"create-prefix-dispatcher"},{"location":"hunchentoot/#create-regex-dispatcher","text":"Function: (create-regex-dispatcher regex handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request matches the CL-PPCRE regular expression REGEX.","title":"create-regex-dispatcher"},{"location":"hunchentoot/#create-request-handler-thread","text":"Function: (create-request-handler-thread taskmaster socket) Create a new thread in which to process the request. This thread will call PROCESS-CONNECTION to process the request.","title":"create-request-handler-thread"},{"location":"hunchentoot/#create-static-file-dispatcher-and-handler","text":"Function: (create-static-file-dispatcher-and-handler uri path &optional content-type) Creates and returns a request dispatch function which will dispatch to a handler function which emits the file denoted by the pathname designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of the request matches the string URI. If CONTENT-TYPE is NIL, tries to determine the content type via the file's suffix.","title":"create-static-file-dispatcher-and-handler"},{"location":"hunchentoot/#decrement-taskmaster-thread-count","text":"Function: (decrement-taskmaster-thread-count taskmaster) Atomically decrement the number of taskmaster requests","title":"decrement-taskmaster-thread-count"},{"location":"hunchentoot/#default-document-directory","text":"Function: (default-document-directory &optional sub-directory)","title":"default-document-directory"},{"location":"hunchentoot/#detach-socket_1","text":"Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function.","title":"detach-socket"},{"location":"hunchentoot/#dispatch-easy-handlers","text":"Function: (dispatch-easy-handlers request) This is a dispatcher which returns the appropriate handler defined with DEFINE-EASY-HANDLER, if there is one.","title":"dispatch-easy-handlers"},{"location":"hunchentoot/#escape-for-html","text":"Function: (escape-for-html string) Escapes the characters #\\<, #>, #\\', #\\\", and #\\& for HTML output.","title":"escape-for-html"},{"location":"hunchentoot/#handle-if-modified-since","text":"Function: (handle-if-modified-since time &optional (request *request*)) Handles the 'If-Modified-Since' header of REQUEST. The date string is compared to the one generated from the supplied universal time TIME.","title":"handle-if-modified-since"},{"location":"hunchentoot/#handle-static-file","text":"Function: (handle-static-file pathname &optional content-type) A function which acts like a Hunchentoot handler for the file denoted by PATHNAME. Sends a content type header corresponding to CONTENT-TYPE or (if that is NIL) tries to determine the content type via the file's suffix.","title":"handle-static-file"},{"location":"hunchentoot/#http-token-p","text":"Function: (http-token-p token) This function tests whether OBJECT is a non-empty string which is a TOKEN according to RFC 2068 (i.e. whether it may be used for, say, cookie names).","title":"http-token-p"},{"location":"hunchentoot/#hunchentoot-error","text":"Function: (hunchentoot-error format-control &rest format-arguments) Signals an error of type HUNCHENTOOT-SIMPLE-ERROR with the provided format control and arguments. Superclass for all errors related to Hunchentoot.","title":"hunchentoot-error"},{"location":"hunchentoot/#increment-taskmaster-thread-count","text":"Function: (increment-taskmaster-thread-count taskmaster) Atomically increment the number of taskmaster requests.","title":"increment-taskmaster-thread-count"},{"location":"hunchentoot/#initialize-connection-stream_1","text":"Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use.","title":"initialize-connection-stream"},{"location":"hunchentoot/#log-message","text":"Function: (log-message* log-level format-string &rest format-arguments) Convenience function which calls the message logger of the current acceptor (if there is one) with the same arguments it accepts. This is the function which Hunchentoot itself uses to log errors it catches during request processing.","title":"log-message*"},{"location":"hunchentoot/#maybe-invoke-debugger","text":"Function: (maybe-invoke-debugger condition) This generic function is called whenever a condition CONDITION is signaled in Hunchentoot. You might want to specialize it on specific condition classes for debugging purposes.","title":"maybe-invoke-debugger"},{"location":"hunchentoot/#mime-type","text":"Function: (mime-type pathspec) Given a pathname designator PATHSPEC returns the MIME type (as a string) corresponding to the suffix of the file denoted by PATHSPEC (or NIL).","title":"mime-type"},{"location":"hunchentoot/#next-session-id","text":"Function: (next-session-id acceptor) Returns the next sequential session ID, an integer, which should be unique per session. The default method uses a simple global counter and isn't guarded by a lock. For a high-performance production environment you might consider using a more robust implementation.","title":"next-session-id"},{"location":"hunchentoot/#no-cache","text":"Function: (no-cache) Adds appropriate headers to completely prevent caching on most browsers.","title":"no-cache"},{"location":"hunchentoot/#parameter-error","text":"Function: (parameter-error format-control &rest format-arguments) Signals an error of type PARAMETER-ERROR with the provided format control and arguments. Signalled if a function was called with incosistent or illegal parameters.","title":"parameter-error"},{"location":"hunchentoot/#process-connection_1","text":"Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing.","title":"process-connection"},{"location":"hunchentoot/#reason-phrase","text":"Function: (reason-phrase return-code) Returns a reason phrase for the HTTP return code RETURN-CODE (which should be an integer) or NIL for return codes Hunchentoot doesn't know.","title":"reason-phrase"},{"location":"hunchentoot/#redirect","text":"Function: (redirect target &key (host (host *request*) host-provided-p) port (protocol (if (ssl-p) :https :http)) (add-session-id (not (or host-provided-p (starts-with-scheme-p target) (cookie-in (session-cookie-name *acceptor*))))) (code +http-moved-temporarily+)) Redirects the browser to TARGET which should be a string. If TARGET is a full URL starting with a scheme, HOST, PORT and PROTOCOL are ignored. Otherwise, TARGET should denote the path part of a URL, PROTOCOL must be one of the keywords :HTTP or :HTTPS, and the URL to redirect to will be constructed from HOST, PORT, PROTOCOL, and TARGET. Adds a session ID if ADD-SESSION-ID is true. If CODE is a 3xx redirection code, it will be sent as status code.","title":"redirect"},{"location":"hunchentoot/#regenerate-session-cookie-value","text":"Function: (regenerate-session-cookie-value session) Regenerates the cookie value. This should be used when a user logs in according to the application to prevent against session fixation attacks. The cookie value being dependent on ID, USER-AGENT, REMOTE-ADDR, START, and *SESSION-SECRET*, the only value we can change is START to regenerate a new value. Since we're generating a new cookie, it makes sense to have the session being restarted, in time. That said, because of this fact, calling this function twice in the same second will regenerate twice the same value.","title":"regenerate-session-cookie-value"},{"location":"hunchentoot/#reply-external-format_1","text":"Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output.","title":"reply-external-format*"},{"location":"hunchentoot/#request-pathname","text":"Function: (request-pathname &optional (request *request*) drop-prefix) Construct a relative pathname from the request's SCRIPT-NAME. If DROP-PREFIX is given, pathname construction starts at the first path segment after the prefix.","title":"request-pathname"},{"location":"hunchentoot/#require-authorization","text":"Function: (require-authorization &optional (realm hunchentoot)) Sends back appropriate headers to require basic HTTP authentication (see RFC 2617) for the realm REALM.","title":"require-authorization"},{"location":"hunchentoot/#reset-connection-stream_1","text":"Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream.","title":"reset-connection-stream"},{"location":"hunchentoot/#reset-session-secret","text":"Function: (reset-session-secret) Sets *SESSION-SECRET* to a new random value. All old sessions will cease to be valid.","title":"reset-session-secret"},{"location":"hunchentoot/#reset-sessions","text":"Function: (reset-sessions &optional (acceptor *acceptor*)) Removes ALL stored sessions of ACCEPTOR.","title":"reset-sessions"},{"location":"hunchentoot/#rfc-1123-date","text":"Function: (rfc-1123-date &optional (time (get-universal-time))) Generates a time string according to RFC 1123. Default is current time. This can be used to send a 'Last-Modified' header - see HANDLE-IF-MODIFIED-SINCE.","title":"rfc-1123-date"},{"location":"hunchentoot/#script-name_2","text":"Function: (script-name object)","title":"script-name"},{"location":"hunchentoot/#server-protocol_2","text":"Function: (server-protocol object)","title":"server-protocol"},{"location":"hunchentoot/#session-cookie-name","text":"Function: (session-cookie-name acceptor) Returns the name (a string) of the cookie (or the GET parameter) which is used to store a session on the client side. The default is to use the string \"hunchentoot-session\", but you can specialize this function if you want another name.","title":"session-cookie-name"},{"location":"hunchentoot/#session-cookie-value","text":"Function: (session-cookie-value session) Returns a string which can be used to safely restore the session SESSION if as session has already been established. This is used as the value stored in the session cookie or in the corresponding GET parameter and verified by SESSION-VERIFY. A default method is provided and there's no reason to change it unless you want to use your own session objects.","title":"session-cookie-value"},{"location":"hunchentoot/#session-created","text":"Function: (session-created acceptor new-session) This function is called whenever a new session has been created. There's a default method which might trigger a session GC based on the value of *SESSION-GC-FREQUENCY*. The return value is ignored.","title":"session-created"},{"location":"hunchentoot/#session-db","text":"Function: (session-db acceptor) Returns the current session database which is an alist where each car is a session's ID and the cdr is the corresponding SESSION object itself. The default is to use a global list for all acceptors.","title":"session-db"},{"location":"hunchentoot/#session-db-lock","text":"Function: (session-db-lock acceptor &key whole-db-p) A function which returns a lock that will be used to prevent concurrent access to sessions. The first argument will be the acceptor that handles the current request, the second argument is true if the whole (current) session database is modified. If it is NIL, only one existing session in the database is modified. This function can return NIL which means that sessions or session databases will be modified without a lock held (for example for single-threaded environments). The default is to always return a global lock (ignoring the ACCEPTOR argument) for Lisps that support threads and NIL otherwise.","title":"session-db-lock"},{"location":"hunchentoot/#session-gc","text":"Function: (session-gc) Removes sessions from the current session database which are too old - see SESSION-TOO-OLD-P.","title":"session-gc"},{"location":"hunchentoot/#session-too-old-p","text":"Function: (session-too-old-p session) Returns true if the SESSION object SESSION has not been active in the last (SESSION-MAX-TIME SESSION) seconds.","title":"session-too-old-p"},{"location":"hunchentoot/#session-verify","text":"Function: (session-verify request) Tries to get a session identifier from the cookies (or alternatively from the GET parameters) sent by the client (see SESSION-COOKIE-NAME and SESSION-COOKIE-VALUE). This identifier is then checked for validity against the REQUEST object REQUEST. On success the corresponding session object (if not too old) is returned (and updated). Otherwise NIL is returned. A default method is provided and you only need to write your own one if you want to maintain your own sessions.","title":"session-verify"},{"location":"hunchentoot/#set-cookie","text":"Function: (set-cookie name &key (value \"\") expires max-age path domain secure http-only (reply *reply*)) Creates a cookie object from the parameters provided and adds it to the outgoing cookies of the REPLY object REPLY. If a cookie with the name NAME (case-sensitive) already exists, it is replaced.","title":"set-cookie"},{"location":"hunchentoot/#set-cookie_1","text":"Function: (set-cookie* cookie &optional (reply *reply*)) Adds the COOKIE object COOKIE to the outgoing cookies of the REPLY object REPLY. If a cookie with the same name (case-sensitive) already exists, it is replaced.","title":"set-cookie*"},{"location":"hunchentoot/#ssl-p","text":"Function: (ssl-p &optional (acceptor *acceptor*)) Whether the current connection to the client is secure. See ACCEPTOR-SSL-P.","title":"ssl-p"},{"location":"hunchentoot/#taskmaster-max-accept-count","text":"Function: (taskmaster-max-accept-count taskmaster) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT.","title":"taskmaster-max-accept-count"},{"location":"hunchentoot/#taskmaster-max-thread-count","text":"Function: (taskmaster-max-thread-count taskmaster) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit.","title":"taskmaster-max-thread-count"},{"location":"hunchentoot/#taskmaster-thread-count","text":"Function: (taskmaster-thread-count taskmaster) Returns the current number of taskmaster requests.","title":"taskmaster-thread-count"},{"location":"hunchentoot/#too-many-taskmaster-requests","text":"Function: (too-many-taskmaster-requests taskmaster socket) Signal a \"too many requests\" error, just prior to closing the connection.","title":"too-many-taskmaster-requests"},{"location":"hunchentoot/#url-decode","text":"Function: (url-decode string &optional (external-format *hunchentoot-default-external-format*)) Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"url-decode"},{"location":"hunchentoot/#url-encode","text":"Function: (url-encode string &optional (external-format *hunchentoot-default-external-format*)) URL-encodes a string using the external format EXTERNAL-FORMAT. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"url-encode"},{"location":"hunchentoot/#within-request-p","text":"Function: (within-request-p) True if we're in the context of a request, otherwise nil.","title":"within-request-p"},{"location":"hunchentoot/#10-configuration-variables","text":"","title":"10. CONFIGURATION VARIABLES"},{"location":"hunchentoot/#catch-errors-p","text":"Variable Whether Hunchentoot should catch and log errors (or rather invoke the debugger).","title":"*catch-errors-p*"},{"location":"hunchentoot/#content-types-for-url-rewrite","text":"Variable The content types for which url-rewriting is OK. See *REWRITE-FOR-SESSION-URLS* .","title":"*content-types-for-url-rewrite*"},{"location":"hunchentoot/#default-connection-timeout","text":"Variable The default connection timeout used when an acceptor is reading from and writing to a socket stream.","title":"*default-connection-timeout*"},{"location":"hunchentoot/#default-content-type","text":"Variable The default content-type header which is returned to the client. If this is text content type, the character set used for encoding the response will automatically be added to the content type in a ``charset'' attribute.","title":"*default-content-type*"},{"location":"hunchentoot/#dispatch-table","text":"Variable A global list of dispatch functions.","title":"*dispatch-table*"},{"location":"hunchentoot/#file-upload-hook","text":"Variable If this is not NIL, it should be a unary function which will be called with a pathname for each file which is uploaded to Hunchentoot. The pathname denotes the temporary file to which the uploaded file is written. The hook is called directly before the file is created.","title":"*file-upload-hook*"},{"location":"hunchentoot/#handle-http-errors-p","text":"","title":"*handle-http-errors-p*"},{"location":"hunchentoot/#header-stream","text":"Variable If this variable is not NIL, it should be bound to a stream to which incoming and outgoing headers will be written for debugging purposes.","title":"*header-stream*"},{"location":"hunchentoot/#http-error-handler","text":"","title":"*http-error-handler*"},{"location":"hunchentoot/#hunchentoot-default-external-format","text":"Variable The external format used to compute the REQUEST object.","title":"*hunchentoot-default-external-format*"},{"location":"hunchentoot/#hunchentoot-version","text":"","title":"*hunchentoot-version*"},{"location":"hunchentoot/#lisp-errors-log-level","text":"Variable Log level for Lisp errors. Should be one of :ERROR (the default), :WARNING, or :INFO.","title":"*lisp-errors-log-level*"},{"location":"hunchentoot/#lisp-warnings-log-level","text":"Variable Log level for Lisp warnings. Should be one of :ERROR, :WARNING (the default), or :INFO.","title":"*lisp-warnings-log-level*"},{"location":"hunchentoot/#log-lisp-backtraces-p","text":"Variable Whether Lisp backtraces should be logged. Only has an effect if [*LOG-LISP-ERRORS-P*](#log-lisp-errors-p] is true as well.","title":"*log-lisp-backtraces-p*"},{"location":"hunchentoot/#log-lisp-errors-p","text":"Variable Whether Lisp errors in request handlers should be logged.","title":"*log-lisp-errors-p*"},{"location":"hunchentoot/#log-lisp-warnings-p","text":"Variable Whether Lisp warnings in request handlers should be logged.","title":"*log-lisp-warnings-p*"},{"location":"hunchentoot/#methods-for-post-parameters","text":"Variable A list of the request method types (as keywords) for which Hunchentoot will try to compute POST-PARAMETERS .","title":"*methods-for-post-parameters*"},{"location":"hunchentoot/#rewrite-for-session-urls","text":"Variable Whether HTML pages should possibly be rewritten for cookie-less session-management.","title":"*rewrite-for-session-urls*"},{"location":"hunchentoot/#session-gc-frequency","text":"Variable A session GC (see function SESSION-GC) will happen every *SESSION-GC-FREQUENCY* requests (counting only requests which create a new session) if this variable is not NIL. See SESSION-CREATED .","title":"*session-gc-frequency*"},{"location":"hunchentoot/#session-max-time","text":"Variable The default time (in seconds) after which a session times out.","title":"*session-max-time*"},{"location":"hunchentoot/#session-secret","text":"Variable A random ASCII string that's used to encode the public session data. This variable is initially unbound and will be set (using RESET-SESSION-SECRET ) the first time a session is created, if necessary. You can prevent this from happening if you set the value yourself before starting acceptors.","title":"*session-secret*"},{"location":"hunchentoot/#show-lisp-backtraces-p","text":"Variable Whether Lisp errors shown in HTML output should contain backtrace information.","title":"*show-lisp-backtraces-p*"},{"location":"hunchentoot/#show-lisp-errors-p","text":"Variable Whether Lisp errors in request handlers should be shown in HTML output.","title":"*show-lisp-errors-p*"},{"location":"hunchentoot/#tmp-directory","text":"Variable Directory for temporary files created by MAKE-TMP-FILE-NAME.","title":"*tmp-directory*"},{"location":"hunchentoot/#use-remote-addr-for-sessions","text":"Variable Whether the client's remote IP (as returned by REAL-REMOTE-ADDR ) should be encoded into the session string. If this value is true, a session will cease to be accessible if the client's remote IP changes. This might for example be an issue if the client uses a proxy server which doesn't send correct 'X_FORWARDED_FOR' headers.","title":"*use-remote-addr-for-sessions*"},{"location":"hunchentoot/#use-user-agent-for-sessions","text":"Variable Whether the 'User-Agent' header should be encoded into the session string. If this value is true, a session will cease to be accessible if the client sends a different 'User-Agent' header.","title":"*use-user-agent-for-sessions*"},{"location":"hunchentoot/#11-variables-in-the-context-of-a-request","text":"","title":"11. VARIABLES IN THE CONTEXT OF A REQUEST"},{"location":"hunchentoot/#acceptor_1","text":"Variable The current ACCEPTOR object.","title":"*acceptor*"},{"location":"hunchentoot/#reply","text":"Variable The current REPLY object.","title":"*reply*"},{"location":"hunchentoot/#request","text":"Variable The current REQUEST object.","title":"*request*"},{"location":"hunchentoot/#session_1","text":"Variable The current SESSION (can be NIL).","title":"*session*"},{"location":"hunchentoot/#12-constants","text":"","title":"12. CONSTANTS"},{"location":"hunchentoot/#http-accepted","text":"Constant: 202 HTTP return code (202) for 'Accepted'.","title":"+http-accepted+"},{"location":"hunchentoot/#http-authorization-required","text":"Constant: 401 HTTP return code (401) for 'Authorization Required'.","title":"+http-authorization-required+"},{"location":"hunchentoot/#http-bad-gateway","text":"Constant: 502 HTTP return code (502) for 'Bad Gateway'.","title":"+http-bad-gateway+"},{"location":"hunchentoot/#http-bad-request","text":"Constant: 400 HTTP return code (400) for 'Bad Request'.","title":"+http-bad-request+"},{"location":"hunchentoot/#http-conflict","text":"Constant: 409 HTTP return code (409) for 'Conflict'.","title":"+http-conflict+"},{"location":"hunchentoot/#http-continue","text":"Constant: 100 HTTP return code (100) for 'Continue'.","title":"+http-continue+"},{"location":"hunchentoot/#http-created","text":"Constant: 201 HTTP return code (201) for 'Created'.","title":"+http-created+"},{"location":"hunchentoot/#http-expectation-failed","text":"Constant: 417 HTTP return code (417) for 'Expectation Failed'.","title":"+http-expectation-failed+"},{"location":"hunchentoot/#http-failed-dependency","text":"Constant: 424 HTTP return code (424) for 'Failed Dependency'.","title":"+http-failed-dependency+"},{"location":"hunchentoot/#http-forbidden","text":"Constant: 403 HTTP return code (403) for 'Forbidden'.","title":"+http-forbidden+"},{"location":"hunchentoot/#http-gateway-time-out","text":"Constant: 504 HTTP return code (504) for 'Gateway Time-out'.","title":"+http-gateway-time-out+"},{"location":"hunchentoot/#http-gone","text":"Constant: 410 HTTP return code (410) for 'Gone'.","title":"+http-gone+"},{"location":"hunchentoot/#http-internal-server-error","text":"Constant: 500 HTTP return code (500) for 'Internal Server Error'.","title":"+http-internal-server-error+"},{"location":"hunchentoot/#http-length-required","text":"Constant: 411 HTTP return code (411) for 'Length Required'.","title":"+http-length-required+"},{"location":"hunchentoot/#http-method-not-allowed","text":"Constant: 405 HTTP return code (405) for 'Method Not Allowed'.","title":"+http-method-not-allowed+"},{"location":"hunchentoot/#http-moved-permanently","text":"Constant: 301 HTTP return code (301) for 'Moved Permanently'.","title":"+http-moved-permanently+"},{"location":"hunchentoot/#http-moved-temporarily","text":"Constant: 302 HTTP return code (302) for 'Moved Temporarily'.","title":"+http-moved-temporarily+"},{"location":"hunchentoot/#http-multi-status","text":"Constant: 207 HTTP return code (207) for 'Multi-Status'.","title":"+http-multi-status+"},{"location":"hunchentoot/#http-multiple-choices","text":"Constant: 300 HTTP return code (300) for 'Multiple Choices'.","title":"+http-multiple-choices+"},{"location":"hunchentoot/#http-network-authentication-required","text":"Constant: 511 HTTP return code (511) for 'Network Authentication Required'.","title":"+http-network-authentication-required+"},{"location":"hunchentoot/#http-no-content","text":"Constant: 204 HTTP return code (204) for 'No Content'.","title":"+http-no-content+"},{"location":"hunchentoot/#http-non-authoritative-information","text":"Constant: 203 HTTP return code (203) for 'Non-Authoritative Information'.","title":"+http-non-authoritative-information+"},{"location":"hunchentoot/#http-not-acceptable","text":"Constant: 406 HTTP return code (406) for 'Not Acceptable'.","title":"+http-not-acceptable+"},{"location":"hunchentoot/#http-not-found","text":"Constant: 404 HTTP return code (404) for 'Not Found'.","title":"+http-not-found+"},{"location":"hunchentoot/#http-not-implemented","text":"Constant: 501 HTTP return code (501) for 'Not Implemented'.","title":"+http-not-implemented+"},{"location":"hunchentoot/#http-not-modified","text":"Constant: 304 HTTP return code (304) for 'Not Modified'.","title":"+http-not-modified+"},{"location":"hunchentoot/#http-ok","text":"Constant: 200 HTTP return code (200) for 'OK'.","title":"+http-ok+"},{"location":"hunchentoot/#http-partial-content","text":"Constant: 206 HTTP return code (206) for 'Partial Content'.","title":"+http-partial-content+"},{"location":"hunchentoot/#http-payment-required","text":"Constant: 402 HTTP return code (402) for 'Payment Required'.","title":"+http-payment-required+"},{"location":"hunchentoot/#http-precondition-failed","text":"Constant: 412 HTTP return code (412) for 'Precondition Failed'.","title":"+http-precondition-failed+"},{"location":"hunchentoot/#http-precondition-required","text":"Constant: 428 HTTP return code (428) for 'Precondition Required'.","title":"+http-precondition-required+"},{"location":"hunchentoot/#http-proxy-authentication-required","text":"Constant: 407 HTTP return code (407) for 'Proxy Authentication Required'.","title":"+http-proxy-authentication-required+"},{"location":"hunchentoot/#http-request-entity-too-large","text":"Constant: 413 HTTP return code (413) for 'Request Entity Too Large'.","title":"+http-request-entity-too-large+"},{"location":"hunchentoot/#http-request-header-fields-too-large","text":"Constant: 431 HTTP return code (431) for 'Request Header Fields Too Large'.","title":"+http-request-header-fields-too-large+"},{"location":"hunchentoot/#http-request-time-out","text":"Constant: 408 HTTP return code (408) for 'Request Time-out'.","title":"+http-request-time-out+"},{"location":"hunchentoot/#http-request-uri-too-large","text":"Constant: 414 HTTP return code (414) for 'Request-URI Too Large'.","title":"+http-request-uri-too-large+"},{"location":"hunchentoot/#http-requested-range-not-satisfiable","text":"Constant: 416 HTTP return code (416) for 'Requested range not satisfiable'.","title":"+http-requested-range-not-satisfiable+"},{"location":"hunchentoot/#http-reset-content","text":"Constant: 205 HTTP return code (205) for 'Reset Content'.","title":"+http-reset-content+"},{"location":"hunchentoot/#http-see-other","text":"Constant: 303 HTTP return code (303) for 'See Other'.","title":"+http-see-other+"},{"location":"hunchentoot/#http-service-unavailable","text":"Constant: 503 HTTP return code (503) for 'Service Unavailable'.","title":"+http-service-unavailable+"},{"location":"hunchentoot/#http-switching-protocols","text":"Constant: 101 HTTP return code (101) for 'Switching Protocols'.","title":"+http-switching-protocols+"},{"location":"hunchentoot/#http-temporary-redirect","text":"Constant: 307 HTTP return code (307) for 'Temporary Redirect'.","title":"+http-temporary-redirect+"},{"location":"hunchentoot/#http-too-many-requests","text":"Constant: 429 HTTP return code (429) for 'Too Many Requests'.","title":"+http-too-many-requests+"},{"location":"hunchentoot/#http-unsupported-media-type","text":"Constant: 415 HTTP return code (415) for 'Unsupported Media Type'.","title":"+http-unsupported-media-type+"},{"location":"hunchentoot/#http-use-proxy","text":"Constant: 305 HTTP return code (305) for 'Use Proxy'.","title":"+http-use-proxy+"},{"location":"hunchentoot/#http-version-not-supported","text":"Constant: 505 HTTP return code (505) for 'Version not supported'.","title":"+http-version-not-supported+"},{"location":"hunchentoot/#13-hunchentoot-condition","text":"Class Superclass for all conditions related to Hunchentoot.","title":"13. HUNCHENTOOT-CONDITION"},{"location":"hunchentoot/#14-hunchentoot-warning","text":"Class Superclass for all warnings related to Hunchentoot.","title":"14. HUNCHENTOOT-WARNING"},{"location":"hunchentoot/#15-taskmaster","text":"","title":"15. TASKMASTER"},{"location":"hunchentoot/#taskmaster_1","text":"Class An instance of this class is responsible for distributing the work of handling requests for its acceptor. This is an \"abstract\" class in the sense that usually only instances of subclasses of TASKMASTER will be used. Direct superclasses: STANDARD-OBJECT Direct subclasses: MULTI-THREADED-TASKMASTER , SINGLE-THREADED-TASKMASTER","title":"taskmaster"},{"location":"hunchentoot/#relevant-methods_4","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#shutdown","text":"Function: (shutdown taskmaster) Shuts down the taskmaster, i.e. frees all resources that were set up by it. For example, a multi-threaded taskmaster might terminate all threads that are currently associated with it. This function is called by the acceptor's STOP method.","title":"shutdown"},{"location":"hunchentoot/#execute-acceptor","text":"Function: (execute-acceptor taskmaster) This is a callback called by the acceptor once it has performed all initial processing to start listening for incoming connections (see START-LISTENING). It usually calls the ACCEPT-CONNECTIONS method of the acceptor, but depending on the taskmaster instance the method might be called from a new thread.","title":"execute-acceptor"},{"location":"hunchentoot/#handle-incoming-connection","text":"Function: (handle-incoming-connection taskmaster socket) This function is called by the acceptor to start processing of requests on a new incoming connection. SOCKET is the usocket instance that represents the new connection (or a socket handle on LispWorks). The taskmaster starts processing requests on the incoming connection by calling the PROCESS-CONNECTION method of the acceptor instance. The SOCKET argument is passed to PROCESS-CONNECTION as an argument.","title":"handle-incoming-connection"},{"location":"hunchentoot/#start-thread","text":"Function: (start-thread taskmaster thunk &key name) Start a name thread in which to call the THUNK, in the context of the given TASKMASTER. Keyword arguments provide TASKMASTER-dependent options. Return a thread object. Hunchentoot taskmaster methods will call it with the taskmaster as the context, allowing hunchentoot extensions to define specialized methods that may e.g. wrap the thunk within a proper set of bindings and condition handlers.","title":"start-thread"},{"location":"hunchentoot/#direct-slots_1","text":"","title":"DIRECT SLOTS"},{"location":"hunchentoot/#acceptor_2","text":"Readers: taskmaster-acceptor Writers: (setf taskmaster-acceptor) A backpointer to the acceptor instance this taskmaster works for.","title":"acceptor"},{"location":"hunchentoot/#multi-threaded-taskmaster","text":"Class An abstract class for taskmasters that use multiple threads. For a concrete class to instantiate, use one-thread-per-connection-taskmaster. Direct superclasses: TASKMASTER Direct subclasses: ONE-THREAD-PER-CONNECTION-TASKMASTER","title":"multi-threaded-taskmaster"},{"location":"hunchentoot/#direct-slots_2","text":"","title":"DIRECT SLOTS"},{"location":"hunchentoot/#acceptor-process","text":"A process that accepts incoming connections and hands them off to new processes for request handling.","title":"acceptor-process"},{"location":"hunchentoot/#one-thread-per-connection-taskmaster","text":"Class A taskmaster that starts one thread for listening to incoming requests and one new thread for each incoming connection. If MAX-THREAD-COUNT is null, a new thread will always be created for each request. If MAX-THREAD-COUNT is supplied, the number of request threads is limited to that. Furthermore, if MAX-ACCEPT-COUNT is not supplied, an HTTP 503 will be sent if the thread limit is exceeded. Otherwise, if MAX-ACCEPT-COUNT is supplied, it must be greater than MAX-THREAD-COUNT; in this case, requests are accepted up to MAX-ACCEPT-COUNT, and only then is HTTP 503 sent. It is important to note that MAX-ACCEPT-COUNT and the HTTP 503 behavior described above is racing with the acceptor listen backlog. If we are receiving requests faster than threads can be spawned and 503 sent, the requests will be silently rejected by the kernel. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide MAX-THREAD-COUNT but leave MAX-ACCEPT-COUNT null. This will immediately result in HTTP 503 when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both MAX-THREAD-COUNT and a somewhat larger value for MAX-ACCEPT-COUNT. This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be HTTP 503. This is the default taskmaster implementation for multi-threaded Lisp implementations. Direct superclasses: MULTI-THREADED-TASKMASTER No subclasses.","title":"one-thread-per-connection-taskmaster"},{"location":"hunchentoot/#direct-slots_3","text":"","title":"DIRECT SLOTS"},{"location":"hunchentoot/#max-thread-count","text":"Type: (OR INTEGER NULL) Initargs: :max-thread-count Readers: taskmaster-max-thread-count Writers: (setf taskmaster-max-thread-count) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit.","title":"max-thread-count"},{"location":"hunchentoot/#thread-count","text":"Type: INTEGER Initform: 0 Readers: taskmaster-thread-count Writers: (setf taskmaster-thread-count) The number of taskmaster processing threads currently running.","title":"thread-count"},{"location":"hunchentoot/#thread-count-lock","text":"In the absence of 'atomic-incf', we need this to atomically increment and decrement the request count.","title":"thread-count-lock"},{"location":"hunchentoot/#max-accept-count","text":"Type: (OR INTEGER NULL) Initargs: :max-accept-count Readers: taskmaster-max-accept-count Writers: (setf taskmaster-max-accept-count) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT.","title":"max-accept-count"},{"location":"hunchentoot/#accept-count","text":"Type: INTEGER Initform: 0 The number of connection currently accepted by the taskmaster. These connections are not ensured to be processed, thay may be waiting for an empty processing slot or rejected because the load is too heavy.","title":"accept-count"},{"location":"hunchentoot/#accept-count-lock","text":"In the absence of 'atomic-incf', we need this to atomically increment and decrement the accept count.","title":"accept-count-lock"},{"location":"hunchentoot/#wait-queue","text":"A queue that we use to wait for a free connection.","title":"wait-queue"},{"location":"hunchentoot/#wait-lock","text":"The lock for the connection wait queue.","title":"wait-lock"},{"location":"hunchentoot/#worker-thread-name-format","text":"Type: (OR STRING NULL) Initargs: :worker-thread-name-format Initform: \"hunchentoot-worker-~A\"","title":"worker-thread-name-format"},{"location":"hunchentoot/#single-threaded-taskmaster","text":"Class A taskmaster that runs synchronously in the thread where the START function was invoked (or in the case of LispWorks in the thread started by COMM:START-UP-SERVER). This is the simplest possible taskmaster implementation in that its methods do nothing but calling their acceptor \"sister\" methods - EXECUTE-ACCEPTOR calls ACCEPT-CONNECTIONS, HANDLE-INCOMING-CONNECTION calls PROCESS-CONNECTION. Direct superclasses: TASKMASTER","title":"single-threaded-taskmaster"},{"location":"hunchentoot/#advanced-topics","text":"","title":"ADVANCED TOPICS"},{"location":"hunchentoot/#customizing-session-behaviour","text":"For everyday session usage, you will probably just use START-SESSION , SESSION-VALUE , and maybe DELETE-SESSION-VALUE and *SESSION* . However, there are two ways to customize the way Hunchentoot maintains sessions. One way is to mostly leave the session mechanism intact but to tweak it a bit: The publicly visible part of a session is encoded using a secret which you can set yourself. And it is stored using a cookie (or GET parameter) name that you can override. Each session receives a new ID when it is created and you can implement a more robust way to do that. You can arrange to be called whenever a session is created to trigger some action. You might also do this to invent your own session garbage collection . By default, all sessions are stored in a global alist in memory. You can't change the alist part, but you can distribute your sessions over different \"databases\" . By default, every operation which modifies sessions or one of the session databases is guarded by a global lock, but you can arrange to provide different locks for this. The other way to customize Hunchentoot's sessions is to completely replace them. This is actually pretty easy: Create your own class to store state (which doesn't have to and probably shouldn't inherit from SESSION ) and implement methods for SESSION-VERIFY and SESSION-COOKIE-VALUE - that's it. Hunchentoot will continue to use cookies and/or to rewrite URLs to keep track of session state and it will store \"the current session\" (whatever that is in your implementation) in *SESSION* . Everything else (like persisting sessions, GC, getting and setting values) you'll have to take care of yourself and the other session functions (like START-SESSION or SESSION-VALUE ) won't work anymore. (Almost) total freedom, but a lot of responsibility as well... :) reset-session-secret session-cookie-name session-cookie-value session-created next-session-id session-db session-db-lock session-verify","title":"CUSTOMIZING SESSION BEHAVIOUR"},{"location":"hunchentoot/#customizing-acceptor-behaviour","text":"If you want to modify what acceptors do, you should subclass ACCEPTOR (or SSL-ACCEPTOR ) and specialize the generic functions that constitute their behaviour (see example below). The life of an acceptor looks like this: It is started with the function START which immediately calls START-LISTENING and then applies the function EXECUTE-ACCEPTOR to its taskmaster . This function will eventually call ACCEPT-CONNECTIONS which is responsible for setting things up to wait for clients to connect. For each incoming connection which comes in, HANDLE-INCOMING-CONNECTION is applied to the taskmaster which will either call PROCESS-CONNECTION directly, or will create a thread to call it. PROCESS-CONNECTION calls INITIALIZE-CONNECTION-STREAM before it does anything else, then it selects and calls a function which handles the request , and finally it sends the reply to the client before it calls RESET-CONNECTION-STREAM . If the connection is persistent, this procedure is repeated (except for the intialization step) in a loop until the connection is closed. The acceptor is stopped with STOP . If you just want to use the standard acceptors that come with Hunchentoot, you don't need to know anything about the functions listed in this section. start-listening accept-connections acceptor-log-access acceptor-log-message acceptor-status-message detach-socket initialize-connection-stream process-connection reset-connection-stream","title":"CUSTOMIZING ACCEPTOR BEHAVIOUR"},{"location":"hunchentoot/#an-example-of-how-to-subclass-acceptor","text":"This example shows how to subclass ACCEPTOR in order to provide Hunchentoot with basic virtual host support. It assumes Hunchentoot is sitting behind an Internet-facing reverse-proxy web server that maps the host (or domain) part of incoming HTTP requests to unique localhost ports. (ql:quickload '(\"hunchentoot\" \"drakma\")) ;;; Subclass ACCEPTOR (defclass vhost (hunchentoot:acceptor) ;; slots ((dispatch-table :initform '() :accessor dispatch-table :documentation \"List of dispatch functions\")) ;; options (:default-initargs ; default-initargs must be used :address \"127.0.0.1\")) ; because ACCEPTOR uses it ;;; Specialise ACCEPTOR-DISPATCH-REQUEST for VHOSTs (defmethod hunchentoot:acceptor-dispatch-request ((vhost vhost) request) ;; try REQUEST on each dispatcher in turn (mapc (lambda (dispatcher) (let ((handler (funcall dispatcher request))) (when handler ; Handler found. FUNCALL it and return result (return-from hunchentoot:acceptor-dispatch-request (funcall handler))))) (dispatch-table vhost)) (call-next-method)) ;;; ====================================================================== ;;; Now all we need to do is test it ;;; Instantiate VHOSTs (defvar vhost1 (make-instance 'vhost :port 50001)) (defvar vhost2 (make-instance 'vhost :port 50002)) ;;; Populate each dispatch table (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo1) (dispatch-table vhost1)) (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo2) (dispatch-table vhost2)) ;;; Define handlers (defun foo1 () \"Hello\") (defun foo2 () \"Goodbye\") ;;; Start VHOSTs (hunchentoot:start vhost1) (hunchentoot:start vhost2) ;;; Make some requests (drakma:http-request \"http://127.0.0.1:50001/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:39] \"GET /foo HTTP/1.1\" 200 5 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Hello\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"5\") (:DATE . \"Fri, 08 Jun 2012 14:30:39 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50001/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CA90059}> ;;; T ;;; \"OK\" (drakma:http-request \"http://127.0.0.1:50002/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:47] \"GET /foo HTTP/1.1\" 200 7 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Goodbye\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"7\") (:DATE . \"Fri, 08 Jun 2012 14:30:47 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50002/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CAE8059}> ;;; T ;;; \"OK\" How to make each VHOST write to separate access log streams (or files) is left as an exercise to the reader.","title":"An example of how to subclass ACCEPTOR"},{"location":"hunchentoot/#taskmasters","text":"As a \"normal\" Hunchentoot user, you can completely ignore taskmasters and skip this section. But if you're still reading, here are the dirty details: Each acceptor has a taskmaster associated with it at creation time. It is the taskmaster's job to distribute the work of accepting and handling incoming connections. The acceptor calls the taskmaster if appropriate and the taskmaster calls back into the acceptor. This is done using the generic functions described in this and the previous section. Hunchentoot comes with two standard taskmaster implementations - one (which is the default used on multi-threaded Lisps) which starts a new thread for each incoming connection and one which handles all requests sequentially. It should for example be relatively straightforward to create a taskmaster which allocates threads from a fixed pool instead of creating a new one for each connection. You can control the resources consumed by a threaded taskmaster via two initargs. :max-thread-count lets you set the maximum number of request threads that can be processes simultaneously. If this is nil , the is no thread limit imposed. :max-accept-count lets you set the maximum number of requests that can be outstanding (i.e. being processed or queued for processing). If :max-thread-count is supplied and :max-accept-count is NIL , then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated if there are more than the max-thread-count threads processing requests. If both :max-thread-count and :max-accept-count are supplied, then max-thread-count must be less than max-accept-count; if more than max-thread-count requests are being processed, then requests up to max-accept-count will be queued until a thread becomes available. If more than max-accept-count requests are outstanding, then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide :max-thread-count but leave :max-accept-count null. This will immediately result in +HTTP-SERVICE-UNAVAILABLE+ when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both :max-thread-count and a somewhat larger value for :max-accept-count . This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be +HTTP-SERVICE-UNAVAILABLE+ . The default for these values is 100 and 120, respectively. If you want to implement your own taskmasters, you should subclass TASKMASTER or one of its subclasses, SINGLE-THREADED-TASKMASTER or ONE-THREAD-PER-CONNECTION-TASKMASTER , and specialize the generic functions in this section. execute-acceptor handle-incoming-connection start-thread create-request-handler-thread shutdown Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"TASKMASTERS"},{"location":"hunchentoot/#some-more-technical-details","text":"Hunchentoot will only work with Lisps where the character codes of all Latin-1 characters coincide with their Unicode code points (which is the case for all current implementations I know). Source code can be downloaded from https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz . The current development version of Hunchentoot can be found at https://github.com/edicl/hunchentoot . If you want to send patches, please fork the github repository and send pull requests.","title":"SOME MORE TECHNICAL DETAILS"},{"location":"hunchentoot/#without-clssl","text":"You can compile Hunchentoot without SSL support - and thus without the need to have CL+SSL - if you add :HUNCHENTOOT-NO-SSL to *FEATURES* before you compile it.","title":"Without cl+ssl"},{"location":"hunchentoot/#clbuild","text":"Hunchentoot and its dependencies can also be installed with clbuild .","title":"clbuild"},{"location":"hunchentoot/#gentoo-linux","text":"There's also a port for Gentoo Linux thanks to Matthew Kennedy.","title":"Gentoo Linux"},{"location":"hunchentoot/#running-hunchentoot-on-port-80","text":"Hunchentoot does not come with code to help with running it on a privileged port (i.e. port 80 or 443) on Unix-like operating systems. Modern Unix-like systems have specific, non-portable ways to allow non-root users to listen to privileged ports, so including such functionality in Hunchentoot was considered unnecessary. Please refer to online resources for help. At the time of this writing, the YAWS documentation has a comprehensive writeup on the topic.","title":"Running Hunchentoot on port 80"},{"location":"hunchentoot/#hunchentoot-behind-a-proxy","text":"If you're feeling unsecure about exposing Hunchentoot to the wild, wild Internet or if your Lisp web application is part of a larger website, you can hide it behind a proxy server . One approach that I have used several times is to employ Apache's mod_proxy module with a configuration that looks like this: ProxyPass /hunchentoot http://127.0.0.1:3000/hunchentoot ProxyPassReverse /hunchentoot http://127.0.0.1:3000/hunchentoot This will tunnel all requests where the URI path begins with \"/hunchentoot\" to a (Hunchentoot) server listening on port 3000 on the same machine. Of course, there are several other (more lightweight) web proxies that you could use instead of Apache.","title":"Hunchentoot behind a proxy"},{"location":"hunchentoot/#support","text":"The development version of Hunchentoot can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"SUPPORT"},{"location":"iterate/","text":"iterate - Psuedocodic Iteration Version: 1.5 Repository: iterate/iterate - Gitlab In case of any inaccuracies, ambiguities or suggestions, please create an issue here . iterate is a powerful iteration facility for Common Lisp, and a alternative to loop . As opposed to loop , iterate is more lispy, extensible, besides being more powerful. See The Iterate Manual for a more detailed explanation of the various facilities. For a tutorial on looping in Common Lisp, check out Loops, Iterate and Mapping - The Common Lisp Cookbook . HIGHLIGHTS def* : extensibility display-iterate-clauses : quick help for clauses dsetq : for use outside the iter form finally-protected : for protecting against unwindings finding-maximizing : loop equivalent can be quite verbose for : lots of variants! generate in : loop equivalent can be quite verbose there's no support for \"true\" parallel assignment - see with OTHER POINTS iterate does not declare variables unless asked to. See Types and Declarations . into var stores the value into var instead of returning it. There, probably, are some idiosyncrasies involved with running the epilogue code - it is not run \"always\": always , finding , finish , thereis . Notes for myself - indications of incomplete documentation Documentation for finding is incomplete here. Documentation for def* , for has been omitted here. When are the variable values for prologue defined? Will there be future versions of iterate? What is the compatibility relation between terminate and finish for for-next Generalized Drivers ? Installation If quicklisp is set-up, simply (ql:quickload 'iterate) . Otherwise head over here . Accumulation vs Reduction The differences between accumulate and reducing are slight. One difference is that the functions take their arguments in a different order. Another is that in the absence of init-val, accumulate will use nil, whereas reducing will generate different code that avoids any dependence on the initial value. The reason for having both clauses is that one usually thinks of reductions (like sum) and accumulations (like collect) as different beasts. API (CLAUSE) REFERENCE accumulate accumulate expr by func &optional initial-value init-val into var This is a general-purpose accumulation clause. func should be a function of two arguments, the value of expr and the value accumulated so far in the iteration, and it should return the updated value. If no initial value is supplied, nil is used. CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)))) (3 2 1) CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)) initial-value '(init))) (3 2 1 INIT) CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)) initial-value '(init) into var)) NIL See Accumulations , Accumulation vs Reduction and reducing . accumulating An alias for accumulate . adjoining adjoining exptr &optional into var test test at place result-type type Like collect , but only adds the value of exptr if it is not already present. test, which defaults to #'eql, is the test to be used with member. after-each after-each &rest forms Executes forms at the end of the loop body, after each iteration. Forms may contain iterate clauses. CL-USER> (iter (for i below 4) (after-each (print var)) (if (oddp i) (collect i into var) (collect (* 2 i) into var))) ; (0) ; (0 1) ; (0 1 4) ; (0 1 4 3) NIL See Code Placement and Problems with Code Movement . always always expr CL-USER> (iter (for i below 4) (always (evenp i))) NIL If expr ever evaluates to nil, then nil is immediately returned; the epilogue code is not executed. If expr never evaluates to nil, the epilogue code is executed and the last value of expr (or t if expr was never evaluated) is returned (whereas loop would constantly return t). See Aggregated Boolean Tests . appending appending exptr &optional into var at place Like collect , but behaves like the Common Lisp append , and works only on lists. CL-USER> (iter (for i in '((1) (2 3) (4 5 6))) (appending i)) (1 2 3 4 5 6) CL-USER> (iter (for i in '((1) (2 3) (4 5 6))) (appending i into var)) NIL See Accumulations . as An alias for for . collect collect exptr &optional into var test test at place result-type type CL-USER> (iter (for i from 1 to 5) (collect i)) (1 2 3 4 5) CL-USER> (iter (for i from 1 to 5) (collect i at start)) ;; likely to be faster (5 4 3 2 1) place can be either beginning / start or end : default value is end . type should be a subtype of sequence - default is list ; however, the type of sequence being constructed inside the loop is undefined when a non-list type is specified. CL-USER> (iter (for i from 1 to 3) (collect i into vec result-type 'vector) (print vec) (finally (return vec))) ; (1) ; (1 2) ; (1 2 3) #(1 2 3) type or place may be optionally quoted. See Accumulations . collecting Alias for collect . count Alias for counting . This, probably, overrides the CL count when used in top-level inside an iterate loop. CL-USER> (iter (for i in '(1 2 3)) (finally (return (count 1 '(1 2 1))))) 2 counting counting expr &optional into var See Reductions and accumulate . declare-variables (declare (declare-variables)) iterate does not declare variable types unless asked to. Declaration of types of user introduced symbols can be done by either the usual Common Lisp declare , but this declaration should be inside the iter form. Declaration of internal variables or use of the requires one to use declare-variables , or set iterate:::*always-declare-variables* to t`. CL-USER> (macroexpand-1 '(iter (for (the fixnum el) in '(1 2 3)) (declare (DECLARE-VARIABLES)) (count (oddp el)))) ;; note that this produces a type declaration for el. CL-USER> (macroexpand-1 '(iter (for el in '(1 2 3)) (declare (DECLARE-VARIABLES)) (count (oddp el)))) ;; this does not produce a type declaration for el. CL-USER> (macroexpand-1 '(iter (for (the fixnum el) in '(1 2 3)) (count (oddp el)))) ;; this does not produce any declarations. See Types and Declarations . defclause-sequence [Undocumented here.] See Extensibility Aids . defmacro-clause [Undocumented here] See Rolling Your Own . defmacro-driver [Undocumented here.] See Writing Drivers . defsynonym [Undocumented here.] See Extensibility Aids . display-iterate-clauses display-iterate-clauses &optional clause-spec CL-USER> (display-iterate-clauses 'repeat) ; REPEAT Repeat the loop some number of times T CL-USER> (display-iterate-clauses '(for in-vector)) ; FOR IN-VECTOR &OPTIONAL FROM UPFROM DOWNFROM TO DOWNTO ABOVE BELOW BY ; WITH-INDEX Elements of a vector T See On-line help . dsetq dsetq template expr Can be used outside iter. CL-USER> (foo) FIRST SECOND CL-USER> (progn (dsetq (values a b) (foo)) (list a b)) ;; undeclared variables warning (FIRST SECOND) See Destructuring . else else &rest forms Forms are executed if loop is never entered, but is terminated normally. CL-USER> (iter (for i in '(1 2 3)) (while nil) (else (write 'else))) ; ELSE NIL See Code Placement and Problems with Code Movement . finally finally &rest forms Forms are executed after a normal termination of the loop. CL-USER> (iter (for i in '(1 2 3)) (finally (write 'end))) ; END NIL See Code Placement and Problems with Code Movement . finally-protected finally-protected &rest forms Forms are executed \"always\" - regardless of whether the termination was notmal CL-USER> (iter (for i in-vector '(1 2 3)) (finally-protected (write 'error))) ;; warnings ERROR ; Evaluation aborted on #<SIMPLE-TYPE-ERROR expected-type: VECTOR datum: (1 2 3)>. CL-USER> (iter (for i in '(1 2 3)) (finally-protected (write 'no-error))) ; NO-ERROR NIL See Code Placement and Problems with Code Movement . finding finding expr such-that test &optionally into var on-failure failure-value The loop terminates (with epilogue code) whenever test evaluates to non- nil . expr that satifies the test , or failure-value , or nil is returned (unless modified by epilogue). failure-value is always evaluated. CL-USER> (iter (for x in '(1 2 3)) (finding x such-that #'evenp on-failure 'not-found)) 2 CL-USER> (iter (for x in '(1 2 3)) (finding x such-that #'evenp on-failure (error \"not found\"))) ; Evaluation aborted on #<SIMPLE-ERROR \"not found\" {1002F63063}>. CL-USER> (iter (for x in '(1 2 3)) (if (evenp x) (leave x)) (finally (error \"not found\"))) 2 finding expr maximizing m-expr &optionally into var finding expr minimizing m-expr &optionally into var Returns expr corresponding to the maximum value of m-expr . If m-expr is never evaluated (how?), the return value is nil or 0 depending on the type (or its absence) of expr (or var if supplied.) Here, m-expr can also be a list of two symbols. CL-USER> CL-USER> (iter (for list in '((1) (2 3) nil)) (finding list maximizing (length list))) (2 3) CL-USER> (iter (for i in '(1 2 3)) (finding (* 2 i) maximizing (- i) into (twice neg)) (finally (return (values twice neg)))) 2 -1 [Example required for the case when m-expr is not evaluated.] See Finders . finish finish Stop the loop (and run the epilogue code). CL-USER> (iter (for i in '(1 2 3)) (if (evenp i) (finish))) NIL See Control Flow . first-iteration-p first-iteration-p t in the first cycle of the loop, otherwise nil . CL-USER> (iter (for el in '(nil 1 2 nil 3)) (when el (unless (first-iteration-p) (princ \", \")) (princ el))) ; , 1, 2, 3 NIL See Boolean Tests . first-time-p first-iteration-p t only when the expression is evaluated for the first time. CL-USER> (iter (for el in '(nil 1 2 nil 3)) (when el (unless (first-time-p) (princ \", \")) (princ el))) ; 1, 2, 3 NIL See Boolean Tests . for [Undocumented here.] See Numeric Iteration Sequence Iteration Variable Binding and Setting Generalized Drivers Previous Values of Driver Variables generate See Generators and for . CL-USER> (iter (for el in '(a b nil c)) (generate i upfrom 1) (if el (collect (cons el (next i))))) ((A . 1) (B . 2) (C . 3)) for can be replaced by generate to achieve the desired result, except in the case of Variable Binding and Setting . generating Alias for generate if-first-time if-first-time then &optional else CL-USER> (iter (for i in '(1 2 3)) (if-first-time (princ 'first) (print 'not-first))) ; FIRST ; NOT-FIRST ; NOT-FIRST NIL See Control Flow . in in name &rest forms CL-USER> (defvar ar #2A((1 2 3) (4 5 6))) AR CL-USER> (iter outer (for i below (array-dimension ar 0)) (iter (for j below (array-dimension ar 1)) (in outer (collect (aref ar i j))))) (1 2 3 4 5 6) See Named Blocks . initially in &rest forms Place the forms in the prologue of the loop. CL-USER> (iter (initially (princ 'hi)) (for i below 3) (print i)) ; HI ; 0 ; 1 ; 2 NIL CL-USER> (iter (for i below 3) (initially (princ i))) ; -1 ;; this is probably an undefined behaviour. NIL See Code Placement and Problems with Code Movement . leave leave &optional value Returns from the current iterate form with value or nil . CL-USER> (iter (for i below 3) (leave (iter (for j below 2) (if (oddp j) (leave j))))) 1 See Control Flow . maximize maximize expr &optional into var CL-USER> (iter (for list in '((1) (1 2) nil)) (maximize (length list))) 2 See Reductions and finding . maximizing Alias for maximize . minimize minimize expr &optional into var CL-USER> (iter (for list in '((1) (1 2) nil)) (minimize (length list))) 0 See Reductions and finding . minimizing Alias for minimize . multiply multiply expr &optional into var CL-USER> (iter (for i from 1 to 5) (multiply i)) 120 Initial value of * var`* is 1. See Reductions . multiplying Alias for [multiply](# nconcing nconcing exptr &optional into var test test at place result-type type See Accumulations and collect . never never expr Effectively (always (not expr)) , but does not influence the last value returned by a possible other always clause. CL-USER> (iter (repeat 2) (always 2) (never nil)) 2 See Aggregated Boolean Tests next See generate . next-iteration next-iteration CL-USER> (iter (for i below 3) (if (oddp i) (next-iteration) (collect i))) (0 2) nunioning nunioning exptr &optional into var test test at place result-type type See Accumulations and collect . reducing reducing expr by func &optional initial-value init-val into var CL-USER> (iter (for i in '(1 2 3)) (reducing i by (lambda (value-so-far i) (cons i value-so-far)) initial-value ())) (3 2 1) See Reductions , Accumulation vs Reduction and accumulate . repeat repeat n Repeat the loop n times. See Drivers . CL-USER> (iter (repeat 3) (print 'doing)) ; DOING ; DOING ; DOING NIL sum sum expr &optional into var CL-USER> (iter (for i from 1 to 5) (sum i)) 15 summing Alias for sum . terminate `terminate Use to terminate for-next clause. Effectively an alias for finish - but use with for-next to maintain compatibility with future versions of iterate (!). CL-USER> (iter (for i upfrom 0) (if (> i 5) (terminate) (collect i))) (0 1 2 3 4 5) CL-USER> (iter (initially (setq i 0)) (for i next (if (> i 10) (terminate) (incf i)))) NIL See Generalized Drivers . thereis thereis expr If expr is ever non- nil , its value is returned without running the epilogue code. Otherwise epilogue code is run, and nil is returned. Cannot be used with always or never . See Aggregated Boolean Tests . unioning unioning exptr &optional into var test test at place result-type type See Accumulations and collect . until until expr CL-USER> (iter (for i in '(1 2 3 4 5)) (until (> i 5)) (collect i)) (1 2 3 4 5) Equivalent to (if expr (finish)) . See finish and Control Flow . while repeat n until expr Equivalent to (if (not expr) (finish)) . CL-USER> (iter (for i below 10) (while (= 0 (rem i 5))) (collect i)) (0) See finish and Control Flow . with with var &optional = value var is bound to value before the loop is entered. Binding happens sequentially, as while using a let* , and not in parallel as with let . CL-USER> (iter (with i = 0) (while (< i 3)) (collect (incf i))) (1 2 3) CL-USER> (iter (with i = 1) (for i below 3) (collect (incf i))) ; Evaluation aborted on #<SIMPLE-ERROR \"Iterate~@[, in ~a~]:~%Duplicate variable: ~a\" {1004185183}>. See Variable Binding and Setting and Parallel Binding and Stepping . OTHER RESOURCES ON ITERATE The Iterate Manual Comparing LOOP and ITERATE Loop v Iterate - SabraOnTheHill [DLI]: appendix/Don't Loop, Iterate","title":"iterate - Psuedocodic Iteration"},{"location":"iterate/#iterate-psuedocodic-iteration","text":"Version: 1.5 Repository: iterate/iterate - Gitlab In case of any inaccuracies, ambiguities or suggestions, please create an issue here . iterate is a powerful iteration facility for Common Lisp, and a alternative to loop . As opposed to loop , iterate is more lispy, extensible, besides being more powerful. See The Iterate Manual for a more detailed explanation of the various facilities. For a tutorial on looping in Common Lisp, check out Loops, Iterate and Mapping - The Common Lisp Cookbook .","title":"iterate - Psuedocodic Iteration"},{"location":"iterate/#highlights","text":"def* : extensibility display-iterate-clauses : quick help for clauses dsetq : for use outside the iter form finally-protected : for protecting against unwindings finding-maximizing : loop equivalent can be quite verbose for : lots of variants! generate in : loop equivalent can be quite verbose there's no support for \"true\" parallel assignment - see with","title":"HIGHLIGHTS"},{"location":"iterate/#other-points","text":"iterate does not declare variables unless asked to. See Types and Declarations . into var stores the value into var instead of returning it. There, probably, are some idiosyncrasies involved with running the epilogue code - it is not run \"always\": always , finding , finish , thereis .","title":"OTHER POINTS"},{"location":"iterate/#notes-for-myself-indications-of-incomplete-documentation","text":"Documentation for finding is incomplete here. Documentation for def* , for has been omitted here. When are the variable values for prologue defined? Will there be future versions of iterate? What is the compatibility relation between terminate and finish for for-next Generalized Drivers ?","title":"Notes for myself - indications of incomplete documentation"},{"location":"iterate/#installation","text":"If quicklisp is set-up, simply (ql:quickload 'iterate) . Otherwise head over here .","title":"Installation"},{"location":"iterate/#accumulation-vs-reduction","text":"The differences between accumulate and reducing are slight. One difference is that the functions take their arguments in a different order. Another is that in the absence of init-val, accumulate will use nil, whereas reducing will generate different code that avoids any dependence on the initial value. The reason for having both clauses is that one usually thinks of reductions (like sum) and accumulations (like collect) as different beasts.","title":"Accumulation vs Reduction"},{"location":"iterate/#api-clause-reference","text":"","title":"API (CLAUSE) REFERENCE"},{"location":"iterate/#accumulate","text":"accumulate expr by func &optional initial-value init-val into var This is a general-purpose accumulation clause. func should be a function of two arguments, the value of expr and the value accumulated so far in the iteration, and it should return the updated value. If no initial value is supplied, nil is used. CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)))) (3 2 1) CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)) initial-value '(init))) (3 2 1 INIT) CL-USER> (iter (for i in '(1 2 3)) (accumulate i by (lambda (i values-so-far) (cons i values-so-far)) initial-value '(init) into var)) NIL See Accumulations , Accumulation vs Reduction and reducing .","title":"accumulate"},{"location":"iterate/#accumulating","text":"An alias for accumulate .","title":"accumulating"},{"location":"iterate/#adjoining","text":"adjoining exptr &optional into var test test at place result-type type Like collect , but only adds the value of exptr if it is not already present. test, which defaults to #'eql, is the test to be used with member.","title":"adjoining"},{"location":"iterate/#after-each","text":"after-each &rest forms Executes forms at the end of the loop body, after each iteration. Forms may contain iterate clauses. CL-USER> (iter (for i below 4) (after-each (print var)) (if (oddp i) (collect i into var) (collect (* 2 i) into var))) ; (0) ; (0 1) ; (0 1 4) ; (0 1 4 3) NIL See Code Placement and Problems with Code Movement .","title":"after-each"},{"location":"iterate/#always","text":"always expr CL-USER> (iter (for i below 4) (always (evenp i))) NIL If expr ever evaluates to nil, then nil is immediately returned; the epilogue code is not executed. If expr never evaluates to nil, the epilogue code is executed and the last value of expr (or t if expr was never evaluated) is returned (whereas loop would constantly return t). See Aggregated Boolean Tests .","title":"always"},{"location":"iterate/#appending","text":"appending exptr &optional into var at place Like collect , but behaves like the Common Lisp append , and works only on lists. CL-USER> (iter (for i in '((1) (2 3) (4 5 6))) (appending i)) (1 2 3 4 5 6) CL-USER> (iter (for i in '((1) (2 3) (4 5 6))) (appending i into var)) NIL See Accumulations .","title":"appending"},{"location":"iterate/#as","text":"An alias for for .","title":"as"},{"location":"iterate/#collect","text":"collect exptr &optional into var test test at place result-type type CL-USER> (iter (for i from 1 to 5) (collect i)) (1 2 3 4 5) CL-USER> (iter (for i from 1 to 5) (collect i at start)) ;; likely to be faster (5 4 3 2 1) place can be either beginning / start or end : default value is end . type should be a subtype of sequence - default is list ; however, the type of sequence being constructed inside the loop is undefined when a non-list type is specified. CL-USER> (iter (for i from 1 to 3) (collect i into vec result-type 'vector) (print vec) (finally (return vec))) ; (1) ; (1 2) ; (1 2 3) #(1 2 3) type or place may be optionally quoted. See Accumulations .","title":"collect"},{"location":"iterate/#collecting","text":"Alias for collect .","title":"collecting"},{"location":"iterate/#count","text":"Alias for counting . This, probably, overrides the CL count when used in top-level inside an iterate loop. CL-USER> (iter (for i in '(1 2 3)) (finally (return (count 1 '(1 2 1))))) 2","title":"count"},{"location":"iterate/#counting","text":"counting expr &optional into var See Reductions and accumulate .","title":"counting"},{"location":"iterate/#declare-variables","text":"(declare (declare-variables)) iterate does not declare variable types unless asked to. Declaration of types of user introduced symbols can be done by either the usual Common Lisp declare , but this declaration should be inside the iter form. Declaration of internal variables or use of the requires one to use declare-variables , or set iterate:::*always-declare-variables* to t`. CL-USER> (macroexpand-1 '(iter (for (the fixnum el) in '(1 2 3)) (declare (DECLARE-VARIABLES)) (count (oddp el)))) ;; note that this produces a type declaration for el. CL-USER> (macroexpand-1 '(iter (for el in '(1 2 3)) (declare (DECLARE-VARIABLES)) (count (oddp el)))) ;; this does not produce a type declaration for el. CL-USER> (macroexpand-1 '(iter (for (the fixnum el) in '(1 2 3)) (count (oddp el)))) ;; this does not produce any declarations. See Types and Declarations .","title":"declare-variables"},{"location":"iterate/#defclause-sequence","text":"[Undocumented here.] See Extensibility Aids .","title":"defclause-sequence"},{"location":"iterate/#defmacro-clause","text":"[Undocumented here] See Rolling Your Own .","title":"defmacro-clause"},{"location":"iterate/#defmacro-driver","text":"[Undocumented here.] See Writing Drivers .","title":"defmacro-driver"},{"location":"iterate/#defsynonym","text":"[Undocumented here.] See Extensibility Aids .","title":"defsynonym"},{"location":"iterate/#display-iterate-clauses","text":"display-iterate-clauses &optional clause-spec CL-USER> (display-iterate-clauses 'repeat) ; REPEAT Repeat the loop some number of times T CL-USER> (display-iterate-clauses '(for in-vector)) ; FOR IN-VECTOR &OPTIONAL FROM UPFROM DOWNFROM TO DOWNTO ABOVE BELOW BY ; WITH-INDEX Elements of a vector T See On-line help .","title":"display-iterate-clauses"},{"location":"iterate/#dsetq","text":"dsetq template expr Can be used outside iter. CL-USER> (foo) FIRST SECOND CL-USER> (progn (dsetq (values a b) (foo)) (list a b)) ;; undeclared variables warning (FIRST SECOND) See Destructuring .","title":"dsetq"},{"location":"iterate/#else","text":"else &rest forms Forms are executed if loop is never entered, but is terminated normally. CL-USER> (iter (for i in '(1 2 3)) (while nil) (else (write 'else))) ; ELSE NIL See Code Placement and Problems with Code Movement .","title":"else"},{"location":"iterate/#finally","text":"finally &rest forms Forms are executed after a normal termination of the loop. CL-USER> (iter (for i in '(1 2 3)) (finally (write 'end))) ; END NIL See Code Placement and Problems with Code Movement .","title":"finally"},{"location":"iterate/#finally-protected","text":"finally-protected &rest forms Forms are executed \"always\" - regardless of whether the termination was notmal CL-USER> (iter (for i in-vector '(1 2 3)) (finally-protected (write 'error))) ;; warnings ERROR ; Evaluation aborted on #<SIMPLE-TYPE-ERROR expected-type: VECTOR datum: (1 2 3)>. CL-USER> (iter (for i in '(1 2 3)) (finally-protected (write 'no-error))) ; NO-ERROR NIL See Code Placement and Problems with Code Movement .","title":"finally-protected"},{"location":"iterate/#finding","text":"finding expr such-that test &optionally into var on-failure failure-value The loop terminates (with epilogue code) whenever test evaluates to non- nil . expr that satifies the test , or failure-value , or nil is returned (unless modified by epilogue). failure-value is always evaluated. CL-USER> (iter (for x in '(1 2 3)) (finding x such-that #'evenp on-failure 'not-found)) 2 CL-USER> (iter (for x in '(1 2 3)) (finding x such-that #'evenp on-failure (error \"not found\"))) ; Evaluation aborted on #<SIMPLE-ERROR \"not found\" {1002F63063}>. CL-USER> (iter (for x in '(1 2 3)) (if (evenp x) (leave x)) (finally (error \"not found\"))) 2 finding expr maximizing m-expr &optionally into var finding expr minimizing m-expr &optionally into var Returns expr corresponding to the maximum value of m-expr . If m-expr is never evaluated (how?), the return value is nil or 0 depending on the type (or its absence) of expr (or var if supplied.) Here, m-expr can also be a list of two symbols. CL-USER> CL-USER> (iter (for list in '((1) (2 3) nil)) (finding list maximizing (length list))) (2 3) CL-USER> (iter (for i in '(1 2 3)) (finding (* 2 i) maximizing (- i) into (twice neg)) (finally (return (values twice neg)))) 2 -1 [Example required for the case when m-expr is not evaluated.] See Finders .","title":"finding"},{"location":"iterate/#finish","text":"finish Stop the loop (and run the epilogue code). CL-USER> (iter (for i in '(1 2 3)) (if (evenp i) (finish))) NIL See Control Flow .","title":"finish"},{"location":"iterate/#first-iteration-p","text":"first-iteration-p t in the first cycle of the loop, otherwise nil . CL-USER> (iter (for el in '(nil 1 2 nil 3)) (when el (unless (first-iteration-p) (princ \", \")) (princ el))) ; , 1, 2, 3 NIL See Boolean Tests .","title":"first-iteration-p"},{"location":"iterate/#first-time-p","text":"first-iteration-p t only when the expression is evaluated for the first time. CL-USER> (iter (for el in '(nil 1 2 nil 3)) (when el (unless (first-time-p) (princ \", \")) (princ el))) ; 1, 2, 3 NIL See Boolean Tests .","title":"first-time-p"},{"location":"iterate/#for","text":"[Undocumented here.] See Numeric Iteration Sequence Iteration Variable Binding and Setting Generalized Drivers Previous Values of Driver Variables","title":"for"},{"location":"iterate/#generate","text":"See Generators and for . CL-USER> (iter (for el in '(a b nil c)) (generate i upfrom 1) (if el (collect (cons el (next i))))) ((A . 1) (B . 2) (C . 3)) for can be replaced by generate to achieve the desired result, except in the case of Variable Binding and Setting .","title":"generate"},{"location":"iterate/#generating","text":"Alias for generate","title":"generating"},{"location":"iterate/#if-first-time","text":"if-first-time then &optional else CL-USER> (iter (for i in '(1 2 3)) (if-first-time (princ 'first) (print 'not-first))) ; FIRST ; NOT-FIRST ; NOT-FIRST NIL See Control Flow .","title":"if-first-time"},{"location":"iterate/#in","text":"in name &rest forms CL-USER> (defvar ar #2A((1 2 3) (4 5 6))) AR CL-USER> (iter outer (for i below (array-dimension ar 0)) (iter (for j below (array-dimension ar 1)) (in outer (collect (aref ar i j))))) (1 2 3 4 5 6) See Named Blocks .","title":"in"},{"location":"iterate/#initially","text":"in &rest forms Place the forms in the prologue of the loop. CL-USER> (iter (initially (princ 'hi)) (for i below 3) (print i)) ; HI ; 0 ; 1 ; 2 NIL CL-USER> (iter (for i below 3) (initially (princ i))) ; -1 ;; this is probably an undefined behaviour. NIL See Code Placement and Problems with Code Movement .","title":"initially"},{"location":"iterate/#leave","text":"leave &optional value Returns from the current iterate form with value or nil . CL-USER> (iter (for i below 3) (leave (iter (for j below 2) (if (oddp j) (leave j))))) 1 See Control Flow .","title":"leave"},{"location":"iterate/#maximize","text":"maximize expr &optional into var CL-USER> (iter (for list in '((1) (1 2) nil)) (maximize (length list))) 2 See Reductions and finding .","title":"maximize"},{"location":"iterate/#maximizing","text":"Alias for maximize .","title":"maximizing"},{"location":"iterate/#minimize","text":"minimize expr &optional into var CL-USER> (iter (for list in '((1) (1 2) nil)) (minimize (length list))) 0 See Reductions and finding .","title":"minimize"},{"location":"iterate/#minimizing","text":"Alias for minimize .","title":"minimizing"},{"location":"iterate/#multiply","text":"multiply expr &optional into var CL-USER> (iter (for i from 1 to 5) (multiply i)) 120 Initial value of * var`* is 1. See Reductions .","title":"multiply"},{"location":"iterate/#multiplying","text":"Alias for [multiply](#","title":"multiplying"},{"location":"iterate/#nconcing","text":"nconcing exptr &optional into var test test at place result-type type See Accumulations and collect .","title":"nconcing"},{"location":"iterate/#never","text":"never expr Effectively (always (not expr)) , but does not influence the last value returned by a possible other always clause. CL-USER> (iter (repeat 2) (always 2) (never nil)) 2 See Aggregated Boolean Tests","title":"never"},{"location":"iterate/#next","text":"See generate .","title":"next"},{"location":"iterate/#next-iteration","text":"next-iteration CL-USER> (iter (for i below 3) (if (oddp i) (next-iteration) (collect i))) (0 2)","title":"next-iteration"},{"location":"iterate/#nunioning","text":"nunioning exptr &optional into var test test at place result-type type See Accumulations and collect .","title":"nunioning"},{"location":"iterate/#reducing","text":"reducing expr by func &optional initial-value init-val into var CL-USER> (iter (for i in '(1 2 3)) (reducing i by (lambda (value-so-far i) (cons i value-so-far)) initial-value ())) (3 2 1) See Reductions , Accumulation vs Reduction and accumulate .","title":"reducing"},{"location":"iterate/#repeat","text":"repeat n Repeat the loop n times. See Drivers . CL-USER> (iter (repeat 3) (print 'doing)) ; DOING ; DOING ; DOING NIL","title":"repeat"},{"location":"iterate/#sum","text":"sum expr &optional into var CL-USER> (iter (for i from 1 to 5) (sum i)) 15","title":"sum"},{"location":"iterate/#summing","text":"Alias for sum .","title":"summing"},{"location":"iterate/#terminate","text":"`terminate Use to terminate for-next clause. Effectively an alias for finish - but use with for-next to maintain compatibility with future versions of iterate (!). CL-USER> (iter (for i upfrom 0) (if (> i 5) (terminate) (collect i))) (0 1 2 3 4 5) CL-USER> (iter (initially (setq i 0)) (for i next (if (> i 10) (terminate) (incf i)))) NIL See Generalized Drivers .","title":"terminate"},{"location":"iterate/#thereis","text":"thereis expr If expr is ever non- nil , its value is returned without running the epilogue code. Otherwise epilogue code is run, and nil is returned. Cannot be used with always or never . See Aggregated Boolean Tests .","title":"thereis"},{"location":"iterate/#unioning","text":"unioning exptr &optional into var test test at place result-type type See Accumulations and collect .","title":"unioning"},{"location":"iterate/#until","text":"until expr CL-USER> (iter (for i in '(1 2 3 4 5)) (until (> i 5)) (collect i)) (1 2 3 4 5) Equivalent to (if expr (finish)) . See finish and Control Flow .","title":"until"},{"location":"iterate/#while","text":"repeat n until expr Equivalent to (if (not expr) (finish)) . CL-USER> (iter (for i below 10) (while (= 0 (rem i 5))) (collect i)) (0) See finish and Control Flow .","title":"while"},{"location":"iterate/#with","text":"with var &optional = value var is bound to value before the loop is entered. Binding happens sequentially, as while using a let* , and not in parallel as with let . CL-USER> (iter (with i = 0) (while (< i 3)) (collect (incf i))) (1 2 3) CL-USER> (iter (with i = 1) (for i below 3) (collect (incf i))) ; Evaluation aborted on #<SIMPLE-ERROR \"Iterate~@[, in ~a~]:~%Duplicate variable: ~a\" {1004185183}>. See Variable Binding and Setting and Parallel Binding and Stepping .","title":"with"},{"location":"iterate/#other-resources-on-iterate","text":"The Iterate Manual Comparing LOOP and ITERATE Loop v Iterate - SabraOnTheHill [DLI]: appendix/Don't Loop, Iterate","title":"OTHER RESOURCES ON ITERATE"},{"location":"local-time/","text":"local-time *clock* Variable Use the ` clock ' special variable if you need to define your own idea of the current time. The value of this variable should have the methods local-time::clock-now', and local-time::clock-today'. The currently supported values in local-time are: t - use the standard clock local-time:leap-second-adjusted - use a clock which adjusts for leap seconds using the information in default-timezone . +rfc-1123-format+ Variable See the RFC 1123 for the details about the possible values of the timezone field. adjust-timestamp Macro: (adjust-timestamp timestamp &body changes) adjust-timestamp! Macro: (adjust-timestamp! timestamp &body changes) astronomical-julian-date Function: (astronomical-julian-date timestamp) Returns the astronomical julian date referred to by the timestamp. clock-now Generic Function: (clock-now clock) Returns a timestamp for the current time given a clock. clock-today Generic Function: (clock-today clock) Returns a timestamp for the current date given a clock. The date is encoded by convention as a timestamp with the time set to 00:00:00UTC. clone-timestamp Function: (clone-timestamp timestamp) day-of Generic Function: (day-of object) days-in-month Function: (days-in-month month year) Returns the number of days in the given month of the specified year. decode-timestamp Function: (decode-timestamp timestamp &key (timezone *default-timezone*) offset) Returns the decoded time as multiple values: nsec, ss, mm, hh, day, month, year, day-of-week define-timezone Macro: (define-timezone zone-name zone-file &key (load NIL)) Define zone-name (a symbol or a string) as a new timezone, lazy-loaded from zone-file (a pathname designator relative to the zoneinfo directory on this system. If load is true, load immediately. enable-read-macros Function: (enable-read-macros) Enables the local-time reader macros for literal timestamps and universal time. encode-timestamp Function: (encode-timestamp nsec sec minute hour day month year &key (timezone *default-timezone*) offset into) Return a new timestamp instance corresponding to the specified time elements. find-timezone-by-location-name Function: (find-timezone-by-location-name name) format-rfc1123-timestring Function: (format-rfc1123-timestring destination timestamp &key (timezone *default-timezone*)) format-rfc3339-timestring Function: (format-rfc3339-timestring destination timestamp &key omit-date-part omit-time-part (omit-timezone-part omit-time-part) (use-zulu t) (timezone *default-timezone*)) Formats a timestring in the RFC 3339 format, a restricted form of the ISO-8601 timestring specification for Internet timestamps. format-timestring Function: (format-timestring destination timestamp &key (format +iso-8601-format+) (timezone *default-timezone*)) Constructs a string representation of timestamp according to format and returns it. If destination is T, the string is written to standard-output . If destination is a stream, the string is written to the stream. format is a list containing one or more of strings, characters, and keywords. Strings and characters are output literally, while keywords are replaced by the values here: :YEAR year :MONTH numeric month :DAY day of month :HOUR hour :MIN minutes :SEC seconds :WEEKDAY numeric day of week starting from index 0, which means Sunday :MSEC milliseconds :USEC microseconds :NSEC nanoseconds :ISO-WEEK-YEAR year for ISO week date (can be different from regular calendar year) :ISO-WEEK-NUMBER ISO week number (i.e. 1 through 53) :ISO-WEEK-DAY ISO compatible weekday number (monday=1, sunday=7) :LONG-WEEKDAY long form of weekday (e.g. Sunday, Monday) :SHORT-WEEKDAY short form of weekday (e.g. Sun, Mon) :MINIMAL-WEEKDAY minimal form of weekday (e.g. Su, Mo) :SHORT-YEAR short form of year (last 2 digits, e.g. 41, 42 instead of 2041, 2042) :LONG-MONTH long form of month (e.g. January, February) :SHORT-MONTH short form of month (e.g. Jan, Feb) :HOUR12 hour on a 12-hour clock :AMPM am/pm marker in lowercase :GMT-OFFSET the gmt-offset of the time, in +00:00 form :GMT-OFFSET-OR-Z like :GMT-OFFSET, but is Z when UTC :GMT-OFFSET-HHMM like :GMT-OFFSET, but in +0000 form :TIMEZONE timezone abbrevation for the time Elements marked by * can be placed in a list in the form (:keyword padding &optional (padchar #\\0)) The string representation of the value will be padded with the padchar. You can see examples in +ISO-8601-FORMAT+, +ASCTIME-FORMAT+, and +RFC-1123-FORMAT+. invalid-timestring Condition make-timestamp Macro: (make-timestamp &rest args) modified-julian-date Function: (modified-julian-date timestamp) Returns the modified julian date referred to by the timestamp. now Function: (now) Returns a timestamp representing the present moment. nsec-of Generic Function: (nsec-of object) parse-rfc3339-timestring Function: (parse-rfc3339-timestring timestring &key (fail-on-error t) (allow-missing-time-part NIL)) parse-timestring Function: (parse-timestring timestring &key start end (fail-on-error t) (time-separator :) (date-separator -) (date-time-separator t) (allow-missing-elements t) (allow-missing-date-part allow-missing-elements) (allow-missing-time-part allow-missing-elements) (allow-missing-timezone-part allow-missing-elements) (offset 0)) Parse a timestring and return the corresponding timestamp . See split-timestring for details. Unspecified fields in the timestring are initialized to their lowest possible value, and timezone offset is 0 (UTC) unless explicitly specified in the input string. reread-timezone-repository Function: (reread-timezone-repository &key (timezone-repository *default-timezone-repository-path*)) sec-of Generic Function: (sec-of object) timestamp Class timestamp+ Function: (timestamp+ time amount unit &optional (timezone *default-timezone*) offset) timestamp- Function: (timestamp- time amount unit &optional (timezone *default-timezone*) offset) timestamp-century Function: (timestamp-century timestamp &key (timezone *default-timezone*)) Returns the ordinal century upon which the timestamp falls. timestamp-day Function: (timestamp-day timestamp &key (timezone *default-timezone*)) Returns the day of the month upon which the timestamp falls. timestamp-day-of-week Function: (timestamp-day-of-week timestamp &key (timezone *default-timezone*) offset) timestamp-decade Function: (timestamp-decade timestamp &key (timezone *default-timezone*)) Returns the cardinal decade upon which the timestamp falls. timestamp-difference Function: (timestamp-difference time-a time-b) Returns the difference between time-a and time-b in seconds timestamp-hour Function: (timestamp-hour timestamp &key (timezone *default-timezone*)) timestamp-maximize-part Function: (timestamp-maximize-part timestamp part &key (timezone *default-timezone*) into) timestamp-maximum Function: (timestamp-maximum time &rest times) Returns the latest timestamp timestamp-microsecond Function: (timestamp-microsecond timestamp) timestamp-millennium Function: (timestamp-millennium timestamp &key (timezone *default-timezone*)) Returns the ordinal millennium upon which the timestamp falls. timestamp-millisecond Function: (timestamp-millisecond timestamp) timestamp-minimize-part Function: (timestamp-minimize-part timestamp part &key (timezone *default-timezone*) into) timestamp-minimum Function: (timestamp-minimum time &rest times) Returns the earliest timestamp timestamp-minute Function: (timestamp-minute timestamp &key (timezone *default-timezone*)) timestamp-month Function: (timestamp-month timestamp &key (timezone *default-timezone*)) Returns the month upon which the timestamp falls. timestamp-second Function: (timestamp-second timestamp &key (timezone *default-timezone*)) timestamp-subtimezone Function: (timestamp-subtimezone timestamp timezone) Return as multiple values the time zone as the number of seconds east of UTC, a boolean daylight-saving-p, and the customary abbreviation of the timezone. timestamp-to-universal Function: (timestamp-to-universal timestamp) Return the UNIVERSAL-TIME corresponding to the timestamp timestamp-to-unix Function: (timestamp-to-unix timestamp) Return the Unix time corresponding to the timestamp timestamp-whole-year-difference Function: (timestamp-whole-year-difference time-a time-b) Returns the number of whole years elapsed between time-a and time-b (hint: anniversaries). timestamp-year Function: (timestamp-year timestamp &key (timezone *default-timezone*)) Returns the cardinal year upon which the timestamp falls. timestamp/= Function: (timestamp/= &rest timestamps) Returns T if no pair of timestamps is equal. Otherwise return NIL. timestamp< Function: (timestamp< &rest times) timestamp<= Function: (timestamp<= &rest times) timestamp= Function: (timestamp= &rest times) timestamp> Function: (timestamp> &rest times) timestamp>= Function: (timestamp>= &rest times) to-rfc1123-timestring Function: (to-rfc1123-timestring timestamp) to-rfc3339-timestring Function: (to-rfc3339-timestring timestamp) today Function: (today) Returns a timestamp representing the present day. universal-to-timestamp Function: (universal-to-timestamp universal &key (nsec 0)) Returns a timestamp corresponding to the given universal time. unix-to-timestamp Function: (unix-to-timestamp unix &key (nsec 0)) Return a timestamp corresponding to unix , which is the number of seconds since the unix epoch, 1970-01-01T00:00:00Z. with-decoded-timestamp Macro: (with-decoded-timestamp (&key nsec sec minute hour day month year day-of-week daylight-p timezone offset) timestamp &body forms) This macro binds variables to the decoded elements of timestamp . The timezone argument is used for decoding the timestamp, and is not bound by the macro. The value of day-of-week starts from 0 which means Sunday.","title":"local-time"},{"location":"local-time/#local-time","text":"","title":"local-time"},{"location":"local-time/#clock","text":"Variable Use the ` clock ' special variable if you need to define your own idea of the current time. The value of this variable should have the methods local-time::clock-now', and local-time::clock-today'. The currently supported values in local-time are: t - use the standard clock local-time:leap-second-adjusted - use a clock which adjusts for leap seconds using the information in default-timezone .","title":"*clock*"},{"location":"local-time/#rfc-1123-format","text":"Variable See the RFC 1123 for the details about the possible values of the timezone field.","title":"+rfc-1123-format+"},{"location":"local-time/#adjust-timestamp","text":"Macro: (adjust-timestamp timestamp &body changes)","title":"adjust-timestamp"},{"location":"local-time/#adjust-timestamp_1","text":"Macro: (adjust-timestamp! timestamp &body changes)","title":"adjust-timestamp!"},{"location":"local-time/#astronomical-julian-date","text":"Function: (astronomical-julian-date timestamp) Returns the astronomical julian date referred to by the timestamp.","title":"astronomical-julian-date"},{"location":"local-time/#clock-now","text":"Generic Function: (clock-now clock) Returns a timestamp for the current time given a clock.","title":"clock-now"},{"location":"local-time/#clock-today","text":"Generic Function: (clock-today clock) Returns a timestamp for the current date given a clock. The date is encoded by convention as a timestamp with the time set to 00:00:00UTC.","title":"clock-today"},{"location":"local-time/#clone-timestamp","text":"Function: (clone-timestamp timestamp)","title":"clone-timestamp"},{"location":"local-time/#day-of","text":"Generic Function: (day-of object)","title":"day-of"},{"location":"local-time/#days-in-month","text":"Function: (days-in-month month year) Returns the number of days in the given month of the specified year.","title":"days-in-month"},{"location":"local-time/#decode-timestamp","text":"Function: (decode-timestamp timestamp &key (timezone *default-timezone*) offset) Returns the decoded time as multiple values: nsec, ss, mm, hh, day, month, year, day-of-week","title":"decode-timestamp"},{"location":"local-time/#define-timezone","text":"Macro: (define-timezone zone-name zone-file &key (load NIL)) Define zone-name (a symbol or a string) as a new timezone, lazy-loaded from zone-file (a pathname designator relative to the zoneinfo directory on this system. If load is true, load immediately.","title":"define-timezone"},{"location":"local-time/#enable-read-macros","text":"Function: (enable-read-macros) Enables the local-time reader macros for literal timestamps and universal time.","title":"enable-read-macros"},{"location":"local-time/#encode-timestamp","text":"Function: (encode-timestamp nsec sec minute hour day month year &key (timezone *default-timezone*) offset into) Return a new timestamp instance corresponding to the specified time elements.","title":"encode-timestamp"},{"location":"local-time/#find-timezone-by-location-name","text":"Function: (find-timezone-by-location-name name)","title":"find-timezone-by-location-name"},{"location":"local-time/#format-rfc1123-timestring","text":"Function: (format-rfc1123-timestring destination timestamp &key (timezone *default-timezone*))","title":"format-rfc1123-timestring"},{"location":"local-time/#format-rfc3339-timestring","text":"Function: (format-rfc3339-timestring destination timestamp &key omit-date-part omit-time-part (omit-timezone-part omit-time-part) (use-zulu t) (timezone *default-timezone*)) Formats a timestring in the RFC 3339 format, a restricted form of the ISO-8601 timestring specification for Internet timestamps.","title":"format-rfc3339-timestring"},{"location":"local-time/#format-timestring","text":"Function: (format-timestring destination timestamp &key (format +iso-8601-format+) (timezone *default-timezone*)) Constructs a string representation of timestamp according to format and returns it. If destination is T, the string is written to standard-output . If destination is a stream, the string is written to the stream. format is a list containing one or more of strings, characters, and keywords. Strings and characters are output literally, while keywords are replaced by the values here: :YEAR year :MONTH numeric month :DAY day of month :HOUR hour :MIN minutes :SEC seconds :WEEKDAY numeric day of week starting from index 0, which means Sunday :MSEC milliseconds :USEC microseconds :NSEC nanoseconds :ISO-WEEK-YEAR year for ISO week date (can be different from regular calendar year) :ISO-WEEK-NUMBER ISO week number (i.e. 1 through 53) :ISO-WEEK-DAY ISO compatible weekday number (monday=1, sunday=7) :LONG-WEEKDAY long form of weekday (e.g. Sunday, Monday) :SHORT-WEEKDAY short form of weekday (e.g. Sun, Mon) :MINIMAL-WEEKDAY minimal form of weekday (e.g. Su, Mo) :SHORT-YEAR short form of year (last 2 digits, e.g. 41, 42 instead of 2041, 2042) :LONG-MONTH long form of month (e.g. January, February) :SHORT-MONTH short form of month (e.g. Jan, Feb) :HOUR12 hour on a 12-hour clock :AMPM am/pm marker in lowercase :GMT-OFFSET the gmt-offset of the time, in +00:00 form :GMT-OFFSET-OR-Z like :GMT-OFFSET, but is Z when UTC :GMT-OFFSET-HHMM like :GMT-OFFSET, but in +0000 form :TIMEZONE timezone abbrevation for the time Elements marked by * can be placed in a list in the form (:keyword padding &optional (padchar #\\0)) The string representation of the value will be padded with the padchar. You can see examples in +ISO-8601-FORMAT+, +ASCTIME-FORMAT+, and +RFC-1123-FORMAT+.","title":"format-timestring"},{"location":"local-time/#invalid-timestring","text":"Condition","title":"invalid-timestring"},{"location":"local-time/#make-timestamp","text":"Macro: (make-timestamp &rest args)","title":"make-timestamp"},{"location":"local-time/#modified-julian-date","text":"Function: (modified-julian-date timestamp) Returns the modified julian date referred to by the timestamp.","title":"modified-julian-date"},{"location":"local-time/#now","text":"Function: (now) Returns a timestamp representing the present moment.","title":"now"},{"location":"local-time/#nsec-of","text":"Generic Function: (nsec-of object)","title":"nsec-of"},{"location":"local-time/#parse-rfc3339-timestring","text":"Function: (parse-rfc3339-timestring timestring &key (fail-on-error t) (allow-missing-time-part NIL))","title":"parse-rfc3339-timestring"},{"location":"local-time/#parse-timestring","text":"Function: (parse-timestring timestring &key start end (fail-on-error t) (time-separator :) (date-separator -) (date-time-separator t) (allow-missing-elements t) (allow-missing-date-part allow-missing-elements) (allow-missing-time-part allow-missing-elements) (allow-missing-timezone-part allow-missing-elements) (offset 0)) Parse a timestring and return the corresponding timestamp . See split-timestring for details. Unspecified fields in the timestring are initialized to their lowest possible value, and timezone offset is 0 (UTC) unless explicitly specified in the input string.","title":"parse-timestring"},{"location":"local-time/#reread-timezone-repository","text":"Function: (reread-timezone-repository &key (timezone-repository *default-timezone-repository-path*))","title":"reread-timezone-repository"},{"location":"local-time/#sec-of","text":"Generic Function: (sec-of object)","title":"sec-of"},{"location":"local-time/#timestamp","text":"Class","title":"timestamp"},{"location":"local-time/#timestamp_1","text":"Function: (timestamp+ time amount unit &optional (timezone *default-timezone*) offset)","title":"timestamp+"},{"location":"local-time/#timestamp-","text":"Function: (timestamp- time amount unit &optional (timezone *default-timezone*) offset)","title":"timestamp-"},{"location":"local-time/#timestamp-century","text":"Function: (timestamp-century timestamp &key (timezone *default-timezone*)) Returns the ordinal century upon which the timestamp falls.","title":"timestamp-century"},{"location":"local-time/#timestamp-day","text":"Function: (timestamp-day timestamp &key (timezone *default-timezone*)) Returns the day of the month upon which the timestamp falls.","title":"timestamp-day"},{"location":"local-time/#timestamp-day-of-week","text":"Function: (timestamp-day-of-week timestamp &key (timezone *default-timezone*) offset)","title":"timestamp-day-of-week"},{"location":"local-time/#timestamp-decade","text":"Function: (timestamp-decade timestamp &key (timezone *default-timezone*)) Returns the cardinal decade upon which the timestamp falls.","title":"timestamp-decade"},{"location":"local-time/#timestamp-difference","text":"Function: (timestamp-difference time-a time-b) Returns the difference between time-a and time-b in seconds","title":"timestamp-difference"},{"location":"local-time/#timestamp-hour","text":"Function: (timestamp-hour timestamp &key (timezone *default-timezone*))","title":"timestamp-hour"},{"location":"local-time/#timestamp-maximize-part","text":"Function: (timestamp-maximize-part timestamp part &key (timezone *default-timezone*) into)","title":"timestamp-maximize-part"},{"location":"local-time/#timestamp-maximum","text":"Function: (timestamp-maximum time &rest times) Returns the latest timestamp","title":"timestamp-maximum"},{"location":"local-time/#timestamp-microsecond","text":"Function: (timestamp-microsecond timestamp)","title":"timestamp-microsecond"},{"location":"local-time/#timestamp-millennium","text":"Function: (timestamp-millennium timestamp &key (timezone *default-timezone*)) Returns the ordinal millennium upon which the timestamp falls.","title":"timestamp-millennium"},{"location":"local-time/#timestamp-millisecond","text":"Function: (timestamp-millisecond timestamp)","title":"timestamp-millisecond"},{"location":"local-time/#timestamp-minimize-part","text":"Function: (timestamp-minimize-part timestamp part &key (timezone *default-timezone*) into)","title":"timestamp-minimize-part"},{"location":"local-time/#timestamp-minimum","text":"Function: (timestamp-minimum time &rest times) Returns the earliest timestamp","title":"timestamp-minimum"},{"location":"local-time/#timestamp-minute","text":"Function: (timestamp-minute timestamp &key (timezone *default-timezone*))","title":"timestamp-minute"},{"location":"local-time/#timestamp-month","text":"Function: (timestamp-month timestamp &key (timezone *default-timezone*)) Returns the month upon which the timestamp falls.","title":"timestamp-month"},{"location":"local-time/#timestamp-second","text":"Function: (timestamp-second timestamp &key (timezone *default-timezone*))","title":"timestamp-second"},{"location":"local-time/#timestamp-subtimezone","text":"Function: (timestamp-subtimezone timestamp timezone) Return as multiple values the time zone as the number of seconds east of UTC, a boolean daylight-saving-p, and the customary abbreviation of the timezone.","title":"timestamp-subtimezone"},{"location":"local-time/#timestamp-to-universal","text":"Function: (timestamp-to-universal timestamp) Return the UNIVERSAL-TIME corresponding to the timestamp","title":"timestamp-to-universal"},{"location":"local-time/#timestamp-to-unix","text":"Function: (timestamp-to-unix timestamp) Return the Unix time corresponding to the timestamp","title":"timestamp-to-unix"},{"location":"local-time/#timestamp-whole-year-difference","text":"Function: (timestamp-whole-year-difference time-a time-b) Returns the number of whole years elapsed between time-a and time-b (hint: anniversaries).","title":"timestamp-whole-year-difference"},{"location":"local-time/#timestamp-year","text":"Function: (timestamp-year timestamp &key (timezone *default-timezone*)) Returns the cardinal year upon which the timestamp falls.","title":"timestamp-year"},{"location":"local-time/#timestamp_2","text":"Function: (timestamp/= &rest timestamps) Returns T if no pair of timestamps is equal. Otherwise return NIL.","title":"timestamp/="},{"location":"local-time/#timestamp_3","text":"Function: (timestamp< &rest times)","title":"timestamp&lt;"},{"location":"local-time/#timestamp_4","text":"Function: (timestamp<= &rest times)","title":"timestamp&lt;="},{"location":"local-time/#timestamp_5","text":"Function: (timestamp= &rest times)","title":"timestamp="},{"location":"local-time/#timestamp_6","text":"Function: (timestamp> &rest times)","title":"timestamp&gt;"},{"location":"local-time/#timestamp_7","text":"Function: (timestamp>= &rest times)","title":"timestamp&gt;="},{"location":"local-time/#to-rfc1123-timestring","text":"Function: (to-rfc1123-timestring timestamp)","title":"to-rfc1123-timestring"},{"location":"local-time/#to-rfc3339-timestring","text":"Function: (to-rfc3339-timestring timestamp)","title":"to-rfc3339-timestring"},{"location":"local-time/#today","text":"Function: (today) Returns a timestamp representing the present day.","title":"today"},{"location":"local-time/#universal-to-timestamp","text":"Function: (universal-to-timestamp universal &key (nsec 0)) Returns a timestamp corresponding to the given universal time.","title":"universal-to-timestamp"},{"location":"local-time/#unix-to-timestamp","text":"Function: (unix-to-timestamp unix &key (nsec 0)) Return a timestamp corresponding to unix , which is the number of seconds since the unix epoch, 1970-01-01T00:00:00Z.","title":"unix-to-timestamp"},{"location":"local-time/#with-decoded-timestamp","text":"Macro: (with-decoded-timestamp (&key nsec sec minute hour day month year day-of-week daylight-p timezone offset) timestamp &body forms) This macro binds variables to the decoded elements of timestamp . The timezone argument is used for decoding the timestamp, and is not bound by the macro. The value of day-of-week starts from 0 which means Sunday.","title":"with-decoded-timestamp"},{"location":"numcl/","text":"numcl - Lispy clone of numpy Version: 0.1 Repository: numcl/numcl - Github This documentation was possible due to the excellent official documentation . In case of any errors here, please create an issue . INTRODUCTION This is a Numpy clone in Common Lisp. At the moment the library is written in pure Common Lisp, focusing more on correctness and usefulness, not speed. Track the progress at https://github.com/numcl/numcl/projects/1 . Goals Closely follow the numpy API, but still make it lispy. Delegate the documentation effort to Numpy community. Replace the Common Lisp array interface. We do not deviate from the traditional symbols/idioms in Common Lisp unless necessary. Therefore we provide symbols that conflicts the Common Lisp symbol. Math functions become aliases to the original CL functions when the inputs are not arrays. See doc/DETAILS.org#packages . Features/Contracts APIs are provided as functions, not macros. It is a design flaw otherwise. This does not mean the API is functional \u2014 we use procedural code. Still, zero overhead. The APIs are simply the wrappers over simple functions and designed to be fully inlined. Optimization will be done on the compiler side, not by macros. Operations are type-correct. They always return arrays of the most specific array-element-type. For example, (zeros 5) returns a bit vector. (asarray '(1 2 3)) returns an (unsigned-byte 2) vector. See doc/DETAILS.org#types . NUMCL Arrays are CL arrays. As this library aims to extend Common Lisp (not to replace part of it) in a compatible way, we do not introduce custom structures/classes for representing an array. See doc/DETAILS.org#representation . Dependencies NUMCL depends on the following libraries that must be installed manually and other libraries that are automatically loaded by quicklisp. https://github.com/numcl/constantfold https://github.com/numcl/gtype https://github.com/numcl/specialized-function . With Roswell, installation can be done by ros install numcl/constantfold numcl/specialized-function numcl/gtype numcl/numcl This library is at least tested on implementation listed below: SBCL 1.4.12 on X86-64 Linux 4.4.0-141-generic (author's environment) SBCL 1.5.1 on X86-64 Linux 4.4.0-141-generic (author's environment) CI tested on CCL, ECL. Dependency graph: GETTING STARTED Array Representation NUMCL arrays are merely the displaced multidimentional arrays and no classes or structures are used. However, in order to guarantee speed and simplify implementation, arrays given to numcl functions must satisfy the following two conditions: Be a specialized array. Things of type (array single-float) , (array (unsigned-byte 16)) etc. Be an array displaced to a simple 1D specialized array. \" Simple array \" means a non-displaced, non-adjustable array without fill pointer. There are a few ways to create the required arrays: (reshape (arange 4.0) '(2 2)) (asarray #2A((0.0 1.0) (2.0 3.0))) (asarray '((0.0 1.0) (2.0 3.0))) (asarray '(#(0.0 1.0) #(2.0 3.0))) (let ((a (zeros '(2 2) :type 'single-float))) (dotimes (i 2) (dotimes (j 2) (setf (aref a i j) ...)))) The names and the parameters of numcl functions mostly (rather strictly) follows the numpy counterpart. There are even numpy names, such as dtype , which are just aliases for array-element-type . See API Reference for the complete list of functions. Optionally, see Array Representation Details if required. Packages NUMCL defines several symbols which have names identical to the corresponding CL symbols. We call them conflicting symbols . To avoid confusion in the code base, we use 3 packages: NUMCL.IMPL : (internal package) for implementing numcl. NUMCL.EXPORTED : (external package), for storing the numcl exported symbols, NUMCL : package, that replaces COMMON-LISP package by shadowing-import symbols from NUMCL.EXPORTED on top of COMMON-LISP package. Types In NUMCL, there is no ratio type: - CL prohibits ratio to have a denominator 1 (e.g. 3/1), and thus the operations on ratios are not closed. - No implementations provide a specialized array for rational . - Ratio computation requires an additional simplification phase (e.g. 2/4 -> 1/2) which does not finish in a constant number of operations and is incompatible to SIMD operations. As a result, ratios are always converted to *numcl-default-float-format* , which is single-float by default. This means that / always returns a float array (except atomic numbers are given). We also force irrational functions to always return floats, by coercion. (Implementations are allowed to return rationals for certain constants, e.g. (sin pi).) (array bignum) does not exist either. However, when the result of numerical computation causes a fixnum overflow, it signals an error instead of overflowing silently. For complex arrays, only (complex *-float) exists (for each float type). Both complex integers and complex ratios are converted into floats. This is because CL does not allow rational complex with imagpart 0 (cf. http://clhs.lisp.se/Body/t_comple.htm ), thus the numerical operation always coerces the result into reals. This prevents us from having (ARRAY (COMPLEX FIXNUM)). This may be contrasted with that in Common Lisp as provided. Examples example.lisp contains a script that you can explore the functionality implemented so far in NUMCL. API REFERENCE As stated on the section on Packages , NUMCL exports all the symbols in package CL, along with the ones with numcl.exported . Therefore, here, we only list the symbols exported by numcl.exported . * Function: (* &rest args) ** *** + Function: (+ &rest args) ++ +++ - Function: (- first &rest args) / Function: (/ first &rest args) // /// /= Function: (/= x y) 1+ Function: (1+ array) 1- Function: (1- array) < Function: (< x y) <= Function: (<= x y) = Function: (= x y) > Function: (> x y) >= Function: (>= x y) abs Function: (abs x) acos Function: (acos x) amax Function: (amax array &rest args &key axes type) amin Function: (amin array &rest args &key axes type) arange Function: (arange &rest args) Arange's argument signature is irregular, following the API of numpy. The interpretation of its arguments depends on the number of arguments. (arange stop &key type) (arange start stop &key type) (arange start stop step &key type) Don't worry, we provide a compiler-macro to avoid the runtime dispatch. aref Function: (aref array &rest subscripts) An extended aref that accepts ranges as lists, similar to numpy's array access. For a 3D array x, range x[1:5,2,3] = (aref x '(1 5) 2 3) x[2,1:5,3] = (aref x 2 '(1 5) 3) x[2,1:2:5,3] = (aref x 2 '(1 2 5) 3) x[2,1:,3] = (aref x 2 '(1 t) 3) x[2,:1,3] = (aref x 2 '(t 1) 3) x[2,:,3] = (aref x 2 '(t t) 3) x[2,:,3] = (aref x 2 t 3) insufficient axis (aref x '(1 5)) == (aref x '(1 5) t t) (aref x 2 '(1 5)) == (aref x 2 '(1 5) t) newaxis (aref x '(1 2 5) nil 2 3) ellipsis (aref x '- 2) = (aref x t t 2) = x[...,2] (aref x 2 '-) = (aref x 2 t t) = x[2,...] (aref x 2 '- 3) = (aref x 2 t 3) = x[2,...,3] (aref x 2 3 '-) = (aref x 2 3 t) = x[2,3,...] argmax argmin argwhere Function: (argwhere array fn) Returns a list of the multidimentional indices of the elements which satisfies the predicate FN. Note that the list elements are the multidimentional indices, even for a single-dimensional array. array-index-from-row-major-index Function: (array-index-from-row-major-index array row-major-index) Takes a multidimentional array and a row-major-index. Returns a list containing the normal index. asarray Function: (asarray contents &key type) Copy CONTENTS to a new array. NOTE: ASARRAY is SLOW as it recurses into the substructures. When CONTENTS is a multidimentional array, its elements are copied to a new array that guarantees the NUMCL assumption. When CONTENTS is a nested sequence, it is traversed up to the depth that guarantees the sane shape for an array. When elements are copied, it is coerced to TYPE. When TYPE is not given, it is replaced with the float-contagion type deduced from the elements of CONTENTS. It may return a 0-dimensional array with CONTENTS being the only element. For example: ;; a vector of two lists. (asarray '((1) (1 2))) -> #((1) (1 2)) ;; a 2D array of 4 lists. (asarray '(((1) (1 2)) ((3) (3 4)))) -> #2A(((1) (1 2)) ((3) (3 4))) (asarray '((1 2) (3 4))) -> #2A((1 2) (3 4)) (asarray #(#(1 2) #(3 4))) -> #2A((1 2) (3 4)) (asarray #((1 2) (3 4))) -> #2A((1 2) (3 4)) However, this behavior may not be ideal because the resulting shape could be affected by the lengths of the strings. (asarray #(#(1 2) #(3 4))) -> #2A((1 2) (3 4)) (asarray #(#(1 2) #(3 4 5))) -> #(#(1 2) #(3 4 5)) (asarray #(\"aa\" \"aa\")) -> #2A((#a #a) (#a #a)) (asarray #(\"aa\" \"aaa\")) -> #(\"aa\" \"aaa\") As a remedy to this problem, we allow TYPE to be a specifier for vector subtypes. Providing such a type specifier will keep the leaf objects (e.g. strings) from split into individual elements. We don't allow it to be a multidimentional array [at the moment.] (asarray #(#(1 2) #(3 4)) :type '(array fixnum (*))) -> #(#(1 2) #(3 4)) (asarray #(#(1 2) #(3 4 5)) :type '(array fixnum (*))) -> #(#(1 2) #(3 4 5)) (asarray #(\"aa\" \"aa\") :type 'string) -> #(\"aa\" \"aa\") (asarray #(\"aa\" \"aaa\") :type 'string) -> #(\"aa\" \"aaa\") (asarray '((1 2) (3 4)) :type '(array fixnum (* *))) -> error asin Function: (asin x) astype Function: (astype array type) atan Function: (atan x) avg Function: (avg array &key axes) bernoulli Function: (bernoulli p &optional shape) Returns a bit array whose elements are 1 with probability P bernoulli-like Function: (bernoulli-like a) beta Function: (beta a b &optional shape (type (union-to-float-type (type-of a) (type-of b)))) binomial Function: (binomial n p &optional shape) broadcast Function: (broadcast function x y &key type (atomic function)) For binary functions ceiling Function: (ceiling number &optional (divisor 1)) chisquare cis Function: (cis x) clip Function: (clip array min max) concatenate Function: (concatenate arrays &key (axis 0) out) conjugate Function: (conjugate x) copy Function: (copy array) cos Function: (cos x) cosh Function: (cosh x) denominator Function: (denominator x) diag Function: (diag a &optional result) Return the diagonal element of a matrix as a vector dirichlet dot dtype Function: (dtype array) einsum Function: (einsum subscripts &rest args) Performs Einstein's summation. The SUBSCRIPT specification is significantly extended from that of Numpy and can be seens as a full-brown DSL for array operations. SUBSCRIPTS is a sequence of the form (<SPEC>+ [-> <TRANSFORM>*] [-> [<SPEC>*]) . The remaining arguments ARGS contain the input arrays and optionally the output arrays. SPEC The first set of SPECs specifies the input subscripts, and the second set of SPECs specifies the output subscripts. Unlike Numpy, there can be multiple output subscripts: It can performs multiple operations in the same loop, then return multiple values. The symbol -> can be a string and can belong to any package because it is compared by STRING=. Each SPEC is an alphabetical string designator, such as a symbol IJK or a string \"IJK\", where each alphabet is considered as an index. It signals a type-error when it contains any non-alpha char. Note that a symbol NIL is interpreted as an empty list rather than N, I and L. Alternatively, each SPEC can be a list that contains a list of symbols. For example, ((i j) (j k) -> (i k)) and (ij jk -> ik) are equivalent. When -> and the output SPECs are omitted, a single output is assumed and its spec is a union of the input specs. For example, (ij jk) is equivalent to (ij jk -> ijk) . Note that (ij jk) and (ij jk ->) have the different meanings: The latter sums up all elements. TRANSFORM TRANSFORM is a list of element-wise operations. The number of TRANSFORM should correspond to the number of outputs. In each TRANSFORM, the elements in the input arrays can be referenced by $N, where N is a 1-indexed number. Similarly the output array can be referred to by @N. For example, (ij ik -> (+ @1 (* $1 $2)) -> ik) is equivalent to (ij ik -> ik) (a GEMM). By default, TRANSFORM is (+ @1 (* $1 ... $N)) for N inputs, which is equivalent to Einstein's summation. ARGS The shape of each input array should unify against the corresponding input spec. For example, with a spec IJI, the input array should be of rank 3 as well as the 1st and the 3rd dimension of the input array should be the same. The shape of each output array is determined by the corresponding output spec. For example, if SUBSCRIPTS is (ij jk -> ik) , the output is an array of rank 2, and the output shape has the same dimension as the first input in the first axis, and the same dimension as the second input in the second axis. If the output arrays are provided, their shapes and types are also checked against the corresponding output spec. The types should match the result of the numerical operations on the elements of the input arrays. The outputs are calculated in the following rule. The output array types are calculated based on the TRANSFORM, and the shapes are calcurated based on the SPEC and the input arrays. The output arrays are allocated and initialized by zeros. Einsum nests one loop for each index in the input specs. For example, (ij jk -> ik) results in a triple loop. In the innermost loop, each array element is bound to $1..$N / @1..@N . For each @i , i -th TRANSFORM is evaluated and assigned to @i . If the same index appears multiple times in a single spec, they share the same value in each iteration. For example, (ii -> i) returns the diagonal elements of the matrix. When TRANSFORMs are missing, it follows naturally from the default TRANSFORM values that When an index used in the input spec is missing in the output spec, the axis is aggregated over the iteration by summation. If the same index appears across the different input specs, the element values from the multiple input arrays are aggregated by multiplication. For example, (ij jk -> ik) will perform (setf (aref a2 i k) (* (aref a0 i j) (aref a1 j k))) when a0, a1 are the input arrays and a2 is the output array. For example, (einsum '(ij jk) a b) is equivalent to: (dotimes (i <max> <output>) (dotimes (j <max>) (dotimes (k <max>) (setf (aref <output> i j k) (* (aref a i j) (aref b j k)))))) Performance If SUBSCRIPTS is a constant, the compiler macro builds an iterator function and make them inlined. Otherwise, a new function is made in each call to einsum, resulting in a large bottleneck. (It could be memoized in the future.) The nesting order of the loops are automatically decided based on the specs. The order affects the memory access pattern and therefore the performance due to the access locality. For example, when writing a GEMM which accesses three matrices by (setf (aref output i j) (* (aref a i k) (aref b k j))) , it is well known that ikj-loop is the fastest among other loops, e.g. ijk-loop. EINSUM reorders the indices so that it maximizes the cache locality. empty Function: (empty shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. empty-like Function: (empty-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. exp Function: (exp x) expand-dims Function: (expand-dims a axes) axes: an int or a list of ints exponential Function: (exponential scale &optional shape (type (union-to-float-type (type-of scale)))) eye Function: (eye n &key (m n) (k 0) (type 'bit)) Returns a matrix whose k-th diagnonal filled with 1. N,M specifies the shape of the return array. K will adjust the sub-diagonal -- positive K moves it upward. f Function: (f dfnum dfden &optional shape (type (union-to-float-type (type-of dfnum) (type-of dfden)))) fceiling Function: (fceiling number &optional (divisor 1)) ffloor Function: (ffloor number &optional (divisor 1)) flatten Function: (flatten a) floor Function: (floor number &optional (divisor 1)) fround Function: (fround number &optional (divisor 1)) ftruncate Function: (ftruncate number &optional (divisor 1)) full Function: (full shape value &key (type (type-of value))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. full-like Function: (full-like array value &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. gamma Function: (gamma k &optional (theta 1.0) shape (type (union-to-float-type (type-of k) (type-of theta)))) geometric gumbel histogram Function: (histogram array &key (low (amin array)) (high (amax array)) (split 1)) Returns a fixnum vector representing a histogram of values. The interval between LOW and HIGH are split by STEP value. All values less than LOW are put in the 0-th bucket; All values greater than equal to HIGH are put in the last bucket. hypergeometric imagpart Function: (imagpart x) inner Function: (inner a b &optional result) Inner product of two vectors. integer-length Function: (integer-length x) invalid-array-index-error NIL NUMCL.EXPORTED:SHAPE Initargs: :shape Readers: numcl.exported:invalid-array-index-error-shape Writers: (setf numcl.exported:invalid-array-index-error-shape) axis Initargs: :axis Readers: numcl.exported:invalid-array-index-error-axis Writers: (setf numcl.exported:invalid-array-index-error-axis) #### subscripts ```lisp Initargs: :subscripts Readers: numcl.exported:invalid-array-index-error-subscripts Writers: (setf numcl.exported:invalid-array-index-error-subscripts)### kron ```lisp Function: (kron a b &optional result) Compute the kronecker product of two vectors. laplace length Function: (length array) linspace Function: (linspace start stop length &key type endpoint) log Function: (log x) logand Function: (logand &rest args) logandc1 Function: (logandc1 &rest args) logandc2 Function: (logandc2 &rest args) logcount Function: (logcount x) logeqv Function: (logeqv &rest args) logior Function: (logior &rest args) logistic lognand Function: (lognand &rest args) lognor Function: (lognor &rest args) lognormal lognot Function: (lognot x) logorc1 Function: (logorc1 &rest args) logorc2 Function: (logorc2 &rest args) logseries logxor Function: (logxor &rest args) map Function: (map result-type function &rest sequences) map-array Function: (map-array function &rest sequences) map-array-into Function: (map-array-into result-sequence function &rest sequences) map-into Function: (map-into result-sequence function &rest sequences) matmul Function: (matmul a b &optional result) Matrix product of two arrays. max Function: (max &rest args) mean Function: (mean array &key axes) min Function: (min &rest args) mod Function: (mod number &optional (divisor 1)) multinomial Function: (multinomial n pvals &optional shape) pvals is a sequence of probabilities summing up to 1. multivariate-normal negative-binomial Function: (negative-binomial n p &optional shape) noncentral-chisquare noncentral-f nonzero Function: (nonzero array) collect multidimentional indices where the element is nonzero normal Function: (normal &optional (mean 0.0) (var 1.0) shape (type (union-to-float-type (type-of mean) (type-of var)))) numcl-array numcl-array-p Function: (numcl-array-p array) Returns true when ARRAY satisfies the NUMCL assumption, that is, an array displaced to a non-displaced 1D array. numerator Function: (numerator x) onehot ones Function: (ones shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. ones-like Function: (ones-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. outer Function: (outer a b &optional result) Compute the outer product of two vectors. pareto phase Function: (phase x) poisson Function: (poisson &optional (lambda 1.0) shape (type (union-to-float-type (type-of lambda)))) power prod Function: (prod array &rest args &key axes type) rank Function: (rank array) rayleigh realpart Function: (realpart x) reduce-array Function: (reduce-array fn array &key axes (type (%reduce-array-result-type array fn)) (initial-element (zero-value type))) rem Function: (rem number &optional (divisor 1)) reshape Function: (reshape a shape) Reshape the array while sharing the backing 1D array. -1 implies that the axis size is deduced from the other axes. At most one axis is allowed to be -1. T implies that the axis size is preserved. It can be used as many times, but only at the right/leftmost axes. Example of reshaping (3 8 5): valid: (6 -1 10) = (6 2 10) (t 2 2 2 t) = (3 2 2 2 5) (3 t t) = (3 8 5) (2 -1 2 2 t) = (2 3 2 2 5) invalid: (2 t 2 2 t) round Function: (round number &optional (divisor 1)) shape Function: (shape array) shuffle Function: (shuffle array-or-sequence &key (start 0) end) This code extends alexandria:shuffle. It additionally accepts arrays and shuffles the elements according to the first axis, viewing the remaining axes as one \"element\". Original documentation: Returns a random permutation of SEQUENCE bounded by START and END. Original sequence may be destructively modified, and (if it contains CONS or lists themselv) share storage with the original one. Signals an error if SEQUENCE is not a proper sequence. signum Function: (signum x) sin Function: (sin x) sinh Function: (sinh x) size Function: (size array) sqrt Function: (sqrt x) square Function: (square x) squeeze Function: (squeeze a) stack Function: (stack arrays &key (axis 0) out) standard-cauchy standard-deviation Function: (standard-deviation array &key axes) standard-exponential standard-gamma standard-normal standard-t stdev Function: (stdev array &key axes) sum Function: (sum array &rest args &key axes type) take Function: (take array indices) Collect the elements using a list of multidimentional indices (in a format returned by WHERE). tan Function: (tan x) tanh Function: (tanh x) to-simple-array Function: (to-simple-array array) Returns a simple array of the equivalent contents. transpose Function: (transpose matrix &optional result) Reverses the axes of an array. tri Function: (tri n &key (m n) (k 0) (type 'bit)) Returns a triangle matrix whose lower diagnonal (including the diagonal) filled with 1. N,M specifies the shape of the return array. K will adjust the sub-diagonal -- positive K fills more 1s. triangular tril Function: (tril matrix &optional (k 0)) Returns the copy of matrix with elements above the k-th diagonal zeroed. Positive K fills less 0s. triu Function: (triu matrix &optional (k 0)) Returns the copy of matrix with elements below the k-th diagonal zeroed. Positive K fills more 0s. truncate Function: (truncate number &optional (divisor 1)) uniform Function: (uniform &optional (low 0.0) (high 1.0) shape type) unstack Function: (unstack array &key (axis 0)) vander Function: (vander v &key (n (length v)) increasing) Returns a matrix where M[i,j] == V[i]^(N-j) when increasing is false (default), and M[i,j] == V[i]^j when increasing is true. var Function: (var array &key axes) variance Function: (variance array &key axes) vdot Function: (vdot a b &optional result) Dot product of two vectors. For complex values, the first value is conjugated. vonmises wald weibull where Function: (where array fn) Returns a list of list of indices of the elements which satisfies the predicate FN. The first list contains the indices for the 1st dimension, the second list contains the indices for the 2nd dimension, and so on. zeros Function: (zeros shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. zeros-like Function: (zeros-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape. zipf MORE DISCUSSION Common Lisp Types Common Lisp has the following types for numbers. number = (or complex real) real = (or float rational) rational = (or ratio integer) integer = (or fixnum bignum) float = (or short-float ... long-float) (== irrational). Common Lisp defines several rules for the type of the values returned by the numerical operations. The detail of the rules are explained in CLHS 12.1 Number Concepts . Rational functions behave as rational* -> rational , float* -> float , {rational,float}* -> float . This rule is called float contagion rule. Rational functions do not guarantee integer -> integer , primarily due to / , which returns integer* -> (or ratio integer) . Irrational functions behaves as rational -> (or rational float) , float -> float : For a certain irrational functions, implementations are allowed to return the exact rational number or its float approximation. Examples are (sin pi) -> 1/2 . The behavior depends on the implementation and is called float substitution rule . Array Representation Details NUMCL arrays are not based on custom classes or structures. They are merely the displaced multidimentional arrays. In order to guarantee the speed and to simplify the implementation, the arrays given to numcl functions must satisfy the following two conditions: It is a specialized array. Things of type (array single-float) , (array (unsigned-byte 16)) etc. It is an array displaced to a simple 1D specialized array. \" Simple array \" means a non-displaced, non-adjustable array without fill pointer. The base function for creating a new array is %make-array , but this is not exported in NUMCL. You should use the wrapper functions like ones , zeros , ones-like , arange , linspace , asarray etc. They are always inline-expanded to %make-array , therefore there is no worry about the performance. These functions analyze the input and return the most specialized array for the input, but you can also specify the element type. %make-array instantiates a new flattened array and returns another array displaced to it with the specified shape. The flattened array is returned as the secondary value (as does most other numcl functions). The justification for this scheme is that some implementations (esp. SBCL) require an indirection for accessing the array element (e.g. through array-header in SBCL) even for a simple multi-dimentional array and thus using a displacing array has essentially no performance penalty over using a simple multi-dimentional array. We also ensure that the length of the base arrays are the multiples of 8. This ensures that the program can safely iterate over the extended region with a future support for SIMD operations in mind. AUTHOR, LICENSE, COPYRIGHT Masataro Asai (guicho2.71828@gmail.com) Licensed under LGPL v3. Copyright (c) 2019 IBM Corporation","title":"numcl - Lispy clone of numpy"},{"location":"numcl/#numcl-lispy-clone-of-numpy","text":"Version: 0.1 Repository: numcl/numcl - Github This documentation was possible due to the excellent official documentation . In case of any errors here, please create an issue .","title":"numcl - Lispy clone of numpy"},{"location":"numcl/#introduction","text":"This is a Numpy clone in Common Lisp. At the moment the library is written in pure Common Lisp, focusing more on correctness and usefulness, not speed. Track the progress at https://github.com/numcl/numcl/projects/1 .","title":"INTRODUCTION"},{"location":"numcl/#goals","text":"Closely follow the numpy API, but still make it lispy. Delegate the documentation effort to Numpy community. Replace the Common Lisp array interface. We do not deviate from the traditional symbols/idioms in Common Lisp unless necessary. Therefore we provide symbols that conflicts the Common Lisp symbol. Math functions become aliases to the original CL functions when the inputs are not arrays. See doc/DETAILS.org#packages .","title":"Goals"},{"location":"numcl/#featurescontracts","text":"APIs are provided as functions, not macros. It is a design flaw otherwise. This does not mean the API is functional \u2014 we use procedural code. Still, zero overhead. The APIs are simply the wrappers over simple functions and designed to be fully inlined. Optimization will be done on the compiler side, not by macros. Operations are type-correct. They always return arrays of the most specific array-element-type. For example, (zeros 5) returns a bit vector. (asarray '(1 2 3)) returns an (unsigned-byte 2) vector. See doc/DETAILS.org#types . NUMCL Arrays are CL arrays. As this library aims to extend Common Lisp (not to replace part of it) in a compatible way, we do not introduce custom structures/classes for representing an array. See doc/DETAILS.org#representation .","title":"Features/Contracts"},{"location":"numcl/#dependencies","text":"NUMCL depends on the following libraries that must be installed manually and other libraries that are automatically loaded by quicklisp. https://github.com/numcl/constantfold https://github.com/numcl/gtype https://github.com/numcl/specialized-function . With Roswell, installation can be done by ros install numcl/constantfold numcl/specialized-function numcl/gtype numcl/numcl This library is at least tested on implementation listed below: SBCL 1.4.12 on X86-64 Linux 4.4.0-141-generic (author's environment) SBCL 1.5.1 on X86-64 Linux 4.4.0-141-generic (author's environment) CI tested on CCL, ECL. Dependency graph:","title":"Dependencies"},{"location":"numcl/#getting-started","text":"","title":"GETTING STARTED"},{"location":"numcl/#array-representation","text":"NUMCL arrays are merely the displaced multidimentional arrays and no classes or structures are used. However, in order to guarantee speed and simplify implementation, arrays given to numcl functions must satisfy the following two conditions: Be a specialized array. Things of type (array single-float) , (array (unsigned-byte 16)) etc. Be an array displaced to a simple 1D specialized array. \" Simple array \" means a non-displaced, non-adjustable array without fill pointer. There are a few ways to create the required arrays: (reshape (arange 4.0) '(2 2)) (asarray #2A((0.0 1.0) (2.0 3.0))) (asarray '((0.0 1.0) (2.0 3.0))) (asarray '(#(0.0 1.0) #(2.0 3.0))) (let ((a (zeros '(2 2) :type 'single-float))) (dotimes (i 2) (dotimes (j 2) (setf (aref a i j) ...)))) The names and the parameters of numcl functions mostly (rather strictly) follows the numpy counterpart. There are even numpy names, such as dtype , which are just aliases for array-element-type . See API Reference for the complete list of functions. Optionally, see Array Representation Details if required.","title":"Array Representation"},{"location":"numcl/#packages","text":"NUMCL defines several symbols which have names identical to the corresponding CL symbols. We call them conflicting symbols . To avoid confusion in the code base, we use 3 packages: NUMCL.IMPL : (internal package) for implementing numcl. NUMCL.EXPORTED : (external package), for storing the numcl exported symbols, NUMCL : package, that replaces COMMON-LISP package by shadowing-import symbols from NUMCL.EXPORTED on top of COMMON-LISP package.","title":"Packages"},{"location":"numcl/#types","text":"In NUMCL, there is no ratio type: - CL prohibits ratio to have a denominator 1 (e.g. 3/1), and thus the operations on ratios are not closed. - No implementations provide a specialized array for rational . - Ratio computation requires an additional simplification phase (e.g. 2/4 -> 1/2) which does not finish in a constant number of operations and is incompatible to SIMD operations. As a result, ratios are always converted to *numcl-default-float-format* , which is single-float by default. This means that / always returns a float array (except atomic numbers are given). We also force irrational functions to always return floats, by coercion. (Implementations are allowed to return rationals for certain constants, e.g. (sin pi).) (array bignum) does not exist either. However, when the result of numerical computation causes a fixnum overflow, it signals an error instead of overflowing silently. For complex arrays, only (complex *-float) exists (for each float type). Both complex integers and complex ratios are converted into floats. This is because CL does not allow rational complex with imagpart 0 (cf. http://clhs.lisp.se/Body/t_comple.htm ), thus the numerical operation always coerces the result into reals. This prevents us from having (ARRAY (COMPLEX FIXNUM)). This may be contrasted with that in Common Lisp as provided.","title":"Types"},{"location":"numcl/#examples","text":"example.lisp contains a script that you can explore the functionality implemented so far in NUMCL.","title":"Examples"},{"location":"numcl/#api-reference","text":"As stated on the section on Packages , NUMCL exports all the symbols in package CL, along with the ones with numcl.exported . Therefore, here, we only list the symbols exported by numcl.exported .","title":"API REFERENCE"},{"location":"numcl/#_1","text":"Function: (* &rest args)","title":"*"},{"location":"numcl/#_2","text":"","title":"**"},{"location":"numcl/#_3","text":"","title":"***"},{"location":"numcl/#_4","text":"Function: (+ &rest args)","title":"+"},{"location":"numcl/#_5","text":"","title":"++"},{"location":"numcl/#_6","text":"","title":"+++"},{"location":"numcl/#-","text":"Function: (- first &rest args)","title":"-"},{"location":"numcl/#_7","text":"Function: (/ first &rest args)","title":"/"},{"location":"numcl/#_8","text":"","title":"//"},{"location":"numcl/#_9","text":"","title":"///"},{"location":"numcl/#_10","text":"Function: (/= x y)","title":"/="},{"location":"numcl/#1","text":"Function: (1+ array)","title":"1+"},{"location":"numcl/#1-","text":"Function: (1- array)","title":"1-"},{"location":"numcl/#_11","text":"Function: (< x y)","title":"&lt;"},{"location":"numcl/#_12","text":"Function: (<= x y)","title":"&lt;="},{"location":"numcl/#_13","text":"Function: (= x y)","title":"="},{"location":"numcl/#_14","text":"Function: (> x y)","title":"&gt;"},{"location":"numcl/#_15","text":"Function: (>= x y)","title":"&gt;="},{"location":"numcl/#abs","text":"Function: (abs x)","title":"abs"},{"location":"numcl/#acos","text":"Function: (acos x)","title":"acos"},{"location":"numcl/#amax","text":"Function: (amax array &rest args &key axes type)","title":"amax"},{"location":"numcl/#amin","text":"Function: (amin array &rest args &key axes type)","title":"amin"},{"location":"numcl/#arange","text":"Function: (arange &rest args) Arange's argument signature is irregular, following the API of numpy. The interpretation of its arguments depends on the number of arguments. (arange stop &key type) (arange start stop &key type) (arange start stop step &key type) Don't worry, we provide a compiler-macro to avoid the runtime dispatch.","title":"arange"},{"location":"numcl/#aref","text":"Function: (aref array &rest subscripts) An extended aref that accepts ranges as lists, similar to numpy's array access. For a 3D array x, range x[1:5,2,3] = (aref x '(1 5) 2 3) x[2,1:5,3] = (aref x 2 '(1 5) 3) x[2,1:2:5,3] = (aref x 2 '(1 2 5) 3) x[2,1:,3] = (aref x 2 '(1 t) 3) x[2,:1,3] = (aref x 2 '(t 1) 3) x[2,:,3] = (aref x 2 '(t t) 3) x[2,:,3] = (aref x 2 t 3) insufficient axis (aref x '(1 5)) == (aref x '(1 5) t t) (aref x 2 '(1 5)) == (aref x 2 '(1 5) t) newaxis (aref x '(1 2 5) nil 2 3) ellipsis (aref x '- 2) = (aref x t t 2) = x[...,2] (aref x 2 '-) = (aref x 2 t t) = x[2,...] (aref x 2 '- 3) = (aref x 2 t 3) = x[2,...,3] (aref x 2 3 '-) = (aref x 2 3 t) = x[2,3,...]","title":"aref"},{"location":"numcl/#argmax","text":"","title":"argmax"},{"location":"numcl/#argmin","text":"","title":"argmin"},{"location":"numcl/#argwhere","text":"Function: (argwhere array fn) Returns a list of the multidimentional indices of the elements which satisfies the predicate FN. Note that the list elements are the multidimentional indices, even for a single-dimensional array.","title":"argwhere"},{"location":"numcl/#array-index-from-row-major-index","text":"Function: (array-index-from-row-major-index array row-major-index) Takes a multidimentional array and a row-major-index. Returns a list containing the normal index.","title":"array-index-from-row-major-index"},{"location":"numcl/#asarray","text":"Function: (asarray contents &key type) Copy CONTENTS to a new array. NOTE: ASARRAY is SLOW as it recurses into the substructures. When CONTENTS is a multidimentional array, its elements are copied to a new array that guarantees the NUMCL assumption. When CONTENTS is a nested sequence, it is traversed up to the depth that guarantees the sane shape for an array. When elements are copied, it is coerced to TYPE. When TYPE is not given, it is replaced with the float-contagion type deduced from the elements of CONTENTS. It may return a 0-dimensional array with CONTENTS being the only element. For example: ;; a vector of two lists. (asarray '((1) (1 2))) -> #((1) (1 2)) ;; a 2D array of 4 lists. (asarray '(((1) (1 2)) ((3) (3 4)))) -> #2A(((1) (1 2)) ((3) (3 4))) (asarray '((1 2) (3 4))) -> #2A((1 2) (3 4)) (asarray #(#(1 2) #(3 4))) -> #2A((1 2) (3 4)) (asarray #((1 2) (3 4))) -> #2A((1 2) (3 4)) However, this behavior may not be ideal because the resulting shape could be affected by the lengths of the strings. (asarray #(#(1 2) #(3 4))) -> #2A((1 2) (3 4)) (asarray #(#(1 2) #(3 4 5))) -> #(#(1 2) #(3 4 5)) (asarray #(\"aa\" \"aa\")) -> #2A((#a #a) (#a #a)) (asarray #(\"aa\" \"aaa\")) -> #(\"aa\" \"aaa\") As a remedy to this problem, we allow TYPE to be a specifier for vector subtypes. Providing such a type specifier will keep the leaf objects (e.g. strings) from split into individual elements. We don't allow it to be a multidimentional array [at the moment.] (asarray #(#(1 2) #(3 4)) :type '(array fixnum (*))) -> #(#(1 2) #(3 4)) (asarray #(#(1 2) #(3 4 5)) :type '(array fixnum (*))) -> #(#(1 2) #(3 4 5)) (asarray #(\"aa\" \"aa\") :type 'string) -> #(\"aa\" \"aa\") (asarray #(\"aa\" \"aaa\") :type 'string) -> #(\"aa\" \"aaa\") (asarray '((1 2) (3 4)) :type '(array fixnum (* *))) -> error","title":"asarray"},{"location":"numcl/#asin","text":"Function: (asin x)","title":"asin"},{"location":"numcl/#astype","text":"Function: (astype array type)","title":"astype"},{"location":"numcl/#atan","text":"Function: (atan x)","title":"atan"},{"location":"numcl/#avg","text":"Function: (avg array &key axes)","title":"avg"},{"location":"numcl/#bernoulli","text":"Function: (bernoulli p &optional shape) Returns a bit array whose elements are 1 with probability P","title":"bernoulli"},{"location":"numcl/#bernoulli-like","text":"Function: (bernoulli-like a)","title":"bernoulli-like"},{"location":"numcl/#beta","text":"Function: (beta a b &optional shape (type (union-to-float-type (type-of a) (type-of b))))","title":"beta"},{"location":"numcl/#binomial","text":"Function: (binomial n p &optional shape)","title":"binomial"},{"location":"numcl/#broadcast","text":"Function: (broadcast function x y &key type (atomic function)) For binary functions","title":"broadcast"},{"location":"numcl/#ceiling","text":"Function: (ceiling number &optional (divisor 1))","title":"ceiling"},{"location":"numcl/#chisquare","text":"","title":"chisquare"},{"location":"numcl/#cis","text":"Function: (cis x)","title":"cis"},{"location":"numcl/#clip","text":"Function: (clip array min max)","title":"clip"},{"location":"numcl/#concatenate","text":"Function: (concatenate arrays &key (axis 0) out)","title":"concatenate"},{"location":"numcl/#conjugate","text":"Function: (conjugate x)","title":"conjugate"},{"location":"numcl/#copy","text":"Function: (copy array)","title":"copy"},{"location":"numcl/#cos","text":"Function: (cos x)","title":"cos"},{"location":"numcl/#cosh","text":"Function: (cosh x)","title":"cosh"},{"location":"numcl/#denominator","text":"Function: (denominator x)","title":"denominator"},{"location":"numcl/#diag","text":"Function: (diag a &optional result) Return the diagonal element of a matrix as a vector","title":"diag"},{"location":"numcl/#dirichlet","text":"","title":"dirichlet"},{"location":"numcl/#dot","text":"","title":"dot"},{"location":"numcl/#dtype","text":"Function: (dtype array)","title":"dtype"},{"location":"numcl/#einsum","text":"Function: (einsum subscripts &rest args) Performs Einstein's summation. The SUBSCRIPT specification is significantly extended from that of Numpy and can be seens as a full-brown DSL for array operations. SUBSCRIPTS is a sequence of the form (<SPEC>+ [-> <TRANSFORM>*] [-> [<SPEC>*]) . The remaining arguments ARGS contain the input arrays and optionally the output arrays.","title":"einsum"},{"location":"numcl/#spec","text":"The first set of SPECs specifies the input subscripts, and the second set of SPECs specifies the output subscripts. Unlike Numpy, there can be multiple output subscripts: It can performs multiple operations in the same loop, then return multiple values. The symbol -> can be a string and can belong to any package because it is compared by STRING=. Each SPEC is an alphabetical string designator, such as a symbol IJK or a string \"IJK\", where each alphabet is considered as an index. It signals a type-error when it contains any non-alpha char. Note that a symbol NIL is interpreted as an empty list rather than N, I and L. Alternatively, each SPEC can be a list that contains a list of symbols. For example, ((i j) (j k) -> (i k)) and (ij jk -> ik) are equivalent. When -> and the output SPECs are omitted, a single output is assumed and its spec is a union of the input specs. For example, (ij jk) is equivalent to (ij jk -> ijk) . Note that (ij jk) and (ij jk ->) have the different meanings: The latter sums up all elements.","title":"SPEC"},{"location":"numcl/#transform","text":"TRANSFORM is a list of element-wise operations. The number of TRANSFORM should correspond to the number of outputs. In each TRANSFORM, the elements in the input arrays can be referenced by $N, where N is a 1-indexed number. Similarly the output array can be referred to by @N. For example, (ij ik -> (+ @1 (* $1 $2)) -> ik) is equivalent to (ij ik -> ik) (a GEMM). By default, TRANSFORM is (+ @1 (* $1 ... $N)) for N inputs, which is equivalent to Einstein's summation.","title":"TRANSFORM"},{"location":"numcl/#args","text":"The shape of each input array should unify against the corresponding input spec. For example, with a spec IJI, the input array should be of rank 3 as well as the 1st and the 3rd dimension of the input array should be the same. The shape of each output array is determined by the corresponding output spec. For example, if SUBSCRIPTS is (ij jk -> ik) , the output is an array of rank 2, and the output shape has the same dimension as the first input in the first axis, and the same dimension as the second input in the second axis. If the output arrays are provided, their shapes and types are also checked against the corresponding output spec. The types should match the result of the numerical operations on the elements of the input arrays. The outputs are calculated in the following rule. The output array types are calculated based on the TRANSFORM, and the shapes are calcurated based on the SPEC and the input arrays. The output arrays are allocated and initialized by zeros. Einsum nests one loop for each index in the input specs. For example, (ij jk -> ik) results in a triple loop. In the innermost loop, each array element is bound to $1..$N / @1..@N . For each @i , i -th TRANSFORM is evaluated and assigned to @i . If the same index appears multiple times in a single spec, they share the same value in each iteration. For example, (ii -> i) returns the diagonal elements of the matrix. When TRANSFORMs are missing, it follows naturally from the default TRANSFORM values that When an index used in the input spec is missing in the output spec, the axis is aggregated over the iteration by summation. If the same index appears across the different input specs, the element values from the multiple input arrays are aggregated by multiplication. For example, (ij jk -> ik) will perform (setf (aref a2 i k) (* (aref a0 i j) (aref a1 j k))) when a0, a1 are the input arrays and a2 is the output array. For example, (einsum '(ij jk) a b) is equivalent to: (dotimes (i <max> <output>) (dotimes (j <max>) (dotimes (k <max>) (setf (aref <output> i j k) (* (aref a i j) (aref b j k))))))","title":"ARGS"},{"location":"numcl/#performance","text":"If SUBSCRIPTS is a constant, the compiler macro builds an iterator function and make them inlined. Otherwise, a new function is made in each call to einsum, resulting in a large bottleneck. (It could be memoized in the future.) The nesting order of the loops are automatically decided based on the specs. The order affects the memory access pattern and therefore the performance due to the access locality. For example, when writing a GEMM which accesses three matrices by (setf (aref output i j) (* (aref a i k) (aref b k j))) , it is well known that ikj-loop is the fastest among other loops, e.g. ijk-loop. EINSUM reorders the indices so that it maximizes the cache locality.","title":"Performance"},{"location":"numcl/#empty","text":"Function: (empty shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"empty"},{"location":"numcl/#empty-like","text":"Function: (empty-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"empty-like"},{"location":"numcl/#exp","text":"Function: (exp x)","title":"exp"},{"location":"numcl/#expand-dims","text":"Function: (expand-dims a axes) axes: an int or a list of ints","title":"expand-dims"},{"location":"numcl/#exponential","text":"Function: (exponential scale &optional shape (type (union-to-float-type (type-of scale))))","title":"exponential"},{"location":"numcl/#eye","text":"Function: (eye n &key (m n) (k 0) (type 'bit)) Returns a matrix whose k-th diagnonal filled with 1. N,M specifies the shape of the return array. K will adjust the sub-diagonal -- positive K moves it upward.","title":"eye"},{"location":"numcl/#f","text":"Function: (f dfnum dfden &optional shape (type (union-to-float-type (type-of dfnum) (type-of dfden))))","title":"f"},{"location":"numcl/#fceiling","text":"Function: (fceiling number &optional (divisor 1))","title":"fceiling"},{"location":"numcl/#ffloor","text":"Function: (ffloor number &optional (divisor 1))","title":"ffloor"},{"location":"numcl/#flatten","text":"Function: (flatten a)","title":"flatten"},{"location":"numcl/#floor","text":"Function: (floor number &optional (divisor 1))","title":"floor"},{"location":"numcl/#fround","text":"Function: (fround number &optional (divisor 1))","title":"fround"},{"location":"numcl/#ftruncate","text":"Function: (ftruncate number &optional (divisor 1))","title":"ftruncate"},{"location":"numcl/#full","text":"Function: (full shape value &key (type (type-of value))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"full"},{"location":"numcl/#full-like","text":"Function: (full-like array value &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"full-like"},{"location":"numcl/#gamma","text":"Function: (gamma k &optional (theta 1.0) shape (type (union-to-float-type (type-of k) (type-of theta))))","title":"gamma"},{"location":"numcl/#geometric","text":"","title":"geometric"},{"location":"numcl/#gumbel","text":"","title":"gumbel"},{"location":"numcl/#histogram","text":"Function: (histogram array &key (low (amin array)) (high (amax array)) (split 1)) Returns a fixnum vector representing a histogram of values. The interval between LOW and HIGH are split by STEP value. All values less than LOW are put in the 0-th bucket; All values greater than equal to HIGH are put in the last bucket.","title":"histogram"},{"location":"numcl/#hypergeometric","text":"","title":"hypergeometric"},{"location":"numcl/#imagpart","text":"Function: (imagpart x)","title":"imagpart"},{"location":"numcl/#inner","text":"Function: (inner a b &optional result) Inner product of two vectors.","title":"inner"},{"location":"numcl/#integer-length","text":"Function: (integer-length x)","title":"integer-length"},{"location":"numcl/#invalid-array-index-error","text":"NIL NUMCL.EXPORTED:SHAPE Initargs: :shape Readers: numcl.exported:invalid-array-index-error-shape Writers: (setf numcl.exported:invalid-array-index-error-shape)","title":"invalid-array-index-error"},{"location":"numcl/#axis","text":"Initargs: :axis Readers: numcl.exported:invalid-array-index-error-axis Writers: (setf numcl.exported:invalid-array-index-error-axis) #### subscripts ```lisp Initargs: :subscripts Readers: numcl.exported:invalid-array-index-error-subscripts Writers: (setf numcl.exported:invalid-array-index-error-subscripts)### kron ```lisp Function: (kron a b &optional result) Compute the kronecker product of two vectors.","title":"axis"},{"location":"numcl/#laplace","text":"","title":"laplace"},{"location":"numcl/#length","text":"Function: (length array)","title":"length"},{"location":"numcl/#linspace","text":"Function: (linspace start stop length &key type endpoint)","title":"linspace"},{"location":"numcl/#log","text":"Function: (log x)","title":"log"},{"location":"numcl/#logand","text":"Function: (logand &rest args)","title":"logand"},{"location":"numcl/#logandc1","text":"Function: (logandc1 &rest args)","title":"logandc1"},{"location":"numcl/#logandc2","text":"Function: (logandc2 &rest args)","title":"logandc2"},{"location":"numcl/#logcount","text":"Function: (logcount x)","title":"logcount"},{"location":"numcl/#logeqv","text":"Function: (logeqv &rest args)","title":"logeqv"},{"location":"numcl/#logior","text":"Function: (logior &rest args)","title":"logior"},{"location":"numcl/#logistic","text":"","title":"logistic"},{"location":"numcl/#lognand","text":"Function: (lognand &rest args)","title":"lognand"},{"location":"numcl/#lognor","text":"Function: (lognor &rest args)","title":"lognor"},{"location":"numcl/#lognormal","text":"","title":"lognormal"},{"location":"numcl/#lognot","text":"Function: (lognot x)","title":"lognot"},{"location":"numcl/#logorc1","text":"Function: (logorc1 &rest args)","title":"logorc1"},{"location":"numcl/#logorc2","text":"Function: (logorc2 &rest args)","title":"logorc2"},{"location":"numcl/#logseries","text":"","title":"logseries"},{"location":"numcl/#logxor","text":"Function: (logxor &rest args)","title":"logxor"},{"location":"numcl/#map","text":"Function: (map result-type function &rest sequences)","title":"map"},{"location":"numcl/#map-array","text":"Function: (map-array function &rest sequences)","title":"map-array"},{"location":"numcl/#map-array-into","text":"Function: (map-array-into result-sequence function &rest sequences)","title":"map-array-into"},{"location":"numcl/#map-into","text":"Function: (map-into result-sequence function &rest sequences)","title":"map-into"},{"location":"numcl/#matmul","text":"Function: (matmul a b &optional result) Matrix product of two arrays.","title":"matmul"},{"location":"numcl/#max","text":"Function: (max &rest args)","title":"max"},{"location":"numcl/#mean","text":"Function: (mean array &key axes)","title":"mean"},{"location":"numcl/#min","text":"Function: (min &rest args)","title":"min"},{"location":"numcl/#mod","text":"Function: (mod number &optional (divisor 1))","title":"mod"},{"location":"numcl/#multinomial","text":"Function: (multinomial n pvals &optional shape) pvals is a sequence of probabilities summing up to 1.","title":"multinomial"},{"location":"numcl/#multivariate-normal","text":"","title":"multivariate-normal"},{"location":"numcl/#negative-binomial","text":"Function: (negative-binomial n p &optional shape)","title":"negative-binomial"},{"location":"numcl/#noncentral-chisquare","text":"","title":"noncentral-chisquare"},{"location":"numcl/#noncentral-f","text":"","title":"noncentral-f"},{"location":"numcl/#nonzero","text":"Function: (nonzero array) collect multidimentional indices where the element is nonzero","title":"nonzero"},{"location":"numcl/#normal","text":"Function: (normal &optional (mean 0.0) (var 1.0) shape (type (union-to-float-type (type-of mean) (type-of var))))","title":"normal"},{"location":"numcl/#numcl-array","text":"","title":"numcl-array"},{"location":"numcl/#numcl-array-p","text":"Function: (numcl-array-p array) Returns true when ARRAY satisfies the NUMCL assumption, that is, an array displaced to a non-displaced 1D array.","title":"numcl-array-p"},{"location":"numcl/#numerator","text":"Function: (numerator x)","title":"numerator"},{"location":"numcl/#onehot","text":"","title":"onehot"},{"location":"numcl/#ones","text":"Function: (ones shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"ones"},{"location":"numcl/#ones-like","text":"Function: (ones-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"ones-like"},{"location":"numcl/#outer","text":"Function: (outer a b &optional result) Compute the outer product of two vectors.","title":"outer"},{"location":"numcl/#pareto","text":"","title":"pareto"},{"location":"numcl/#phase","text":"Function: (phase x)","title":"phase"},{"location":"numcl/#poisson","text":"Function: (poisson &optional (lambda 1.0) shape (type (union-to-float-type (type-of lambda))))","title":"poisson"},{"location":"numcl/#power","text":"","title":"power"},{"location":"numcl/#prod","text":"Function: (prod array &rest args &key axes type)","title":"prod"},{"location":"numcl/#rank","text":"Function: (rank array)","title":"rank"},{"location":"numcl/#rayleigh","text":"","title":"rayleigh"},{"location":"numcl/#realpart","text":"Function: (realpart x)","title":"realpart"},{"location":"numcl/#reduce-array","text":"Function: (reduce-array fn array &key axes (type (%reduce-array-result-type array fn)) (initial-element (zero-value type)))","title":"reduce-array"},{"location":"numcl/#rem","text":"Function: (rem number &optional (divisor 1))","title":"rem"},{"location":"numcl/#reshape","text":"Function: (reshape a shape) Reshape the array while sharing the backing 1D array. -1 implies that the axis size is deduced from the other axes. At most one axis is allowed to be -1. T implies that the axis size is preserved. It can be used as many times, but only at the right/leftmost axes. Example of reshaping (3 8 5): valid: (6 -1 10) = (6 2 10) (t 2 2 2 t) = (3 2 2 2 5) (3 t t) = (3 8 5) (2 -1 2 2 t) = (2 3 2 2 5) invalid: (2 t 2 2 t)","title":"reshape"},{"location":"numcl/#round","text":"Function: (round number &optional (divisor 1))","title":"round"},{"location":"numcl/#shape","text":"Function: (shape array)","title":"shape"},{"location":"numcl/#shuffle","text":"Function: (shuffle array-or-sequence &key (start 0) end) This code extends alexandria:shuffle. It additionally accepts arrays and shuffles the elements according to the first axis, viewing the remaining axes as one \"element\". Original documentation: Returns a random permutation of SEQUENCE bounded by START and END. Original sequence may be destructively modified, and (if it contains CONS or lists themselv) share storage with the original one. Signals an error if SEQUENCE is not a proper sequence.","title":"shuffle"},{"location":"numcl/#signum","text":"Function: (signum x)","title":"signum"},{"location":"numcl/#sin","text":"Function: (sin x)","title":"sin"},{"location":"numcl/#sinh","text":"Function: (sinh x)","title":"sinh"},{"location":"numcl/#size","text":"Function: (size array)","title":"size"},{"location":"numcl/#sqrt","text":"Function: (sqrt x)","title":"sqrt"},{"location":"numcl/#square","text":"Function: (square x)","title":"square"},{"location":"numcl/#squeeze","text":"Function: (squeeze a)","title":"squeeze"},{"location":"numcl/#stack","text":"Function: (stack arrays &key (axis 0) out)","title":"stack"},{"location":"numcl/#standard-cauchy","text":"","title":"standard-cauchy"},{"location":"numcl/#standard-deviation","text":"Function: (standard-deviation array &key axes)","title":"standard-deviation"},{"location":"numcl/#standard-exponential","text":"","title":"standard-exponential"},{"location":"numcl/#standard-gamma","text":"","title":"standard-gamma"},{"location":"numcl/#standard-normal","text":"","title":"standard-normal"},{"location":"numcl/#standard-t","text":"","title":"standard-t"},{"location":"numcl/#stdev","text":"Function: (stdev array &key axes)","title":"stdev"},{"location":"numcl/#sum","text":"Function: (sum array &rest args &key axes type)","title":"sum"},{"location":"numcl/#take","text":"Function: (take array indices) Collect the elements using a list of multidimentional indices (in a format returned by WHERE).","title":"take"},{"location":"numcl/#tan","text":"Function: (tan x)","title":"tan"},{"location":"numcl/#tanh","text":"Function: (tanh x)","title":"tanh"},{"location":"numcl/#to-simple-array","text":"Function: (to-simple-array array) Returns a simple array of the equivalent contents.","title":"to-simple-array"},{"location":"numcl/#transpose","text":"Function: (transpose matrix &optional result) Reverses the axes of an array.","title":"transpose"},{"location":"numcl/#tri","text":"Function: (tri n &key (m n) (k 0) (type 'bit)) Returns a triangle matrix whose lower diagnonal (including the diagonal) filled with 1. N,M specifies the shape of the return array. K will adjust the sub-diagonal -- positive K fills more 1s.","title":"tri"},{"location":"numcl/#triangular","text":"","title":"triangular"},{"location":"numcl/#tril","text":"Function: (tril matrix &optional (k 0)) Returns the copy of matrix with elements above the k-th diagonal zeroed. Positive K fills less 0s.","title":"tril"},{"location":"numcl/#triu","text":"Function: (triu matrix &optional (k 0)) Returns the copy of matrix with elements below the k-th diagonal zeroed. Positive K fills more 0s.","title":"triu"},{"location":"numcl/#truncate","text":"Function: (truncate number &optional (divisor 1))","title":"truncate"},{"location":"numcl/#uniform","text":"Function: (uniform &optional (low 0.0) (high 1.0) shape type)","title":"uniform"},{"location":"numcl/#unstack","text":"Function: (unstack array &key (axis 0))","title":"unstack"},{"location":"numcl/#vander","text":"Function: (vander v &key (n (length v)) increasing) Returns a matrix where M[i,j] == V[i]^(N-j) when increasing is false (default), and M[i,j] == V[i]^j when increasing is true.","title":"vander"},{"location":"numcl/#var","text":"Function: (var array &key axes)","title":"var"},{"location":"numcl/#variance","text":"Function: (variance array &key axes)","title":"variance"},{"location":"numcl/#vdot","text":"Function: (vdot a b &optional result) Dot product of two vectors. For complex values, the first value is conjugated.","title":"vdot"},{"location":"numcl/#vonmises","text":"","title":"vonmises"},{"location":"numcl/#wald","text":"","title":"wald"},{"location":"numcl/#weibull","text":"","title":"weibull"},{"location":"numcl/#where","text":"Function: (where array fn) Returns a list of list of indices of the elements which satisfies the predicate FN. The first list contains the indices for the 1st dimension, the second list contains the indices for the 2nd dimension, and so on.","title":"where"},{"location":"numcl/#zeros","text":"Function: (zeros shape &key (type 'bit)) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"zeros"},{"location":"numcl/#zeros-like","text":"Function: (zeros-like array &key (type (array-element-type array))) Equivalent of the same function in numpy. Note the default type difference. empty : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear. full : fill the array with a certain value. zeros , ones : fill the array with zeros / ones. type affects the actual value being filled. X-like : similar to above functions, but takes another array and returns the array of the same shape.","title":"zeros-like"},{"location":"numcl/#zipf","text":"","title":"zipf"},{"location":"numcl/#more-discussion","text":"","title":"MORE DISCUSSION"},{"location":"numcl/#common-lisp-types","text":"Common Lisp has the following types for numbers. number = (or complex real) real = (or float rational) rational = (or ratio integer) integer = (or fixnum bignum) float = (or short-float ... long-float) (== irrational). Common Lisp defines several rules for the type of the values returned by the numerical operations. The detail of the rules are explained in CLHS 12.1 Number Concepts . Rational functions behave as rational* -> rational , float* -> float , {rational,float}* -> float . This rule is called float contagion rule. Rational functions do not guarantee integer -> integer , primarily due to / , which returns integer* -> (or ratio integer) . Irrational functions behaves as rational -> (or rational float) , float -> float : For a certain irrational functions, implementations are allowed to return the exact rational number or its float approximation. Examples are (sin pi) -> 1/2 . The behavior depends on the implementation and is called float substitution rule .","title":"Common Lisp Types"},{"location":"numcl/#array-representation-details","text":"NUMCL arrays are not based on custom classes or structures. They are merely the displaced multidimentional arrays. In order to guarantee the speed and to simplify the implementation, the arrays given to numcl functions must satisfy the following two conditions: It is a specialized array. Things of type (array single-float) , (array (unsigned-byte 16)) etc. It is an array displaced to a simple 1D specialized array. \" Simple array \" means a non-displaced, non-adjustable array without fill pointer. The base function for creating a new array is %make-array , but this is not exported in NUMCL. You should use the wrapper functions like ones , zeros , ones-like , arange , linspace , asarray etc. They are always inline-expanded to %make-array , therefore there is no worry about the performance. These functions analyze the input and return the most specialized array for the input, but you can also specify the element type. %make-array instantiates a new flattened array and returns another array displaced to it with the specified shape. The flattened array is returned as the secondary value (as does most other numcl functions). The justification for this scheme is that some implementations (esp. SBCL) require an indirection for accessing the array element (e.g. through array-header in SBCL) even for a simple multi-dimentional array and thus using a displacing array has essentially no performance penalty over using a simple multi-dimentional array. We also ensure that the length of the base arrays are the multiples of 8. This ensures that the program can safely iterate over the extended region with a future support for SIMD operations in mind.","title":"Array Representation Details"},{"location":"numcl/#author-license-copyright","text":"Masataro Asai (guicho2.71828@gmail.com) Licensed under LGPL v3. Copyright (c) 2019 IBM Corporation","title":"AUTHOR, LICENSE, COPYRIGHT"},{"location":"postmodern/","text":"postmodern - PostgreSQL programming interace Version: 1.32 (The June 2020 Quicklisp dist contains version 1.30. 1.32 should be available post this. Everything except the constructs relevant to Database Management and Roles should work.) Nickname: pomo Repository: marijnh/Postmodern - Github This page was possible due to the excellent official documentation . In fact, there are several sections the manual goes into, which we do not go into below. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . Postmodern is a Common Lisp library for interacting with PostgreSQL databases . The focus has been on: Efficient communication with the database server without need for foreign libraries. Support for UTF-8 on Unicode-aware Lisp implementations A syntax for mixing SQL and Lisp code Convenient support for prepared statements and stored procedures A metaclass for simple database-access objects The biggest differences between this library and clsql or cl-dbi or to some extent, mito , are that Postmodern has no intention of being portable across different SQL implementations (it embraces non-standard PostgreSQL features), and approaches extensions like lispy SQL and database access objects in a quite different way. In addition, there is no builtin support for migrations , for which, you may want to use other libraries - cl-migratum database-migrations postmodern-passenger-pigeon cl-migrations mito , along with being an ORM, also provides support for migrations. GETTING STARTED Starting the Postgres server Follow the installation instructions to install Postgres. Once done, you should have access to the database server daemon postgres and the helper commands pg_ctl and psql on your command line / terminal. Once done, this page elaborates the process of starting the database server and any issues that may arise. (The postgresql version can be selected from the top of that page.) Initialize the directory: pg_ctl init -D postmodern # see \\ pg_ctl --help \\ from the options . Optionally, change port and unix_socket_directories from postmodern/postgresql.conf . (Simply search for lines starting with these terms.) pg_ctl start -D postmodern to start the server. You should get a server started message; if not, the link above should help in debugging. Proceed to the next section once you successfully start the server. This page elaborates on the configuration settings. In addition, you can list the databases by using psql -p PORT -h unix_socket_directories -l , replacing the italicized arguments appropriately. A few things to note above include that you can run multiple postgres servers from different directories on different ports on a single machine. Note also that the directory name is independent of the database name. Connecting to the Postgres server Postgres has a connect-toplevel and with-connection besides a few other ways (see below) for establishing connections. The latter establishes connections with a lexical scope and can be useful in the case of multiple roles . See connect for the spec in with-connection . Below, we firstly connect to the default existing database postgres . Create a new database testdb for our purpose, and then disconnect and reconnect to this new database. The first connection and disconnection is all carried out by the with-connection . Assume that \"foucault\" role is a superuser, and that the database server was started above at the non-default port 8080. (See psql -p 8080 -h unix_socket_directories -c '\\du' -d postgres to list all the users.) (with-connection '(\"postgres\" \"foucault\" \"surveiller\" \"localhost\" :port 8080) (create-database 'testdb :limit-public-access t :comment \"This database is for testing silly theories\")) (connect-toplevel \"testdb\" \"foucault\" \"surveiller\" \"localhost\" :port 8080) Connect-toplevel will maintain a single connection for the life of the session. A word about Postgresql connections: Postgresql connections are not lightweight threads. They actually consume about 10 MB of memory per connection and Postgresql can be tuned to limit the number of connections allowed at any one time. In addition, any connections which require security (ssl or scram authentication) will take additional time and create more overhead. If you have an application (web apps for instance) which will make many connections, you generally do not want to create and drop connections for every query. The usual solution is to use connection pools so that the application is grabbing an already existing connection and returning it to the pool when finished, saving connection time and memory. To use postmodern's simple connection pooler, the with-connection call would look like: (with-connection '(\"testdb\" \"foucault\" \"surveiller\" \"localhost\" :pooled-p t) ...) The maximum number of connections is determined by *max-pool-size* . Things you may want to take a look at with regards to connection include: database-connection connect *default-use-ssl* disconnect connected-p reconnect *database* with-connection call-with-connection connect-toplevel disconnect-toplevel clear-connection-pool *max-pool-size* list-connections Executing arbitrary database commands Query is the basic way to send queries to the database: CL-USER> (query \"select 22, 'Folie et d\u00e9raison', 4.5\") ((22 \"Folie et d\u00e9raison\" 9/2)) CL-USER> (query (:select 22 \"Folie et d\u00e9raison\" 4.5)) ((22 \"Folie et d\u00e9raison\" 9/2)) In many contexts, query strings and lists starting with keywords can be used interchangeably. The lists will be compiled to SQL. The S-SQL manual describes the syntax used by these expressions. Lisp values occurring in them are automatically escaped. In the above query, only constant values are used, but it is possible to transparently use run-time values as well: CL-USER> (defun database-powered-addition (a b) (query (:select (:+ a b)) :single)) DATABASE-POWERED-ADDITION CL-USER> (database-powered-addition 1030 204) 1234 1 That last argument, :single , indicates that we want the result not as a list of lists (for the result rows), but as a single value, since we know that we are only selecting one value. See the documentation of query for the other options. You do not have to pull in the whole result of a query at once, you can also iterate over it with the doquery macro. The following things should be useful about querying: query execute doquery prepare defprepared defprepared-with-names with-transaction commit-transaction abort-transaction with-savepoint release-savepoint rollback-savepoint commit-hooks abort-hooks with-logical-transaction abort-logical-transaction commit-logical-transaction *current-logical-transaction* ensure-transaction with-schema sequence-next coalesce Database Access Class You can work directly with the database or you can use a simple database-access-class (aka dao-class ) which would cover all the fields in a row. This is what a database-access class looks like: (defclass points () ((x :col-type integer :initarg :x :reader point-x) (y :col-type integer :initarg :y :reader point-y) (value :col-type integer :initarg :value :accessor value)) (:metaclass dao-class) (:keys x y)) Once the class is defined, we create the table in the database: CL-USER> (dao-table-definition 'points) \"CREATE TABLE points (x INTEGER NOT NULL, y INTEGER NOT NULL, value INTEGER NOT NULL, PRIMARY KEY (x, y))\" CL-USER> (execute (dao-table-definition 'points)) 0 In more complicated cases, you might want to :create-table directly. You can use sql to view the result of parsing the form . CL-USER> (sql (:create-table so-items ((item-id :type integer) (so-id :type (or integer db-null) :references ((so-headers id))) (product-id :type (or integer db-null)) (qty :type (or integer db-null)) (net-price :type (or numeric db-null))) (:primary-key item-id so-id))) \"CREATE TABLE so_items (item_id INTEGER NOT NULL, so_id INTEGER REFERENCES so_headers(id) MATCH SIMPLE ON DELETE RESTRICT ON UPDATE RESTRICT, product_id INTEGER, qty INTEGER, net_price NUMERIC, PRIMARY KEY (item_id, so_id))\" (Note that you'd need to execute this form using query or execute . Also see this for details and examples on using S-SQL for creating tables.) You can use insert-dao for inserting DAO-objects into the database. (Of course, you can use query to do all this using the usual SQL syntax.) CL-USER> (insert-dao (make-instance 'points :x 0 :y 1 :value 10)) #<POINTS {10145AC1D3}> CL-USER> (insert-dao (make-instance 'points :x 1 :y 0 :value 15)) #<POINTS {10145B5EA3}> CL-USER> (select-dao 'country) (#<COUNTRY {101C5F3103}> #<COUNTRY {101C5F3883}>) 2 CL-USER> (select-dao 'points) (#<POINTS {1017B9BB93}> #<POINTS {1017B9BC23}>) 2 CL-USER> (query (:select '* :from 'points)) ((0 1 10) (1 0 15)) 2 Finally, you can use update-dao to, well, update the database entry: CL-USER> (let ((1-0 (get-dao 'points 1 0))) (setf (value 1-0) 20) (update-dao 1-0)) #<POINTS {101F1628E3}> CL-USER> (query (:select '* :from 'points)) ((0 1 10) (1 0 20)) 2 Here are the other useful constructs related to database access objects: dao-class dao-keys dao-exists-p make-dao define-dao-finalization get-dao select-dao do-select-dao query-dao do-query-dao *ignore-unknown-columns* insert-dao update-dao save-dao save-dao/transaction upsert-dao delete-dao dao-table-name dao-table-definition with-column-writers S-SQL Finally, here is some more demonstration of S-SQL syntax: (sql (:select 'relname :from 'pg-catalog.pg-class :inner-join 'pg-catalog.pg-namespace :on (:= 'relnamespace 'pg-namespace.oid) :where (:and (:= 'relkind \"r\") (:not-in 'nspname (:set \"pg_catalog\" \"pg_toast\")) (:pg-catalog.pg-table-is-visible 'pg-class.oid)))) ;; => \"(SELECT relname FROM pg_catalog.pg_class ;; INNER JOIN pg_catalog.pg_namespace ON (relnamespace = pg_namespace.oid) ;; WHERE ((relkind = 'r') and (nspname NOT IN ('pg_catalog', 'pg_toast')) ;; and pg_catalog.pg_table_is_visible(pg_class.oid)))\" Lists starting with keywords are used to express SQL commands and operators while lists starting with something else will be evaluated and then inserted into the query. Quoted symbols name columns or tables (keywords can also be used but might introduce ambiguities). The syntax supports subqueries, multiple joins, stored procedures, etc. See the S-SQL reference manual for a complete treatment. [TODO] Add more S-SQL examples. Compare them with SxQL as well. Prepared statements *allow-overwriting-prepared-statements* prepared-statement-exists-p list-prepared-statements drop-prepared-statement list-postmodern-prepared-statements find-postgresql-prepared-statement find-postmodern-prepared-statement reset-prepared-statement get-pid get-pid-from-postmodern cancel-backend terminate-backend Example Usage: CL-USER> (funcall (prepare (:select '* :from 'points :where (:= 'x '$1))) 0) ((0 1 10)) 1 prepare defprepared defprepared-with-names Migration The meaning of the term migration depends upon the context. People can talk about migrating from Oracle to Postgresql or to Mssql or Mysql. In that context, migration means changing database structure and functions from one database implementation to another. To developers, the term migration normally means tracking and managing version changes of the database structure in the development process. This is often called schema migration. Of course development often continues after software has gone into production, in which case \"migration' not only needs to deal with version controls of the database structure, but also needs to ensure that such changes of the database do not result in lost production data. For example, renaming a column in a database table is a simple one command operation in development but at least four commands if there is actually data in the column. There are two different approaches taken to schema migration. The first and more typical approach is is writing scripts to manage changes, both forward and back. The second approach is to generate diff snapshots and determine the changes needed to move from one snapshot to another. Both have their pluses and minuses, particularly when it comes to how to manage the data that already exists in the database. The script writing approach requires the developer to write both the sql commands necessary to make the desired change and the requisite sql commands to undo that change. Typically these scripts are then saved in .sql files in a migration directory and a migration library is used to track dependencies which can get complicated if there are more than one developer on the team. Undoing migrations (sometimes called rollbacks) is difficult if production data exists on the database. There are schools of thought among DBAs that rollbacks should never be allowed because of the danger of losing critical production data. It may be obvious, but it is a good reminder that any migration should start with creating a backup which has been tested. Other useful constructs Database Management create-database drop-database Inspecting the database list-tables list-tables-in-schema table-exists-p table-description list-sequences sequence-exists-p list-views view-exists-p list-schemata schema-exist-p schema-exists-p database-version num-records-in-database current-database database-exists-p database-size list-databases list-schemas list-tablespaces list-available-types list-table-sizes table-size more-table-info list-columns list-columns-with-types column-exists-p describe-views list-database-functions list-indices list-table-indices index-exists-p list-indexed-column-and-attributes list-index-definitions find-primary-key-info list-foreign-keys list-unique-or-primary-constraints list-all-constraints describe-constraint describe-foreign-key-constraints list-triggers list-detailed-triggers list-database-users list-roles list-available-extensions list-installed-extensions change-toplevel-database Table definition and creation deftable !dao-def !index !unique-index !foreign !unique create-table create-all-tables create-package-tables *table-name* *table-symbol* Roles role-exists-p create-role drop-role alter-role-search-path change-password grant-role-permissions grant-readonly-permissions grant-editor-permissions grant-admin-permissions revoke-all-on-table list-role-accessible-databases list-roles list-role-permissions Schemata create-schema drop-schema get-search-path set-search-path split-fully-qualified-table-name Database Health Measurements cache-hit-ratio bloat-measurement unused-indexes check-query-performance Miscellaneous Utility Functions execute-file CONFIGURATION VARIABLES *allow-overwriting-prepared-statements* Variable When set to t, ensured-prepared will overwrite prepared statements having the same name if the query statement itself in the postmodern meta connection is different than the query statement provided to ensure-prepared. *current-logical-transaction* Variable This is bound to the current transaction-handle or savepoint-handle instance representing the innermost open logical transaction. *database* Variable Special variable holding the current database connection information. Most functions and macros operating on a database assume this binds to a connected database. *default-use-ssl* Variable The default for connect's use-ssl argument. This starts at :no. If you set it to anything else, be sure to also load the CL+SSL library. *escape-sql-names-p* Variable Determines whether double quotes are added around column, table, and function names in queries. Valid values: T, in which case every name is escaped, NIL, in which case no name is escape, :auto, which causes only reserved words to be escaped, or. :literal which is the same as :auto except it has added consequence in to-sql-name . The default value is :auto. Be careful when binding this with let and such \u2015 since a lot of SQL compilation tends to happen at compile-time, the result might not be what you expect. Mixed case sensitivity is not currently well supported. Postgresql itself will downcase unquoted identifiers. This will be revisited in the future if requested. *ignore-unknown-columns* Variable Normally, when get-dao, select-dao, or query-dao finds a column in the database that's not in the DAO class, it will raise an error. Setting this variable to a non-NIL will cause it to simply ignore the unknown column. *isolation-level* Variable The transaction isolation level currently in use. Defaults to :read-committed-rw You can specify the following isolation levels in postmodern transactions: :read-committed-rw (read committed with read and write) :read-committed-ro (read committed with read only) :repeatable-read-rw (repeatable read with read and write) :repeatable-read-ro (repeatable read with read only) :serializable (serializable with reand and write) *max-pool-size* Variable Set the maximum amount of connections kept in a single connection pool, where a pool consists of all the stored connections with the exact same connect arguments. Defaults to NIL, which means there is no maximum. *table-name* Variable Used inside deftable to find the name of the table being defined. *table-name* Variable Used inside deftable to find the name of the table being defined. *table-symbol* Variable Used inside deftable to find the symbol naming the table being defined. FUNCTIONS AND MACROS !dao-def Function: (!dao-def) Should only be used inside a deftable form. Define this table using the corresponding DAO class' slots. Adds the result of calling dao-table-definition on table-symbol to the definition. !foreign Function: (!foreign target fields &rest target-fields/on-delete/on-update/deferrable/initially-deferred) Used insde a deftable form. Add a foreign key to the table being defined. target-table is the referenced table. columns is a list of column names or single name in this table, and, if the columns have different names in the referenced table, target-columns must be another list of column names or single column name of the target-table, or :primary-key to denote the column(s) of the target-table's primary key as referenced column(s). The on-delete and on-update arguments can be used to specify ON DELETE and ON UPDATE actions, as per the keywords allowed in create-table. In addition, the deferrable and initially-deferred arguments can be used to indicate whether constraint checking can be deferred until the current transaction completed, and whether this should be done by default. Note that none of these are really &key arguments, but rather are picked out of a &rest arg at runtime, so that they can be specified even when target-columns is not given. !index Function: (!index &rest fields) Used inside a deftable form. Define an index on the table being defined. The columns can be given as symbols or strings. !unique Function: (!unique target-fields &key deferrable initially-deferred) Constrains one or more columns to only contain unique (combinations of) values, with deferrable and initially-deferred defined as in !foreign !unique-index Function: (!unique-index &rest fields) Used inside a deftable form. Define a unique index on the defined table. abort-hooks Generic Function: (abort-hooks object) Generic Function: (setf (abort-hooks object) ...) An accessor for the transaction or savepoint's list of abort hooks, each of which should be a function with no required arguments. These functions will be executed when a transaction is aborted or a savepoint rolled back (whether via a non-local transfer of control or explicitly by either abort-transaction or rollback-savepoint). abort-logical-transaction Generic Function: (abort-logical-transaction obj) Roll back the given logical transaction, regardless of whether it is an actual transaction or a savepoint. abort-transaction Function: (abort-transaction transaction) Roll back the given transaction. add-comment Function: (add-comment type name comment &optional (second-name )) Attempts to add a comment to a particular database object. The first parameter is a keyword for the type of database object. The second parameter is the name of the object. The third parameter is the comment itself. Some objects require an additional identifier. The names can be strings or symbols. Example usage would be: (add-comment :database 'my-database-name \"Does anyone actually use this database?\") (add-comment :column 'country-locations.name \"Is what it looks like - the name of a country\") (add-comment :column \"country_locations.name\" \"Is what it looks like - the name of a country\") Example usage where two identifiers are required would be constraints: (add-comment :constraint 'constraint1 \"Some kind of constraint descriptions here\" 'country-locations) alter-role-search-path Function: (alter-role-search-path role search-path) Changes the priority of where a role looks for tables (which schema first, second, etc. Role should be a string or symbol. Search-path could be a list of schema names either as strings or symbols. bigint '(signed-byte 64) bloat-measurement Function: (bloat-measurement) \u2192 list Bloat measurement of unvacuumed dead tuples. Borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ who borrowed it from https://github.com/heroku/heroku-pg-extras/tree/master/commands . bytea '(array (unsigned-byte 8)) cache-hit-ratio Function: (cache-hit-ratio) \u2192 list The cache hit ratio shows data on serving the data from memory compared to how often you have to go to disk. This function returns a list of heapblocks read from disk, heapblocks hit from memory and the ratio of heapblocks hit from memory / total heapblocks hit. Borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ call-with-connection Function: (call-with-connection spec thunk) The functional backend to with-connection. Binds *database* to a new connection as specified by spec, which should be a list that connect can be applied to, and runs the zero-argument function given as second argument in the new environment. When the function returns or throws, the new connection is disconnected. cancel-backend Function: (cancel-backend pid &optional (database *database*)) Polite way of terminating a query at the database (as opposed to calling close-database). This is slower than (terminate-backend pid) and does not always work. change-password Function: (change-password role password &optional expiration-date) Alters a role's password. If the optional expiration-date parameter is provided, the password will expire at the stated date. A sample expiration date would be 'December 31, 2020'. If the expiration date is 'infinity', it will never expire. The password will be encrypted in the system catalogs. This is automatic with postgresql versions 10 and above. change-toplevel-database Function: (change-toplevel-database new-database user password host) \u2192 string Just changes the database assuming you are using a toplevel connection. Recommended only for development work. Returns the name of the newly connected database as a string. check-query-performance Function: (check-query-performance &optional (ob nil) (num-calls 100) (limit 20)) \u2192 list This function requires that postgresql extension pg_stat_statements must be loaded via shared_preload_libraries. It is borrowed from https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ . Optional parameters: OB allow order-by to be 'calls', 'total-time', 'rows-per' or 'time-per', defaulting to time-per. num-calls to require that the number of calls exceeds a certain threshold, and limit to limit the number of rows returned. It returns a list of lists, each row containing the query, number of calls, total_time, total_time/calls, stddev_time, rows, rows/calls and the cache hit percentage. clear-connection-pool Function: (clear-connection-pool) Disconnect and remove all connections from the connection pools. coalesce Function: (coalesce &rest args) \u2192 value Returns the first non-NIL, non-NULL (as in :null) argument, or NIL if none are present. Useful for providing a fall-back value for the result of a query, or, when given only one argument, for transforming :nulls to NIL. column-exists-p Function: (column-exists-p table-name column-name &optional schema-name) \u2192 boolean Determine if a particular column exists. Table name and column-name can be either strings or symbols. If the optional schema name is not given or the table-name is not fully qualified with a schema name, the schema will be assumed to be the public schema. commit-hooks Generic Function: (commit-hooks obj) An accessor for the transaction or savepoint's list of commit hooks, each of which should be a function with no required arguments. These functions will be executed when a transaction is committed or a savepoint released. commit-logical-transaction Generic Function: (commit-logical-transaction obj) Commit the given logical transaction, regardless of whether it is an actual transaction or a savepoint. commit-transaction Function: (commit-transaction transaction) Immediately commit an open transaction. connect Function: (connect database-name user-name password host &key (port 5432) pooled-p (use-ssl *default-use-ssl*) (service postgres)) \u2192 database-connection Create a new database connection for the given user and the database. Port will default to 5432, which is where most PostgreSQL servers are running. If pooled-p is T, a connection will be taken from a pool of connections of this type, if one is available there, and when the connection is disconnected it will be put back into this pool instead. use-ssl can be :no, :yes, or :try, as in open-database, and defaults to the value of *default-use-ssl* . connect-toplevel Function: (connect-toplevel database-name user-name password host &key (port 5432) (use-ssl *default-use-ssl*)) Bind the *database* to a new connection. Use this if you only need one connection, or if you want a connection for debugging from the REPL. connected-p Function: (connected-p database) \u2192 boolean Returns a boolean indicating whether the given connection is still connected to the server. create-all-tables Function: (create-all-tables) Creates all defined tables. create-database Function: (create-database database-name &key (encoding utf8) (connection-limit -1) owner limit-public-access comment collation template) Creates a basic database. Besides the obvious database-name parameter, you can also use key parameters to set encoding (defaults to UTF8), owner, connection-limit (defaults to no limit)). If limit-public-access is set to t, then only superuser roles or roles with explicit access to this database will be able to access it. (See Roles below) If collation is set, the assumption is that template0 needs to be used as the base of the database rather than template1 which may contain encoding specific or locale specific data. (create-database 'testdb :limit-public-access t :comment \"This database is for testing silly theories\") create-index Function: (create-index name &key unique if-not-exists concurrently on using fields) Create an index. Slightly less sophisticated than the query version because it does not have a where clause capability. create-package-tables Function: (create-package-tables package) Creates all tables identified by symbols interned in the given package. create-role Function: (create-role name password &key (base-role readonly) (schema public) (tables all) (databases current) (allow-whitespace nil) (allow-utf8 nil) (allow-disallowed-names nil) (comment nil)) Keyword parameters: Base-role. Base-role should be one of :readonly, :editor, :admin, :standard or :superuser. A readonly user can only select existing data in the specified tables or databases. An editor has the ability to insert, update, delete or select data. An admin has all privileges on a database, but cannot create new databases, roles, or replicate the system. A standard user has no particular privileges other than connecting to databases. :schema defaults to :public but can be a list of schemas. User will not have access to any schemas not in the list. :tables defaults to :all but can be a list of tables. User will not have access to any tables not in the list. :databases defaults to :current but can be a list of databases. User will not have access to any databases not in the list. :allow-whitespace - Whitespace in either the name or password is not allowed by default. :allow-utf8 defaults to nil. If t, the name and password will be normalized. If nil, the name and password are limited to printable ascii characters. For fun reading on utf8 user names see https://labs.spotify.com/2013/06/18/creative-usernames . Also interesting reading is https://github.com/flurdy/bad_usernames and https://github.com/dsignr/disallowed-usernames/blob/master/disallowed%20usernames.csv , and https://www.b-list.org/weblog/2018/feb/11/usernames/ :allow-disallowed-names defaults to nil. If nil, the user name will be checked against disallowed-role-names . As an aside, if allowing utf8 in names, you might want to think about whether you should second copy of the username in the original casing and normalized as NFC for display purposes as opposed to normalizing to NFKC. It might be viewed as culturally insensitive to change the display of the name. create-schema Function: (create-schema schema &optional authorization) Creates a new schema. Raises an error if the schema is already exists. create-sequence Function: (create-sequence name &key temp if-not-exists increment min-value max-value start cache) Create a sequence. Available additional key parameters are :temp :if-not-exists :increment :min-value :max-value :start and :cache. See https://www.postgresql.org/docs/current/static/sql-createsequence.html for details on usage. create-table Function: (create-table name) Takes the name of a dao-class and creates the table identified by symbol by executing all forms in its definition as found in the tables list. current-database Function: (current-database) \u2192 string Returns the string name of the current database. dao-class Class You can work directly with the database or you can use a simple database-access-class (aka dao) which would cover all the fields in a row. Postmodern allows you to have a relatively simple but straight forward matching of clos classes to a database table. At the heart of Postmodern's DAO system is the dao-class metaclass. It allows you to define classes for your database-access objects as regular CLOS classes. Some of the slots in these classes will refer to columns in the database. To specify that a slot refers to a column, give it a :col-type option containing an S-SQL type expression (useful if you want to be able to derive a table definition from the class definition), or simply a :column option with value T. Such slots can also take a :col-default option, used to provide a database-side default value as an S-SQL expression. You can use the :col-name initarg (whose unevaluated value will be passed to to-sql-name) to specify the slot's column's name. DAO class definitions support two extra class options: :table-name to give the name of the table that the class refers to (defaults to the class name), and :keys to provide a set of primary keys for the table if they have not been specified in a single column. If more than one key is provided, this creates a multi-column primary key and all keys must be specified when using operations such as update-dao and get-dao. When no primary keys are defined, operations such as update-dao and get-dao will not work. IMPORTANT: Class finalization for a dao class instance are wrapped with a thread lock. However, any time you are using threads and a class that inherits from other classes, you should ensure that classes are finalized before you start generating threads that create new instances of that class. The (or db-null integer) form is used to indicate a column can have NULL values otherwise the column will be treated as NOT NULL. Simple example: (defclass users () ((name :col-type string :initarg :name :accessor name) (creditcard :col-type (or db-null integer) :initarg :card :col-default :null) (score :col-type bigint :col-default 0 :accessor score)) (:metaclass dao-class) (:keys name)) In this case the name of the users will be treated as the primary key and the database table is assumed to be users. (It might be worth noting that \"user\" is a reserved word for Postgresql and using reserved words, while possible using quotes, is generally not worth the additional trouble they cause.) The name and score slots cannot be null, but the creditcard slot can be null and actually defaults to null. The :col-default :null specification ensures that the default in the database for this field is null, but it does not bound the slot to a default form. Thus, making an instance of the class without initializing this slot will leave it in an unbound state. An example of a class where the keys are set as multiple column keys is here: (defclass points () ((x :col-type integer :initarg :x :reader point-x) (y :col-type integer :initarg :y :reader point-y) (value :col-type integer :initarg :value :accessor value)) (:metaclass dao-class) (:keys x y)) In this case, retrieving a points record would look like the following where 12 and 34 would be the values you are looking to find in the x column and y column respectively.: (get-dao 'points 12 34) Now look at a slightly more complex example. (defclass country () ((id :col-type integer :col-identity t :accessor id) (name :col-type string :col-unique t :check (:<> 'name \"\") :initarg :name :reader country-name) (inhabitants :col-type integer :initarg :inhabitants :accessor country-inhabitants) (sovereign :col-type (or db-null string) :initarg :sovereign :accessor country-sovereign) (region-id :col-type integer :col-references ((regions id)) :initarg :region-id :accessor region-id)) (:documentation \"Dao class for a countries record.\") (:metaclass dao-class) (:table-name countries)) In this example we have an id column which is specified to be an identity column. Postgresql will automatically generate a sequence of of integers and this will be the primary key. We have a name column which is specified as unique and is not null. We have a region-id column which references the id column in the regions table. This is a foreign key constraint and Postgresql will not accept inserting a country into the database unless there is an existing region table with an id that matches this number. Postgresql will also not allow deleting a region if there are countries that reference that region's id. If we wanted Postgresql to delete countries when regions are deleted, that column would be specified as: (region-id :col-type integer :col-references ((regions id) :cascade) :initarg :region-id :accessor region-id) Now you can see why the double parens. We also specified that the table name is not \"country\" but \"countries\". (Some style guides recommend that table names be plural and references to rows be singular.) When inheriting from DAO classes, a subclass' set of columns also contains all the columns of its superclasses. The primary key for such a class is the union of its own keys and all the keys from its superclasses. Classes inheriting from DAO classes should probably always use the dao-class metaclass themselves. When a DAO is created with make-instance, the :fetch-defaults keyword argument can be passed, which, when T, will cause a query to fetch the default values for all slots that refers to columns with defaults and were not bound through initargs. In some cases, such as serial and identity columns, which have an implicit default, this will not work. You can work around this by creating your own sequence, e.g. \"my_sequence\", and defining a (:nextval \"my_sequence\") default. Finally, DAO class slots can have an option :ghost t to specify them as ghost slots. These are selected when retrieving instances, but not written when updating or inserting, or even included in the table definition. The only known use for this to date is for creating the table with (oids=true), and specify a slot like this: (oid :col-type integer :ghost t :accessor get-oid) dao-exists-p Generic Function: (dao-exists-p dao) \u2192 boolean Test whether a row with the same primary key as the given dao exists in the database. Will also return NIL when any of the key slots in the object are unbound. dao-keys Generic Function: (dao-keys class) \u2192 list Returns list of slot names that are the primary key of DAO class. This is likely interesting if you have primary keys which are composed of more than one slot. Pay careful attention to situations where the primary key not only has more than one column, but they are actually in a different order than they are in the database table itself. You can check this with the internal find-primary-key-info function. Obviously the table needs to have been defined. The class must be quoted. (pomo:find-primary-key-info 'country1) ((\"name\" \"text\") (\"id\" \"integer\")) \u2192 list Returns list of values that are the primary key of dao. dao-table-definition Function: (dao-table-definition table) \u2192 string Given a DAO class, or the name of one, this will produce an SQL query string with a definition of the table. This is just the bare simple definition, so if you need any extra indices or or constraints, you'll have to write your own queries to add them, in which case look to s-sql's create-table function. dao-table-name Function: (dao-table-name class) \u2192 string Get the name of the table associated with the given DAO class (or symbol naming such a class). database-connection Class Representation of a database connection. Contains login information in order to be able to automatically re-establish a connection when it is somehow closed. database-connection-error Condition Conditions of this type are signalled when an error occurs that breaks the connection socket. They offer a :reconnect restart. database-error Condition This is the condition type that will be used to signal virtually all database-related errors (though in some cases socket errors may be raised when a connection fails on the IP level). database-error-code Generic Function: (database-error-constraint-name err) Code: the Postgresql SQLSTATE code for the error (see the Postgresql Manual Appendix A for their meaning). Not localizable. Always present. database-error-message Generic Function: (database-error-constraint-name err) Message: the primary human-readable error message. This should be accurate but terse (typically one line). Always present. database-error-detail Generic Function: (database-error-constraint-name err) Detail: an optional secondary error message carrying more detail about the problem. Might run to multiple lines or NIL if none is available. database-error-query Generic Function: (database-error-constraint-name err) Query that led to the error, or NIL if no query was involved. database-error-cause Generic Function: (database-error-constraint-name err) The condition that caused this error, or NIL when it was not caused by another condition. database-error-constraint-name Generic Function: (database-error-constraint-name err) Given a database-error for an integrity violation, will attempt to extract the constraint name. database-error-extract-name Function: (database-error-extract-name err) Given a database-error, will extract the critical name from the error message. database-exists-p Function: (database-exists-p database) \u2192 boolean Checks to see if a particular database exists. Returns T if true, nil if not. database-size Function: (database-size &optional (name nil)) \u2192 list Given the name of a database, will return the name, a pretty-print string of the size of the database and the size in bytes. If a database name is not provided, it will return the result for the currently connected database. database-version Function: (database-version) \u2192 string DEPRECATED. This returns the postgresql server version number, not a version number from the currently connected database. The format of the return string is determined by the current postgresql server. E.g. \"PostgreSQL 12.2 on x86_64-pc-linux-gnu, compiled by gcc (Arch Linux 9.3.0-1) 9.3.0, 64-bit\". If you want just the postgresql version number, use (cl-postgres:get-postgresql-version). db-null Type for representing NULL values. Use like (or integer db-null) for declaring a type to be an integer that may be null.\" '(eql :null) define-dao-finalization Macro: (define-dao-finalization ((dao-name class) &rest keyword-args) &body body) Create an :around-method for make-dao. The body is executed in a lexical environment where dao-name is bound to a freshly created and inserted DAO. The representation of the DAO in the database is then updated to reflect changes that body might have introduced. Useful for processing values of slots with the type serial, which are unknown before insert-dao. defprepared Macro: (defprepared name query &optional (format rows)) \u2192 function This is the macro-style variant of prepare. It is like prepare, but gives the function a name which now becomes a top-level function for the prepared statement. The name should not a string but may be quoted. defprepared-with-names Macro: (defprepared-with-names name (&rest args) (query &rest query-args) &optional (format rows)) Like defprepared, but allows to specify names of the function arguments in a lambda list as well as arguments supplied to the query. (defprepared-with-names user-messages (user &key (limit 10)) (\"select * from messages where user_id = $1 order by date desc limit $2\" (user-id user) limit) :plists) deftable Macro: (deftable name &body definitions) Define a table. name can be either a symbol or a (symbol string) list. In the first case, the table name is derived from the symbol's name by S-SQL's rules. In the second case, the name is given explicitly. The body of definitions can contain anything that evaluates to a string, as well as S-SQL expressions. The variables table-name and *table-symbol* are bound to the relevant values in the body. Note that the evaluation of the definition is ordered, so you'll generally want to create your table first and then define indices on it. delete-dao Generic Function: (delete-dao dao) Delete the given dao from the database. describe-constraint Function: (describe-constraint table-name constraint-name) \u2192 list Return a list of alists of the descriptions a particular constraint given the table-name and the constraint name using the information_schema table. describe-foreign-key-constraints Function: (describe-foreign-key-constraints) \u2192 list Generates a list of lists of information on the foreign key constraints describe-triggers Function: (describe-triggers) \u2192 list List detailed information on the triggers from the information_schema table. describe-views Function: (describe-views &optional (schema public)) \u2192 list Describe the current views in the specified schema. Includes the select statements used to create the view. Takes an optional schema but defaults to public schema. disconnect Generic Function: (disconnect database) Disconnects a normal database connection, or moves a pooled connection into the pool. disconnect-toplevel Function: (disconnect-toplevel) Disconnect the *database* . do-query-dao Macro: (do-query-dao ((type type-var) query) &body body) \u2192 list Like query-dao, but iterates over the results rather than returning them. For each matching DAO, body is evaluated with type-var bound to the instance. Example: (do-query-dao (('user user) (:order-by (:select '* :from 'user :where (:> 'score 10000)) 'name)) (pushnew user high-scorers)) do-select-dao Macro: (do-select-dao ((type type-var) &optional (test t) &rest ordering) &body body) Like select-dao, but iterates over the results rather than returning them. For each matching DAO, body is evaluated with type-var bound to the DAO instance. Example: (do-select-dao (('user user) (:> 'score 10000) 'name) (pushnew user high-scorers)) doquery Macro: (doquery query (&rest names) &body body) Execute the given query (a string or a list starting with a keyword), iterating over the rows in the result. The body will be executed with the values in the row bound to the symbols given in names. To iterate over a parameterised query, one can specify a list whose car is the query, and whose cdr contains the arguments. For example: (doquery (:select 'name 'score :from 'scores) (n s) (incf (gethash n *scores*) s)) (doquery ((:select 'name :from 'scores :where (:> 'score '$1)) 100) (name) (print name)) double-precision 'double-float drop-database Function: (drop-database database) Drop the specified database. The database parameter can be a string or a symbol. Note: Only the owner of a database (or superuser) can drop a database and there cannot be any current connections to the database. See Database information below for information specific functions Postmodern contains a simple system for defining CLOS classes that represent rows in the database. This is not intended as a full-fledged object-relational magic system \u2015 while serious ORM systems have their place, they are notoriously hard to get right, and are outside of the scope of a humble SQL library like this. drop-index Function: (drop-index name &key concurrently if-exists cascade) Drop an index. Available keys are :concurrently, :if-exists, and :cascade. drop-prepared-statement Function: (drop-prepared-statement name &key (location both) (database *database*) (remove-function t)) The statement name can be a string or quoted symbol. Prepared statements are stored both in the meta slot in the postmodern connection and in postgresql session information. In the case of prepared statements generated with defprepared, there is also a lisp function with the same name. If you know the prepared statement name, you can delete the prepared statement from both locations (the default behavior), just from postmodern by passing :postmodern to the location key parameter or just from postgresql by passing :postgresql to the location key parameter. If you pass the name 'All' as the statement name, it will delete all prepared statements. The default behavior is to also remove any lisp function of the same name. This behavior is controlled by the remove-function key parameter. drop-role Function: (drop-role role-name &optional (new-owner postgres) (database all)) \u2192 boolean The role-name and optional new-owner name should be strings. If they are symbols, they will be converted to string and hyphens will be converted to underscores. Before dropping the role, you must drop all the objects it owns (or reassign their ownership) and revoke any privileges the role has been granted on other objects. If database is :all, drop-role will loop through all databases in the cluster ensuring that the role has no privileges or owned objects in every database. Otherwise drop-role will drop objects owned by a role in the current database. We will reassign ownership of the objects to the postgres role unless otherwise specified in the optional second parameter. Returns t if successful. Will not drop the postgres role. drop-schema Function: (drop-schema schema &key (if-exists nil) (cascade nil)) Drops an existing database schema. Accepts :if-exists and/or :cascade arguments like :drop-table. A notice instead of an error is raised with the is-exists parameter. drop-sequence Function: (drop-sequence name &key if-exists cascade) \u2192 list Drop a sequence. Name should be quoted. Available key parameters are :if-exists and :cascade. drop-table Function: (drop-table table-name &key if-exists cascade) If a table exists, drop a table. Available additional key parameters are :if-exists and :cascade. ensure-transaction Macro: (ensure-transaction &body body) Ensures that body is executed within a transaction, but does not begin a new transaction if one is already in progress. ensure-transaction-with-isolation-level Macro: (ensure-transaction-with-isolation-level isolation-level &body body) Executes body within a with-transaction form if and only if no transaction is already in progress. This adds the ability to specify an isolation level other than the current default execute Macro: (execute query &rest args) Execute a query, ignore the results. So, in effect, Like a query called with format :none. Returns the amount of affected rows as its first returned value. (Also returns this amount as the second returned value, but use of this is deprecated.) execute-file Function: (execute-file pathname &optional (print nil)) This function will execute sql queries stored in a file. Each sql statement in the file will be run independently, but if one statement fails, subsequent query statements will not be run, but any statement prior to the failing statement will have been commited. If you want the standard transction treatment such that all statements succeed or no statement succeeds, then ensure that the file starts with a \"begin transaction\" statement and finishes with an \"end transaction\" statement. See the test file test-execute-file-broken-transaction.sql as an example. For debugging purposes, if the optional print parameter is set to t, format will print the count of the query and the query to the REPL. IMPORTANT NOTE: This utility function assumes that the file containing the sql queries can be trusted and bypasses the normal postmodern parameterization of queries. find-postgresql-prepared-statement Function: (find-postgresql-prepared-statement name) \u2192 string Returns the specified named prepared statement (if any) that postgresql has for this session and placed in the meta slot in the connection. find-postmodern-prepared-statement Function: (find-postmodern-prepared-statement name) \u2192 string Returns the specified named prepared statement (if any) that postmodern has put in the meta slot in the connection. Note that this is the statement itself, not the name. find-primary-key-info Function: (find-primary-key-info table &optional (just-key nil)) \u2192 list Returns a list of sublists where the sublist contains two strings. If a table primary key consists of only one column, such as 'id' there will be a single sublist where the first string is the name of the column and the second string is the string name for the datatype for that column. If the primary key for the table consists of more than one column, there will be a sublist for each column subpart of the key. The sublists will be in the order they are used in the key, not in the order they appear in the table. If just-key is set to t, the list being returned will contain just the column names in the primary key as string names with no sublists. If the table is not in the public schema, provide the fully qualified table name e.g. schema-name.table-name. from-sql-name Function: (from-sql-name str) Convert a string to a symbol, upcasing and replacing underscores with hyphens. get-dao Generic Function: (get-dao type &rest args) \u2192 dao Get the single DAO object from the row that has the given primary key values, or NIL if no such row exists. Objects created by this function will have initialize-instance called on them (after loading in the values from the database) without any arguments \u2015 even :default-initargs are skipped. The same goes for select-dao and query-dao. (get-dao 'country \"The Netherlands\") #<COUNTRY {1010F0DCF3}> From an sql perspective, the standard call to get-dao translates as: select * from table NOTE: if you have added fields to the database table without updating the class definition, get-dao and select-dao will throw errors. This may cause your application to appear to hang unless you have the necessary condition handling in your code. Usually this will only happen during development, so throwing an error is not a bad idea. If you want to ignore the errors, set ignore-unknown-columns to t. get-database-comment Function: (get-database-comment database-name) \u2192 string Returns the comment, if any, attached to a database. get-pid Function: (get-pid) \u2192 integer Get the process id used by postgresql for this connection. get-pid-from-postmodern Function: (get-pid-from-postmodern) \u2192 integer Get the process id used by postgresql for this connection, but get it from the postmodern connection parameters. get-search-path Function: (get-search-path) Returns the default schema search path for the current session. get-table-comment Function: (get-table-comment table-name &optional schema-name) \u2192 string Retrieves the comment, if any attached to the table. get-table-oid Function: (get-table-oid table-name &optional schema-name) \u2192 integer Retrieves the oid identifier for a particular table from postgresql. Works for tables in all schemas. grant-admin-permissions Function: (grant-admin-permissions schema-name role-name &optional (table-name nil)) Grants all privileges to a role for the named schema. If the optional table-name parameter is provided, the privileges are only granted with respect to that table. grant-editor-permissions Function: (grant-editor-permissions schema-name role-name &optional (table-name nil)) Grants select, insert, update and delete privileges to a role for the named schema. If the optional table-name parameter is provided, the privileges are only granted with respect to that table. Note that we are giving some function execute permissions if table-name is nil, but if the table-name is specified, those are not provided. Your mileage may vary on how many privileges you want to provide to a editor role with access to only a limited number of tables. grant-readonly-permissions Function: (grant-readonly-permissions schema-name role-name &optional (table-name nil)) Grants select privileges to a role for the named schema. If the optional table-name parameter is provided, the privileges are only granted with respect to that table. Note that we are giving some function execute permissions if table-name is nil, but if the table-name is specified, those are not provided. Your mileage may vary on how many privileges you want to provide to a read-only role with access to only a limited number of tables. grant-role-permissions Function: (grant-role-permissions role-type name &key (schema public) (tables all) (databases all)) Grant-role-permissions assumes that a role has already been created, but permissions need to be granted or revoked on a particular database. A :superuser can create databases, roles, replication, etc. Returns nil. A :standard user has no particular privileges or restrictions. Returns nil. An :admin user can edit existing data, insert new data and create new tables in the specified databases/schemas/tables. An :editor user can update fields or insert new records but cannot create new tables in the specified tables or databases. A :readonly role can only read existing data in the specified schemas, tables or databases. Schema, tables or databases can be :all or a list of schemas, tables or databases to be granted permission. Granting :all provides access to all future items of that type as well. Note that the schema and table rights and revocations granted are limited to the connected database at the time of execution of this function. index-exists-p Function: (index-exists-p index-name) \u2192 boolean Tests whether an index with the given name exists. The name can be either a string or a symbol. insert-dao Generic Function: (insert-dao dao) \u2192 dao Insert the given dao into the database. Column slots of the object which are unbound implies the database defaults. Hence, if these columns has no defaults defined in the database, the the insertion of the dao will be failed. (This feature only works on PostgreSQL 8.2 and up.) list-all-constraints Function: (list-all-constraints table-name &optional (strings-p)) \u2192 list Users information_schema to list all the constraints in a table. Table-name can be either a string or quoted. Turns constraints into keywords if strings-p is not true. list-all-tables Function: (list-all-tables &optional (fully-qualified-names-only nil)) \u2192 list If fully-qualified-names-only is set to t, returns a flattened list of all schema.table names other than pg_catalog or the information_schema. Otherwise returns the following info: schema-name, table-name, table-owner, tablespace, hasindexes, hasrules, hastriggers and rowsecurity(&optional strings-p). list-available-collations Function: (list-available-collations) \u2192 list Get a list of the collations available from the current database cluster. Collations are a mess as different operating systems provide different collations. We might get some sanity if Postgresql can use ICU as the default. See https://wiki.postgresql.org/wiki/Collations . list-available-extensions Function: (list-available-extensions) \u2192 list List the postgresql extensions which are available in the system to the currently connected database. The extensions may or may not be installed. list-available-types Function: (list-available-types) \u2192 list List the available data types in the connected postgresql version, It returns a list of lists, each sublist containing the oid (object identifier number) and the name of the data types. E.g. (21 \"smallint\") list-columns Function: (list-columns table-name) \u2192 list Returns a list of strings of just the column names in a table. Pulls info from the postmodern table-description function rather than directly. The table-name can be a string or quoted. Any table-name that is not fully qualified with the schema will be assumed to be in the public schema. list-columns-with-types Function: (list-columns-with-types table-name) \u2192 list Returns a list of (name type) lists for the fields of a table. Returns a list of strings of just the column names and their sql data types in a table. Pulls info from the postmodern table-description function rather than directly. The table-name can be a string or quoted. Any table-name that is not fully qualified with the schema will be assumed to be in the public schema. list-connections Function: (list-connections) \u2192 list List the current postgresql connections to the currently connected database. It does this by returningo info from pg_stat_activity on open connections. list-database-access-rights Function: (list-database-access-rights &optional database-name) \u2192 list If the database parameter is specifed, this returns an list of lists where each sublist is a role name and whether they have access rights (t or nil) to that particular database. If the database-name is not provided, the sublist is a database name, a role name and whether they have access rights (t or nil). This excludes the template databases. list-database-functions Function: (list-database-functions) \u2192 list Returns a list of the functions in the database from the information_schema. DEPRECATED FOR DESCRIBE-TRIGGERS. List detailed information on the triggers from the information_schema table. list-database-users Function: (list-database-users) \u2192 list List database users (actually 'roles' in Postgresql terminology). list-databases Function: (list-databases &key (order-by-size nil) (size t) (names-only nil)) \u2192 list Returns a list of lists where each sub-list contains the name of the database, a pretty-print string of the size of that database and the size in bytes. The default order is by database name. Pass t as a parameter to :order-by-size for order by size. Setting size to nil will return just the database names in a single list ordered by name. This function excludes the template databases list-detailed-triggers Function: (list-detailed-triggers) \u2192 list list-foreign-keys Function: (list-foreign-keys table schema) \u2192 list Returns a list of sublists of foreign key info in the form of '((constraint-name local-table local-table-column foreign-table-name foreign-column-name)) list-index-definitions Function: (list-index-definitions table-name) \u2192 list Returns a list of the definitions used to create the current indexes for the table list-indexed-column-and-attributes Function: (list-indexed-column-and-attributes table-name) \u2192 list List the indexed columns and their attributes in a table. Includes primary key. list-indices Function: (list-indices &optional strings-p) \u2192 list Return a list of the indexs in a database. Turn them into keywords if strings-p is not true. list-installed-extensions Function: (list-installed-extensions) \u2192 list List the postgresql extensions which are installed in the currently connected database. list-postmodern-prepared-statements Function: (list-postmodern-prepared-statements &optional (names-only nil)) \u2192 list List the prepared statements that postmodern has put in the meta slot in the connection. It will return a list of alists of form: ((:NAME . SNY24) (:STATEMENT . (SELECT name, salary FROM employee WHERE (city = \\$1))) (:PREPARE-TIME . #<TIMESTAMP 25-11-2018T15:36:43,385>) (:PARAMETER-TYPES . text) (:FROM-SQL) If the names-only parameter is set to t, it will only return a list of the names of the prepared statements. list-prepared-statements Function: (list-prepared-statements &optional (names-only nil)) \u2192 list This is syntactic sugar. It runs a query that lists the prepared statements in the session in which the function is run. If the names-only parameter is set to t, it will only return a list of the names of the prepared statements. list-role-accessible-databases Function: (list-role-accessible-databases role-name) \u2192 list Returns a list of the databases to which the specified role can connect. list-role-permissions Function: (list-role-permissions &optional role) \u2192 list This returns a list of sublists of the permissions granted within the currently connected database. If an optional role is provided, the result is limited to that role. The sublist returned will be in the form of role-name, schema-name, table-name and then a string containing all the rights of that role on that table in that schema. list-roles Function: (list-roles &optional (lt nil)) \u2192 list Returns a list of alists of rolenames, role attributes and membership in roles. See https://www.postgresql.org/docs/current/role-membership.html for an explanation. Optionally passing :alists or :plists can be used to set the return list types to :alists or :plists. This is the same as the psql function \\du. list-schemas Function: (list-schemas) \u2192 list List schemas in the current database, excluding the pg_* system schemas. list-schemata \u2192 list List all existing user defined schemata. Note: The query uses the portable information_schema relations instead of pg_tables relations. select schema_name from information_schema.schemata where schema_name !~ '(pg_*)|information_schema' order by schema_name ; list-sequences Function: (list-sequences &optional strings-p) \u2192 list Returns a list of the sequences in the current database. When strings-p is T, the names will be given as strings, otherwise as keywords. list-table-indices Function: (list-table-indices table-name &optional strings-p) \u2192 list List the index names and the related columns in a single table. Each index will be in a separate sublist. list-table-sizes Function: (list-table-sizes &key (schema public) (order-by-size nil) (size t)) \u2192 list Returns a list of lists (table-name, size in 8k pages) of tables in the current database. Providing a name to the schema parameter will return just the information for tables in that schema. It defaults to just the tables in the public schema. Setting schema to nil will return all tables, indexes etc in the database in descending order of size. This would include system tables, so there are a lot more than you would expect. If :size is set to nil, it returns only a flat list of table names. Setting order-by-size to t will return the result in order of size instead of by table name. list-tables Function: (list-tables &optional (strings-p nil)) \u2192 list DEPRECATED FOR LIST-ALL-TABLES. Return a list of the tables in the public schema of a database. By default the table names are returned as keywords. They will be returned as lowercase strings if strings-p is true. list-tables-in-schema Function: (list-tables-in-schema &optional (schema-name public) (strings-p nil)) \u2192 list Returns a list of tables in a particular schema, defaulting to public. If schema-name is :all, it will return all the non-system tables in the database in fully qualified form: e.g. 'public.test_table'. If string-p is t, the names will be returned as strings with underscores converted to hyphens. list-tablespaces Function: (list-tablespaces) \u2192 list Lists the tablespaces in the currently connected database. What are tablespace you ask? Per the Postgresql documentation https://www.postgresql.org/docs/current/manage-ag-tablespaces.html : Tablespaces in PostgreSQL allow database administrators to define locations in the file system where the files representing database objects can be stored. Once created, a tablespace can be referred to by name when creating database objects. By using tablespaces, an administrator can control the disk layout of a PostgreSQL installation. This is useful in at least two ways. First, if the partition or volume on which the cluster was initialized runs out of space and cannot be extended, a tablespace can be created on a different partition and used until the system can be reconfigured. Second, tablespaces allow an administrator to use knowledge of the usage pattern of database objects to optimize performance. For example, an index which is very heavily used can be placed on a very fast, highly available disk, such as an expensive solid state device. At the same time a table storing archived data which is rarely used or not performance critical could be stored on a less expensive, slower disk system. list-templates Function: (list-templates) \u2192 list Returns a list of existing database template names. list-triggers Function: (list-triggers &optional table-name) \u2192 list List distinct trigger names from the information_schema table. Table-name can be either quoted or string. (A trigger is a specification that the database should automatically execute a particular function whenever a certain type of operation is performed. Triggers can be attached to tables (partitioned or not), views, and foreign tables. See https://www.postgresql.org/docs/current/trigger-definition.html ) list-unique-or-primary-constraints Function: (list-unique-or-primary-constraints table-name &optional (strings-p)) \u2192 list List constraints on a table. Table-name can be either a string or quoted. Turns constraints into keywords if strings-p is not true. list-views Function: (list-views &optional strings-p) \u2192 list Returns list of the user defined views in the current database. When strings-p is T, the names will be returned as strings, otherwise as keywords. make-dao Generic Function: (make-dao type &rest args &key &allow-other-keys) \u2192 dao Combines make-instance with insert-dao. Make the instance of the given class and insert it into the database, returning the created dao. num-records-in-database Function: (num-records-in-database) \u2192 list Returns a list of lists with schema, table name and approximate number of records in the currently connected database. \u2192 list Returns a list of lists with schema, table name and approximate number of records in the currently connected database. numeric (declare (ignore precision/scale scale)) 'number parse-queries Function: (parse-queries file-content) \u2192 list Read SQL queries in given string and split them, returns a list. postgres-array-string-to-array Function: (postgres-array-string-to-array str) \"Takes a postgresql array in the form of a string like wol=CTc/wol,a=c/wol,b=c/wol\" and returns a lisp list like (wol=CTc/wol\" \u00e4=c/wol\" b=c/wol).\" postgres-array-string-to-list Function: (postgres-array-string-to-list str) \u2192 array Takes a postgresql array in the form of a string like \"{wol=CTc/wol,a=c/wol,b=c/wol}\" and returns a lisp array like #(\"wol=CTc/wol\" \"a=c/wol\" \"b=c/wol\") postgresql-version Function: (postgresql-version) \u2192 string Returns the version string provided by postgresql of the current postgresql server. E.g. \"PostgreSQL 12.2 on x86_64-pc-linux-gnu, compiled by gcc (Arch Linux 9.3.0-1) 9.3.0, 64-bit\". If you want just the postgresql version number, use (cl-postgres:get-postgresql-version). prepare Macro: (prepare query &optional (format rows)) \u2192 function Wraps a query into a function that can be used as the interface to a prepared statement. The given query (either a string or an S-SQL form) may contain placeholders, which look like \\$1, \\$2, etc. The resulting function takes one argument for every placeholder in the query, executes the prepared query, and returns the result in the format specified. (Allowed formats are the same as for query.) For queries that have to be run very often, especially when they are complex, it may help performance since the server only has to plan them once. See the PostgreSQL manual for details. In some cases, the server will complain about not being able to deduce the type of the arguments in a statement. In that case you should add type declarations (either with the PostgreSQL's CAST SQL-conforming syntax or historical :: syntax, or with S-SQL's :type construct) to help it out. Note that it will attempt to automatically reconnect if database-connection-error, or admin-shutdown. It will reset prepared statements triggering an invalid-sql-statement-name error. It will overwrite old prepared statements triggering a duplicate-prepared-statement error. prepared-statement-exists-p Function: (prepared-statement-exists-p name) \u2192 boolean This returns t if the prepared statement exists in the current postgresql session, otherwise nil. query Macro: (query query &rest args/format) \u2192 result Execute the given query, which can be either a string or an S-SQL form (list starting with a keyword). If the query contains placeholders (\\$1, \\$2, etc) their values can be given as extra arguments. If one of these arguments is a keyword occurring in the table below, it will not be used as a query argument, but will determine the format in which the results are returned instead. Any of the following formats can be used, with the default being :rows: --------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------- :none Ignore the result values. :lists, :rows Return a list of lists, each list containing the values for a row. :list, :row Return a single row as a list. :alists Return a list of alists which map column names to values, with the names represented as keywords. :alist Return a single row as an alist. :array-hash Return an array of hashtables which map column names to hash table keys :str-alists Like :alists, but use the original column names. :str-alist Return a single row as an alist, with strings for names. :plists Return a list of plists which map column names to values,with the names represented as keywords. :plist Return a single row as a plist. :column Return a single column as a list. :single Return a single value. :single! Like :single, but raise an error when the number of selected rows is not equal to 1. (:dao type) Return a list of DAOs of the given type. The names of the fields returned by the query must match slots in the DAO class the same way as with query-dao. (:dao type :single) Return a single DAO of the given type. --------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------- Some Examples: (query (:select '* :from 'country :where (:= 'name \"Croatia\"))) ((\"Croatia\" 4400000 :NULL)) (query (:select 'inhabitants :from 'country :where (:= 'name \"Croatia\")) :single) 4400000 (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :alist) ((:NAME . \"Croatia\") (:INHABITANTS . 4400000) (:SOVEREIGN . :NULL)) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :str-alist) ((\"name\" . \"Croatia\") (\"inhabitants\" . 4400000) (\"sovereign\" . :NULL)) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :plist) (:NAME \"Croatia\" :INHABITANTS 4400000 :SOVEREIGN :NULL) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :list) (\"Croatia\" 4400000 :NULL) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :lists) ((\"Croatia\" 4400000 :NULL)) (query (:select '* :from 'country) :lists) ((\"The Netherlands\" 16800000 \"Willem-Alexander\") (\"Croatia\" 4400000 :NULL)) (query (:select '* :from 'country) :alists) (((:NAME . \"The Netherlands\") (:INHABITANTS . 16800000) (:SOVEREIGN . \"Willem-Alexander\")) ((:NAME . \"Croatia\") (:INHABITANTS . 4400000) (:SOVEREIGN . :NULL))) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :array-hash) #(#<HASH-TABLE :TEST EQUAL :COUNT 3 {10106CA323}>) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) (:dao country)) (#<COUNTRY {1010688943}>) (query (:select '* :from 'country) (:dao country)) (#<COUNTRY {1010464023}> #<COUNTRY {1010465CB3}>) (query (:select 'inhabitants :from 'country :where (:= 'name \"Croatia\")) :column) (4400000) If the database returns information about the amount rows that were affected, such as with updating or deleting queries, this is returned as a second value. query-dao Macro: (query-dao type query &rest args) \u2192 list Execute the given query (which can be either a string or an S-SQL expression) and return the result as DAOs of the given type. If the query contains placeholders (\\$1, \\$2, etc) their values can be given as extra arguments. The names of the fields returned by the query must either match slots in the DAO class, or be bound through with-column-writers. read-queries Function: (read-queries filename) Read SQL queries in a given file and split them, returns a list. real 'float reconnect Generic Function: (reconnect database) Reconnect a disconnected database connection. This is not allowed for pooled connections \u2015 after they are disconnected they might be in use by some other process, and should no longer be used. register-sql-operators Macro: (register-sql-operators arity &rest names) Define simple operators. Arity is one of :unary (like 'not'), :unary-postfix (the operator comes after the operand), :n-ary (like + : the operator falls away when there is only one operand), :2+-ary (like '=', which is meaningless for one operand), or :n-or-unary (like '-', where the operator is kept in the unary case). After the arity follow any number of operators, either just a keyword, in which case the downcased symbol name is used as the operator, or a two-element list containing a keyword and a name string. release-savepoint Function: (release-savepoint savepoint) Immediately release a savepoint, commiting its results. reset-prepared-statement Function: (reset-prepared-statement condition) \u2192 restart If you have received an invalid-prepared-statement error but the prepared statement is still in the meta slot in the postmodern connection, this will try to regenerate the prepared statement at the database connection level and restart the connection. revoke-all-on-table Function: (revoke-all-on-table table-name role-name) Takes a table-name which could be a string, symbol or list of strings or symbols of tables names, a role name and revokes all privileges that role-name may have with that/those tables. This is limited to the currently connected database and can only revoke the privileges granted by the caller of the function. role-exists-p Function: (role-exists-p role-name) \u2192 boolean Does the named role exist in this database cluster? Returns t or nil. rollback-savepoint Function: (rollback-savepoint savepoint) Immediately roll back a savepoint, aborting the results. save-dao Function: (save-dao dao) \u2192 boolean Tries to insert the given dao using insert-dao. If this raises a unique key violation error, it tries to update it by using update-dao instead. Be aware that there is a possible race condition here \u2015 if some other process deletes the row at just the right moment, the update fails as well. Returns a boolean telling you whether a new row was inserted. This function is unsafe to use inside of a transaction \u2015 when a row with the given keys already exists, the transaction will be aborted. Use save-dao/transaction instead in such a situation. See also: upsert-dao. save-dao/transaction Function: (save-dao/transaction dao) \u2192 boolean The transaction safe version of save-dao. Tries to insert the given dao using insert-dao. If this raises a unique key violation error, it tries to update it by using update-dao instead. Be aware that there is a possible race condition here \u2015 if some other process deletes the row at just the right moment, the update fails as well. Returns a boolean telling you whether a new row was inserted. Acts exactly like save-dao, except that it protects its attempt to insert the object with a rollback point, so that a failure will not abort the transaction. See also: upsert-dao. schema-exists-p Function: (schema-exists-p name) \u2192 boolean Tests the existence of a given schema. Returns T if the schema exists or NIL otherwise. The name provided can be either a string or quoted symbol. select-dao Macro: (select-dao type &optional (test t) &rest ordering) \u2192 list Select DAO objects for the rows in the associated table for which the given test (either an S-SQL expression or a string) holds. When sorting arguments are given, which can also be S-SQL forms or strings, these are used to sort the result. (Note that, if you want to sort, you have to pass the test argument.) (select-dao 'country) (#<COUNTRY {101088F6F3}> #<COUNTRY {101088FAA3}>) 2 (select-dao 'country (:> 'inhabitants 50000000)) NIL 0 (select-dao 'country (:> 'inhabitants 5000000)) (#<COUNTRY {10108AD293}>) 1 (select-dao 'country (:> 'inhabitants 5000)) (#<COUNTRY {10108CA773}> #<COUNTRY {10108CAB23}>) 2 (select-dao 'country (:> 'inhabitants 5000) 'name) ;sorted by name (#<COUNTRY {10108EF423}> #<COUNTRY {10108EF643}>) (mapcar 'country-name (select-dao 'country (:> 'inhabitants 5000) 'name)) (\"Croatia\" \"The Netherlands\") (mapcar 'country-name (select-dao 'country (:> 'inhabitants 5000))) (\"The Netherlands\" \"Croatia\") If for some reason, you wanted the list in reverse alphabetical order, then: (select-dao 'country (:> 'id 0) (:desc 'name)) sequence-exists-p Function: (sequence-exists-p sequence) \u2192 boolean Tests whether a sequence with the given name exists. The name can be either a string or a symbol. sequence-next Function: (sequence-next sequence) \u2192 integer Shortcut for getting the next value from a sequence. The sequence identifier can be either a string or a symbol, in the latter case it will be converted to a string according to S-SQL rules. serial 'integer serial8 'integer set-search-path Function: (set-search-path path) This changes the postgresql runtime parameter controlling what order schemas are searched. You can always use fully qualified names [schema.table]. By default, this function only changes the search path for the current session. This function is used by with-schema. smallint '(signed-byte 16) split-fully-qualified-tablename Function: (split-fully-qualified-tablename name) \u2192 list Take a tablename of the form database.schema.table or schema.table or table and return the tablename and the schema name. The name can be a symbol or a string. Returns a list of form '(table schema database. If the tablename is not fully qualified, it will assume that the schema should be public. sql Macro: (sql form) \u2192 string Convert the given form (a list starting with a keyword) to an SQL query string at compile time, according to the rules described here. For example: (sql (:select '* :from 'country :where (:= 'a 1))) \"(SELECT * FROM country WHERE (a = 1))\" but (sql '(:select '* :from 'country :where (:= 'a 1))) would throw an error. For the later case you need to use sql-compile. sql-compile Function: (sql-compile form) \u2192 string This is the run-time variant of the sql macro. It converts the given list to an SQL query, with the same rules except that symbols in this list do not have to be quoted to be interpreted as identifiers. For example: (sql-compile '(:select '* :from 'country :where (:= 'a 1))) \\\"(SELECT * FROM country WHERE (a = 1))\\\" but (sql (:select '* :from 'country :where (:= 'a 1))) would throw an error. For the later case you need to use sql. sql-error Function: (sql-error control &rest args) No documentation provided. sql-escape Generic Function: (sql-escape arg) A generalisation of sql-escape-string looks at the type of the value passed, and properly writes it out it for inclusion in an SQL query. Symbols will be converted to SQL names. Examples: (sql-escape \"tr'-x\") \"E'tr''-x'\" (sql-escape (/ 1 13)) \"0.0769230769230769230769230769230769230\" (sql-escape #(\"Baden-Wurttemberg\" \"Bavaria\" \"Berlin\" \"Brandenburg\")) \"ARRAY[E'Baden-Wurttemberg', E'Bavaria', E'Berlin', E'Brandenburg']\" sql-escape-string Function: (sql-escape-string string &optional prefix) \u2192 string Escapes a string for inclusion in a PostgreSQL query. Example: (sql-escape-string \\\"Puss in 'Boots'\\\") \\\"E'Puss in ''Boots'''\\\" table-description Function: (table-description table-name &optional schema-name) \u2192 list Returns a list of the fields in the named table. Each field is represented by a list of three elements: the field name, the type, and a boolean indicating whether the field may be NULL. Table can be either a string or quoted. Table-names can be fully qualified with the schema or not. If the table-name is not fully qualified and a schema name is not provided, the table will be assumed to be in the public schema. table-description-plus Function: (table-description-plus table-name &optional schema-name) \u2192 list Returns more table info than table-description. Specifically returns ordinal-position, column-name, data-type, character-maximum-length, modifier, whether it is not-null and the default value. Table can be either a string or quoted. Table-names can be fully qualified with the schema or not. If the table-name is not fully qualified and a schema name is not provided, the table will be assumed to be in the public schema. table-exists-p Function: (table-exists-p table-name &optional schema-name) \u2192 boolean Check whether a table exists in a particular schema. Defaults to the search path. Takes either a string or a symbol for the table name. The table-name can be fully qualified in the form of schema.table-name or database.schema.table-name. If the schema is specified either in a qualified table-name or in the optional schema-name parameter, we look directly to the information schema tables. Otherwise we use the search path which can be controlled by being within a with-schema form. table-size Function: (table-size table-name) \u2192 list Return the size of a given postgresql table in k or m. Table-name can be either a string or quoted. terminate-backend Function: (terminate-backend pid &optional (database *database*)) Less polite way of terminating at the database (as opposed to calling close-database). Faster than (cancel-backend pid) and more reliable. text Generic Function: (text condition) 'string to-sql-name Function: (to-sql-name name &optional (escape-p *escape-sql-names-p*) (ignore-reserved-words nil)) Convert a symbol or string into a name that can be a sql table, column, or operation name. Add quotes when escape-p is true, or escape-p is :auto and the name contains reserved words. Quoted or delimited identifiers can be used by passing :literal as the value of escape-p. If escape-p is :literal, and the name is a string then the string is still escaped but the symbol or string is not downcased, regardless of the setting for downcase-symbols and the hyphen and forward slash characters are not replaced with underscores. Ignore-reserved-words is only used internally for column names which are allowed to be reserved words, but it is not recommended. unused-indexes \u2192 list Returns a list of lists showing schema.table, indexname, index_size and number of scans. The code was borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ update-dao Generic Function: (update-dao dao) \u2192 dao Update the representation of the given dao in the database to the values in the object. This is not defined for tables that do not have any non-primary-key columns. Raises an error when no row matching the dao exists. upsert-dao Generic Function: (upsert-dao dao) \u2192 dao Like save-dao or save-dao/transaction but using a different method that doesn't involve a database exception. This is safe to use both in and outside a transaction, though it's advisable to always do it in a transaction to prevent a race condition. The way it works is: If the object contains unbound slots, we call insert-dao directly, thus the behavior is like save-dao. Otherwise we try to update a record with the same primary key. If the PostgreSQL returns a non-zero number of rows updated it treated as the record is already exists in the database, and we stop here. If the PostgreSQL returns a zero number of rows updated, it treated as the record does not exist and we call insert-dao. The race condition might occur at step 3 if there's no transaction: if UPDATE returns zero number of rows updated and another thread inserts the record at that moment, the insertion implied by step 3 will fail. Note, that triggers and rules may affect the number of inserted or updated rows returned by PostgreSQL, so zero or non-zero number of affected rows may not actually indicate the existence of record in the database. This method returns two values: the DAO object and a boolean (T if the object was inserted, NIL if it was updated). varchar (declare (ignore length)) `string) view-exists-p Function: (view-exists-p view) \u2192 boolean Tests whether a view with the given name exists. Takes either a string or a symbol for the view name. with-column-writers Macro: (with-column-writers (&rest defs) &body body) Provides control over the way get-dao, select-dao, and query-dao read values from the database. This is not commonly needed, but can be used to reduce the amount of queries a system makes. writers should be a list of alternating column names (strings or symbols) and writers, where writers are either symbols referring to a slot in the objects, or functions taking two arguments \u2015 an instance and a value \u2015 which can be used to somehow store the value in the new instance. When any DAO-fetching function is called in the body, and columns matching the given names are encountered in the result, the writers are used instead of the default behaviour (try and store the value in the slot that matches the column name). An example of using this is to add some non-column slots to a DAO class, and use query-dao within a with-column-writers form to pull in extra information about the objects, and immediately store it in the new instances. with-connection Macro: (with-connection spec &body body) Evaluates the body with database bound to a connection as specified by spec, which should be list that connect can be applied to. with-logical-transaction Macro: (with-logical-transaction (&optional (name nil) (isolation-level *isolation-level*)) &body body) Executes body within a with-transaction form if no transaction is currently in progress, otherwise simulates a nested transaction by executing it within a with-savepoint form. The transaction or savepoint is bound to name if one is supplied. The isolation-level will set the isolation-level used by the transaction. You can specify the following isolation levels in postmodern transactions: :read-committed-rw (read committed with read and write) :read-committed-ro (read committed with read only) :repeatable-read-rw (repeatable read with read and write) :repeatable-read-ro (repeatable read with read only) :serializable (serializable with reand and write) For more information see isolation-notes Sample usage where \"george\" is just the name given to the transaction (not quoted or a string) and ... simply indicates other statements would be expected here: (with-logical-transaction () (execute (:insert-into 'test-data :set 'value 77)) ...) (with-logical-transaction (george) (execute (:insert-into 'test-data :set 'value 22)) ...) (with-logical-transaction (george :read-committed-rw) (execute (:insert-into 'test-data :set 'value 33)) ...) (with-logical-transaction (:serializable) (execute (:insert-into 'test-data :set 'value 44)) ...) with-savepoint Macro: (with-savepoint name &body body) Can only be used within a transaction. Establishes a savepoint with the given name at the start of body, and binds the same name to a handle for that savepoint. The body is executed and, at the end of body, the savepoint is released, unless a condition is thrown, in which case it is rolled back. Execute the body within a savepoint, releasing savepoint when the body exits normally, and rolling back otherwise. NAME is both the variable that can be used to release or rolled back before the body unwinds, and the SQL name of the savepoint. with-schema Macro: (with-schema (schema &key (strict t) (if-not-exist create) (drop-after nil)) &body form) A macro to set the schema search path (namespace) of the postgresql database to include as first entry a specified schema and then executes the body. Before executing body the PostgreSQL's session variable search_path is set to the given namespace. After executing body the search_path variable is restored to the original value. Calling with :strict 't only the specified schema is set as current search path. All other schema are then not searched any more. If strict is nil, the namespace is just first schema on the search path upon the the body execution. Calling with :if-not-exist set to :create the schema is created if this schema did not exist. Calling with :if-not-exist set to nil, an error is signaled. calling with drop-after set to 't the schema is removed after the execution of the body form. example : (with-schema (:schema-name :strict nil :drop-after nil :if-not-exist :error) (foo 1) (foo 2)) example : (with-schema ('uniq :if-not-exist :create) ;; changing the search path (schema-exists-p 'uniq)) with-transaction Macro: (with-transaction (&optional name isolation-level) &body body) Execute the given body within a database transaction, committing it when the body exits normally, and aborting otherwise. An optional name and/or isolation-level can be given to the transaction. The name can be used to force a commit or abort before the body unwinds. The isolation-level will set the isolation-level used by the transaction. You can specify the following isolation levels in postmodern transactions: :read-committed-rw (read committed with read and write) :read-committed-ro (read committed with read only) :repeatable-read-rw (repeatable read with read and write) :repeatable-read-ro (repeatable read with read only) :serializable (serializable with reand and write) Sample usage where \"george\" is just the name given to the transaction (not quoted or a string) and ... simply indicates other statements would be expected here: (with-transaction () (execute (:insert-into 'test-data :set 'value 77)) ...) (with-transaction (george) (execute (:insert-into 'test-data :set 'value 22)) ...) (with-transaction (george :read-committed-rw) (execute (:insert-into 'test-data :set 'value 33)) (query (:select '* :from 'test-data)) ...) (with-transaction (:serializable) (execute (:insert-into 'test-data :set 'value 44)) ...) Further discussion of transactions and isolation levels can found at isolation-notes.html in the doc directory.","title":"postmodern - PostgreSQL programming interace"},{"location":"postmodern/#postmodern-postgresql-programming-interace","text":"Version: 1.32 (The June 2020 Quicklisp dist contains version 1.30. 1.32 should be available post this. Everything except the constructs relevant to Database Management and Roles should work.) Nickname: pomo Repository: marijnh/Postmodern - Github This page was possible due to the excellent official documentation . In fact, there are several sections the manual goes into, which we do not go into below. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . Postmodern is a Common Lisp library for interacting with PostgreSQL databases . The focus has been on: Efficient communication with the database server without need for foreign libraries. Support for UTF-8 on Unicode-aware Lisp implementations A syntax for mixing SQL and Lisp code Convenient support for prepared statements and stored procedures A metaclass for simple database-access objects The biggest differences between this library and clsql or cl-dbi or to some extent, mito , are that Postmodern has no intention of being portable across different SQL implementations (it embraces non-standard PostgreSQL features), and approaches extensions like lispy SQL and database access objects in a quite different way. In addition, there is no builtin support for migrations , for which, you may want to use other libraries - cl-migratum database-migrations postmodern-passenger-pigeon cl-migrations mito , along with being an ORM, also provides support for migrations.","title":"postmodern - PostgreSQL programming interace"},{"location":"postmodern/#getting-started","text":"","title":"GETTING STARTED"},{"location":"postmodern/#starting-the-postgres-server","text":"Follow the installation instructions to install Postgres. Once done, you should have access to the database server daemon postgres and the helper commands pg_ctl and psql on your command line / terminal. Once done, this page elaborates the process of starting the database server and any issues that may arise. (The postgresql version can be selected from the top of that page.) Initialize the directory: pg_ctl init -D postmodern # see \\ pg_ctl --help \\ from the options . Optionally, change port and unix_socket_directories from postmodern/postgresql.conf . (Simply search for lines starting with these terms.) pg_ctl start -D postmodern to start the server. You should get a server started message; if not, the link above should help in debugging. Proceed to the next section once you successfully start the server. This page elaborates on the configuration settings. In addition, you can list the databases by using psql -p PORT -h unix_socket_directories -l , replacing the italicized arguments appropriately. A few things to note above include that you can run multiple postgres servers from different directories on different ports on a single machine. Note also that the directory name is independent of the database name.","title":"Starting the Postgres server"},{"location":"postmodern/#connecting-to-the-postgres-server","text":"Postgres has a connect-toplevel and with-connection besides a few other ways (see below) for establishing connections. The latter establishes connections with a lexical scope and can be useful in the case of multiple roles . See connect for the spec in with-connection . Below, we firstly connect to the default existing database postgres . Create a new database testdb for our purpose, and then disconnect and reconnect to this new database. The first connection and disconnection is all carried out by the with-connection . Assume that \"foucault\" role is a superuser, and that the database server was started above at the non-default port 8080. (See psql -p 8080 -h unix_socket_directories -c '\\du' -d postgres to list all the users.) (with-connection '(\"postgres\" \"foucault\" \"surveiller\" \"localhost\" :port 8080) (create-database 'testdb :limit-public-access t :comment \"This database is for testing silly theories\")) (connect-toplevel \"testdb\" \"foucault\" \"surveiller\" \"localhost\" :port 8080) Connect-toplevel will maintain a single connection for the life of the session. A word about Postgresql connections: Postgresql connections are not lightweight threads. They actually consume about 10 MB of memory per connection and Postgresql can be tuned to limit the number of connections allowed at any one time. In addition, any connections which require security (ssl or scram authentication) will take additional time and create more overhead. If you have an application (web apps for instance) which will make many connections, you generally do not want to create and drop connections for every query. The usual solution is to use connection pools so that the application is grabbing an already existing connection and returning it to the pool when finished, saving connection time and memory. To use postmodern's simple connection pooler, the with-connection call would look like: (with-connection '(\"testdb\" \"foucault\" \"surveiller\" \"localhost\" :pooled-p t) ...) The maximum number of connections is determined by *max-pool-size* . Things you may want to take a look at with regards to connection include: database-connection connect *default-use-ssl* disconnect connected-p reconnect *database* with-connection call-with-connection connect-toplevel disconnect-toplevel clear-connection-pool *max-pool-size* list-connections","title":"Connecting to the Postgres server"},{"location":"postmodern/#executing-arbitrary-database-commands","text":"Query is the basic way to send queries to the database: CL-USER> (query \"select 22, 'Folie et d\u00e9raison', 4.5\") ((22 \"Folie et d\u00e9raison\" 9/2)) CL-USER> (query (:select 22 \"Folie et d\u00e9raison\" 4.5)) ((22 \"Folie et d\u00e9raison\" 9/2)) In many contexts, query strings and lists starting with keywords can be used interchangeably. The lists will be compiled to SQL. The S-SQL manual describes the syntax used by these expressions. Lisp values occurring in them are automatically escaped. In the above query, only constant values are used, but it is possible to transparently use run-time values as well: CL-USER> (defun database-powered-addition (a b) (query (:select (:+ a b)) :single)) DATABASE-POWERED-ADDITION CL-USER> (database-powered-addition 1030 204) 1234 1 That last argument, :single , indicates that we want the result not as a list of lists (for the result rows), but as a single value, since we know that we are only selecting one value. See the documentation of query for the other options. You do not have to pull in the whole result of a query at once, you can also iterate over it with the doquery macro. The following things should be useful about querying: query execute doquery prepare defprepared defprepared-with-names with-transaction commit-transaction abort-transaction with-savepoint release-savepoint rollback-savepoint commit-hooks abort-hooks with-logical-transaction abort-logical-transaction commit-logical-transaction *current-logical-transaction* ensure-transaction with-schema sequence-next coalesce","title":"Executing arbitrary database commands"},{"location":"postmodern/#database-access-class","text":"You can work directly with the database or you can use a simple database-access-class (aka dao-class ) which would cover all the fields in a row. This is what a database-access class looks like: (defclass points () ((x :col-type integer :initarg :x :reader point-x) (y :col-type integer :initarg :y :reader point-y) (value :col-type integer :initarg :value :accessor value)) (:metaclass dao-class) (:keys x y)) Once the class is defined, we create the table in the database: CL-USER> (dao-table-definition 'points) \"CREATE TABLE points (x INTEGER NOT NULL, y INTEGER NOT NULL, value INTEGER NOT NULL, PRIMARY KEY (x, y))\" CL-USER> (execute (dao-table-definition 'points)) 0 In more complicated cases, you might want to :create-table directly. You can use sql to view the result of parsing the form . CL-USER> (sql (:create-table so-items ((item-id :type integer) (so-id :type (or integer db-null) :references ((so-headers id))) (product-id :type (or integer db-null)) (qty :type (or integer db-null)) (net-price :type (or numeric db-null))) (:primary-key item-id so-id))) \"CREATE TABLE so_items (item_id INTEGER NOT NULL, so_id INTEGER REFERENCES so_headers(id) MATCH SIMPLE ON DELETE RESTRICT ON UPDATE RESTRICT, product_id INTEGER, qty INTEGER, net_price NUMERIC, PRIMARY KEY (item_id, so_id))\" (Note that you'd need to execute this form using query or execute . Also see this for details and examples on using S-SQL for creating tables.) You can use insert-dao for inserting DAO-objects into the database. (Of course, you can use query to do all this using the usual SQL syntax.) CL-USER> (insert-dao (make-instance 'points :x 0 :y 1 :value 10)) #<POINTS {10145AC1D3}> CL-USER> (insert-dao (make-instance 'points :x 1 :y 0 :value 15)) #<POINTS {10145B5EA3}> CL-USER> (select-dao 'country) (#<COUNTRY {101C5F3103}> #<COUNTRY {101C5F3883}>) 2 CL-USER> (select-dao 'points) (#<POINTS {1017B9BB93}> #<POINTS {1017B9BC23}>) 2 CL-USER> (query (:select '* :from 'points)) ((0 1 10) (1 0 15)) 2 Finally, you can use update-dao to, well, update the database entry: CL-USER> (let ((1-0 (get-dao 'points 1 0))) (setf (value 1-0) 20) (update-dao 1-0)) #<POINTS {101F1628E3}> CL-USER> (query (:select '* :from 'points)) ((0 1 10) (1 0 20)) 2 Here are the other useful constructs related to database access objects: dao-class dao-keys dao-exists-p make-dao define-dao-finalization get-dao select-dao do-select-dao query-dao do-query-dao *ignore-unknown-columns* insert-dao update-dao save-dao save-dao/transaction upsert-dao delete-dao dao-table-name dao-table-definition with-column-writers","title":"Database Access Class"},{"location":"postmodern/#s-sql","text":"Finally, here is some more demonstration of S-SQL syntax: (sql (:select 'relname :from 'pg-catalog.pg-class :inner-join 'pg-catalog.pg-namespace :on (:= 'relnamespace 'pg-namespace.oid) :where (:and (:= 'relkind \"r\") (:not-in 'nspname (:set \"pg_catalog\" \"pg_toast\")) (:pg-catalog.pg-table-is-visible 'pg-class.oid)))) ;; => \"(SELECT relname FROM pg_catalog.pg_class ;; INNER JOIN pg_catalog.pg_namespace ON (relnamespace = pg_namespace.oid) ;; WHERE ((relkind = 'r') and (nspname NOT IN ('pg_catalog', 'pg_toast')) ;; and pg_catalog.pg_table_is_visible(pg_class.oid)))\" Lists starting with keywords are used to express SQL commands and operators while lists starting with something else will be evaluated and then inserted into the query. Quoted symbols name columns or tables (keywords can also be used but might introduce ambiguities). The syntax supports subqueries, multiple joins, stored procedures, etc. See the S-SQL reference manual for a complete treatment. [TODO] Add more S-SQL examples. Compare them with SxQL as well.","title":"S-SQL"},{"location":"postmodern/#prepared-statements","text":"*allow-overwriting-prepared-statements* prepared-statement-exists-p list-prepared-statements drop-prepared-statement list-postmodern-prepared-statements find-postgresql-prepared-statement find-postmodern-prepared-statement reset-prepared-statement get-pid get-pid-from-postmodern cancel-backend terminate-backend Example Usage: CL-USER> (funcall (prepare (:select '* :from 'points :where (:= 'x '$1))) 0) ((0 1 10)) 1 prepare defprepared defprepared-with-names","title":"Prepared statements"},{"location":"postmodern/#migration","text":"The meaning of the term migration depends upon the context. People can talk about migrating from Oracle to Postgresql or to Mssql or Mysql. In that context, migration means changing database structure and functions from one database implementation to another. To developers, the term migration normally means tracking and managing version changes of the database structure in the development process. This is often called schema migration. Of course development often continues after software has gone into production, in which case \"migration' not only needs to deal with version controls of the database structure, but also needs to ensure that such changes of the database do not result in lost production data. For example, renaming a column in a database table is a simple one command operation in development but at least four commands if there is actually data in the column. There are two different approaches taken to schema migration. The first and more typical approach is is writing scripts to manage changes, both forward and back. The second approach is to generate diff snapshots and determine the changes needed to move from one snapshot to another. Both have their pluses and minuses, particularly when it comes to how to manage the data that already exists in the database. The script writing approach requires the developer to write both the sql commands necessary to make the desired change and the requisite sql commands to undo that change. Typically these scripts are then saved in .sql files in a migration directory and a migration library is used to track dependencies which can get complicated if there are more than one developer on the team. Undoing migrations (sometimes called rollbacks) is difficult if production data exists on the database. There are schools of thought among DBAs that rollbacks should never be allowed because of the danger of losing critical production data. It may be obvious, but it is a good reminder that any migration should start with creating a backup which has been tested.","title":"Migration"},{"location":"postmodern/#other-useful-constructs","text":"Database Management create-database drop-database Inspecting the database list-tables list-tables-in-schema table-exists-p table-description list-sequences sequence-exists-p list-views view-exists-p list-schemata schema-exist-p schema-exists-p database-version num-records-in-database current-database database-exists-p database-size list-databases list-schemas list-tablespaces list-available-types list-table-sizes table-size more-table-info list-columns list-columns-with-types column-exists-p describe-views list-database-functions list-indices list-table-indices index-exists-p list-indexed-column-and-attributes list-index-definitions find-primary-key-info list-foreign-keys list-unique-or-primary-constraints list-all-constraints describe-constraint describe-foreign-key-constraints list-triggers list-detailed-triggers list-database-users list-roles list-available-extensions list-installed-extensions change-toplevel-database Table definition and creation deftable !dao-def !index !unique-index !foreign !unique create-table create-all-tables create-package-tables *table-name* *table-symbol* Roles role-exists-p create-role drop-role alter-role-search-path change-password grant-role-permissions grant-readonly-permissions grant-editor-permissions grant-admin-permissions revoke-all-on-table list-role-accessible-databases list-roles list-role-permissions Schemata create-schema drop-schema get-search-path set-search-path split-fully-qualified-table-name Database Health Measurements cache-hit-ratio bloat-measurement unused-indexes check-query-performance Miscellaneous Utility Functions execute-file","title":"Other useful constructs"},{"location":"postmodern/#configuration-variables","text":"","title":"CONFIGURATION VARIABLES"},{"location":"postmodern/#allow-overwriting-prepared-statements","text":"Variable When set to t, ensured-prepared will overwrite prepared statements having the same name if the query statement itself in the postmodern meta connection is different than the query statement provided to ensure-prepared.","title":"*allow-overwriting-prepared-statements*"},{"location":"postmodern/#current-logical-transaction","text":"Variable This is bound to the current transaction-handle or savepoint-handle instance representing the innermost open logical transaction.","title":"*current-logical-transaction*"},{"location":"postmodern/#database","text":"Variable Special variable holding the current database connection information. Most functions and macros operating on a database assume this binds to a connected database.","title":"*database*"},{"location":"postmodern/#default-use-ssl","text":"Variable The default for connect's use-ssl argument. This starts at :no. If you set it to anything else, be sure to also load the CL+SSL library.","title":"*default-use-ssl*"},{"location":"postmodern/#escape-sql-names-p","text":"Variable Determines whether double quotes are added around column, table, and function names in queries. Valid values: T, in which case every name is escaped, NIL, in which case no name is escape, :auto, which causes only reserved words to be escaped, or. :literal which is the same as :auto except it has added consequence in to-sql-name . The default value is :auto. Be careful when binding this with let and such \u2015 since a lot of SQL compilation tends to happen at compile-time, the result might not be what you expect. Mixed case sensitivity is not currently well supported. Postgresql itself will downcase unquoted identifiers. This will be revisited in the future if requested.","title":"*escape-sql-names-p*"},{"location":"postmodern/#ignore-unknown-columns","text":"Variable Normally, when get-dao, select-dao, or query-dao finds a column in the database that's not in the DAO class, it will raise an error. Setting this variable to a non-NIL will cause it to simply ignore the unknown column.","title":"*ignore-unknown-columns*"},{"location":"postmodern/#isolation-level","text":"Variable The transaction isolation level currently in use. Defaults to :read-committed-rw You can specify the following isolation levels in postmodern transactions: :read-committed-rw (read committed with read and write) :read-committed-ro (read committed with read only) :repeatable-read-rw (repeatable read with read and write) :repeatable-read-ro (repeatable read with read only) :serializable (serializable with reand and write)","title":"*isolation-level*"},{"location":"postmodern/#max-pool-size","text":"Variable Set the maximum amount of connections kept in a single connection pool, where a pool consists of all the stored connections with the exact same connect arguments. Defaults to NIL, which means there is no maximum.","title":"*max-pool-size*"},{"location":"postmodern/#table-name","text":"Variable Used inside deftable to find the name of the table being defined.","title":"*table-name*"},{"location":"postmodern/#table-name_1","text":"Variable Used inside deftable to find the name of the table being defined.","title":"*table-name*"},{"location":"postmodern/#table-symbol","text":"Variable Used inside deftable to find the symbol naming the table being defined.","title":"*table-symbol*"},{"location":"postmodern/#functions-and-macros","text":"","title":"FUNCTIONS AND MACROS"},{"location":"postmodern/#dao-def","text":"Function: (!dao-def) Should only be used inside a deftable form. Define this table using the corresponding DAO class' slots. Adds the result of calling dao-table-definition on table-symbol to the definition.","title":"!dao-def"},{"location":"postmodern/#foreign","text":"Function: (!foreign target fields &rest target-fields/on-delete/on-update/deferrable/initially-deferred) Used insde a deftable form. Add a foreign key to the table being defined. target-table is the referenced table. columns is a list of column names or single name in this table, and, if the columns have different names in the referenced table, target-columns must be another list of column names or single column name of the target-table, or :primary-key to denote the column(s) of the target-table's primary key as referenced column(s). The on-delete and on-update arguments can be used to specify ON DELETE and ON UPDATE actions, as per the keywords allowed in create-table. In addition, the deferrable and initially-deferred arguments can be used to indicate whether constraint checking can be deferred until the current transaction completed, and whether this should be done by default. Note that none of these are really &key arguments, but rather are picked out of a &rest arg at runtime, so that they can be specified even when target-columns is not given.","title":"!foreign"},{"location":"postmodern/#index","text":"Function: (!index &rest fields) Used inside a deftable form. Define an index on the table being defined. The columns can be given as symbols or strings.","title":"!index"},{"location":"postmodern/#unique","text":"Function: (!unique target-fields &key deferrable initially-deferred) Constrains one or more columns to only contain unique (combinations of) values, with deferrable and initially-deferred defined as in !foreign","title":"!unique"},{"location":"postmodern/#unique-index","text":"Function: (!unique-index &rest fields) Used inside a deftable form. Define a unique index on the defined table.","title":"!unique-index"},{"location":"postmodern/#abort-hooks","text":"Generic Function: (abort-hooks object) Generic Function: (setf (abort-hooks object) ...) An accessor for the transaction or savepoint's list of abort hooks, each of which should be a function with no required arguments. These functions will be executed when a transaction is aborted or a savepoint rolled back (whether via a non-local transfer of control or explicitly by either abort-transaction or rollback-savepoint).","title":"abort-hooks"},{"location":"postmodern/#abort-logical-transaction","text":"Generic Function: (abort-logical-transaction obj) Roll back the given logical transaction, regardless of whether it is an actual transaction or a savepoint.","title":"abort-logical-transaction"},{"location":"postmodern/#abort-transaction","text":"Function: (abort-transaction transaction) Roll back the given transaction.","title":"abort-transaction"},{"location":"postmodern/#add-comment","text":"Function: (add-comment type name comment &optional (second-name )) Attempts to add a comment to a particular database object. The first parameter is a keyword for the type of database object. The second parameter is the name of the object. The third parameter is the comment itself. Some objects require an additional identifier. The names can be strings or symbols. Example usage would be: (add-comment :database 'my-database-name \"Does anyone actually use this database?\") (add-comment :column 'country-locations.name \"Is what it looks like - the name of a country\") (add-comment :column \"country_locations.name\" \"Is what it looks like - the name of a country\") Example usage where two identifiers are required would be constraints: (add-comment :constraint 'constraint1 \"Some kind of constraint descriptions here\" 'country-locations)","title":"add-comment"},{"location":"postmodern/#alter-role-search-path","text":"Function: (alter-role-search-path role search-path) Changes the priority of where a role looks for tables (which schema first, second, etc. Role should be a string or symbol. Search-path could be a list of schema names either as strings or symbols.","title":"alter-role-search-path"},{"location":"postmodern/#bigint","text":"'(signed-byte 64)","title":"bigint"},{"location":"postmodern/#bloat-measurement","text":"Function: (bloat-measurement) \u2192 list Bloat measurement of unvacuumed dead tuples. Borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ who borrowed it from https://github.com/heroku/heroku-pg-extras/tree/master/commands .","title":"bloat-measurement"},{"location":"postmodern/#bytea","text":"'(array (unsigned-byte 8))","title":"bytea"},{"location":"postmodern/#cache-hit-ratio","text":"Function: (cache-hit-ratio) \u2192 list The cache hit ratio shows data on serving the data from memory compared to how often you have to go to disk. This function returns a list of heapblocks read from disk, heapblocks hit from memory and the ratio of heapblocks hit from memory / total heapblocks hit. Borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/","title":"cache-hit-ratio"},{"location":"postmodern/#call-with-connection","text":"Function: (call-with-connection spec thunk) The functional backend to with-connection. Binds *database* to a new connection as specified by spec, which should be a list that connect can be applied to, and runs the zero-argument function given as second argument in the new environment. When the function returns or throws, the new connection is disconnected.","title":"call-with-connection"},{"location":"postmodern/#cancel-backend","text":"Function: (cancel-backend pid &optional (database *database*)) Polite way of terminating a query at the database (as opposed to calling close-database). This is slower than (terminate-backend pid) and does not always work.","title":"cancel-backend"},{"location":"postmodern/#change-password","text":"Function: (change-password role password &optional expiration-date) Alters a role's password. If the optional expiration-date parameter is provided, the password will expire at the stated date. A sample expiration date would be 'December 31, 2020'. If the expiration date is 'infinity', it will never expire. The password will be encrypted in the system catalogs. This is automatic with postgresql versions 10 and above.","title":"change-password"},{"location":"postmodern/#change-toplevel-database","text":"Function: (change-toplevel-database new-database user password host) \u2192 string Just changes the database assuming you are using a toplevel connection. Recommended only for development work. Returns the name of the newly connected database as a string.","title":"change-toplevel-database"},{"location":"postmodern/#check-query-performance","text":"Function: (check-query-performance &optional (ob nil) (num-calls 100) (limit 20)) \u2192 list This function requires that postgresql extension pg_stat_statements must be loaded via shared_preload_libraries. It is borrowed from https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/ . Optional parameters: OB allow order-by to be 'calls', 'total-time', 'rows-per' or 'time-per', defaulting to time-per. num-calls to require that the number of calls exceeds a certain threshold, and limit to limit the number of rows returned. It returns a list of lists, each row containing the query, number of calls, total_time, total_time/calls, stddev_time, rows, rows/calls and the cache hit percentage.","title":"check-query-performance"},{"location":"postmodern/#clear-connection-pool","text":"Function: (clear-connection-pool) Disconnect and remove all connections from the connection pools.","title":"clear-connection-pool"},{"location":"postmodern/#coalesce","text":"Function: (coalesce &rest args) \u2192 value Returns the first non-NIL, non-NULL (as in :null) argument, or NIL if none are present. Useful for providing a fall-back value for the result of a query, or, when given only one argument, for transforming :nulls to NIL.","title":"coalesce"},{"location":"postmodern/#column-exists-p","text":"Function: (column-exists-p table-name column-name &optional schema-name) \u2192 boolean Determine if a particular column exists. Table name and column-name can be either strings or symbols. If the optional schema name is not given or the table-name is not fully qualified with a schema name, the schema will be assumed to be the public schema.","title":"column-exists-p"},{"location":"postmodern/#commit-hooks","text":"Generic Function: (commit-hooks obj) An accessor for the transaction or savepoint's list of commit hooks, each of which should be a function with no required arguments. These functions will be executed when a transaction is committed or a savepoint released.","title":"commit-hooks"},{"location":"postmodern/#commit-logical-transaction","text":"Generic Function: (commit-logical-transaction obj) Commit the given logical transaction, regardless of whether it is an actual transaction or a savepoint.","title":"commit-logical-transaction"},{"location":"postmodern/#commit-transaction","text":"Function: (commit-transaction transaction) Immediately commit an open transaction.","title":"commit-transaction"},{"location":"postmodern/#connect","text":"Function: (connect database-name user-name password host &key (port 5432) pooled-p (use-ssl *default-use-ssl*) (service postgres)) \u2192 database-connection Create a new database connection for the given user and the database. Port will default to 5432, which is where most PostgreSQL servers are running. If pooled-p is T, a connection will be taken from a pool of connections of this type, if one is available there, and when the connection is disconnected it will be put back into this pool instead. use-ssl can be :no, :yes, or :try, as in open-database, and defaults to the value of *default-use-ssl* .","title":"connect"},{"location":"postmodern/#connect-toplevel","text":"Function: (connect-toplevel database-name user-name password host &key (port 5432) (use-ssl *default-use-ssl*)) Bind the *database* to a new connection. Use this if you only need one connection, or if you want a connection for debugging from the REPL.","title":"connect-toplevel"},{"location":"postmodern/#connected-p","text":"Function: (connected-p database) \u2192 boolean Returns a boolean indicating whether the given connection is still connected to the server.","title":"connected-p"},{"location":"postmodern/#create-all-tables","text":"Function: (create-all-tables) Creates all defined tables.","title":"create-all-tables"},{"location":"postmodern/#create-database","text":"Function: (create-database database-name &key (encoding utf8) (connection-limit -1) owner limit-public-access comment collation template) Creates a basic database. Besides the obvious database-name parameter, you can also use key parameters to set encoding (defaults to UTF8), owner, connection-limit (defaults to no limit)). If limit-public-access is set to t, then only superuser roles or roles with explicit access to this database will be able to access it. (See Roles below) If collation is set, the assumption is that template0 needs to be used as the base of the database rather than template1 which may contain encoding specific or locale specific data. (create-database 'testdb :limit-public-access t :comment \"This database is for testing silly theories\")","title":"create-database"},{"location":"postmodern/#create-index","text":"Function: (create-index name &key unique if-not-exists concurrently on using fields) Create an index. Slightly less sophisticated than the query version because it does not have a where clause capability.","title":"create-index"},{"location":"postmodern/#create-package-tables","text":"Function: (create-package-tables package) Creates all tables identified by symbols interned in the given package.","title":"create-package-tables"},{"location":"postmodern/#create-role","text":"Function: (create-role name password &key (base-role readonly) (schema public) (tables all) (databases current) (allow-whitespace nil) (allow-utf8 nil) (allow-disallowed-names nil) (comment nil)) Keyword parameters: Base-role. Base-role should be one of :readonly, :editor, :admin, :standard or :superuser. A readonly user can only select existing data in the specified tables or databases. An editor has the ability to insert, update, delete or select data. An admin has all privileges on a database, but cannot create new databases, roles, or replicate the system. A standard user has no particular privileges other than connecting to databases. :schema defaults to :public but can be a list of schemas. User will not have access to any schemas not in the list. :tables defaults to :all but can be a list of tables. User will not have access to any tables not in the list. :databases defaults to :current but can be a list of databases. User will not have access to any databases not in the list. :allow-whitespace - Whitespace in either the name or password is not allowed by default. :allow-utf8 defaults to nil. If t, the name and password will be normalized. If nil, the name and password are limited to printable ascii characters. For fun reading on utf8 user names see https://labs.spotify.com/2013/06/18/creative-usernames . Also interesting reading is https://github.com/flurdy/bad_usernames and https://github.com/dsignr/disallowed-usernames/blob/master/disallowed%20usernames.csv , and https://www.b-list.org/weblog/2018/feb/11/usernames/ :allow-disallowed-names defaults to nil. If nil, the user name will be checked against disallowed-role-names . As an aside, if allowing utf8 in names, you might want to think about whether you should second copy of the username in the original casing and normalized as NFC for display purposes as opposed to normalizing to NFKC. It might be viewed as culturally insensitive to change the display of the name.","title":"create-role"},{"location":"postmodern/#create-schema","text":"Function: (create-schema schema &optional authorization) Creates a new schema. Raises an error if the schema is already exists.","title":"create-schema"},{"location":"postmodern/#create-sequence","text":"Function: (create-sequence name &key temp if-not-exists increment min-value max-value start cache) Create a sequence. Available additional key parameters are :temp :if-not-exists :increment :min-value :max-value :start and :cache. See https://www.postgresql.org/docs/current/static/sql-createsequence.html for details on usage.","title":"create-sequence"},{"location":"postmodern/#create-table","text":"Function: (create-table name) Takes the name of a dao-class and creates the table identified by symbol by executing all forms in its definition as found in the tables list.","title":"create-table"},{"location":"postmodern/#current-database","text":"Function: (current-database) \u2192 string Returns the string name of the current database.","title":"current-database"},{"location":"postmodern/#dao-class","text":"Class You can work directly with the database or you can use a simple database-access-class (aka dao) which would cover all the fields in a row. Postmodern allows you to have a relatively simple but straight forward matching of clos classes to a database table. At the heart of Postmodern's DAO system is the dao-class metaclass. It allows you to define classes for your database-access objects as regular CLOS classes. Some of the slots in these classes will refer to columns in the database. To specify that a slot refers to a column, give it a :col-type option containing an S-SQL type expression (useful if you want to be able to derive a table definition from the class definition), or simply a :column option with value T. Such slots can also take a :col-default option, used to provide a database-side default value as an S-SQL expression. You can use the :col-name initarg (whose unevaluated value will be passed to to-sql-name) to specify the slot's column's name. DAO class definitions support two extra class options: :table-name to give the name of the table that the class refers to (defaults to the class name), and :keys to provide a set of primary keys for the table if they have not been specified in a single column. If more than one key is provided, this creates a multi-column primary key and all keys must be specified when using operations such as update-dao and get-dao. When no primary keys are defined, operations such as update-dao and get-dao will not work. IMPORTANT: Class finalization for a dao class instance are wrapped with a thread lock. However, any time you are using threads and a class that inherits from other classes, you should ensure that classes are finalized before you start generating threads that create new instances of that class. The (or db-null integer) form is used to indicate a column can have NULL values otherwise the column will be treated as NOT NULL. Simple example: (defclass users () ((name :col-type string :initarg :name :accessor name) (creditcard :col-type (or db-null integer) :initarg :card :col-default :null) (score :col-type bigint :col-default 0 :accessor score)) (:metaclass dao-class) (:keys name)) In this case the name of the users will be treated as the primary key and the database table is assumed to be users. (It might be worth noting that \"user\" is a reserved word for Postgresql and using reserved words, while possible using quotes, is generally not worth the additional trouble they cause.) The name and score slots cannot be null, but the creditcard slot can be null and actually defaults to null. The :col-default :null specification ensures that the default in the database for this field is null, but it does not bound the slot to a default form. Thus, making an instance of the class without initializing this slot will leave it in an unbound state. An example of a class where the keys are set as multiple column keys is here: (defclass points () ((x :col-type integer :initarg :x :reader point-x) (y :col-type integer :initarg :y :reader point-y) (value :col-type integer :initarg :value :accessor value)) (:metaclass dao-class) (:keys x y)) In this case, retrieving a points record would look like the following where 12 and 34 would be the values you are looking to find in the x column and y column respectively.: (get-dao 'points 12 34) Now look at a slightly more complex example. (defclass country () ((id :col-type integer :col-identity t :accessor id) (name :col-type string :col-unique t :check (:<> 'name \"\") :initarg :name :reader country-name) (inhabitants :col-type integer :initarg :inhabitants :accessor country-inhabitants) (sovereign :col-type (or db-null string) :initarg :sovereign :accessor country-sovereign) (region-id :col-type integer :col-references ((regions id)) :initarg :region-id :accessor region-id)) (:documentation \"Dao class for a countries record.\") (:metaclass dao-class) (:table-name countries)) In this example we have an id column which is specified to be an identity column. Postgresql will automatically generate a sequence of of integers and this will be the primary key. We have a name column which is specified as unique and is not null. We have a region-id column which references the id column in the regions table. This is a foreign key constraint and Postgresql will not accept inserting a country into the database unless there is an existing region table with an id that matches this number. Postgresql will also not allow deleting a region if there are countries that reference that region's id. If we wanted Postgresql to delete countries when regions are deleted, that column would be specified as: (region-id :col-type integer :col-references ((regions id) :cascade) :initarg :region-id :accessor region-id) Now you can see why the double parens. We also specified that the table name is not \"country\" but \"countries\". (Some style guides recommend that table names be plural and references to rows be singular.) When inheriting from DAO classes, a subclass' set of columns also contains all the columns of its superclasses. The primary key for such a class is the union of its own keys and all the keys from its superclasses. Classes inheriting from DAO classes should probably always use the dao-class metaclass themselves. When a DAO is created with make-instance, the :fetch-defaults keyword argument can be passed, which, when T, will cause a query to fetch the default values for all slots that refers to columns with defaults and were not bound through initargs. In some cases, such as serial and identity columns, which have an implicit default, this will not work. You can work around this by creating your own sequence, e.g. \"my_sequence\", and defining a (:nextval \"my_sequence\") default. Finally, DAO class slots can have an option :ghost t to specify them as ghost slots. These are selected when retrieving instances, but not written when updating or inserting, or even included in the table definition. The only known use for this to date is for creating the table with (oids=true), and specify a slot like this: (oid :col-type integer :ghost t :accessor get-oid)","title":"dao-class"},{"location":"postmodern/#dao-exists-p","text":"Generic Function: (dao-exists-p dao) \u2192 boolean Test whether a row with the same primary key as the given dao exists in the database. Will also return NIL when any of the key slots in the object are unbound.","title":"dao-exists-p"},{"location":"postmodern/#dao-keys","text":"Generic Function: (dao-keys class) \u2192 list Returns list of slot names that are the primary key of DAO class. This is likely interesting if you have primary keys which are composed of more than one slot. Pay careful attention to situations where the primary key not only has more than one column, but they are actually in a different order than they are in the database table itself. You can check this with the internal find-primary-key-info function. Obviously the table needs to have been defined. The class must be quoted. (pomo:find-primary-key-info 'country1) ((\"name\" \"text\") (\"id\" \"integer\")) \u2192 list Returns list of values that are the primary key of dao.","title":"dao-keys"},{"location":"postmodern/#dao-table-definition","text":"Function: (dao-table-definition table) \u2192 string Given a DAO class, or the name of one, this will produce an SQL query string with a definition of the table. This is just the bare simple definition, so if you need any extra indices or or constraints, you'll have to write your own queries to add them, in which case look to s-sql's create-table function.","title":"dao-table-definition"},{"location":"postmodern/#dao-table-name","text":"Function: (dao-table-name class) \u2192 string Get the name of the table associated with the given DAO class (or symbol naming such a class).","title":"dao-table-name"},{"location":"postmodern/#database-connection","text":"Class Representation of a database connection. Contains login information in order to be able to automatically re-establish a connection when it is somehow closed.","title":"database-connection"},{"location":"postmodern/#database-connection-error","text":"Condition Conditions of this type are signalled when an error occurs that breaks the connection socket. They offer a :reconnect restart.","title":"database-connection-error"},{"location":"postmodern/#database-error","text":"Condition This is the condition type that will be used to signal virtually all database-related errors (though in some cases socket errors may be raised when a connection fails on the IP level).","title":"database-error"},{"location":"postmodern/#database-error-code","text":"Generic Function: (database-error-constraint-name err) Code: the Postgresql SQLSTATE code for the error (see the Postgresql Manual Appendix A for their meaning). Not localizable. Always present.","title":"database-error-code"},{"location":"postmodern/#database-error-message","text":"Generic Function: (database-error-constraint-name err) Message: the primary human-readable error message. This should be accurate but terse (typically one line). Always present.","title":"database-error-message"},{"location":"postmodern/#database-error-detail","text":"Generic Function: (database-error-constraint-name err) Detail: an optional secondary error message carrying more detail about the problem. Might run to multiple lines or NIL if none is available.","title":"database-error-detail"},{"location":"postmodern/#database-error-query","text":"Generic Function: (database-error-constraint-name err) Query that led to the error, or NIL if no query was involved.","title":"database-error-query"},{"location":"postmodern/#database-error-cause","text":"Generic Function: (database-error-constraint-name err) The condition that caused this error, or NIL when it was not caused by another condition.","title":"database-error-cause"},{"location":"postmodern/#database-error-constraint-name","text":"Generic Function: (database-error-constraint-name err) Given a database-error for an integrity violation, will attempt to extract the constraint name.","title":"database-error-constraint-name"},{"location":"postmodern/#database-error-extract-name","text":"Function: (database-error-extract-name err) Given a database-error, will extract the critical name from the error message.","title":"database-error-extract-name"},{"location":"postmodern/#database-exists-p","text":"Function: (database-exists-p database) \u2192 boolean Checks to see if a particular database exists. Returns T if true, nil if not.","title":"database-exists-p"},{"location":"postmodern/#database-size","text":"Function: (database-size &optional (name nil)) \u2192 list Given the name of a database, will return the name, a pretty-print string of the size of the database and the size in bytes. If a database name is not provided, it will return the result for the currently connected database.","title":"database-size"},{"location":"postmodern/#database-version","text":"Function: (database-version) \u2192 string DEPRECATED. This returns the postgresql server version number, not a version number from the currently connected database. The format of the return string is determined by the current postgresql server. E.g. \"PostgreSQL 12.2 on x86_64-pc-linux-gnu, compiled by gcc (Arch Linux 9.3.0-1) 9.3.0, 64-bit\". If you want just the postgresql version number, use (cl-postgres:get-postgresql-version).","title":"database-version"},{"location":"postmodern/#db-null","text":"Type for representing NULL values. Use like (or integer db-null) for declaring a type to be an integer that may be null.\" '(eql :null)","title":"db-null"},{"location":"postmodern/#define-dao-finalization","text":"Macro: (define-dao-finalization ((dao-name class) &rest keyword-args) &body body) Create an :around-method for make-dao. The body is executed in a lexical environment where dao-name is bound to a freshly created and inserted DAO. The representation of the DAO in the database is then updated to reflect changes that body might have introduced. Useful for processing values of slots with the type serial, which are unknown before insert-dao.","title":"define-dao-finalization"},{"location":"postmodern/#defprepared","text":"Macro: (defprepared name query &optional (format rows)) \u2192 function This is the macro-style variant of prepare. It is like prepare, but gives the function a name which now becomes a top-level function for the prepared statement. The name should not a string but may be quoted.","title":"defprepared"},{"location":"postmodern/#defprepared-with-names","text":"Macro: (defprepared-with-names name (&rest args) (query &rest query-args) &optional (format rows)) Like defprepared, but allows to specify names of the function arguments in a lambda list as well as arguments supplied to the query. (defprepared-with-names user-messages (user &key (limit 10)) (\"select * from messages where user_id = $1 order by date desc limit $2\" (user-id user) limit) :plists)","title":"defprepared-with-names"},{"location":"postmodern/#deftable","text":"Macro: (deftable name &body definitions) Define a table. name can be either a symbol or a (symbol string) list. In the first case, the table name is derived from the symbol's name by S-SQL's rules. In the second case, the name is given explicitly. The body of definitions can contain anything that evaluates to a string, as well as S-SQL expressions. The variables table-name and *table-symbol* are bound to the relevant values in the body. Note that the evaluation of the definition is ordered, so you'll generally want to create your table first and then define indices on it.","title":"deftable"},{"location":"postmodern/#delete-dao","text":"Generic Function: (delete-dao dao) Delete the given dao from the database.","title":"delete-dao"},{"location":"postmodern/#describe-constraint","text":"Function: (describe-constraint table-name constraint-name) \u2192 list Return a list of alists of the descriptions a particular constraint given the table-name and the constraint name using the information_schema table.","title":"describe-constraint"},{"location":"postmodern/#describe-foreign-key-constraints","text":"Function: (describe-foreign-key-constraints) \u2192 list Generates a list of lists of information on the foreign key constraints","title":"describe-foreign-key-constraints"},{"location":"postmodern/#describe-triggers","text":"Function: (describe-triggers) \u2192 list List detailed information on the triggers from the information_schema table.","title":"describe-triggers"},{"location":"postmodern/#describe-views","text":"Function: (describe-views &optional (schema public)) \u2192 list Describe the current views in the specified schema. Includes the select statements used to create the view. Takes an optional schema but defaults to public schema.","title":"describe-views"},{"location":"postmodern/#disconnect","text":"Generic Function: (disconnect database) Disconnects a normal database connection, or moves a pooled connection into the pool.","title":"disconnect"},{"location":"postmodern/#disconnect-toplevel","text":"Function: (disconnect-toplevel) Disconnect the *database* .","title":"disconnect-toplevel"},{"location":"postmodern/#do-query-dao","text":"Macro: (do-query-dao ((type type-var) query) &body body) \u2192 list Like query-dao, but iterates over the results rather than returning them. For each matching DAO, body is evaluated with type-var bound to the instance. Example: (do-query-dao (('user user) (:order-by (:select '* :from 'user :where (:> 'score 10000)) 'name)) (pushnew user high-scorers))","title":"do-query-dao"},{"location":"postmodern/#do-select-dao","text":"Macro: (do-select-dao ((type type-var) &optional (test t) &rest ordering) &body body) Like select-dao, but iterates over the results rather than returning them. For each matching DAO, body is evaluated with type-var bound to the DAO instance. Example: (do-select-dao (('user user) (:> 'score 10000) 'name) (pushnew user high-scorers))","title":"do-select-dao"},{"location":"postmodern/#doquery","text":"Macro: (doquery query (&rest names) &body body) Execute the given query (a string or a list starting with a keyword), iterating over the rows in the result. The body will be executed with the values in the row bound to the symbols given in names. To iterate over a parameterised query, one can specify a list whose car is the query, and whose cdr contains the arguments. For example: (doquery (:select 'name 'score :from 'scores) (n s) (incf (gethash n *scores*) s)) (doquery ((:select 'name :from 'scores :where (:> 'score '$1)) 100) (name) (print name))","title":"doquery"},{"location":"postmodern/#double-precision","text":"'double-float","title":"double-precision"},{"location":"postmodern/#drop-database","text":"Function: (drop-database database) Drop the specified database. The database parameter can be a string or a symbol. Note: Only the owner of a database (or superuser) can drop a database and there cannot be any current connections to the database. See Database information below for information specific functions Postmodern contains a simple system for defining CLOS classes that represent rows in the database. This is not intended as a full-fledged object-relational magic system \u2015 while serious ORM systems have their place, they are notoriously hard to get right, and are outside of the scope of a humble SQL library like this.","title":"drop-database"},{"location":"postmodern/#drop-index","text":"Function: (drop-index name &key concurrently if-exists cascade) Drop an index. Available keys are :concurrently, :if-exists, and :cascade.","title":"drop-index"},{"location":"postmodern/#drop-prepared-statement","text":"Function: (drop-prepared-statement name &key (location both) (database *database*) (remove-function t)) The statement name can be a string or quoted symbol. Prepared statements are stored both in the meta slot in the postmodern connection and in postgresql session information. In the case of prepared statements generated with defprepared, there is also a lisp function with the same name. If you know the prepared statement name, you can delete the prepared statement from both locations (the default behavior), just from postmodern by passing :postmodern to the location key parameter or just from postgresql by passing :postgresql to the location key parameter. If you pass the name 'All' as the statement name, it will delete all prepared statements. The default behavior is to also remove any lisp function of the same name. This behavior is controlled by the remove-function key parameter.","title":"drop-prepared-statement"},{"location":"postmodern/#drop-role","text":"Function: (drop-role role-name &optional (new-owner postgres) (database all)) \u2192 boolean The role-name and optional new-owner name should be strings. If they are symbols, they will be converted to string and hyphens will be converted to underscores. Before dropping the role, you must drop all the objects it owns (or reassign their ownership) and revoke any privileges the role has been granted on other objects. If database is :all, drop-role will loop through all databases in the cluster ensuring that the role has no privileges or owned objects in every database. Otherwise drop-role will drop objects owned by a role in the current database. We will reassign ownership of the objects to the postgres role unless otherwise specified in the optional second parameter. Returns t if successful. Will not drop the postgres role.","title":"drop-role"},{"location":"postmodern/#drop-schema","text":"Function: (drop-schema schema &key (if-exists nil) (cascade nil)) Drops an existing database schema. Accepts :if-exists and/or :cascade arguments like :drop-table. A notice instead of an error is raised with the is-exists parameter.","title":"drop-schema"},{"location":"postmodern/#drop-sequence","text":"Function: (drop-sequence name &key if-exists cascade) \u2192 list Drop a sequence. Name should be quoted. Available key parameters are :if-exists and :cascade.","title":"drop-sequence"},{"location":"postmodern/#drop-table","text":"Function: (drop-table table-name &key if-exists cascade) If a table exists, drop a table. Available additional key parameters are :if-exists and :cascade.","title":"drop-table"},{"location":"postmodern/#ensure-transaction","text":"Macro: (ensure-transaction &body body) Ensures that body is executed within a transaction, but does not begin a new transaction if one is already in progress.","title":"ensure-transaction"},{"location":"postmodern/#ensure-transaction-with-isolation-level","text":"Macro: (ensure-transaction-with-isolation-level isolation-level &body body) Executes body within a with-transaction form if and only if no transaction is already in progress. This adds the ability to specify an isolation level other than the current default","title":"ensure-transaction-with-isolation-level"},{"location":"postmodern/#execute","text":"Macro: (execute query &rest args) Execute a query, ignore the results. So, in effect, Like a query called with format :none. Returns the amount of affected rows as its first returned value. (Also returns this amount as the second returned value, but use of this is deprecated.)","title":"execute"},{"location":"postmodern/#execute-file","text":"Function: (execute-file pathname &optional (print nil)) This function will execute sql queries stored in a file. Each sql statement in the file will be run independently, but if one statement fails, subsequent query statements will not be run, but any statement prior to the failing statement will have been commited. If you want the standard transction treatment such that all statements succeed or no statement succeeds, then ensure that the file starts with a \"begin transaction\" statement and finishes with an \"end transaction\" statement. See the test file test-execute-file-broken-transaction.sql as an example. For debugging purposes, if the optional print parameter is set to t, format will print the count of the query and the query to the REPL. IMPORTANT NOTE: This utility function assumes that the file containing the sql queries can be trusted and bypasses the normal postmodern parameterization of queries.","title":"execute-file"},{"location":"postmodern/#find-postgresql-prepared-statement","text":"Function: (find-postgresql-prepared-statement name) \u2192 string Returns the specified named prepared statement (if any) that postgresql has for this session and placed in the meta slot in the connection.","title":"find-postgresql-prepared-statement"},{"location":"postmodern/#find-postmodern-prepared-statement","text":"Function: (find-postmodern-prepared-statement name) \u2192 string Returns the specified named prepared statement (if any) that postmodern has put in the meta slot in the connection. Note that this is the statement itself, not the name.","title":"find-postmodern-prepared-statement"},{"location":"postmodern/#find-primary-key-info","text":"Function: (find-primary-key-info table &optional (just-key nil)) \u2192 list Returns a list of sublists where the sublist contains two strings. If a table primary key consists of only one column, such as 'id' there will be a single sublist where the first string is the name of the column and the second string is the string name for the datatype for that column. If the primary key for the table consists of more than one column, there will be a sublist for each column subpart of the key. The sublists will be in the order they are used in the key, not in the order they appear in the table. If just-key is set to t, the list being returned will contain just the column names in the primary key as string names with no sublists. If the table is not in the public schema, provide the fully qualified table name e.g. schema-name.table-name.","title":"find-primary-key-info"},{"location":"postmodern/#from-sql-name","text":"Function: (from-sql-name str) Convert a string to a symbol, upcasing and replacing underscores with hyphens.","title":"from-sql-name"},{"location":"postmodern/#get-dao","text":"Generic Function: (get-dao type &rest args) \u2192 dao Get the single DAO object from the row that has the given primary key values, or NIL if no such row exists. Objects created by this function will have initialize-instance called on them (after loading in the values from the database) without any arguments \u2015 even :default-initargs are skipped. The same goes for select-dao and query-dao. (get-dao 'country \"The Netherlands\") #<COUNTRY {1010F0DCF3}> From an sql perspective, the standard call to get-dao translates as: select * from table NOTE: if you have added fields to the database table without updating the class definition, get-dao and select-dao will throw errors. This may cause your application to appear to hang unless you have the necessary condition handling in your code. Usually this will only happen during development, so throwing an error is not a bad idea. If you want to ignore the errors, set ignore-unknown-columns to t.","title":"get-dao"},{"location":"postmodern/#get-database-comment","text":"Function: (get-database-comment database-name) \u2192 string Returns the comment, if any, attached to a database.","title":"get-database-comment"},{"location":"postmodern/#get-pid","text":"Function: (get-pid) \u2192 integer Get the process id used by postgresql for this connection.","title":"get-pid"},{"location":"postmodern/#get-pid-from-postmodern","text":"Function: (get-pid-from-postmodern) \u2192 integer Get the process id used by postgresql for this connection, but get it from the postmodern connection parameters.","title":"get-pid-from-postmodern"},{"location":"postmodern/#get-search-path","text":"Function: (get-search-path) Returns the default schema search path for the current session.","title":"get-search-path"},{"location":"postmodern/#get-table-comment","text":"Function: (get-table-comment table-name &optional schema-name) \u2192 string Retrieves the comment, if any attached to the table.","title":"get-table-comment"},{"location":"postmodern/#get-table-oid","text":"Function: (get-table-oid table-name &optional schema-name) \u2192 integer Retrieves the oid identifier for a particular table from postgresql. Works for tables in all schemas.","title":"get-table-oid"},{"location":"postmodern/#grant-admin-permissions","text":"Function: (grant-admin-permissions schema-name role-name &optional (table-name nil)) Grants all privileges to a role for the named schema. If the optional table-name parameter is provided, the privileges are only granted with respect to that table.","title":"grant-admin-permissions"},{"location":"postmodern/#grant-editor-permissions","text":"Function: (grant-editor-permissions schema-name role-name &optional (table-name nil)) Grants select, insert, update and delete privileges to a role for the named schema. If the optional table-name parameter is provided, the privileges are only granted with respect to that table. Note that we are giving some function execute permissions if table-name is nil, but if the table-name is specified, those are not provided. Your mileage may vary on how many privileges you want to provide to a editor role with access to only a limited number of tables.","title":"grant-editor-permissions"},{"location":"postmodern/#grant-readonly-permissions","text":"Function: (grant-readonly-permissions schema-name role-name &optional (table-name nil)) Grants select privileges to a role for the named schema. If the optional table-name parameter is provided, the privileges are only granted with respect to that table. Note that we are giving some function execute permissions if table-name is nil, but if the table-name is specified, those are not provided. Your mileage may vary on how many privileges you want to provide to a read-only role with access to only a limited number of tables.","title":"grant-readonly-permissions"},{"location":"postmodern/#grant-role-permissions","text":"Function: (grant-role-permissions role-type name &key (schema public) (tables all) (databases all)) Grant-role-permissions assumes that a role has already been created, but permissions need to be granted or revoked on a particular database. A :superuser can create databases, roles, replication, etc. Returns nil. A :standard user has no particular privileges or restrictions. Returns nil. An :admin user can edit existing data, insert new data and create new tables in the specified databases/schemas/tables. An :editor user can update fields or insert new records but cannot create new tables in the specified tables or databases. A :readonly role can only read existing data in the specified schemas, tables or databases. Schema, tables or databases can be :all or a list of schemas, tables or databases to be granted permission. Granting :all provides access to all future items of that type as well. Note that the schema and table rights and revocations granted are limited to the connected database at the time of execution of this function.","title":"grant-role-permissions"},{"location":"postmodern/#index-exists-p","text":"Function: (index-exists-p index-name) \u2192 boolean Tests whether an index with the given name exists. The name can be either a string or a symbol.","title":"index-exists-p"},{"location":"postmodern/#insert-dao","text":"Generic Function: (insert-dao dao) \u2192 dao Insert the given dao into the database. Column slots of the object which are unbound implies the database defaults. Hence, if these columns has no defaults defined in the database, the the insertion of the dao will be failed. (This feature only works on PostgreSQL 8.2 and up.)","title":"insert-dao"},{"location":"postmodern/#list-all-constraints","text":"Function: (list-all-constraints table-name &optional (strings-p)) \u2192 list Users information_schema to list all the constraints in a table. Table-name can be either a string or quoted. Turns constraints into keywords if strings-p is not true.","title":"list-all-constraints"},{"location":"postmodern/#list-all-tables","text":"Function: (list-all-tables &optional (fully-qualified-names-only nil)) \u2192 list If fully-qualified-names-only is set to t, returns a flattened list of all schema.table names other than pg_catalog or the information_schema. Otherwise returns the following info: schema-name, table-name, table-owner, tablespace, hasindexes, hasrules, hastriggers and rowsecurity(&optional strings-p).","title":"list-all-tables"},{"location":"postmodern/#list-available-collations","text":"Function: (list-available-collations) \u2192 list Get a list of the collations available from the current database cluster. Collations are a mess as different operating systems provide different collations. We might get some sanity if Postgresql can use ICU as the default. See https://wiki.postgresql.org/wiki/Collations .","title":"list-available-collations"},{"location":"postmodern/#list-available-extensions","text":"Function: (list-available-extensions) \u2192 list List the postgresql extensions which are available in the system to the currently connected database. The extensions may or may not be installed.","title":"list-available-extensions"},{"location":"postmodern/#list-available-types","text":"Function: (list-available-types) \u2192 list List the available data types in the connected postgresql version, It returns a list of lists, each sublist containing the oid (object identifier number) and the name of the data types. E.g. (21 \"smallint\")","title":"list-available-types"},{"location":"postmodern/#list-columns","text":"Function: (list-columns table-name) \u2192 list Returns a list of strings of just the column names in a table. Pulls info from the postmodern table-description function rather than directly. The table-name can be a string or quoted. Any table-name that is not fully qualified with the schema will be assumed to be in the public schema.","title":"list-columns"},{"location":"postmodern/#list-columns-with-types","text":"Function: (list-columns-with-types table-name) \u2192 list Returns a list of (name type) lists for the fields of a table. Returns a list of strings of just the column names and their sql data types in a table. Pulls info from the postmodern table-description function rather than directly. The table-name can be a string or quoted. Any table-name that is not fully qualified with the schema will be assumed to be in the public schema.","title":"list-columns-with-types"},{"location":"postmodern/#list-connections","text":"Function: (list-connections) \u2192 list List the current postgresql connections to the currently connected database. It does this by returningo info from pg_stat_activity on open connections.","title":"list-connections"},{"location":"postmodern/#list-database-access-rights","text":"Function: (list-database-access-rights &optional database-name) \u2192 list If the database parameter is specifed, this returns an list of lists where each sublist is a role name and whether they have access rights (t or nil) to that particular database. If the database-name is not provided, the sublist is a database name, a role name and whether they have access rights (t or nil). This excludes the template databases.","title":"list-database-access-rights"},{"location":"postmodern/#list-database-functions","text":"Function: (list-database-functions) \u2192 list Returns a list of the functions in the database from the information_schema. DEPRECATED FOR DESCRIBE-TRIGGERS. List detailed information on the triggers from the information_schema table.","title":"list-database-functions"},{"location":"postmodern/#list-database-users","text":"Function: (list-database-users) \u2192 list List database users (actually 'roles' in Postgresql terminology).","title":"list-database-users"},{"location":"postmodern/#list-databases","text":"Function: (list-databases &key (order-by-size nil) (size t) (names-only nil)) \u2192 list Returns a list of lists where each sub-list contains the name of the database, a pretty-print string of the size of that database and the size in bytes. The default order is by database name. Pass t as a parameter to :order-by-size for order by size. Setting size to nil will return just the database names in a single list ordered by name. This function excludes the template databases","title":"list-databases"},{"location":"postmodern/#list-detailed-triggers","text":"Function: (list-detailed-triggers) \u2192 list","title":"list-detailed-triggers"},{"location":"postmodern/#list-foreign-keys","text":"Function: (list-foreign-keys table schema) \u2192 list Returns a list of sublists of foreign key info in the form of '((constraint-name local-table local-table-column foreign-table-name foreign-column-name))","title":"list-foreign-keys"},{"location":"postmodern/#list-index-definitions","text":"Function: (list-index-definitions table-name) \u2192 list Returns a list of the definitions used to create the current indexes for the table","title":"list-index-definitions"},{"location":"postmodern/#list-indexed-column-and-attributes","text":"Function: (list-indexed-column-and-attributes table-name) \u2192 list List the indexed columns and their attributes in a table. Includes primary key.","title":"list-indexed-column-and-attributes"},{"location":"postmodern/#list-indices","text":"Function: (list-indices &optional strings-p) \u2192 list Return a list of the indexs in a database. Turn them into keywords if strings-p is not true.","title":"list-indices"},{"location":"postmodern/#list-installed-extensions","text":"Function: (list-installed-extensions) \u2192 list List the postgresql extensions which are installed in the currently connected database.","title":"list-installed-extensions"},{"location":"postmodern/#list-postmodern-prepared-statements","text":"Function: (list-postmodern-prepared-statements &optional (names-only nil)) \u2192 list List the prepared statements that postmodern has put in the meta slot in the connection. It will return a list of alists of form: ((:NAME . SNY24) (:STATEMENT . (SELECT name, salary FROM employee WHERE (city = \\$1))) (:PREPARE-TIME . #<TIMESTAMP 25-11-2018T15:36:43,385>) (:PARAMETER-TYPES . text) (:FROM-SQL) If the names-only parameter is set to t, it will only return a list of the names of the prepared statements.","title":"list-postmodern-prepared-statements"},{"location":"postmodern/#list-prepared-statements","text":"Function: (list-prepared-statements &optional (names-only nil)) \u2192 list This is syntactic sugar. It runs a query that lists the prepared statements in the session in which the function is run. If the names-only parameter is set to t, it will only return a list of the names of the prepared statements.","title":"list-prepared-statements"},{"location":"postmodern/#list-role-accessible-databases","text":"Function: (list-role-accessible-databases role-name) \u2192 list Returns a list of the databases to which the specified role can connect.","title":"list-role-accessible-databases"},{"location":"postmodern/#list-role-permissions","text":"Function: (list-role-permissions &optional role) \u2192 list This returns a list of sublists of the permissions granted within the currently connected database. If an optional role is provided, the result is limited to that role. The sublist returned will be in the form of role-name, schema-name, table-name and then a string containing all the rights of that role on that table in that schema.","title":"list-role-permissions"},{"location":"postmodern/#list-roles","text":"Function: (list-roles &optional (lt nil)) \u2192 list Returns a list of alists of rolenames, role attributes and membership in roles. See https://www.postgresql.org/docs/current/role-membership.html for an explanation. Optionally passing :alists or :plists can be used to set the return list types to :alists or :plists. This is the same as the psql function \\du.","title":"list-roles"},{"location":"postmodern/#list-schemas","text":"Function: (list-schemas) \u2192 list List schemas in the current database, excluding the pg_* system schemas.","title":"list-schemas"},{"location":"postmodern/#list-schemata","text":"\u2192 list List all existing user defined schemata. Note: The query uses the portable information_schema relations instead of pg_tables relations. select schema_name from information_schema.schemata where schema_name !~ '(pg_*)|information_schema' order by schema_name ;","title":"list-schemata"},{"location":"postmodern/#list-sequences","text":"Function: (list-sequences &optional strings-p) \u2192 list Returns a list of the sequences in the current database. When strings-p is T, the names will be given as strings, otherwise as keywords.","title":"list-sequences"},{"location":"postmodern/#list-table-indices","text":"Function: (list-table-indices table-name &optional strings-p) \u2192 list List the index names and the related columns in a single table. Each index will be in a separate sublist.","title":"list-table-indices"},{"location":"postmodern/#list-table-sizes","text":"Function: (list-table-sizes &key (schema public) (order-by-size nil) (size t)) \u2192 list Returns a list of lists (table-name, size in 8k pages) of tables in the current database. Providing a name to the schema parameter will return just the information for tables in that schema. It defaults to just the tables in the public schema. Setting schema to nil will return all tables, indexes etc in the database in descending order of size. This would include system tables, so there are a lot more than you would expect. If :size is set to nil, it returns only a flat list of table names. Setting order-by-size to t will return the result in order of size instead of by table name.","title":"list-table-sizes"},{"location":"postmodern/#list-tables","text":"Function: (list-tables &optional (strings-p nil)) \u2192 list DEPRECATED FOR LIST-ALL-TABLES. Return a list of the tables in the public schema of a database. By default the table names are returned as keywords. They will be returned as lowercase strings if strings-p is true.","title":"list-tables"},{"location":"postmodern/#list-tables-in-schema","text":"Function: (list-tables-in-schema &optional (schema-name public) (strings-p nil)) \u2192 list Returns a list of tables in a particular schema, defaulting to public. If schema-name is :all, it will return all the non-system tables in the database in fully qualified form: e.g. 'public.test_table'. If string-p is t, the names will be returned as strings with underscores converted to hyphens.","title":"list-tables-in-schema"},{"location":"postmodern/#list-tablespaces","text":"Function: (list-tablespaces) \u2192 list Lists the tablespaces in the currently connected database. What are tablespace you ask? Per the Postgresql documentation https://www.postgresql.org/docs/current/manage-ag-tablespaces.html : Tablespaces in PostgreSQL allow database administrators to define locations in the file system where the files representing database objects can be stored. Once created, a tablespace can be referred to by name when creating database objects. By using tablespaces, an administrator can control the disk layout of a PostgreSQL installation. This is useful in at least two ways. First, if the partition or volume on which the cluster was initialized runs out of space and cannot be extended, a tablespace can be created on a different partition and used until the system can be reconfigured. Second, tablespaces allow an administrator to use knowledge of the usage pattern of database objects to optimize performance. For example, an index which is very heavily used can be placed on a very fast, highly available disk, such as an expensive solid state device. At the same time a table storing archived data which is rarely used or not performance critical could be stored on a less expensive, slower disk system.","title":"list-tablespaces"},{"location":"postmodern/#list-templates","text":"Function: (list-templates) \u2192 list Returns a list of existing database template names.","title":"list-templates"},{"location":"postmodern/#list-triggers","text":"Function: (list-triggers &optional table-name) \u2192 list List distinct trigger names from the information_schema table. Table-name can be either quoted or string. (A trigger is a specification that the database should automatically execute a particular function whenever a certain type of operation is performed. Triggers can be attached to tables (partitioned or not), views, and foreign tables. See https://www.postgresql.org/docs/current/trigger-definition.html )","title":"list-triggers"},{"location":"postmodern/#list-unique-or-primary-constraints","text":"Function: (list-unique-or-primary-constraints table-name &optional (strings-p)) \u2192 list List constraints on a table. Table-name can be either a string or quoted. Turns constraints into keywords if strings-p is not true.","title":"list-unique-or-primary-constraints"},{"location":"postmodern/#list-views","text":"Function: (list-views &optional strings-p) \u2192 list Returns list of the user defined views in the current database. When strings-p is T, the names will be returned as strings, otherwise as keywords.","title":"list-views"},{"location":"postmodern/#make-dao","text":"Generic Function: (make-dao type &rest args &key &allow-other-keys) \u2192 dao Combines make-instance with insert-dao. Make the instance of the given class and insert it into the database, returning the created dao.","title":"make-dao"},{"location":"postmodern/#num-records-in-database","text":"Function: (num-records-in-database) \u2192 list Returns a list of lists with schema, table name and approximate number of records in the currently connected database. \u2192 list Returns a list of lists with schema, table name and approximate number of records in the currently connected database.","title":"num-records-in-database"},{"location":"postmodern/#numeric","text":"(declare (ignore precision/scale scale)) 'number","title":"numeric"},{"location":"postmodern/#parse-queries","text":"Function: (parse-queries file-content) \u2192 list Read SQL queries in given string and split them, returns a list.","title":"parse-queries"},{"location":"postmodern/#postgres-array-string-to-array","text":"Function: (postgres-array-string-to-array str) \"Takes a postgresql array in the form of a string like wol=CTc/wol,a=c/wol,b=c/wol\" and returns a lisp list like (wol=CTc/wol\" \u00e4=c/wol\" b=c/wol).\"","title":"postgres-array-string-to-array"},{"location":"postmodern/#postgres-array-string-to-list","text":"Function: (postgres-array-string-to-list str) \u2192 array Takes a postgresql array in the form of a string like \"{wol=CTc/wol,a=c/wol,b=c/wol}\" and returns a lisp array like #(\"wol=CTc/wol\" \"a=c/wol\" \"b=c/wol\")","title":"postgres-array-string-to-list"},{"location":"postmodern/#postgresql-version","text":"Function: (postgresql-version) \u2192 string Returns the version string provided by postgresql of the current postgresql server. E.g. \"PostgreSQL 12.2 on x86_64-pc-linux-gnu, compiled by gcc (Arch Linux 9.3.0-1) 9.3.0, 64-bit\". If you want just the postgresql version number, use (cl-postgres:get-postgresql-version).","title":"postgresql-version"},{"location":"postmodern/#prepare","text":"Macro: (prepare query &optional (format rows)) \u2192 function Wraps a query into a function that can be used as the interface to a prepared statement. The given query (either a string or an S-SQL form) may contain placeholders, which look like \\$1, \\$2, etc. The resulting function takes one argument for every placeholder in the query, executes the prepared query, and returns the result in the format specified. (Allowed formats are the same as for query.) For queries that have to be run very often, especially when they are complex, it may help performance since the server only has to plan them once. See the PostgreSQL manual for details. In some cases, the server will complain about not being able to deduce the type of the arguments in a statement. In that case you should add type declarations (either with the PostgreSQL's CAST SQL-conforming syntax or historical :: syntax, or with S-SQL's :type construct) to help it out. Note that it will attempt to automatically reconnect if database-connection-error, or admin-shutdown. It will reset prepared statements triggering an invalid-sql-statement-name error. It will overwrite old prepared statements triggering a duplicate-prepared-statement error.","title":"prepare"},{"location":"postmodern/#prepared-statement-exists-p","text":"Function: (prepared-statement-exists-p name) \u2192 boolean This returns t if the prepared statement exists in the current postgresql session, otherwise nil.","title":"prepared-statement-exists-p"},{"location":"postmodern/#query","text":"Macro: (query query &rest args/format) \u2192 result Execute the given query, which can be either a string or an S-SQL form (list starting with a keyword). If the query contains placeholders (\\$1, \\$2, etc) their values can be given as extra arguments. If one of these arguments is a keyword occurring in the table below, it will not be used as a query argument, but will determine the format in which the results are returned instead. Any of the following formats can be used, with the default being :rows: --------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------- :none Ignore the result values. :lists, :rows Return a list of lists, each list containing the values for a row. :list, :row Return a single row as a list. :alists Return a list of alists which map column names to values, with the names represented as keywords. :alist Return a single row as an alist. :array-hash Return an array of hashtables which map column names to hash table keys :str-alists Like :alists, but use the original column names. :str-alist Return a single row as an alist, with strings for names. :plists Return a list of plists which map column names to values,with the names represented as keywords. :plist Return a single row as a plist. :column Return a single column as a list. :single Return a single value. :single! Like :single, but raise an error when the number of selected rows is not equal to 1. (:dao type) Return a list of DAOs of the given type. The names of the fields returned by the query must match slots in the DAO class the same way as with query-dao. (:dao type :single) Return a single DAO of the given type. --------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------- Some Examples: (query (:select '* :from 'country :where (:= 'name \"Croatia\"))) ((\"Croatia\" 4400000 :NULL)) (query (:select 'inhabitants :from 'country :where (:= 'name \"Croatia\")) :single) 4400000 (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :alist) ((:NAME . \"Croatia\") (:INHABITANTS . 4400000) (:SOVEREIGN . :NULL)) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :str-alist) ((\"name\" . \"Croatia\") (\"inhabitants\" . 4400000) (\"sovereign\" . :NULL)) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :plist) (:NAME \"Croatia\" :INHABITANTS 4400000 :SOVEREIGN :NULL) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :list) (\"Croatia\" 4400000 :NULL) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :lists) ((\"Croatia\" 4400000 :NULL)) (query (:select '* :from 'country) :lists) ((\"The Netherlands\" 16800000 \"Willem-Alexander\") (\"Croatia\" 4400000 :NULL)) (query (:select '* :from 'country) :alists) (((:NAME . \"The Netherlands\") (:INHABITANTS . 16800000) (:SOVEREIGN . \"Willem-Alexander\")) ((:NAME . \"Croatia\") (:INHABITANTS . 4400000) (:SOVEREIGN . :NULL))) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) :array-hash) #(#<HASH-TABLE :TEST EQUAL :COUNT 3 {10106CA323}>) (query (:select '* :from 'country :where (:= 'name \"Croatia\")) (:dao country)) (#<COUNTRY {1010688943}>) (query (:select '* :from 'country) (:dao country)) (#<COUNTRY {1010464023}> #<COUNTRY {1010465CB3}>) (query (:select 'inhabitants :from 'country :where (:= 'name \"Croatia\")) :column) (4400000) If the database returns information about the amount rows that were affected, such as with updating or deleting queries, this is returned as a second value.","title":"query"},{"location":"postmodern/#query-dao","text":"Macro: (query-dao type query &rest args) \u2192 list Execute the given query (which can be either a string or an S-SQL expression) and return the result as DAOs of the given type. If the query contains placeholders (\\$1, \\$2, etc) their values can be given as extra arguments. The names of the fields returned by the query must either match slots in the DAO class, or be bound through with-column-writers.","title":"query-dao"},{"location":"postmodern/#read-queries","text":"Function: (read-queries filename) Read SQL queries in a given file and split them, returns a list.","title":"read-queries"},{"location":"postmodern/#real","text":"'float","title":"real"},{"location":"postmodern/#reconnect","text":"Generic Function: (reconnect database) Reconnect a disconnected database connection. This is not allowed for pooled connections \u2015 after they are disconnected they might be in use by some other process, and should no longer be used.","title":"reconnect"},{"location":"postmodern/#register-sql-operators","text":"Macro: (register-sql-operators arity &rest names) Define simple operators. Arity is one of :unary (like 'not'), :unary-postfix (the operator comes after the operand), :n-ary (like + : the operator falls away when there is only one operand), :2+-ary (like '=', which is meaningless for one operand), or :n-or-unary (like '-', where the operator is kept in the unary case). After the arity follow any number of operators, either just a keyword, in which case the downcased symbol name is used as the operator, or a two-element list containing a keyword and a name string.","title":"register-sql-operators"},{"location":"postmodern/#release-savepoint","text":"Function: (release-savepoint savepoint) Immediately release a savepoint, commiting its results.","title":"release-savepoint"},{"location":"postmodern/#reset-prepared-statement","text":"Function: (reset-prepared-statement condition) \u2192 restart If you have received an invalid-prepared-statement error but the prepared statement is still in the meta slot in the postmodern connection, this will try to regenerate the prepared statement at the database connection level and restart the connection.","title":"reset-prepared-statement"},{"location":"postmodern/#revoke-all-on-table","text":"Function: (revoke-all-on-table table-name role-name) Takes a table-name which could be a string, symbol or list of strings or symbols of tables names, a role name and revokes all privileges that role-name may have with that/those tables. This is limited to the currently connected database and can only revoke the privileges granted by the caller of the function.","title":"revoke-all-on-table"},{"location":"postmodern/#role-exists-p","text":"Function: (role-exists-p role-name) \u2192 boolean Does the named role exist in this database cluster? Returns t or nil.","title":"role-exists-p"},{"location":"postmodern/#rollback-savepoint","text":"Function: (rollback-savepoint savepoint) Immediately roll back a savepoint, aborting the results.","title":"rollback-savepoint"},{"location":"postmodern/#save-dao","text":"Function: (save-dao dao) \u2192 boolean Tries to insert the given dao using insert-dao. If this raises a unique key violation error, it tries to update it by using update-dao instead. Be aware that there is a possible race condition here \u2015 if some other process deletes the row at just the right moment, the update fails as well. Returns a boolean telling you whether a new row was inserted. This function is unsafe to use inside of a transaction \u2015 when a row with the given keys already exists, the transaction will be aborted. Use save-dao/transaction instead in such a situation. See also: upsert-dao.","title":"save-dao"},{"location":"postmodern/#save-daotransaction","text":"Function: (save-dao/transaction dao) \u2192 boolean The transaction safe version of save-dao. Tries to insert the given dao using insert-dao. If this raises a unique key violation error, it tries to update it by using update-dao instead. Be aware that there is a possible race condition here \u2015 if some other process deletes the row at just the right moment, the update fails as well. Returns a boolean telling you whether a new row was inserted. Acts exactly like save-dao, except that it protects its attempt to insert the object with a rollback point, so that a failure will not abort the transaction. See also: upsert-dao.","title":"save-dao/transaction"},{"location":"postmodern/#schema-exists-p","text":"Function: (schema-exists-p name) \u2192 boolean Tests the existence of a given schema. Returns T if the schema exists or NIL otherwise. The name provided can be either a string or quoted symbol.","title":"schema-exists-p"},{"location":"postmodern/#select-dao","text":"Macro: (select-dao type &optional (test t) &rest ordering) \u2192 list Select DAO objects for the rows in the associated table for which the given test (either an S-SQL expression or a string) holds. When sorting arguments are given, which can also be S-SQL forms or strings, these are used to sort the result. (Note that, if you want to sort, you have to pass the test argument.) (select-dao 'country) (#<COUNTRY {101088F6F3}> #<COUNTRY {101088FAA3}>) 2 (select-dao 'country (:> 'inhabitants 50000000)) NIL 0 (select-dao 'country (:> 'inhabitants 5000000)) (#<COUNTRY {10108AD293}>) 1 (select-dao 'country (:> 'inhabitants 5000)) (#<COUNTRY {10108CA773}> #<COUNTRY {10108CAB23}>) 2 (select-dao 'country (:> 'inhabitants 5000) 'name) ;sorted by name (#<COUNTRY {10108EF423}> #<COUNTRY {10108EF643}>) (mapcar 'country-name (select-dao 'country (:> 'inhabitants 5000) 'name)) (\"Croatia\" \"The Netherlands\") (mapcar 'country-name (select-dao 'country (:> 'inhabitants 5000))) (\"The Netherlands\" \"Croatia\") If for some reason, you wanted the list in reverse alphabetical order, then: (select-dao 'country (:> 'id 0) (:desc 'name))","title":"select-dao"},{"location":"postmodern/#sequence-exists-p","text":"Function: (sequence-exists-p sequence) \u2192 boolean Tests whether a sequence with the given name exists. The name can be either a string or a symbol.","title":"sequence-exists-p"},{"location":"postmodern/#sequence-next","text":"Function: (sequence-next sequence) \u2192 integer Shortcut for getting the next value from a sequence. The sequence identifier can be either a string or a symbol, in the latter case it will be converted to a string according to S-SQL rules.","title":"sequence-next"},{"location":"postmodern/#serial","text":"'integer","title":"serial"},{"location":"postmodern/#serial8","text":"'integer","title":"serial8"},{"location":"postmodern/#set-search-path","text":"Function: (set-search-path path) This changes the postgresql runtime parameter controlling what order schemas are searched. You can always use fully qualified names [schema.table]. By default, this function only changes the search path for the current session. This function is used by with-schema.","title":"set-search-path"},{"location":"postmodern/#smallint","text":"'(signed-byte 16)","title":"smallint"},{"location":"postmodern/#split-fully-qualified-tablename","text":"Function: (split-fully-qualified-tablename name) \u2192 list Take a tablename of the form database.schema.table or schema.table or table and return the tablename and the schema name. The name can be a symbol or a string. Returns a list of form '(table schema database. If the tablename is not fully qualified, it will assume that the schema should be public.","title":"split-fully-qualified-tablename"},{"location":"postmodern/#sql","text":"Macro: (sql form) \u2192 string Convert the given form (a list starting with a keyword) to an SQL query string at compile time, according to the rules described here. For example: (sql (:select '* :from 'country :where (:= 'a 1))) \"(SELECT * FROM country WHERE (a = 1))\" but (sql '(:select '* :from 'country :where (:= 'a 1))) would throw an error. For the later case you need to use sql-compile.","title":"sql"},{"location":"postmodern/#sql-compile","text":"Function: (sql-compile form) \u2192 string This is the run-time variant of the sql macro. It converts the given list to an SQL query, with the same rules except that symbols in this list do not have to be quoted to be interpreted as identifiers. For example: (sql-compile '(:select '* :from 'country :where (:= 'a 1))) \\\"(SELECT * FROM country WHERE (a = 1))\\\" but (sql (:select '* :from 'country :where (:= 'a 1))) would throw an error. For the later case you need to use sql.","title":"sql-compile"},{"location":"postmodern/#sql-error","text":"Function: (sql-error control &rest args) No documentation provided.","title":"sql-error"},{"location":"postmodern/#sql-escape","text":"Generic Function: (sql-escape arg) A generalisation of sql-escape-string looks at the type of the value passed, and properly writes it out it for inclusion in an SQL query. Symbols will be converted to SQL names. Examples: (sql-escape \"tr'-x\") \"E'tr''-x'\" (sql-escape (/ 1 13)) \"0.0769230769230769230769230769230769230\" (sql-escape #(\"Baden-Wurttemberg\" \"Bavaria\" \"Berlin\" \"Brandenburg\")) \"ARRAY[E'Baden-Wurttemberg', E'Bavaria', E'Berlin', E'Brandenburg']\"","title":"sql-escape"},{"location":"postmodern/#sql-escape-string","text":"Function: (sql-escape-string string &optional prefix) \u2192 string Escapes a string for inclusion in a PostgreSQL query. Example: (sql-escape-string \\\"Puss in 'Boots'\\\") \\\"E'Puss in ''Boots'''\\\"","title":"sql-escape-string"},{"location":"postmodern/#table-description","text":"Function: (table-description table-name &optional schema-name) \u2192 list Returns a list of the fields in the named table. Each field is represented by a list of three elements: the field name, the type, and a boolean indicating whether the field may be NULL. Table can be either a string or quoted. Table-names can be fully qualified with the schema or not. If the table-name is not fully qualified and a schema name is not provided, the table will be assumed to be in the public schema.","title":"table-description"},{"location":"postmodern/#table-description-plus","text":"Function: (table-description-plus table-name &optional schema-name) \u2192 list Returns more table info than table-description. Specifically returns ordinal-position, column-name, data-type, character-maximum-length, modifier, whether it is not-null and the default value. Table can be either a string or quoted. Table-names can be fully qualified with the schema or not. If the table-name is not fully qualified and a schema name is not provided, the table will be assumed to be in the public schema.","title":"table-description-plus"},{"location":"postmodern/#table-exists-p","text":"Function: (table-exists-p table-name &optional schema-name) \u2192 boolean Check whether a table exists in a particular schema. Defaults to the search path. Takes either a string or a symbol for the table name. The table-name can be fully qualified in the form of schema.table-name or database.schema.table-name. If the schema is specified either in a qualified table-name or in the optional schema-name parameter, we look directly to the information schema tables. Otherwise we use the search path which can be controlled by being within a with-schema form.","title":"table-exists-p"},{"location":"postmodern/#table-size","text":"Function: (table-size table-name) \u2192 list Return the size of a given postgresql table in k or m. Table-name can be either a string or quoted.","title":"table-size"},{"location":"postmodern/#terminate-backend","text":"Function: (terminate-backend pid &optional (database *database*)) Less polite way of terminating at the database (as opposed to calling close-database). Faster than (cancel-backend pid) and more reliable.","title":"terminate-backend"},{"location":"postmodern/#text","text":"Generic Function: (text condition) 'string","title":"text"},{"location":"postmodern/#to-sql-name","text":"Function: (to-sql-name name &optional (escape-p *escape-sql-names-p*) (ignore-reserved-words nil)) Convert a symbol or string into a name that can be a sql table, column, or operation name. Add quotes when escape-p is true, or escape-p is :auto and the name contains reserved words. Quoted or delimited identifiers can be used by passing :literal as the value of escape-p. If escape-p is :literal, and the name is a string then the string is still escaped but the symbol or string is not downcased, regardless of the setting for downcase-symbols and the hyphen and forward slash characters are not replaced with underscores. Ignore-reserved-words is only used internally for column names which are allowed to be reserved words, but it is not recommended.","title":"to-sql-name"},{"location":"postmodern/#unused-indexes","text":"\u2192 list Returns a list of lists showing schema.table, indexname, index_size and number of scans. The code was borrowed from: https://www.citusdata.com/blog/2019/03/29/health-checks-for-your-postgres-database/","title":"unused-indexes"},{"location":"postmodern/#update-dao","text":"Generic Function: (update-dao dao) \u2192 dao Update the representation of the given dao in the database to the values in the object. This is not defined for tables that do not have any non-primary-key columns. Raises an error when no row matching the dao exists.","title":"update-dao"},{"location":"postmodern/#upsert-dao","text":"Generic Function: (upsert-dao dao) \u2192 dao Like save-dao or save-dao/transaction but using a different method that doesn't involve a database exception. This is safe to use both in and outside a transaction, though it's advisable to always do it in a transaction to prevent a race condition. The way it works is: If the object contains unbound slots, we call insert-dao directly, thus the behavior is like save-dao. Otherwise we try to update a record with the same primary key. If the PostgreSQL returns a non-zero number of rows updated it treated as the record is already exists in the database, and we stop here. If the PostgreSQL returns a zero number of rows updated, it treated as the record does not exist and we call insert-dao. The race condition might occur at step 3 if there's no transaction: if UPDATE returns zero number of rows updated and another thread inserts the record at that moment, the insertion implied by step 3 will fail. Note, that triggers and rules may affect the number of inserted or updated rows returned by PostgreSQL, so zero or non-zero number of affected rows may not actually indicate the existence of record in the database. This method returns two values: the DAO object and a boolean (T if the object was inserted, NIL if it was updated).","title":"upsert-dao"},{"location":"postmodern/#varchar","text":"(declare (ignore length)) `string)","title":"varchar"},{"location":"postmodern/#view-exists-p","text":"Function: (view-exists-p view) \u2192 boolean Tests whether a view with the given name exists. Takes either a string or a symbol for the view name.","title":"view-exists-p"},{"location":"postmodern/#with-column-writers","text":"Macro: (with-column-writers (&rest defs) &body body) Provides control over the way get-dao, select-dao, and query-dao read values from the database. This is not commonly needed, but can be used to reduce the amount of queries a system makes. writers should be a list of alternating column names (strings or symbols) and writers, where writers are either symbols referring to a slot in the objects, or functions taking two arguments \u2015 an instance and a value \u2015 which can be used to somehow store the value in the new instance. When any DAO-fetching function is called in the body, and columns matching the given names are encountered in the result, the writers are used instead of the default behaviour (try and store the value in the slot that matches the column name). An example of using this is to add some non-column slots to a DAO class, and use query-dao within a with-column-writers form to pull in extra information about the objects, and immediately store it in the new instances.","title":"with-column-writers"},{"location":"postmodern/#with-connection","text":"Macro: (with-connection spec &body body) Evaluates the body with database bound to a connection as specified by spec, which should be list that connect can be applied to.","title":"with-connection"},{"location":"postmodern/#with-logical-transaction","text":"Macro: (with-logical-transaction (&optional (name nil) (isolation-level *isolation-level*)) &body body) Executes body within a with-transaction form if no transaction is currently in progress, otherwise simulates a nested transaction by executing it within a with-savepoint form. The transaction or savepoint is bound to name if one is supplied. The isolation-level will set the isolation-level used by the transaction. You can specify the following isolation levels in postmodern transactions: :read-committed-rw (read committed with read and write) :read-committed-ro (read committed with read only) :repeatable-read-rw (repeatable read with read and write) :repeatable-read-ro (repeatable read with read only) :serializable (serializable with reand and write) For more information see isolation-notes Sample usage where \"george\" is just the name given to the transaction (not quoted or a string) and ... simply indicates other statements would be expected here: (with-logical-transaction () (execute (:insert-into 'test-data :set 'value 77)) ...) (with-logical-transaction (george) (execute (:insert-into 'test-data :set 'value 22)) ...) (with-logical-transaction (george :read-committed-rw) (execute (:insert-into 'test-data :set 'value 33)) ...) (with-logical-transaction (:serializable) (execute (:insert-into 'test-data :set 'value 44)) ...)","title":"with-logical-transaction"},{"location":"postmodern/#with-savepoint","text":"Macro: (with-savepoint name &body body) Can only be used within a transaction. Establishes a savepoint with the given name at the start of body, and binds the same name to a handle for that savepoint. The body is executed and, at the end of body, the savepoint is released, unless a condition is thrown, in which case it is rolled back. Execute the body within a savepoint, releasing savepoint when the body exits normally, and rolling back otherwise. NAME is both the variable that can be used to release or rolled back before the body unwinds, and the SQL name of the savepoint.","title":"with-savepoint"},{"location":"postmodern/#with-schema","text":"Macro: (with-schema (schema &key (strict t) (if-not-exist create) (drop-after nil)) &body form) A macro to set the schema search path (namespace) of the postgresql database to include as first entry a specified schema and then executes the body. Before executing body the PostgreSQL's session variable search_path is set to the given namespace. After executing body the search_path variable is restored to the original value. Calling with :strict 't only the specified schema is set as current search path. All other schema are then not searched any more. If strict is nil, the namespace is just first schema on the search path upon the the body execution. Calling with :if-not-exist set to :create the schema is created if this schema did not exist. Calling with :if-not-exist set to nil, an error is signaled. calling with drop-after set to 't the schema is removed after the execution of the body form. example : (with-schema (:schema-name :strict nil :drop-after nil :if-not-exist :error) (foo 1) (foo 2)) example : (with-schema ('uniq :if-not-exist :create) ;; changing the search path (schema-exists-p 'uniq))","title":"with-schema"},{"location":"postmodern/#with-transaction","text":"Macro: (with-transaction (&optional name isolation-level) &body body) Execute the given body within a database transaction, committing it when the body exits normally, and aborting otherwise. An optional name and/or isolation-level can be given to the transaction. The name can be used to force a commit or abort before the body unwinds. The isolation-level will set the isolation-level used by the transaction. You can specify the following isolation levels in postmodern transactions: :read-committed-rw (read committed with read and write) :read-committed-ro (read committed with read only) :repeatable-read-rw (repeatable read with read and write) :repeatable-read-ro (repeatable read with read only) :serializable (serializable with reand and write) Sample usage where \"george\" is just the name given to the transaction (not quoted or a string) and ... simply indicates other statements would be expected here: (with-transaction () (execute (:insert-into 'test-data :set 'value 77)) ...) (with-transaction (george) (execute (:insert-into 'test-data :set 'value 22)) ...) (with-transaction (george :read-committed-rw) (execute (:insert-into 'test-data :set 'value 33)) (query (:select '* :from 'test-data)) ...) (with-transaction (:serializable) (execute (:insert-into 'test-data :set 'value 44)) ...) Further discussion of transactions and isolation levels can found at isolation-notes.html in the doc directory.","title":"with-transaction"},{"location":"quicklisp/","text":"quicklisp - Library Manager Version: 2020-01-04 Repository: quicklisp/quicklisp-client - Github In case of any inaccuracies, ambiguities or suggestions, please create an issue here . GETTING STARTED Installation Download Do the equivalent steps on Windows and Mac OS: curl -O https://beta.quicklisp.org/quicklisp.lisp # download quicklisp.lisp curl -O https://beta.quicklisp.org/quicklisp.lisp.asc # download the PGP signature file gpg --verify quicklisp.lisp.asc quicklisp.lisp # verify it against the signing key As of 07 June 2020, Quicklisp release signing key has a fingerprint of D7A3 489D DEFE 32B7 D0E7 CC61 3079 65AB 028B 5FF7 , an id of 028B5FF7 , and an email of release@quicklisp.org . See here for the more recent details. Installation Load quicklisp.lisp: sbcl --load quicklisp.lisp # or an equivalent command for your implementation (optionally, you may want to rlwrap sbcl --load quicklisp.lisp for a better repl experience): (quicklisp-quickstart:install) (ql:add-to-init-file) ; to automatically load quicklisp at implementation startup ;;; Note that ql acts as a nickname for the quicklisp-client package. quicklisp-quickstart:install also takes a couple keyword arguments (see (describe 'quicklisp-quickstart:install) - but unless you know what you are doing, it is recommended to leave them as they are. Loading after installation (ql:add-to-init-file) adds instructions to your implementations init-file ( .sbclrc or equivalent) to load quicklisp on implementation startup. However, some runtime options of the implementation may disable loading the init-file - sbcl --script for instance. For these cases, you might want to alias (or equivalent) alias sbcl-ql='rlwrap sbcl --noinform --load $HOME/quicklisp/setup.lisp' in your .bashrc (or equivalent). A few useful functions and variables quickload : (ql:quickload '(\"alexandria\" \"bordeaux-threads\")) or (ql:quickload \"alexandria\") . system-apropos : (ql:system-apropos \"postgres\") where-is-system *local-project-directories* : you may either want to have this variable modified from implementation init-file, or symlink ~/quicklisp/local-projects to wherever your projects directory is. This is the location - as the name suggests - where quicklisp searches for local projects. uninstall update-client You may also need to run (asdf:clear-configuration) to have ASDF reprocess its configuration files while loading a newer library. There is also the ql:register-local-projects that can help with the same. A note on quicklisp dists Besides being an ASDF system, quicklisp is also the name of a dist . This distribution is released about once per month, with the guarantee that all systems in the distribution build together - note that this does not still imply that they work together. For these cases, you may want to go back in dist time . You might, additionally, want to learn about qlot that helps with version pinning - however, given the stability of Common Lisp, that translates to the stability for its (old but gold) libraries, it may be an overkill. But, YMMV. Also worth a read is getting libraries into quicklisp . (Hope you took note of the blog!) The once-per-month release nature of quicklisp can be an issue if you need to work with bleeding edge packages - for these cases, there exists Ultralisp - which updates every 5 minutes! This is yet another distribution. Some useful functions for working with distributions include: install-dist uninstall-dist update-dist : (ql:update-dist \"quicklisp\") find-dist enabled-dists enable disable More reading More reading about quicklisp is available on its official page . quicklisp-client: API REFERENCE Nickname: ql The Quicklisp client package, intended for end-user Quicklisp commands and configuration parameters. *local-project-directories* Variable The default local projects directory. *quickload-prompt* Variable When NIL, quickload systems without prompting for enter to continue, otherwise proceed directly without user intervention. *quickload-verbose* Variable When NIL, show terse output when quickloading a system. Otherwise, show normal compile and load output. add-to-init-file Function: (add-to-init-file &optional implementation-or-file) Add forms to the Lisp implementation's init file that will load quicklisp at CL startup. available-client-versions Function: (available-client-versions) available-dist-versions Function: (available-dist-versions name) bundle-systems Function: (bundle-systems system-names &key include-local-projects to (overwrite t)) In the directory to , construct a self-contained bundle of libraries based on system-names . For each system named, and its recursive required systems, unpack its release archive in TO/software/, and write a system index, compatible with the output of QL: write-asdf-manifest-file , to TO/system-index.txt. Write a loader script to TO/bundle.lisp that, when loaded via CL:LOAD, configures ASDF to load systems from the bundle before any other system. system-names must name systems provided directly by Quicklisp. If include-local-projects is true, each directory in QL: LOCAL-PROJECT-DIRECTORIES is copied into the bundle and loaded before any of the other bundled systems. client-url Function: (client-url) Return an URL suitable for passing as the :URL argument to install-client for the current local client installation. client-version Function: (client-version) Return the version for the current local client installation. May or may not be suitable for passing as the :VERSION argument to install-client , depending on if it's a standard Quicklisp-provided client. config-value Function: (config-value path) dist-url Function: (dist-url name) dist-version Function: (dist-version name) help Function: (help) install-client Function: (install-client &key url version) list-local-projects Function: (list-local-projects) Return a list of pathnames to local project system files. list-local-systems Function: (list-local-systems) Return a list of local project system names. local-projects-searcher Function: (local-projects-searcher system-name) This function is added to ASDF: SYSTEM-DEFINITION-SEARCH-FUNCTIONS to use the local project directory and cache to find systems. provided-systems Generic Function: (provided-systems object) Return a list of systems provided by object . qmerge Function: (qmerge pathname) Return pathname merged with the base Quicklisp directory. quickload Generic Function: (quickload systems &key verbose silent prompt explain &allow-other-keys) Load systems the quicklisp way. systems is a designator for a list of things to be loaded. register-local-projects Function: (register-local-projects) Force a scan of the local projects directory to create the system file index. setup Function: (setup) system-apropos Generic Function: (system-apropos term) system-apropos-list Generic Function: (system-apropos-list term) system-list Function: (system-list) system-not-found Condition This condition is signaled by QUICKLOAD when a system given to load is not available via ASDF or a Quicklisp dist. Direct Slots ql-dist:name Initargs: :NAME Readers: SYSTEM-NOT-FOUND-NAME system-not-found-name Generic Function: (system-not-found-name condition) uninstall Function: (uninstall system-name) uninstall-dist Function: (uninstall-dist name) update-all-dists Function: (update-all-dists &key (prompt t)) update-client Function: (update-client &key (prompt t)) update-dist Function: (update-dist dist &key (prompt t)) use-only-quicklisp-systems Function: (use-only-quicklisp-systems) where-is-system Function: (where-is-system name) Return the pathname to the source directory of ASDF system with the given name , or NIL if no system by that name can be found known. who-depends-on Function: (who-depends-on system-name) Return a list of names of systems that depend on system-name . write-asdf-manifest-file Function: (write-asdf-manifest-file output-file &key (if-exists :rename-and-delete) exclude-local-projects) Write a list of system file pathnames to output-file , one per line, in order of descending QL-DIST:PREFERENCE. ql-dist: API Reference Generic functions, variables, and classes for interacting with the dist system. Documented, exported symbols are intended for public use. *dist-enumeration-functions* Variable all-dists calls each function in this list with no arguments, and appends the results into a list of dist objects, removing duplicates. Functions might be called just once for a batch of related operations; see with-consistent-dists . all-dists Function: (all-dists) Return a list of all known dists. archive-content-sha1 Generic Function: (archive-content-sha1 object) archive-md5 Generic Function: (archive-md5 object) archive-size Generic Function: (archive-size object) archive-url Generic Function: (archive-url release) Return the full URL for fetching the archive file of release . available-update Generic Function: (available-update dist) If an update is available for dist , return the update as an uninstalled dist object. Otherwise, return NIL. available-versions Generic Function: (available-versions object) Return a list of version information for object . available-versions-url Generic Function: (available-versions-url object) Return the URL for the available versions data file of object . badly-sized-local-archive Condition base-directory Generic Function: (base-directory object) Return the base directory pathname of object . canonical-distinfo-url Generic Function: (canonical-distinfo-url object) check-local-archive-file Generic Function: (check-local-archive-file release) Check the local archive file of release for validity, including size and signature checks. Signals errors in the case of invalid files. clean Generic Function: (clean object) Remove any unneeded files or directories related to object . dependency-tree Generic Function: (dependency-tree system) disable Generic Function: (disable object) Disable object . dist Generic Function: (dist object) Return the dist of object . Class Direct Slots base-directory Initargs: :BASE-DIRECTORY Readers: BASE-DIRECTORY Writers: (SETF BASE-DIRECTORY) name Initargs: :NAME Readers: NAME Writers: (SETF NAME) version Initargs: :VERSION Readers: VERSION Writers: (SETF VERSION) system-index-url Initargs: :SYSTEM-INDEX-URL Readers: SYSTEM-INDEX-URL Writers: (SETF SYSTEM-INDEX-URL) release-index-url Initargs: :RELEASE-INDEX-URL Readers: RELEASE-INDEX-URL Writers: (SETF RELEASE-INDEX-URL) available-versions-url Initargs: :AVAILABLE-VERSIONS-URL Readers: AVAILABLE-VERSIONS-URL Writers: (SETF AVAILABLE-VERSIONS-URL) canonical-distinfo-url Initargs: :CANONICAL-DISTINFO-URL Readers: CANONICAL-DISTINFO-URL Writers: (SETF CANONICAL-DISTINFO-URL) provided-systems Initargs: :PROVIDED-SYSTEMS Readers: PROVIDED-SYSTEMS Writers: (SETF PROVIDED-SYSTEMS) provided-releases Initargs: :PROVIDED-RELEASES Readers: PROVIDED-RELEASES Writers: (SETF PROVIDED-RELEASES) enable Generic Function: (enable object) Enable object . enabled-dists Function: (enabled-dists) Return a list of all known dists for which enabledp returns true. enabledp Generic Function: (enabledp object) Return true if object is enabled. ensure-installed Generic Function: (ensure-installed object) Ensure that object is installed. ensure-local-archive-file Generic Function: (ensure-local-archive-file release) If the archive file for release is not available locally, fetch it and return the pathname to it. find-asdf-system-file Function: (find-asdf-system-file name) Return the ASDF system file in which the system named name is defined. find-dist Function: (find-dist name) find-dist-or-lose Function: (find-dist-or-lose name) find-release Generic Function: (find-release name) Return a release with the given name , or NIL if no system is found. If multiple releases have the same name, the one with the highest preference is returned. find-release-in-dist Generic Function: (find-release-in-dist release-name dist) Return a release with the given name in dist , or NIL if no release is found. find-system Generic Function: (find-system name) Return a system with the given name , or NIL if no system is found. If multiple systems have the same name, the one with the highest preference is returned. find-system-in-dist Generic Function: (find-system-in-dist system-name dist) Return a system with the given name in dist , or NIL if no system is found. forget-preference Generic Function: (forget-preference object) Remove specific preference information for object . inhibit-subscription Generic Function: (inhibit-subscription object) Inhibit subscription for object . initialize-release-index Generic Function: (initialize-release-index dist) Initialize the release index of dist . initialize-system-index Generic Function: (initialize-system-index dist) Initialize the system index of dist . install Generic Function: (install object) Install object . install-dist Function: (install-dist url &key (prompt t) replace) install-metadata-file Generic Function: (install-metadata-file object) The pathname to a file describing the installation status of object . installed-releases Generic Function: (installed-releases dist) Return a list of all releases installed for dist . installed-systems Generic Function: (installed-systems dist) Return a list of all systems installed for dist . installedp Generic Function: (installedp object) Return true if object is installed. invalid-local-archive Condition Direct Slots release Initargs: :RELEASE Readers: INVALID-LOCAL-ARCHIVE-RELEASE invalid-local-archive-file Generic Function: (invalid-local-archive-file condition) invalid-local-archive-release Generic Function: (invalid-local-archive-release condition) local-archive-file Generic Function: (local-archive-file release) Return the pathname to where the archive file of release should be stored. metadata-name Generic Function: (metadata-name object) The metadata-name of an object is used to form the pathname for a few different object metadata files. missing-local-archive Condition name Generic Function: (name object) Return the name of object . new-version-available-p Generic Function: (new-version-available-p dist) Return true if a new version of dist is available. preference Generic Function: (preference object) Returns a value used when comparing multiple systems or releases with the same name. Objects with higher preference are returned by find-system and find-release . preference-file Generic Function: (preference-file object) Return the file from which preference information is loaded for object . preference-parent Generic Function: (preference-parent object) Return a value suitable for checking if object has no specific preference set. prefix Generic Function: (prefix object) project-name Generic Function: (project-name object) provided-releases Generic Function: (provided-releases object) Return a list of releases provided by object . provided-systems Generic Function: (provided-systems object) Return a list of systems provided by object . relative-to Generic Function: (relative-to object pathname) Merge pathname with the base-directory of object . release Generic Function: (release object) Return the release of object . Class Instances of this class represent a snapshot of a project at some point in time, which might be from version control, or from an official release, or from some other source. Direct Slots project-name Initargs: :PROJECT-NAME dist Initargs: :DIST provided-systems Initargs: :PROVIDED-SYSTEMS Readers: PROVIDED-SYSTEMS Writers: (SETF PROVIDED-SYSTEMS) archive-url Initargs: :ARCHIVE-URL Readers: ARCHIVE-URL Writers: (SETF ARCHIVE-URL) archive-size Initargs: :ARCHIVE-SIZE Readers: ARCHIVE-SIZE Writers: (SETF ARCHIVE-SIZE) archive-md5 Initargs: :ARCHIVE-MD5 Readers: ARCHIVE-MD5 Writers: (SETF ARCHIVE-MD5) archive-content-sha1 Initargs: :ARCHIVE-CONTENT-SHA1 Readers: ARCHIVE-CONTENT-SHA1 Writers: (SETF ARCHIVE-CONTENT-SHA1) prefix Initargs: :PREFIX system-files Initargs: :SYSTEM-FILES Readers: SYSTEM-FILES Writers: (SETF SYSTEM-FILES) metadata-name Initargs: :METADATA-NAME Readers: METADATA-NAME Writers: (SETF METADATA-NAME) release-index-url Generic Function: (release-index-url object) Return the URL for the release index of object . required-systems Generic Function: (required-systems object) short-description Generic Function: (short-description object) Return a short string describing object . show-update-report Generic Function: (show-update-report old-dist new-dist) Display a description of the update from old-dist to new-dist . standard-dist-enumeration-function Function: (standard-dist-enumeration-function) The default function used for producing a list of dist objects. subscribe Generic Function: (subscribe object) Subscribe to updates of object , if possible. If no updates are available, a condition of type subscription-unavailable is raised. subscribedp Generic Function: (subscribedp object) Return true if object is subscribed to updates. subscription-inhibited-p Generic Function: (subscription-inhibited-p object) Return T if subscription to object is inhibited. subscription-inhibition-file Generic Function: (subscription-inhibition-file object) The file whose presence indicates the inhibited subscription status of object . subscription-unavailable Condition subscription-url Generic Function: (subscription-url object) system Generic Function: (system object) Return the system of object . Class Direct Slots name Initargs: :NAME system-file-name Initargs: :SYSTEM-FILE-NAME Readers: SYSTEM-FILE-NAME Writers: (SETF SYSTEM-FILE-NAME) release Initargs: :RELEASE dist Initargs: :DIST Readers: DIST Writers: (SETF DIST) required-systems Initargs: :REQUIRED-SYSTEMS Readers: REQUIRED-SYSTEMS Writers: (SETF REQUIRED-SYSTEMS) metadata-name Initargs: :METADATA-NAME Readers: METADATA-NAME Writers: (SETF METADATA-NAME) system-apropos Generic Function: (system-apropos term) system-apropos-list Generic Function: (system-apropos-list term) system-definition-searcher Function: (system-definition-searcher name) Like find-asdf-system-file , but this function can be used in ASDF: SYSTEM-DEFINITION-SEARCH-FUNCTIONS ; it will only return system file names if they match name . system-file-name Generic Function: (system-file-name object) system-files Generic Function: (system-files object) system-index-url Generic Function: (system-index-url object) Return the URL for the system index of object . uninhibit-subscription Generic Function: (uninhibit-subscription object) Remove inhibition of subscription for object . uninstall Generic Function: (uninstall object) Uninstall object . unknown-dist Condition Direct Slots name Initargs: :NAME Readers: :UNKNOWN-DIST-NAME unsubscribe Generic Function: (unsubscribe object) Unsubscribe from updates to object . update-in-place Generic Function: (update-in-place old-dist new-dist) Update old-dist to new-dist in place. update-release-differences Generic Function: (update-release-differences old-dist new-dist) Compare old-dist to new-dist and return three lists as multiple values: new releases (present in new-dist but not old-dist ), changed releases (present in both dists but different in some way), and removed releases (present in old-dist but not new-dist ). The list of changed releases is a list of two-element lists, with each two-element list having first the old release object and then the new release object. version Generic Function: (version object) with-consistent-dists Macro: (with-consistent-dists &body body) See CALL-WITH-CONSISTENT-DISTS.","title":"quicklisp - Library Manager"},{"location":"quicklisp/#quicklisp-library-manager","text":"Version: 2020-01-04 Repository: quicklisp/quicklisp-client - Github In case of any inaccuracies, ambiguities or suggestions, please create an issue here .","title":"quicklisp - Library Manager"},{"location":"quicklisp/#getting-started","text":"","title":"GETTING STARTED"},{"location":"quicklisp/#installation","text":"Download Do the equivalent steps on Windows and Mac OS: curl -O https://beta.quicklisp.org/quicklisp.lisp # download quicklisp.lisp curl -O https://beta.quicklisp.org/quicklisp.lisp.asc # download the PGP signature file gpg --verify quicklisp.lisp.asc quicklisp.lisp # verify it against the signing key As of 07 June 2020, Quicklisp release signing key has a fingerprint of D7A3 489D DEFE 32B7 D0E7 CC61 3079 65AB 028B 5FF7 , an id of 028B5FF7 , and an email of release@quicklisp.org . See here for the more recent details. Installation Load quicklisp.lisp: sbcl --load quicklisp.lisp # or an equivalent command for your implementation (optionally, you may want to rlwrap sbcl --load quicklisp.lisp for a better repl experience): (quicklisp-quickstart:install) (ql:add-to-init-file) ; to automatically load quicklisp at implementation startup ;;; Note that ql acts as a nickname for the quicklisp-client package. quicklisp-quickstart:install also takes a couple keyword arguments (see (describe 'quicklisp-quickstart:install) - but unless you know what you are doing, it is recommended to leave them as they are.","title":"Installation"},{"location":"quicklisp/#loading-after-installation","text":"(ql:add-to-init-file) adds instructions to your implementations init-file ( .sbclrc or equivalent) to load quicklisp on implementation startup. However, some runtime options of the implementation may disable loading the init-file - sbcl --script for instance. For these cases, you might want to alias (or equivalent) alias sbcl-ql='rlwrap sbcl --noinform --load $HOME/quicklisp/setup.lisp' in your .bashrc (or equivalent).","title":"Loading after installation"},{"location":"quicklisp/#a-few-useful-functions-and-variables","text":"quickload : (ql:quickload '(\"alexandria\" \"bordeaux-threads\")) or (ql:quickload \"alexandria\") . system-apropos : (ql:system-apropos \"postgres\") where-is-system *local-project-directories* : you may either want to have this variable modified from implementation init-file, or symlink ~/quicklisp/local-projects to wherever your projects directory is. This is the location - as the name suggests - where quicklisp searches for local projects. uninstall update-client You may also need to run (asdf:clear-configuration) to have ASDF reprocess its configuration files while loading a newer library. There is also the ql:register-local-projects that can help with the same.","title":"A few useful functions and variables"},{"location":"quicklisp/#a-note-on-quicklisp-dists","text":"Besides being an ASDF system, quicklisp is also the name of a dist . This distribution is released about once per month, with the guarantee that all systems in the distribution build together - note that this does not still imply that they work together. For these cases, you may want to go back in dist time . You might, additionally, want to learn about qlot that helps with version pinning - however, given the stability of Common Lisp, that translates to the stability for its (old but gold) libraries, it may be an overkill. But, YMMV. Also worth a read is getting libraries into quicklisp . (Hope you took note of the blog!) The once-per-month release nature of quicklisp can be an issue if you need to work with bleeding edge packages - for these cases, there exists Ultralisp - which updates every 5 minutes! This is yet another distribution. Some useful functions for working with distributions include: install-dist uninstall-dist update-dist : (ql:update-dist \"quicklisp\") find-dist enabled-dists enable disable","title":"A note on quicklisp dists"},{"location":"quicklisp/#more-reading","text":"More reading about quicklisp is available on its official page .","title":"More reading"},{"location":"quicklisp/#quicklisp-client-api-reference","text":"Nickname: ql The Quicklisp client package, intended for end-user Quicklisp commands and configuration parameters.","title":"quicklisp-client: API REFERENCE"},{"location":"quicklisp/#local-project-directories","text":"Variable The default local projects directory.","title":"*local-project-directories*"},{"location":"quicklisp/#quickload-prompt","text":"Variable When NIL, quickload systems without prompting for enter to continue, otherwise proceed directly without user intervention.","title":"*quickload-prompt*"},{"location":"quicklisp/#quickload-verbose","text":"Variable When NIL, show terse output when quickloading a system. Otherwise, show normal compile and load output.","title":"*quickload-verbose*"},{"location":"quicklisp/#add-to-init-file","text":"Function: (add-to-init-file &optional implementation-or-file) Add forms to the Lisp implementation's init file that will load quicklisp at CL startup.","title":"add-to-init-file"},{"location":"quicklisp/#available-client-versions","text":"Function: (available-client-versions)","title":"available-client-versions"},{"location":"quicklisp/#available-dist-versions","text":"Function: (available-dist-versions name)","title":"available-dist-versions"},{"location":"quicklisp/#bundle-systems","text":"Function: (bundle-systems system-names &key include-local-projects to (overwrite t)) In the directory to , construct a self-contained bundle of libraries based on system-names . For each system named, and its recursive required systems, unpack its release archive in TO/software/, and write a system index, compatible with the output of QL: write-asdf-manifest-file , to TO/system-index.txt. Write a loader script to TO/bundle.lisp that, when loaded via CL:LOAD, configures ASDF to load systems from the bundle before any other system. system-names must name systems provided directly by Quicklisp. If include-local-projects is true, each directory in QL: LOCAL-PROJECT-DIRECTORIES is copied into the bundle and loaded before any of the other bundled systems.","title":"bundle-systems"},{"location":"quicklisp/#client-url","text":"Function: (client-url) Return an URL suitable for passing as the :URL argument to install-client for the current local client installation.","title":"client-url"},{"location":"quicklisp/#client-version","text":"Function: (client-version) Return the version for the current local client installation. May or may not be suitable for passing as the :VERSION argument to install-client , depending on if it's a standard Quicklisp-provided client.","title":"client-version"},{"location":"quicklisp/#config-value","text":"Function: (config-value path)","title":"config-value"},{"location":"quicklisp/#dist-url","text":"Function: (dist-url name)","title":"dist-url"},{"location":"quicklisp/#dist-version","text":"Function: (dist-version name)","title":"dist-version"},{"location":"quicklisp/#help","text":"Function: (help)","title":"help"},{"location":"quicklisp/#install-client","text":"Function: (install-client &key url version)","title":"install-client"},{"location":"quicklisp/#list-local-projects","text":"Function: (list-local-projects) Return a list of pathnames to local project system files.","title":"list-local-projects"},{"location":"quicklisp/#list-local-systems","text":"Function: (list-local-systems) Return a list of local project system names.","title":"list-local-systems"},{"location":"quicklisp/#local-projects-searcher","text":"Function: (local-projects-searcher system-name) This function is added to ASDF: SYSTEM-DEFINITION-SEARCH-FUNCTIONS to use the local project directory and cache to find systems.","title":"local-projects-searcher"},{"location":"quicklisp/#provided-systems","text":"Generic Function: (provided-systems object) Return a list of systems provided by object .","title":"provided-systems"},{"location":"quicklisp/#qmerge","text":"Function: (qmerge pathname) Return pathname merged with the base Quicklisp directory.","title":"qmerge"},{"location":"quicklisp/#quickload","text":"Generic Function: (quickload systems &key verbose silent prompt explain &allow-other-keys) Load systems the quicklisp way. systems is a designator for a list of things to be loaded.","title":"quickload"},{"location":"quicklisp/#register-local-projects","text":"Function: (register-local-projects) Force a scan of the local projects directory to create the system file index.","title":"register-local-projects"},{"location":"quicklisp/#setup","text":"Function: (setup)","title":"setup"},{"location":"quicklisp/#system-apropos","text":"Generic Function: (system-apropos term)","title":"system-apropos"},{"location":"quicklisp/#system-apropos-list","text":"Generic Function: (system-apropos-list term)","title":"system-apropos-list"},{"location":"quicklisp/#system-list","text":"Function: (system-list)","title":"system-list"},{"location":"quicklisp/#system-not-found","text":"Condition This condition is signaled by QUICKLOAD when a system given to load is not available via ASDF or a Quicklisp dist. Direct Slots ql-dist:name Initargs: :NAME Readers: SYSTEM-NOT-FOUND-NAME","title":"system-not-found"},{"location":"quicklisp/#system-not-found-name","text":"Generic Function: (system-not-found-name condition)","title":"system-not-found-name"},{"location":"quicklisp/#uninstall","text":"Function: (uninstall system-name)","title":"uninstall"},{"location":"quicklisp/#uninstall-dist","text":"Function: (uninstall-dist name)","title":"uninstall-dist"},{"location":"quicklisp/#update-all-dists","text":"Function: (update-all-dists &key (prompt t))","title":"update-all-dists"},{"location":"quicklisp/#update-client","text":"Function: (update-client &key (prompt t))","title":"update-client"},{"location":"quicklisp/#update-dist","text":"Function: (update-dist dist &key (prompt t))","title":"update-dist"},{"location":"quicklisp/#use-only-quicklisp-systems","text":"Function: (use-only-quicklisp-systems)","title":"use-only-quicklisp-systems"},{"location":"quicklisp/#where-is-system","text":"Function: (where-is-system name) Return the pathname to the source directory of ASDF system with the given name , or NIL if no system by that name can be found known.","title":"where-is-system"},{"location":"quicklisp/#who-depends-on","text":"Function: (who-depends-on system-name) Return a list of names of systems that depend on system-name .","title":"who-depends-on"},{"location":"quicklisp/#write-asdf-manifest-file","text":"Function: (write-asdf-manifest-file output-file &key (if-exists :rename-and-delete) exclude-local-projects) Write a list of system file pathnames to output-file , one per line, in order of descending QL-DIST:PREFERENCE.","title":"write-asdf-manifest-file"},{"location":"quicklisp/#ql-dist-api-reference","text":"Generic functions, variables, and classes for interacting with the dist system. Documented, exported symbols are intended for public use.","title":"ql-dist: API Reference"},{"location":"quicklisp/#dist-enumeration-functions","text":"Variable all-dists calls each function in this list with no arguments, and appends the results into a list of dist objects, removing duplicates. Functions might be called just once for a batch of related operations; see with-consistent-dists .","title":"*dist-enumeration-functions*"},{"location":"quicklisp/#all-dists","text":"Function: (all-dists) Return a list of all known dists.","title":"all-dists"},{"location":"quicklisp/#archive-content-sha1","text":"Generic Function: (archive-content-sha1 object)","title":"archive-content-sha1"},{"location":"quicklisp/#archive-md5","text":"Generic Function: (archive-md5 object)","title":"archive-md5"},{"location":"quicklisp/#archive-size","text":"Generic Function: (archive-size object)","title":"archive-size"},{"location":"quicklisp/#archive-url","text":"Generic Function: (archive-url release) Return the full URL for fetching the archive file of release .","title":"archive-url"},{"location":"quicklisp/#available-update","text":"Generic Function: (available-update dist) If an update is available for dist , return the update as an uninstalled dist object. Otherwise, return NIL.","title":"available-update"},{"location":"quicklisp/#available-versions","text":"Generic Function: (available-versions object) Return a list of version information for object .","title":"available-versions"},{"location":"quicklisp/#available-versions-url","text":"Generic Function: (available-versions-url object) Return the URL for the available versions data file of object .","title":"available-versions-url"},{"location":"quicklisp/#badly-sized-local-archive","text":"Condition","title":"badly-sized-local-archive"},{"location":"quicklisp/#base-directory","text":"Generic Function: (base-directory object) Return the base directory pathname of object .","title":"base-directory"},{"location":"quicklisp/#canonical-distinfo-url","text":"Generic Function: (canonical-distinfo-url object)","title":"canonical-distinfo-url"},{"location":"quicklisp/#check-local-archive-file","text":"Generic Function: (check-local-archive-file release) Check the local archive file of release for validity, including size and signature checks. Signals errors in the case of invalid files.","title":"check-local-archive-file"},{"location":"quicklisp/#clean","text":"Generic Function: (clean object) Remove any unneeded files or directories related to object .","title":"clean"},{"location":"quicklisp/#dependency-tree","text":"Generic Function: (dependency-tree system)","title":"dependency-tree"},{"location":"quicklisp/#disable","text":"Generic Function: (disable object) Disable object .","title":"disable"},{"location":"quicklisp/#dist","text":"Generic Function: (dist object) Return the dist of object . Class Direct Slots base-directory Initargs: :BASE-DIRECTORY Readers: BASE-DIRECTORY Writers: (SETF BASE-DIRECTORY) name Initargs: :NAME Readers: NAME Writers: (SETF NAME) version Initargs: :VERSION Readers: VERSION Writers: (SETF VERSION) system-index-url Initargs: :SYSTEM-INDEX-URL Readers: SYSTEM-INDEX-URL Writers: (SETF SYSTEM-INDEX-URL) release-index-url Initargs: :RELEASE-INDEX-URL Readers: RELEASE-INDEX-URL Writers: (SETF RELEASE-INDEX-URL) available-versions-url Initargs: :AVAILABLE-VERSIONS-URL Readers: AVAILABLE-VERSIONS-URL Writers: (SETF AVAILABLE-VERSIONS-URL) canonical-distinfo-url Initargs: :CANONICAL-DISTINFO-URL Readers: CANONICAL-DISTINFO-URL Writers: (SETF CANONICAL-DISTINFO-URL) provided-systems Initargs: :PROVIDED-SYSTEMS Readers: PROVIDED-SYSTEMS Writers: (SETF PROVIDED-SYSTEMS) provided-releases Initargs: :PROVIDED-RELEASES Readers: PROVIDED-RELEASES Writers: (SETF PROVIDED-RELEASES)","title":"dist"},{"location":"quicklisp/#enable","text":"Generic Function: (enable object) Enable object .","title":"enable"},{"location":"quicklisp/#enabled-dists","text":"Function: (enabled-dists) Return a list of all known dists for which enabledp returns true.","title":"enabled-dists"},{"location":"quicklisp/#enabledp","text":"Generic Function: (enabledp object) Return true if object is enabled.","title":"enabledp"},{"location":"quicklisp/#ensure-installed","text":"Generic Function: (ensure-installed object) Ensure that object is installed.","title":"ensure-installed"},{"location":"quicklisp/#ensure-local-archive-file","text":"Generic Function: (ensure-local-archive-file release) If the archive file for release is not available locally, fetch it and return the pathname to it.","title":"ensure-local-archive-file"},{"location":"quicklisp/#find-asdf-system-file","text":"Function: (find-asdf-system-file name) Return the ASDF system file in which the system named name is defined.","title":"find-asdf-system-file"},{"location":"quicklisp/#find-dist","text":"Function: (find-dist name)","title":"find-dist"},{"location":"quicklisp/#find-dist-or-lose","text":"Function: (find-dist-or-lose name)","title":"find-dist-or-lose"},{"location":"quicklisp/#find-release","text":"Generic Function: (find-release name) Return a release with the given name , or NIL if no system is found. If multiple releases have the same name, the one with the highest preference is returned.","title":"find-release"},{"location":"quicklisp/#find-release-in-dist","text":"Generic Function: (find-release-in-dist release-name dist) Return a release with the given name in dist , or NIL if no release is found.","title":"find-release-in-dist"},{"location":"quicklisp/#find-system","text":"Generic Function: (find-system name) Return a system with the given name , or NIL if no system is found. If multiple systems have the same name, the one with the highest preference is returned.","title":"find-system"},{"location":"quicklisp/#find-system-in-dist","text":"Generic Function: (find-system-in-dist system-name dist) Return a system with the given name in dist , or NIL if no system is found.","title":"find-system-in-dist"},{"location":"quicklisp/#forget-preference","text":"Generic Function: (forget-preference object) Remove specific preference information for object .","title":"forget-preference"},{"location":"quicklisp/#inhibit-subscription","text":"Generic Function: (inhibit-subscription object) Inhibit subscription for object .","title":"inhibit-subscription"},{"location":"quicklisp/#initialize-release-index","text":"Generic Function: (initialize-release-index dist) Initialize the release index of dist .","title":"initialize-release-index"},{"location":"quicklisp/#initialize-system-index","text":"Generic Function: (initialize-system-index dist) Initialize the system index of dist .","title":"initialize-system-index"},{"location":"quicklisp/#install","text":"Generic Function: (install object) Install object .","title":"install"},{"location":"quicklisp/#install-dist","text":"Function: (install-dist url &key (prompt t) replace)","title":"install-dist"},{"location":"quicklisp/#install-metadata-file","text":"Generic Function: (install-metadata-file object) The pathname to a file describing the installation status of object .","title":"install-metadata-file"},{"location":"quicklisp/#installed-releases","text":"Generic Function: (installed-releases dist) Return a list of all releases installed for dist .","title":"installed-releases"},{"location":"quicklisp/#installed-systems","text":"Generic Function: (installed-systems dist) Return a list of all systems installed for dist .","title":"installed-systems"},{"location":"quicklisp/#installedp","text":"Generic Function: (installedp object) Return true if object is installed.","title":"installedp"},{"location":"quicklisp/#invalid-local-archive","text":"Condition Direct Slots release Initargs: :RELEASE Readers: INVALID-LOCAL-ARCHIVE-RELEASE","title":"invalid-local-archive"},{"location":"quicklisp/#invalid-local-archive-file","text":"Generic Function: (invalid-local-archive-file condition)","title":"invalid-local-archive-file"},{"location":"quicklisp/#invalid-local-archive-release","text":"Generic Function: (invalid-local-archive-release condition)","title":"invalid-local-archive-release"},{"location":"quicklisp/#local-archive-file","text":"Generic Function: (local-archive-file release) Return the pathname to where the archive file of release should be stored.","title":"local-archive-file"},{"location":"quicklisp/#metadata-name","text":"Generic Function: (metadata-name object) The metadata-name of an object is used to form the pathname for a few different object metadata files.","title":"metadata-name"},{"location":"quicklisp/#missing-local-archive","text":"Condition","title":"missing-local-archive"},{"location":"quicklisp/#name","text":"Generic Function: (name object) Return the name of object .","title":"name"},{"location":"quicklisp/#new-version-available-p","text":"Generic Function: (new-version-available-p dist) Return true if a new version of dist is available.","title":"new-version-available-p"},{"location":"quicklisp/#preference","text":"Generic Function: (preference object) Returns a value used when comparing multiple systems or releases with the same name. Objects with higher preference are returned by find-system and find-release .","title":"preference"},{"location":"quicklisp/#preference-file","text":"Generic Function: (preference-file object) Return the file from which preference information is loaded for object .","title":"preference-file"},{"location":"quicklisp/#preference-parent","text":"Generic Function: (preference-parent object) Return a value suitable for checking if object has no specific preference set.","title":"preference-parent"},{"location":"quicklisp/#prefix","text":"Generic Function: (prefix object)","title":"prefix"},{"location":"quicklisp/#project-name","text":"Generic Function: (project-name object)","title":"project-name"},{"location":"quicklisp/#provided-releases","text":"Generic Function: (provided-releases object) Return a list of releases provided by object .","title":"provided-releases"},{"location":"quicklisp/#provided-systems_1","text":"Generic Function: (provided-systems object) Return a list of systems provided by object .","title":"provided-systems"},{"location":"quicklisp/#relative-to","text":"Generic Function: (relative-to object pathname) Merge pathname with the base-directory of object .","title":"relative-to"},{"location":"quicklisp/#release","text":"Generic Function: (release object) Return the release of object . Class Instances of this class represent a snapshot of a project at some point in time, which might be from version control, or from an official release, or from some other source. Direct Slots project-name Initargs: :PROJECT-NAME dist Initargs: :DIST provided-systems Initargs: :PROVIDED-SYSTEMS Readers: PROVIDED-SYSTEMS Writers: (SETF PROVIDED-SYSTEMS) archive-url Initargs: :ARCHIVE-URL Readers: ARCHIVE-URL Writers: (SETF ARCHIVE-URL) archive-size Initargs: :ARCHIVE-SIZE Readers: ARCHIVE-SIZE Writers: (SETF ARCHIVE-SIZE) archive-md5 Initargs: :ARCHIVE-MD5 Readers: ARCHIVE-MD5 Writers: (SETF ARCHIVE-MD5) archive-content-sha1 Initargs: :ARCHIVE-CONTENT-SHA1 Readers: ARCHIVE-CONTENT-SHA1 Writers: (SETF ARCHIVE-CONTENT-SHA1) prefix Initargs: :PREFIX system-files Initargs: :SYSTEM-FILES Readers: SYSTEM-FILES Writers: (SETF SYSTEM-FILES) metadata-name Initargs: :METADATA-NAME Readers: METADATA-NAME Writers: (SETF METADATA-NAME)","title":"release"},{"location":"quicklisp/#release-index-url","text":"Generic Function: (release-index-url object) Return the URL for the release index of object .","title":"release-index-url"},{"location":"quicklisp/#required-systems","text":"Generic Function: (required-systems object)","title":"required-systems"},{"location":"quicklisp/#short-description","text":"Generic Function: (short-description object) Return a short string describing object .","title":"short-description"},{"location":"quicklisp/#show-update-report","text":"Generic Function: (show-update-report old-dist new-dist) Display a description of the update from old-dist to new-dist .","title":"show-update-report"},{"location":"quicklisp/#standard-dist-enumeration-function","text":"Function: (standard-dist-enumeration-function) The default function used for producing a list of dist objects.","title":"standard-dist-enumeration-function"},{"location":"quicklisp/#subscribe","text":"Generic Function: (subscribe object) Subscribe to updates of object , if possible. If no updates are available, a condition of type subscription-unavailable is raised.","title":"subscribe"},{"location":"quicklisp/#subscribedp","text":"Generic Function: (subscribedp object) Return true if object is subscribed to updates.","title":"subscribedp"},{"location":"quicklisp/#subscription-inhibited-p","text":"Generic Function: (subscription-inhibited-p object) Return T if subscription to object is inhibited.","title":"subscription-inhibited-p"},{"location":"quicklisp/#subscription-inhibition-file","text":"Generic Function: (subscription-inhibition-file object) The file whose presence indicates the inhibited subscription status of object .","title":"subscription-inhibition-file"},{"location":"quicklisp/#subscription-unavailable","text":"Condition","title":"subscription-unavailable"},{"location":"quicklisp/#subscription-url","text":"Generic Function: (subscription-url object)","title":"subscription-url"},{"location":"quicklisp/#system","text":"Generic Function: (system object) Return the system of object . Class Direct Slots name Initargs: :NAME system-file-name Initargs: :SYSTEM-FILE-NAME Readers: SYSTEM-FILE-NAME Writers: (SETF SYSTEM-FILE-NAME) release Initargs: :RELEASE dist Initargs: :DIST Readers: DIST Writers: (SETF DIST) required-systems Initargs: :REQUIRED-SYSTEMS Readers: REQUIRED-SYSTEMS Writers: (SETF REQUIRED-SYSTEMS) metadata-name Initargs: :METADATA-NAME Readers: METADATA-NAME Writers: (SETF METADATA-NAME)","title":"system"},{"location":"quicklisp/#system-apropos_1","text":"Generic Function: (system-apropos term)","title":"system-apropos"},{"location":"quicklisp/#system-apropos-list_1","text":"Generic Function: (system-apropos-list term)","title":"system-apropos-list"},{"location":"quicklisp/#system-definition-searcher","text":"Function: (system-definition-searcher name) Like find-asdf-system-file , but this function can be used in ASDF: SYSTEM-DEFINITION-SEARCH-FUNCTIONS ; it will only return system file names if they match name .","title":"system-definition-searcher"},{"location":"quicklisp/#system-file-name","text":"Generic Function: (system-file-name object)","title":"system-file-name"},{"location":"quicklisp/#system-files","text":"Generic Function: (system-files object)","title":"system-files"},{"location":"quicklisp/#system-index-url","text":"Generic Function: (system-index-url object) Return the URL for the system index of object .","title":"system-index-url"},{"location":"quicklisp/#uninhibit-subscription","text":"Generic Function: (uninhibit-subscription object) Remove inhibition of subscription for object .","title":"uninhibit-subscription"},{"location":"quicklisp/#uninstall_1","text":"Generic Function: (uninstall object) Uninstall object .","title":"uninstall"},{"location":"quicklisp/#unknown-dist","text":"Condition Direct Slots name Initargs: :NAME Readers: :UNKNOWN-DIST-NAME","title":"unknown-dist"},{"location":"quicklisp/#unsubscribe","text":"Generic Function: (unsubscribe object) Unsubscribe from updates to object .","title":"unsubscribe"},{"location":"quicklisp/#update-in-place","text":"Generic Function: (update-in-place old-dist new-dist) Update old-dist to new-dist in place.","title":"update-in-place"},{"location":"quicklisp/#update-release-differences","text":"Generic Function: (update-release-differences old-dist new-dist) Compare old-dist to new-dist and return three lists as multiple values: new releases (present in new-dist but not old-dist ), changed releases (present in both dists but different in some way), and removed releases (present in old-dist but not new-dist ). The list of changed releases is a list of two-element lists, with each two-element list having first the old release object and then the new release object.","title":"update-release-differences"},{"location":"quicklisp/#version","text":"Generic Function: (version object)","title":"version"},{"location":"quicklisp/#with-consistent-dists","text":"Macro: (with-consistent-dists &body body) See CALL-WITH-CONSISTENT-DISTS.","title":"with-consistent-dists"},{"location":"unix-opts/","text":"unix-opts - cmd line argument parser Version: 0.1.7 Nickname: opts This documentation was possible due to the excellent official documentation and example . In case of any inaccuracies, ambiguities or suggestions, please create an issue here . GETTING STARTED Consider the following command line options defined using define-opts : (opts:define-opts (:name :help :description \"print this help text\" :short #\\h :long \"help\") (:name :verbose :description \"verbose output\" :short #\\v :long \"verbose\") (:name :level :description \"the program will run on LEVEL level\" :short #\\l :long \"level\" :required t :arg-parser #'parse-integer ; <- takes an argument, which we want to parse into integer :meta-var \"LEVEL\") (:name :output :description \"redirect output to file FILE\" :short #\\o :long \"output\" :arg-parser #'identity ; <- takes an argument, but we keep it as the string :meta-var \"FILE\")) describe gets us the required \"help text\" (see the documentation for other options): CL-USER> (opts:describe :prefix \"Demonstrating REPL\") Demonstrating REPL Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL Command line arguments can be processed with a call to get-opts . For demonstration purposes, we use the REPL. See this example directory to see how this might be done in a script. CL-USER> (opts:get-opts '()) ; Evaluation aborted on #<UNIX-OPTS:MISSING-REQUIRED-OPTION {10084173F3}>. CL-USER> (opts:get-opts '(\"--level\" \"2\")) (:LEVEL 2) NIL CL-USER> (opts:get-opts '(\"--level\" \"2\" \"--help\")) (:LEVEL 2 :HELP T) NIL get-opts can throw several conditions: unknown-option missing-arg arg-parser-failed missing-required-option Each of these has several restarts: use-value skip-option reparse-arg (See the documentation for get-opts for the details about each of these restarts. The Cookbook chapter on Error and Exception Handling should be helpful if you want to learn about them.) Thus, a typical way to use get-opts would be simply wrap the error in handler-case : CL-USER> (handler-case (opts:get-opts '()) (error (condition) (format t \"~A\" condition) (opts:describe))) missing required options: \"--level\" Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL You could use getf or destructuring-bind to obtain the arguments you need: CL-USER> (defun process-options (&rest options) (handler-case (opts:get-opts options) (error (condition) ; or you could case down on the various conditions above! (format t \"~A\" condition) (opts:describe)))) PROCESS-OPTIONS CL-USER> (destructuring-bind (&key level help) (process-options \"--level\" \"2\" \"--help\") (if help (opts:describe) (format t \"I see you've supplied level option, you want ~a level!~%\" level))) Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL CL-USER> (destructuring-bind (&key level help) (process-options \"--level\" \"2\") (if help (opts:describe) (format t \"I see you've supplied level option, you want ~a level!~%\" level))) I see you've supplied level option, you want 2 level! NIL You could also iterate:dsetq to bring the options to global space. CL-USER> (destructuring-bind (&key verbose level help) (process-options \"--level\" \"2\" \"--verbose\") (if help (opts:describe) ; assume we have defined *level* and *verbose* previously (dsetq (*verbose* *level*) (list verbose level)))) (T 2) CL-USER> *verbose* T CL-USER> *level* 2 API REFERENCE arg-parser-failed Condition This condition is thrown when some option OPTION wants an argument, it's given but cannot be parsed by argument parser. Direct Slots raw-arg Initargs: :RAW-ARG Readers: RAW-ARG argv Function: (argv) Return a list of program's arguments, including command used to execute the program as first elements of the list. Portable across implementations. define-opts Macro: (define-opts &body descriptions) Define command line options. Arguments of this macro must be plists containing various parameters. Here we enumerate all allowed parameters: :name - keyword that will be included in list returned by get-opts function if actual option is supplied by user. :description - description of the option (it will be used in describe function). This argument is optional, but it's recommended to supply it. :short - single character, short variant of the option. You may omit this argument if you supply :long variant of option. :long - string, long variant of option. You may omit this argument if you supply :short variant of option. :arg-parser - if actual option must take an argument, supply this argument, it must be a function that takes a string and parses it. :meta-var - if actual option requires an argument, this is how it will be printed in option description. describe Function: (describe &key prefix suffix usage-of args (stream *standard-output*)) Return string describing options of the program that were defined with define-opts macro previously. You can supply prefix and suffix arguments that will be printed before and after options respectively. If usage-of is supplied, it should be a string, name of the program for \"Usage: \" section. This section is only printed if this name is given. If your program takes arguments (apart from options), you can specify how to print them in \"Usage: \" section with args option (should be a string designator). Output goes to stream . exit Function: (exit &optional (status 0)) Exit the program returning status . get-opts Function: (get-opts &optional options) Parse command line options. If options is given, it should be a list to parse. If it's not given, the function will use argv function to get list of command line arguments. Return two values: a list that contains keywords associated with command line options with define-opts macro, and a list of free arguments. If some option requires an argument, you can use getf to test presence of the option and get its argument if the option is present. The parser may signal various conditions. Let's list them all specifying which restarts are available for every condition, and what kind of information the programmer can extract from the conditions. unknown-option is thrown when parser encounters unknown (not previously defined with define-opts ) option. Use the option reader to get name of the option (string). Available restarts: use-value : substitute the option and try again, skip-option : ignore the option. missing-arg is thrown when some option wants an argument, but there is no such argument given. Use the option reader to get name of the option (string). Available restarts: use-value : supplied value will be used, skip-option : ignore the option. arg-parser-failed is thrown when some option wants an argument, it's given but cannot be parsed by argument parser. Use the option reader to get name of the option (string) and raw-arg to get raw string representing the argument before parsing. Available restarts: use-value : supplied value will be used, skip-option : ignore the option, reparse-arg : supplied string will be parsed instead. missing-required-option is thrown when some option was required but was not given. Use the missing-options reader to get the list of options that are missing. Available restarts: use-value : supplied list of values will be used, skip-option : ignore all these options, effectively binding them to nil missing-arg Condition This condition is thrown when some option OPTION wants an argument, but there is no such argument given. missing-options Generic Function: (missing-options condition) missing-required-option Condition This condition is thrown when required options are missing. Direct Slots missing-options Initargs: :MISSING-OPTIONS Readers: MISSING-OPTIONS option Generic Function: (option condition) Class representation of an option raw-arg Generic Function: (raw-arg condition) reparse-arg skip-option unknown-option Condition This condition is thrown when parser encounters unknown (not previously defined with define-opts ) option. use-value Function: (use-value value &optional condition) Transfer control and value to a restart named USE-VALUE, or return NIL if none exists.","title":"unix-opts - cmd line argument parser"},{"location":"unix-opts/#unix-opts-cmd-line-argument-parser","text":"Version: 0.1.7 Nickname: opts This documentation was possible due to the excellent official documentation and example . In case of any inaccuracies, ambiguities or suggestions, please create an issue here .","title":"unix-opts - cmd line argument parser"},{"location":"unix-opts/#getting-started","text":"Consider the following command line options defined using define-opts : (opts:define-opts (:name :help :description \"print this help text\" :short #\\h :long \"help\") (:name :verbose :description \"verbose output\" :short #\\v :long \"verbose\") (:name :level :description \"the program will run on LEVEL level\" :short #\\l :long \"level\" :required t :arg-parser #'parse-integer ; <- takes an argument, which we want to parse into integer :meta-var \"LEVEL\") (:name :output :description \"redirect output to file FILE\" :short #\\o :long \"output\" :arg-parser #'identity ; <- takes an argument, but we keep it as the string :meta-var \"FILE\")) describe gets us the required \"help text\" (see the documentation for other options): CL-USER> (opts:describe :prefix \"Demonstrating REPL\") Demonstrating REPL Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL Command line arguments can be processed with a call to get-opts . For demonstration purposes, we use the REPL. See this example directory to see how this might be done in a script. CL-USER> (opts:get-opts '()) ; Evaluation aborted on #<UNIX-OPTS:MISSING-REQUIRED-OPTION {10084173F3}>. CL-USER> (opts:get-opts '(\"--level\" \"2\")) (:LEVEL 2) NIL CL-USER> (opts:get-opts '(\"--level\" \"2\" \"--help\")) (:LEVEL 2 :HELP T) NIL get-opts can throw several conditions: unknown-option missing-arg arg-parser-failed missing-required-option Each of these has several restarts: use-value skip-option reparse-arg (See the documentation for get-opts for the details about each of these restarts. The Cookbook chapter on Error and Exception Handling should be helpful if you want to learn about them.) Thus, a typical way to use get-opts would be simply wrap the error in handler-case : CL-USER> (handler-case (opts:get-opts '()) (error (condition) (format t \"~A\" condition) (opts:describe))) missing required options: \"--level\" Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL You could use getf or destructuring-bind to obtain the arguments you need: CL-USER> (defun process-options (&rest options) (handler-case (opts:get-opts options) (error (condition) ; or you could case down on the various conditions above! (format t \"~A\" condition) (opts:describe)))) PROCESS-OPTIONS CL-USER> (destructuring-bind (&key level help) (process-options \"--level\" \"2\" \"--help\") (if help (opts:describe) (format t \"I see you've supplied level option, you want ~a level!~%\" level))) Available options: -h, --help print this help text -v, --verbose verbose output -l, --level LEVEL (Required) the program will run on LEVEL level -o, --output FILE redirect output to file FILE NIL CL-USER> (destructuring-bind (&key level help) (process-options \"--level\" \"2\") (if help (opts:describe) (format t \"I see you've supplied level option, you want ~a level!~%\" level))) I see you've supplied level option, you want 2 level! NIL You could also iterate:dsetq to bring the options to global space. CL-USER> (destructuring-bind (&key verbose level help) (process-options \"--level\" \"2\" \"--verbose\") (if help (opts:describe) ; assume we have defined *level* and *verbose* previously (dsetq (*verbose* *level*) (list verbose level)))) (T 2) CL-USER> *verbose* T CL-USER> *level* 2","title":"GETTING STARTED"},{"location":"unix-opts/#api-reference","text":"","title":"API REFERENCE"},{"location":"unix-opts/#arg-parser-failed","text":"Condition This condition is thrown when some option OPTION wants an argument, it's given but cannot be parsed by argument parser. Direct Slots raw-arg Initargs: :RAW-ARG Readers: RAW-ARG","title":"arg-parser-failed"},{"location":"unix-opts/#argv","text":"Function: (argv) Return a list of program's arguments, including command used to execute the program as first elements of the list. Portable across implementations.","title":"argv"},{"location":"unix-opts/#define-opts","text":"Macro: (define-opts &body descriptions) Define command line options. Arguments of this macro must be plists containing various parameters. Here we enumerate all allowed parameters: :name - keyword that will be included in list returned by get-opts function if actual option is supplied by user. :description - description of the option (it will be used in describe function). This argument is optional, but it's recommended to supply it. :short - single character, short variant of the option. You may omit this argument if you supply :long variant of option. :long - string, long variant of option. You may omit this argument if you supply :short variant of option. :arg-parser - if actual option must take an argument, supply this argument, it must be a function that takes a string and parses it. :meta-var - if actual option requires an argument, this is how it will be printed in option description.","title":"define-opts"},{"location":"unix-opts/#describe","text":"Function: (describe &key prefix suffix usage-of args (stream *standard-output*)) Return string describing options of the program that were defined with define-opts macro previously. You can supply prefix and suffix arguments that will be printed before and after options respectively. If usage-of is supplied, it should be a string, name of the program for \"Usage: \" section. This section is only printed if this name is given. If your program takes arguments (apart from options), you can specify how to print them in \"Usage: \" section with args option (should be a string designator). Output goes to stream .","title":"describe"},{"location":"unix-opts/#exit","text":"Function: (exit &optional (status 0)) Exit the program returning status .","title":"exit"},{"location":"unix-opts/#get-opts","text":"Function: (get-opts &optional options) Parse command line options. If options is given, it should be a list to parse. If it's not given, the function will use argv function to get list of command line arguments. Return two values: a list that contains keywords associated with command line options with define-opts macro, and a list of free arguments. If some option requires an argument, you can use getf to test presence of the option and get its argument if the option is present. The parser may signal various conditions. Let's list them all specifying which restarts are available for every condition, and what kind of information the programmer can extract from the conditions. unknown-option is thrown when parser encounters unknown (not previously defined with define-opts ) option. Use the option reader to get name of the option (string). Available restarts: use-value : substitute the option and try again, skip-option : ignore the option. missing-arg is thrown when some option wants an argument, but there is no such argument given. Use the option reader to get name of the option (string). Available restarts: use-value : supplied value will be used, skip-option : ignore the option. arg-parser-failed is thrown when some option wants an argument, it's given but cannot be parsed by argument parser. Use the option reader to get name of the option (string) and raw-arg to get raw string representing the argument before parsing. Available restarts: use-value : supplied value will be used, skip-option : ignore the option, reparse-arg : supplied string will be parsed instead. missing-required-option is thrown when some option was required but was not given. Use the missing-options reader to get the list of options that are missing. Available restarts: use-value : supplied list of values will be used, skip-option : ignore all these options, effectively binding them to nil","title":"get-opts"},{"location":"unix-opts/#missing-arg","text":"Condition This condition is thrown when some option OPTION wants an argument, but there is no such argument given.","title":"missing-arg"},{"location":"unix-opts/#missing-options","text":"Generic Function: (missing-options condition)","title":"missing-options"},{"location":"unix-opts/#missing-required-option","text":"Condition This condition is thrown when required options are missing. Direct Slots missing-options Initargs: :MISSING-OPTIONS Readers: MISSING-OPTIONS","title":"missing-required-option"},{"location":"unix-opts/#option","text":"Generic Function: (option condition) Class representation of an option","title":"option"},{"location":"unix-opts/#raw-arg","text":"Generic Function: (raw-arg condition)","title":"raw-arg"},{"location":"unix-opts/#reparse-arg","text":"","title":"reparse-arg"},{"location":"unix-opts/#skip-option","text":"","title":"skip-option"},{"location":"unix-opts/#unknown-option","text":"Condition This condition is thrown when parser encounters unknown (not previously defined with define-opts ) option.","title":"unknown-option"},{"location":"unix-opts/#use-value","text":"Function: (use-value value &optional condition) Transfer control and value to a restart named USE-VALUE, or return NIL if none exists.","title":"use-value"},{"location":"utilities/","text":"utilities - A collection of utility libraries A collection of smallish utility libraries. In case of any inaccuracies, ambiguities or suggestions, please create an issue here . PARSE-NUMBER Version: 1.7 Repository: sharplispers/parse-number - Github PARSE-NUMBER is a library of functions which accept an arbitrary string and attempt to parse it, if possible into one of the standard Common Lisp number types without using the reader, or else signal an error of type invalid-number . invalid-number Condition invalid-number-reason Generic Function: (invalid-number-reason condition) invalid-number-value Generic Function: (invalid-number-value condition) parse-number Function: (parse-number string &key (start 0) (end NIL) (radix 10) ((:float-format *read-default-float-format*) *read-default-float-format*)) parse-positive-real-number Function: (parse-positive-real-number string &key (start 0) (end NIL) (radix 10) ((float-format *read-default-float-format*) *read-default-float-format*)) parse-real-number Function: (parse-real-number string &key (start 0) (end NIL) (radix 10) ((float-format *read-default-float-format*) *read-default-float-format*)) SPLIT-SEQUENCE Version: 2.0.0 Repository: sharplispers/split-sequence split-sequence Function: (split-sequence delimiter sequence &key (start 0) (end NIL) (from-end NIL) (count NIL) (remove-empty-subseqs NIL) (test (function eql) test-p) (test-not NIL test-not-p) (key (function identity))) Return a list of subsequences in seq delimited by delimiter. If :remove-empty-subseqs is NIL, empty subsequences will be included in the result; otherwise they will be discarded. All other keywords work analogously to those for cl:substitute . In particular, the behaviour of :from-end is possibly different from other versions of this function; :from-end values of NIL and T are equivalent unless :count is supplied. :count limits the number of subseqs in the main resulting list. The second return value is an index suitable as an argument to cl:subseq into the sequence indicating where processing stopped. split-sequence-if Function: (split-sequence-if predicate sequence &key (start 0) (end NIL) (from-end NIL) (count NIL) (remove-empty-subseqs NIL) (key (function identity))) Return a list of subsequences in seq delimited by items satisfying predicate. If :remove-empty-subseqs is NIL, empty subsequences will be included in the result; otherwise they will be discarded. All other keywords work analogously to those for cl:substitute-if . In particular, the behaviour of :from-end is possibly different from other versions of this function; :from-end values of NIL and T are equivalent unless :count is supplied. :count limits the number of subseqs in the main resulting list. The second return value is an index suitable as an argument to cl:subseq into the sequence indicating where processing stopped. split-sequence-if-not Function: (split-sequence-if-not predicate sequence &key (start 0) (end NIL) (from-end NIL) (count NIL) (remove-empty-subseqs NIL) (key (function identity))) Return a list of subsequences in seq delimited by items satisfying ( cl:complement predicate). If :remove-empty-subseqs is NIL, empty subsequences will be included in the result; otherwise they will be discarded. All other keywords work analogously to those for cl:substitute-if-not . In particular, the behaviour of :from-end is possibly different from other versions of this function; :from-end values of NIL and T are equivalent unless :count is supplied. :count limits the number of subseqs in the main resulting list. The second return value is an index suitable as an argument to cl:subseq into the sequence indicating where processing stopped. TRIVIAL-TYPES Version: 0.1 Repository: m2ym/trivial-types - Github TODO: This repository is archived; quickdocs points to this; a branch of a fork is ahead of this. TRIVIAL-TYPES provides missing but important type definitions such as proper-list , association-list , property-list and tuple . By using these types, you can keep type declarations more accurate. For example, you may write a class definition like: (defclass person () ((name :type string)) ((age :type fixnum)) ((friends :type list))) However, it is not obvious for anyone except you that FRIENDS slot has only a list of person. If you want declare friends slot more accurately, proper-list is the best for that: (defclass person () ((name :type string)) ((age :type fixnum)) ((friends :type (proper-list person)))) In addition, TRIVIAL-TYPES also provides standard designators defined in ANSI standard such as package-designator . They are useful when you write a function that takes a package-oid argument like: (defun list-external-symbols (package) (declare (package-designator package)) (loop for symbol being the external-symbol of package collect symbol)) An exhaustive list of provided types includes: association-list character-designator file-associated-stream file-position-designator function-designator list-designator non-nil package-designator pathname-designator proper-list property-list stream-designator string-designator association-list-p Function: (association-list-p var) Returns true if OBJECT is an association list. Examples: (association-list-p 1) => NIL (association-list-p '(1 2 3)) => NIL (association-list-p nil) => T (association-list-p '((foo))) => T (association-list-p '((:a . 1) (:b . 2))) => T file-associated-stream-p Function: (file-associated-stream-p stream) Returns true if stream is a stream associated to a file. proper-list-p Function: (proper-list-p object) Returns true if object is a proper list. Examples: (proper-list-p 1) => NIL (proper-list-p '(1 . 2)) => NIL (proper-list-p nil) => T (proper-list-p '(1 2 3)) => T property-list-p Function: (property-list-p object) Returns true if object is a property list. Examples: (property-list-p 1) => NIL (property-list-p '(1 2 3)) => NIL (property-list-p '(foo)) => NIL (property-list-p nil) => T (property-list-p '(foo 1)) => T (property-list-p '(:a 1 :b 2)) => T tuple Function: (tuple &rest args) Exactly same as LIST. tuplep Function: (tuplep object) Returns true if object is a tuple, meaning a proper list. Examples: (tuplep 1) => NIL (tuplep '(1 . 2)) => NIL (tuplep nil) => T (tuplep '(1 2 3)) => T type-expand Function: (type-expand type-specifier &optional env) Expand type-specifier in the lexical environment env . type-specifier-p Function: (type-specifier-p type-specifier) Returns true if type-specifier is a valid type specfiier. TRIVIAL-PACKAGE-LOCAL-NICKNAMES Version: 0.2 Repository: phoe/trivial-package-local-nicknames A portability layer for package local nicknames. add-package-local-nickname Function: (add-package-local-nickname local-nickname actual-package &optional (package-designator (sane-package))) Adds local-nickname for actual-package in the designated package, defaulting to current package. local-nickname must be a string designator, and actual-package must be a package designator. Returns the designated package. Signals a continuable error if local-nickname is already a package local nickname for a different package, or if local-nickname is one of \"CL\", \"COMMON-LISP\", or, \"KEYWORD\", or if local-nickname is a global name or nickname for the package to which the nickname would be added. When in the designated package, calls to FIND-PACKAGE with the local-nickname will return the package the designated actual-package instead. This also affects all implied calls to FIND-PACKAGE, including those performed by the reader. When printing a package prefix for a symbol with a package local nickname, local nickname is used instead of the real name in order to preserve print-read consistency. See also: package-local-nicknames , package-locally-nicknamed-by-list , remove-package-local-nickname , and the DEFPACKAGE option :LOCAL-NICKNAMES. Experimental: interface subject to change. package-local-nicknames Function: (package-local-nicknames package-designator) Returns an alist of (local-nickname . actual-package) describing the nicknames local to the designated package. When in the designated package, calls to FIND-PACKAGE with the any of the local-nicknames will return the corresponding actual-package instead. This also affects all implied calls to FIND-PACKAGE, including those performed by the reader. When printing a package prefix for a symbol with a package local nickname, the local nickname is used instead of the real name in order to preserve print-read consistency. See also: add-package-local-nickname , package-locally-nicknamed-by-list , remove-package-local-nickname , and the DEFPACKAGE option :LOCAL-NICKNAMES. Experimental: interface subject to change. package-locally-nicknamed-by-list Function: (package-locally-nicknamed-by-list package-designator) Returns a list of packages which have a local nickname for the designated package. See also: add-package-local-nickname , package-local-nicknames , remove-package-local-nickname , and the DEFPACKAGE option :LOCAL-NICKNAMES. Experimental: interface subject to change. remove-package-local-nickname Function: (remove-package-local-nickname old-nickname &optional (package-designator (sane-package))) If the designated package had old-nickname as a local nickname for another package, it is removed. Returns true if the nickname existed and was removed, and NIL otherwise. See also: add-package-local-nickname , package-local-nicknames , package-locally-nicknamed-by-list , and the DEFPACKAGE option :LOCAL-NICKNAMES. Experimental: interface subject to change.","title":"utilities - A collection of utility libraries"},{"location":"utilities/#utilities-a-collection-of-utility-libraries","text":"A collection of smallish utility libraries. In case of any inaccuracies, ambiguities or suggestions, please create an issue here .","title":"utilities - A collection of utility libraries"},{"location":"utilities/#parse-number","text":"Version: 1.7 Repository: sharplispers/parse-number - Github PARSE-NUMBER is a library of functions which accept an arbitrary string and attempt to parse it, if possible into one of the standard Common Lisp number types without using the reader, or else signal an error of type invalid-number .","title":"PARSE-NUMBER"},{"location":"utilities/#invalid-number","text":"Condition","title":"invalid-number"},{"location":"utilities/#invalid-number-reason","text":"Generic Function: (invalid-number-reason condition)","title":"invalid-number-reason"},{"location":"utilities/#invalid-number-value","text":"Generic Function: (invalid-number-value condition)","title":"invalid-number-value"},{"location":"utilities/#parse-number_1","text":"Function: (parse-number string &key (start 0) (end NIL) (radix 10) ((:float-format *read-default-float-format*) *read-default-float-format*))","title":"parse-number"},{"location":"utilities/#parse-positive-real-number","text":"Function: (parse-positive-real-number string &key (start 0) (end NIL) (radix 10) ((float-format *read-default-float-format*) *read-default-float-format*))","title":"parse-positive-real-number"},{"location":"utilities/#parse-real-number","text":"Function: (parse-real-number string &key (start 0) (end NIL) (radix 10) ((float-format *read-default-float-format*) *read-default-float-format*))","title":"parse-real-number"},{"location":"utilities/#split-sequence","text":"Version: 2.0.0 Repository: sharplispers/split-sequence","title":"SPLIT-SEQUENCE"},{"location":"utilities/#split-sequence_1","text":"Function: (split-sequence delimiter sequence &key (start 0) (end NIL) (from-end NIL) (count NIL) (remove-empty-subseqs NIL) (test (function eql) test-p) (test-not NIL test-not-p) (key (function identity))) Return a list of subsequences in seq delimited by delimiter. If :remove-empty-subseqs is NIL, empty subsequences will be included in the result; otherwise they will be discarded. All other keywords work analogously to those for cl:substitute . In particular, the behaviour of :from-end is possibly different from other versions of this function; :from-end values of NIL and T are equivalent unless :count is supplied. :count limits the number of subseqs in the main resulting list. The second return value is an index suitable as an argument to cl:subseq into the sequence indicating where processing stopped.","title":"split-sequence"},{"location":"utilities/#split-sequence-if","text":"Function: (split-sequence-if predicate sequence &key (start 0) (end NIL) (from-end NIL) (count NIL) (remove-empty-subseqs NIL) (key (function identity))) Return a list of subsequences in seq delimited by items satisfying predicate. If :remove-empty-subseqs is NIL, empty subsequences will be included in the result; otherwise they will be discarded. All other keywords work analogously to those for cl:substitute-if . In particular, the behaviour of :from-end is possibly different from other versions of this function; :from-end values of NIL and T are equivalent unless :count is supplied. :count limits the number of subseqs in the main resulting list. The second return value is an index suitable as an argument to cl:subseq into the sequence indicating where processing stopped.","title":"split-sequence-if"},{"location":"utilities/#split-sequence-if-not","text":"Function: (split-sequence-if-not predicate sequence &key (start 0) (end NIL) (from-end NIL) (count NIL) (remove-empty-subseqs NIL) (key (function identity))) Return a list of subsequences in seq delimited by items satisfying ( cl:complement predicate). If :remove-empty-subseqs is NIL, empty subsequences will be included in the result; otherwise they will be discarded. All other keywords work analogously to those for cl:substitute-if-not . In particular, the behaviour of :from-end is possibly different from other versions of this function; :from-end values of NIL and T are equivalent unless :count is supplied. :count limits the number of subseqs in the main resulting list. The second return value is an index suitable as an argument to cl:subseq into the sequence indicating where processing stopped.","title":"split-sequence-if-not"},{"location":"utilities/#trivial-types","text":"Version: 0.1 Repository: m2ym/trivial-types - Github TODO: This repository is archived; quickdocs points to this; a branch of a fork is ahead of this. TRIVIAL-TYPES provides missing but important type definitions such as proper-list , association-list , property-list and tuple . By using these types, you can keep type declarations more accurate. For example, you may write a class definition like: (defclass person () ((name :type string)) ((age :type fixnum)) ((friends :type list))) However, it is not obvious for anyone except you that FRIENDS slot has only a list of person. If you want declare friends slot more accurately, proper-list is the best for that: (defclass person () ((name :type string)) ((age :type fixnum)) ((friends :type (proper-list person)))) In addition, TRIVIAL-TYPES also provides standard designators defined in ANSI standard such as package-designator . They are useful when you write a function that takes a package-oid argument like: (defun list-external-symbols (package) (declare (package-designator package)) (loop for symbol being the external-symbol of package collect symbol)) An exhaustive list of provided types includes: association-list character-designator file-associated-stream file-position-designator function-designator list-designator non-nil package-designator pathname-designator proper-list property-list stream-designator string-designator","title":"TRIVIAL-TYPES"},{"location":"utilities/#association-list-p","text":"Function: (association-list-p var) Returns true if OBJECT is an association list. Examples: (association-list-p 1) => NIL (association-list-p '(1 2 3)) => NIL (association-list-p nil) => T (association-list-p '((foo))) => T (association-list-p '((:a . 1) (:b . 2))) => T","title":"association-list-p"},{"location":"utilities/#file-associated-stream-p","text":"Function: (file-associated-stream-p stream) Returns true if stream is a stream associated to a file.","title":"file-associated-stream-p"},{"location":"utilities/#proper-list-p","text":"Function: (proper-list-p object) Returns true if object is a proper list. Examples: (proper-list-p 1) => NIL (proper-list-p '(1 . 2)) => NIL (proper-list-p nil) => T (proper-list-p '(1 2 3)) => T","title":"proper-list-p"},{"location":"utilities/#property-list-p","text":"Function: (property-list-p object) Returns true if object is a property list. Examples: (property-list-p 1) => NIL (property-list-p '(1 2 3)) => NIL (property-list-p '(foo)) => NIL (property-list-p nil) => T (property-list-p '(foo 1)) => T (property-list-p '(:a 1 :b 2)) => T","title":"property-list-p"},{"location":"utilities/#tuple","text":"Function: (tuple &rest args) Exactly same as LIST.","title":"tuple"},{"location":"utilities/#tuplep","text":"Function: (tuplep object) Returns true if object is a tuple, meaning a proper list. Examples: (tuplep 1) => NIL (tuplep '(1 . 2)) => NIL (tuplep nil) => T (tuplep '(1 2 3)) => T","title":"tuplep"},{"location":"utilities/#type-expand","text":"Function: (type-expand type-specifier &optional env) Expand type-specifier in the lexical environment env .","title":"type-expand"},{"location":"utilities/#type-specifier-p","text":"Function: (type-specifier-p type-specifier) Returns true if type-specifier is a valid type specfiier.","title":"type-specifier-p"},{"location":"utilities/#trivial-package-local-nicknames","text":"Version: 0.2 Repository: phoe/trivial-package-local-nicknames A portability layer for package local nicknames.","title":"TRIVIAL-PACKAGE-LOCAL-NICKNAMES"},{"location":"utilities/#add-package-local-nickname","text":"Function: (add-package-local-nickname local-nickname actual-package &optional (package-designator (sane-package))) Adds local-nickname for actual-package in the designated package, defaulting to current package. local-nickname must be a string designator, and actual-package must be a package designator. Returns the designated package. Signals a continuable error if local-nickname is already a package local nickname for a different package, or if local-nickname is one of \"CL\", \"COMMON-LISP\", or, \"KEYWORD\", or if local-nickname is a global name or nickname for the package to which the nickname would be added. When in the designated package, calls to FIND-PACKAGE with the local-nickname will return the package the designated actual-package instead. This also affects all implied calls to FIND-PACKAGE, including those performed by the reader. When printing a package prefix for a symbol with a package local nickname, local nickname is used instead of the real name in order to preserve print-read consistency. See also: package-local-nicknames , package-locally-nicknamed-by-list , remove-package-local-nickname , and the DEFPACKAGE option :LOCAL-NICKNAMES. Experimental: interface subject to change.","title":"add-package-local-nickname"},{"location":"utilities/#package-local-nicknames","text":"Function: (package-local-nicknames package-designator) Returns an alist of (local-nickname . actual-package) describing the nicknames local to the designated package. When in the designated package, calls to FIND-PACKAGE with the any of the local-nicknames will return the corresponding actual-package instead. This also affects all implied calls to FIND-PACKAGE, including those performed by the reader. When printing a package prefix for a symbol with a package local nickname, the local nickname is used instead of the real name in order to preserve print-read consistency. See also: add-package-local-nickname , package-locally-nicknamed-by-list , remove-package-local-nickname , and the DEFPACKAGE option :LOCAL-NICKNAMES. Experimental: interface subject to change.","title":"package-local-nicknames"},{"location":"utilities/#package-locally-nicknamed-by-list","text":"Function: (package-locally-nicknamed-by-list package-designator) Returns a list of packages which have a local nickname for the designated package. See also: add-package-local-nickname , package-local-nicknames , remove-package-local-nickname , and the DEFPACKAGE option :LOCAL-NICKNAMES. Experimental: interface subject to change.","title":"package-locally-nicknamed-by-list"},{"location":"utilities/#remove-package-local-nickname","text":"Function: (remove-package-local-nickname old-nickname &optional (package-designator (sane-package))) If the designated package had old-nickname as a local nickname for another package, it is removed. Returns true if the nickname existed and was removed, and NIL otherwise. See also: add-package-local-nickname , package-local-nicknames , package-locally-nicknamed-by-list , and the DEFPACKAGE option :LOCAL-NICKNAMES. Experimental: interface subject to change.","title":"remove-package-local-nickname"}]}